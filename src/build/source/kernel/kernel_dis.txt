
E:/CppProject/Tinyos/src/build/source/kernel/kernel.elf:     file format elf32-i386
E:/CppProject/Tinyos/src/build/source/kernel/kernel.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010000

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x000095b8 memsz 0x000095b8 flags r-x
    LOAD off    0x0000b000 vaddr 0x0001a000 paddr 0x0001a000 align 2**12
         filesz 0x00000178 memsz 0x00046020 flags rw-
    LOAD off    0x0000c000 vaddr 0x80000000 paddr 0x00060020 align 2**12
         filesz 0x00000399 memsz 0x00000399 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00008581  00010000  00010000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00001018  000185a0  000185a0  000095a0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000178  0001a000  0001a000  0000b000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00045020  0001b000  0001b000  0000b178  2**12
                  ALLOC
  4 .first_task   00000399  80000000  00060020  0000c000  2**0
                  CONTENTS, ALLOC, LOAD, CODE
  5 .debug_line   000048b0  00000000  00000000  0000c399  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012bc1  00000000  00000000  00010c49  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003201  00000000  00000000  0002380a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 00000340  00000000  00000000  00026a10  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 000000d8  00000000  00000000  00026d50  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002b24  00000000  00000000  00026e28  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      00000011  00000000  00000000  0002994c  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00002b9c  00000000  00000000  00029960  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
000185a0 l    d  .rodata	00000000 .rodata
0001a000 l    d  .data	00000000 .data
0001b000 l    d  .bss	00000000 .bss
80000000 l    d  .first_task	00000000 .first_task
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 CMakeFiles/kernel.dir/init/start.S.obj
00010013 l       .text	00000000 gdt_reload
00000000 l    df *ABS*	00000000 memory.c
00010304 l     F .text	00000011 read_cr0
00010315 l     F .text	0000000c write_cr0
00010321 l     F .text	0000000c write_cr3
0001032d l     F .text	0000000c write_cr4
00010339 l     F .text	00000011 read_cr4
0001034a l     F .text	0000000d down2
00010357 l     F .text	00000017 up2
0001036e l     F .text	0000003e mmu_set_page_dir
000103ac l     F .text	0000000b pde_index
000103b7 l     F .text	00000010 pte_index
000103c7 l     F .text	00000010 pde_paddr
000103d7 l     F .text	00000010 pte_paddr
000103e7 l     F .text	0000000f get_pte_perm
0001b000 l     O .bss	00000028 paddr_alloc
0001c000 l     O .bss	00001000 kernel_page_dir
000103f6 l     F .text	00000058 addr_alloc_init
0001044e l     F .text	00000067 addr_alloc_page
000104b5 l     F .text	00000062 addr_free_page
00010517 l     F .text	00000037 total_mem_size
000186b8 l     O .rodata	00000012 __func__.2543
0001a000 l     O .data	00000050 kernel_map.2554
000186cc l     O .rodata	0000000c __func__.2574
00010965 l     F .text	00000013 curr_page_dir
000186d8 l     O .rodata	00000011 __func__.2615
000186ec l     O .rodata	00000009 __func__.2675
00000000 l    df *ABS*	00000000 syscall.c
00018700 l     O .rodata	00000194 sys_table
00000000 l    df *ABS*	00000000 task.c
00010eca l     F .text	00000011 read_cr0
00010edb l     F .text	0000000c write_cr0
00010ee7 l     F .text	00000007 hlt
00010eee l     F .text	00000017 write_tr
00010f05 l     F .text	0000000c write_cr3
00010f11 l     F .text	0000000c write_cr4
00010f1d l     F .text	00000011 read_cr4
00010f2e l     F .text	0000001b list_node_init
00010f49 l     F .text	0000000b list_node_next
00010f54 l     F .text	0000000b list_count
00010f5f l     F .text	0000000a list_first
00010f69 l     F .text	0000003e mmu_set_page_dir
0001d000 l     O .bss	000005c0 task_manager
0001d5c0 l     O .bss	00001000 idle_task_stack
0001e5c0 l     O .bss	00016400 task_table
000349c0 l     O .bss	00000014 table_mutex
00010fa7 l     F .text	0000019b tss_init
000189d8 l     O .rodata	0000000a __func__.3077
0001136c l     F .text	0000000a idle_task_entry
000189e4 l     O .rodata	00000010 __func__.3108
00011885 l     F .text	00000068 alloc_task
000118ed l     F .text	00000033 free_task
00011920 l     F .text	00000056 copy_opened_files
00011af5 l     F .text	000000fe load_phdr
00011bf3 l     F .text	000001be load_elf_file
00011db1 l     F .text	000000f3 copy_args
000189f4 l     O .rodata	0000000a __func__.3239
00000000 l    df *ABS*	00000000 cpu.c
0001233f l     F .text	00000028 lgdt
00012367 l     F .text	0000001a far_jump
000349e0 l     O .bss	00000800 gdt_table
000351e0 l     O .bss	00000014 mutex
00000000 l    df *ABS*	00000000 irq.c
000125b6 l     F .text	00000007 cli
000125bd l     F .text	00000007 sti
000125c4 l     F .text	0000001d inb
000125e1 l     F .text	0000001f outb
00012600 l     F .text	00000028 lidt
00012628 l     F .text	00000007 hlt
0001262f l     F .text	00000010 read_eflags
0001263f l     F .text	0000000b write_eflags
0001264a l     F .text	00000011 read_cr2
0001265b l     F .text	00000093 init_pic
00035200 l     O .bss	00000400 idt_table
000129fe l     F .text	000000f8 dump_core_regs
00012af6 l     F .text	0000003f do_default_handler
00000000 l    df *ABS*	00000000 console.c
00012f2d l     F .text	0000001d inb
00012f4a l     F .text	0000001f outb
00035600 l     O .bss	00000340 console_buf
00035940 l     O .bss	00000004 curr_console_idx
00012f69 l     F .text	00000074 read_cursor_pos
00012fdd l     F .text	000000ba update_cursor_pos
00013097 l     F .text	00000093 erase_rows
0001312a l     F .text	00000089 scroll_up
000131b3 l     F .text	00000086 clear_display
00013239 l     F .text	00000010 move_to_col0
00013249 l     F .text	00000038 move_next_line
00013281 l     F .text	00000076 move_forward
000132f7 l     F .text	00000078 move_backword
00013452 l     F .text	00000095 show_char
000134e7 l     F .text	0000003a erase_backword
00013521 l     F .text	0000001e save_cursor
0001353f l     F .text	0000001e restore_cursor
0001355d l     F .text	00000029 clear_esc_param
00013586 l     F .text	00000071 write_esc
000135f7 l     F .text	00000099 set_font_style
00018fc0 l     O .rodata	00000020 color_table.2464
00013690 l     F .text	00000051 erase_in_display
000136e1 l     F .text	0000001e move_cursor
000136ff l     F .text	00000037 move_left
00013736 l     F .text	00000049 move_right
0001377f l     F .text	000000f4 write_esc_square
00013873 l     F .text	000000a2 write_normal
00000000 l    df *ABS*	00000000 dev.c
0001a050 l     O .data	00000008 dev_desc_tbl
00035960 l     O .bss	00000a00 dev_tb
00013ade l     F .text	0000003c is_devid_bad
00000000 l    df *ABS*	00000000 disk.c
00013dd4 l     F .text	0000001d inb
00013df1 l     F .text	0000001f inw
00013e10 l     F .text	00000021 outw
00013e31 l     F .text	0000001f outb
00036360 l     O .bss	00000014 disk_mutex
00036374 l     O .bss	00000010 op_sem
00036384 l     O .bss	00000004 task_on_op
000363a0 l     O .bss	00000250 disk_buf
00013e50 l     F .text	00000130 disk_send_cmd
00013f80 l     F .text	00000050 disk_read_data
00013fd0 l     F .text	00000050 disk_write_data
00014020 l     F .text	0000004b disk_wait_data
0001406b l     F .text	000000c7 print_disk_info
00014132 l     F .text	00000119 detect_part_info
0001424b l     F .text	00000127 identify_disk
00000000 l    df *ABS*	00000000 kbd.c
00014827 l     F .text	0000001d inb
000365f0 l     O .bss	00000004 kbd_stat
00019140 l     O .rodata	00000074 map_table
000365f4 l     O .bss	00000004 inited.2326
00014893 l     F .text	0000001a is_make_code
000148ad l     F .text	00000015 get_key
000148c2 l     F .text	0000003c do_fx_key
000148fe l     F .text	000001d3 do_normal_key
000365f8 l     O .bss	00000004 recv_state.2373
00000000 l    df *ABS*	00000000 time.c
00014bf5 l     F .text	0000001f outb
000365fc l     O .bss	00000004 sys_tick
00014c3c l     F .text	00000060 init_pit
00000000 l    df *ABS*	00000000 tty.c
00036600 l     O .bss	000022a0 tty_devs
000388a0 l     O .bss	00000004 curr_tty
00014cb4 l     F .text	0000004f get_tty
00000000 l    df *ABS*	00000000 devfs.c
0001a0e0 l     O .data	0000000c devfs_type_list
00000000 l    df *ABS*	00000000 fatfs.c
0001543f l     F .text	00000017 up2
00015456 l     F .text	0000003e bwrite_sector
000154bd l     F .text	00000059 bread_sector
0001562d l     F .text	00000085 read_dir_entry
000159fb l     F .text	00000175 expand_file
00015d7c l     F .text	00000087 to_sfn
00015e03 l     F .text	00000037 diritem_name_match
00015e3a l     F .text	00000065 read_from_diritem
00015f1e l     F .text	000000aa write_dir_entry
00016156 l     F .text	000000c2 move_file_pos
00000000 l    df *ABS*	00000000 file.c
000388c0 l     O .bss	00024000 file_table
0005c8c0 l     O .bss	00000014 file_alloc_mutex
00000000 l    df *ABS*	00000000 fs.c
00016a64 l     F .text	0000000b list_node_next
00016a6f l     F .text	0000000a list_first
0005c8e0 l     O .bss	00000004 root_fs
0005c8e4 l     O .bss	0000000c mounted_list
0005c900 l     O .bss	000016f8 fs_table
0005dff8 l     O .bss	0000000c free_list
00016a79 l     F .text	0000001d is_fd_bad
00016b3f l     F .text	00000021 is_path_valid
00016bb0 l     F .text	0000002b fs_protect
00016bdb l     F .text	0000002b fs_unprotect
000194ec l     O .rodata	0000000a __func__.3216
0001719b l     F .text	00000060 mount_list_init
000171fb l     F .text	00000026 get_fs_op
00017221 l     F .text	000001b7 mount
000194f8 l     O .rodata	00000008 __func__.3262
00000000 l    df *ABS*	00000000 init.c
00019554 l     O .rodata	00000013 __func__.3148
00000000 l    df *ABS*	00000000 mutex.c
000177a5 l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 sem.c
0001792c l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 bitmap.c
00000000 l    df *ABS*	00000000 kilb.c
00017ce6 l     F .text	00000007 hlt
0001a174 l     O .data	00000004 num2ch.2089
00000000 l    df *ABS*	00000000 list.c
000182a4 l     F .text	00000013 list_is_empty
00000000 l    df *ABS*	00000000 log.c
0005e004 l     O .bss	00000014 mutex
0005e018 l     O .bss	00000004 log_dev_id
00000000 l    df *ABS*	00000000 first_task.c
00000000 l    df *ABS*	00000000 lib_syscall.c
800000e0 l     F .first_task	0000004c sys_call
000155d4 g     F .text	00000059 diritem_get_type
00017ade g     F .text	0000004f bitmap_get_bit
00017e59 g     F .text	0000004f kernel_memcpy
00016fa1 g     F .text	000000f9 sys_close
000115fb g     F .text	0000000a task_current
00016b60 g     F .text	00000050 path_begin_with
800001e2 g     F .first_task	0000001b yield
000126f9 g     F .text	0000000b irq_enable_global
0001833b g     F .text	00000064 list_insert_last
00012053 g     F .text	00000031 task_file
000102a8 g       .text	00000000 exception_handler_kbd
00010d15 g     F .text	0000010c sys_sbrk
0001180b g     F .text	00000064 sys_msleep
00012c69 g     F .text	0000001c do_handler_segment_not_present
00011553 g     F .text	00000036 task_set_ready
000158ce g     F .text	0000012d cluster_alloc_free
00017c18 g     F .text	0000001b bitmap_is_set
00017ea8 g     F .text	00000041 kernel_memset
00013cb8 g     F .text	0000004c dev_write
00016f0c g     F .text	00000095 sys_lseek
00014844 g     F .text	0000004f kbd_init
00015745 g     F .text	0000012f cluster_set_next
0001026a g       .text	00000000 exception_handler_virtual_exception
000147e9 g     F .text	00000006 disk_close
00010e3b g     F .text	0000008f do_handler_syscall
000124d9 g     F .text	0000001e cpu_init
0001849c g     F .text	0000002f log_init
00016754 g     F .text	000000e7 fatfs_readdir
00011976 g     F .text	0000017f sys_fork
0001777b g     F .text	0000002a init_main
0001020f g       .text	00000000 exception_handler_alignment_check
000147df g     F .text	0000000a disk_control
00012580 g     F .text	00000036 gdt_free_sel
00010e21 g     F .text	0000001a sys_print_msg
0001a140 g     O .data	00000034 fatfs_op
00017ced g     F .text	00000047 kernel_strcpy
00014ad1 g     F .text	00000064 do_e0_key
0001a000 g       .data	00000000 s_data
800001b4 g     F .first_task	0000002e execve
80000156 g     F .first_task	0000001b getpid
00012704 g     F .text	0000008b irq_enable
0001002b g       .text	00000000 exception_handler_unknown
000156b2 g     F .text	00000093 diritem_get_name
000100a7 g       .text	00000000 exception_handler_breakpoint
00012bc1 g     F .text	0000001c do_handler_overflow
00012e69 g     F .text	0000001c do_handler_alignment_check
000105fe g     F .text	0000009d memory_create_map
00016d83 g     F .text	000000c5 sys_read
00016ae7 g     F .text	00000058 path_next_child
000163b1 g     F .text	0000021d fatfs_write
00013a26 g     F .text	000000b8 console_select
000101b6 g       .text	00000000 exception_handler_general_protection
00012ca1 g     F .text	000000d8 do_handler_general_protection
00017a4c g     F .text	00000029 sem_count
80000012 g     F .first_task	000000af first_task_main
00012b51 g     F .text	0000001c do_handler_divider
00017b2d g     F .text	000000eb bitmap_set_bit
00012c31 g     F .text	0000001c do_handler_double_fault
0001683b g     F .text	0000000a fatfs_closedir
00012d79 g     F .text	000000d4 do_handler_page_fault
00015b70 g     F .text	000001d0 fatfs_mount
800002cc g     F .first_task	00000021 isatty
00016218 g     F .text	00000199 fatfs_read
00010142 g       .text	00000000 exception_handler_double_fault
00012ed9 g     F .text	0000002b pic_send_eoi
00011549 g     F .text	0000000a task_first_task
00010000 g       .text	00000000 s_text
000107e7 g     F .text	00000085 memory_create_uvm
0001795a g     F .text	0000006e sem_wait
00010920 g     F .text	00000025 memory_alloc_page_for
00010199 g       .text	00000000 exception_handler_stack_segment_fault
80000000 g       .first_task	00000000 first_task_entry
000170f5 g     F .text	000000a6 sys_fstat
00013c6c g     F .text	0000004c dev_read
00016658 g     F .text	000000df fatfs_seek
000165ce g     F .text	0000008a fatfs_close
00012ebd g     F .text	0000001c do_handler_virtual_exception
00015415 g     F .text	0000000a devfs_stat
000100c6 g       .text	00000000 exception_handler_overflow
000102c7 g       .text	00000000 exception_handler_ide_primary
00015d40 g     F .text	0000003c fatfs_unmount
8000029f g     F .first_task	0000002d lseek
00010289 g       .text	00000000 exception_handler_time
0005e020 g     O .bss	00002000 stack
00014372 g     F .text	000000f8 disk_init
000173d8 g     F .text	00000090 fs_init
00016a2c g     F .text	00000038 file_inc_ref
00010978 g     F .text	00000099 memory_free_page
00060020 g       *ABS*	00000000 s_first_task
000120d5 g     F .text	00000026 task_remove_fd
0001516f g     F .text	0000005c tty_control
0001336f g     F .text	000000e3 console_init
00014f51 g     F .text	00000121 tty_read
000112c8 g     F .text	00000086 task_uninit
0001086c g     F .text	000000b4 memory_alloc_for_page_dir
0001541f g     F .text	00000020 devfs_ioctl
00014dc4 g     F .text	0000008d tty_fifo_get
000100e5 g       .text	00000000 exception_handler_bound_range
000151d1 g     F .text	0000006d tty_in
00015516 g     F .text	000000be cluster_get_next
000179c8 g     F .text	00000084 sem_notify
00010c93 g     F .text	00000082 memory_copy_uvm_data
00013d04 g     F .text	0000004c dev_control
00014b35 g     F .text	000000c0 do_handler_kbd
00012bf9 g     F .text	0000001c do_handler_invalid_opcode
0001015f g       .text	00000000 exception_handler_invalid_tss
00017546 g     F .text	00000053 sys_readdir
00012e4d g     F .text	0000001c do_handler_fpu_error
0001145d g     F .text	000000ec task_first_init
00012e85 g     F .text	0000001c do_handler_machine_check
80000251 g     F .first_task	0000002d write
00016c06 g     F .text	0000017d sys_open
00012b6d g     F .text	0000001c do_handler_Debug
800002ed g     F .first_task	00000027 fstat
0001709a g     F .text	0000005b sys_isatty
000182dc g     F .text	0000005f list_insert_first
00013b1a g     F .text	00000152 dev_open
00016a96 g     F .text	00000051 path_to_num
000117e9 g     F .text	00000022 task_set_wakeup
00012b89 g     F .text	0000001c do_handler_NMI
0001004a g       .text	00000000 exception_handler_divider
00014d03 g     F .text	00000037 tty_fifo_init
0001a060 g     O .data	00000038 dev_disk_desc
00017d34 g     F .text	00000070 kernel_strncpy
000126ee g     F .text	0000000b irq_disable_global
00011605 g     F .text	00000061 sys_sched_yield
00016e48 g     F .text	000000c4 sys_write
80000378 g     F .first_task	00000021 wait
000603b9 g       *ABS*	00000000 mem_free_start
000176e0 g     F .text	00000035 kernel_init
00017937 g     F .text	00000023 sem_init
00010000 g       .text	00000000 _start
000180b0 g     F .text	0000014b kernel_vsprintf
0001825e g     F .text	00000046 get_file_name
00010123 g       .text	00000000 exception_handler_device_unavailable
00010104 g       .text	00000000 exception_handler_invalid_opcode
00013d50 g     F .text	00000084 dev_close
00060020 g       .bss	00000000 e_data
80000224 g     F .first_task	0000002d read
000177de g     F .text	0000008f mutex_lock
00017599 g     F .text	00000050 sys_closedir
00016845 g     F .text	000000ea fatfs_unlink
00012084 g     F .text	00000051 task_alloc_fd
0001540b g     F .text	0000000a devfs_seek
00018231 g     F .text	0000002d string_count
0001022c g       .text	00000000 exception_handler_machine_check
00015072 g     F .text	000000fd tty_write
00012c4d g     F .text	0000001c do_handler_invalid_tss
00000000 g       .text	00000000 kernel_base
00014d3a g     F .text	0000008a tty_fifo_put
000603b9 g       *ABS*	00000000 e_first_task
000117ad g     F .text	0000003c task_set_sleep
00017468 g     F .text	0000008b sys_dup
000181fb g     F .text	00000036 panic
000129c4 g     F .text	0000003a irq_install
00012407 g     F .text	0000008b init_gdt
00015267 g     F .text	00000013 devfs_mount
00014e51 g     F .text	00000100 tty_open
80000199 g     F .first_task	0000001b fork
00012f04 g     F .text	00000018 irq_enter_protection
000177b0 g     F .text	0000002e mutex_init
0001278f g     F .text	00000087 irq_disable
80000314 g     F .first_task	00000021 sbrk
0001a100 g     O .data	00000034 devfs_op
00015280 g     F .text	00000128 devfs_open
0001024b g       .text	00000000 exception_handler_smd_exception
000175e9 g     F .text	000000a7 sys_ioctl
00010a11 g     F .text	000000e7 memory_destroy_uvm
00017a75 g     F .text	00000016 bitmap_byte_count
00012c15 g     F .text	0000001c do_handler_device_unavailable
00017690 g     F .text	00000050 sys_unlink
00015494 g     F .text	00000029 cluster_is_valid
00016741 g     F .text	00000013 fatfs_opendir
00011666 g     F .text	0000005b task_dispatch
00010af8 g     F .text	00000155 memory_copy_uvm
000151cb g     F .text	00000006 tty_close
000153cc g     F .text	00000024 devfs_write
00017715 g     F .text	00000066 move_to_first_task
0001256c g     F .text	00000014 switch_to_tss
000153f0 g     F .text	0000001b devfs_close
00013915 g     F .text	0000010b console_write
80000335 g     F .first_task	00000021 dup
000115b6 g     F .text	00000045 task_next_run
00017ee9 g     F .text	00000064 kernel_memcmp
0001069b g     F .text	000000a7 create_kernel_table
000182b7 g     F .text	00000025 list_init
00012ea1 g     F .text	0000001c do_handler_smd_exception
000101d3 g       .text	00000000 exception_handler_page_fault
00011589 g     F .text	0000002d task_set_block
00012b35 g     F .text	0000001c do_handler_unknown
00010945 g     F .text	00000020 memory_alloc_page
000101f0 g       .text	00000000 exception_handler_fpu_error
0001134e g     F .text	0000001e task_switch_from_to
00012816 g     F .text	000001ae irq_init
0001786d g     F .text	000000bf mutex_unlock
000169fc g     F .text	00000030 file_table_init
00012f1c g     F .text	00000011 irq_leave_protection
000169ba g     F .text	00000042 file_free
00015e9f g     F .text	0000007f diritem_init
80000171 g     F .first_task	00000028 print_msg
00017e1e g     F .text	0000003b kernel_strlen
00012381 g     F .text	00000086 segment_desc_set
00012bdd g     F .text	0000001c do_handler_bound_range
000102e6 g       .text	00000000 exception_handler_syscall
0001446a g     F .text	000000f5 disk_open
00015fc8 g     F .text	0000018e fatfs_open
0001839f g     F .text	00000078 list_remove_first
000195b8 g       .rodata	00000000 e_text
00017da4 g     F .text	0000007a kernel_strncmp
000174f3 g     F .text	00000053 sys_opendir
00017a8b g     F .text	00000053 bitmap_init
0001017c g       .text	00000000 exception_handler_segment_not_present
00010088 g       .text	00000000 exception_handler_NMI
00016737 g     F .text	0000000a fatfs_stat
00017c33 g     F .text	000000b3 bitmap_alloc_nbits
0001692f g     F .text	0000008b file_alloc
00011376 g     F .text	000000e7 task_manager_init
0001129b g     F .text	0000002d task_start
00010069 g       .text	00000000 exception_handler_Debug
000116c1 g     F .text	000000ec task_time_tick
00010742 g     F .text	000000a5 memory_init
00011ea4 g     F .text	000001af sys_execve
0001469f g     F .text	00000140 disk_write
0001224f g     F .text	000000f0 sys_wait
000120fb g     F .text	00000154 sys_exit
0001523e g     F .text	00000029 tty_select
00013a20 g     F .text	00000006 console_close
00010c4d g     F .text	00000046 memory_get_paddr
00012c85 g     F .text	0000001c do_handler_stack_segment_fault
00012ba5 g     F .text	0000001c do_handler_breakpoint
0001527a g     F .text	00000006 devfs_unmount
80000356 g     F .first_task	00000022 _exit
000153a8 g     F .text	00000024 devfs_read
000184cb g     F .text	000000b6 log_printf
00011142 g     F .text	00000159 task_init
0001455f g     F .text	00000140 disk_read
800001fd g     F .first_task	00000027 open
00015874 g     F .text	0000005a cluster_free_chain
00017f4d g     F .text	00000024 kernel_sprintf
0001186f g     F .text	00000016 sys_getpid
000124f7 g     F .text	00000075 gdt_alloc_desc
00017f71 g     F .text	0000013f kernel_itoa
00018417 g     F .text	00000085 list_remove
00012492 g     F .text	00000047 gate_desc_set
8000012c g     F .first_task	0000002a msleep
8000027e g     F .first_task	00000021 close
000147ef g     F .text	00000038 do_handler_ide_primary
0001054e g     F .text	000000b0 find_pte
00014c14 g     F .text	00000028 do_handler_time
00014c9c g     F .text	00000018 time_init
0001a0a0 g     O .data	00000038 dev_tty_desc



Disassembly of section .text:

00010000 <_start>:
_start:
    // 从栈中取出参数,参数保存在%eax中,最终传递给kernel_init函数
    // 参数位于load_32.c中
    // 以下三步可以简写为: mov 4(%esp),%eax
    // 传递的是boot_info
    push %ebp
   10000:	55                   	push   %ebp
    mov %esp,%ebp
   10001:	89 e5                	mov    %esp,%ebp
    mov 0x8(%ebp),%eax
   10003:	8b 45 08             	mov    0x8(%ebp),%eax
    
    push %eax
   10006:	50                   	push   %eax

    // kernel_init 位于init.c中
    call kernel_init
   10007:	e8 d4 76 00 00       	call   176e0 <kernel_init>

    // 加载到对应选择子以及偏移量
    jmp $KERNEL_SELECTOR_CS,$gdt_reload
   1000c:	ea 13 00 01 00 08 00 	ljmp   $0x8,$0x10013

00010013 <gdt_reload>:
gdt_reload:
    // 初始化寄存器
    mov $KERNEL_SELECTOR_DS,%ax
   10013:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
   10017:	8e d8                	mov    %eax,%ds
	mov %ax, %ss
   10019:	8e d0                	mov    %eax,%ss
	mov %ax, %es
   1001b:	8e c0                	mov    %eax,%es
	mov %ax, %fs
   1001d:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
   1001f:	8e e8                	mov    %eax,%gs
    mov $(stack+KERNEL_STACK_SIZE),%esp
   10021:	bc 20 00 06 00       	mov    $0x60020,%esp
    jmp init_main
   10026:	e9 50 77 00 00       	jmp    1777b <init_main>

0001002b <exception_handler_unknown>:
    iret

// 宏的结束
.endm

exception_handler unknown,-1,0
   1002b:	6a 00                	push   $0x0
   1002d:	6a ff                	push   $0xffffffff
   1002f:	60                   	pusha  
   10030:	1e                   	push   %ds
   10031:	06                   	push   %es
   10032:	0f a0                	push   %fs
   10034:	0f a8                	push   %gs
   10036:	54                   	push   %esp
   10037:	e8 f9 2a 00 00       	call   12b35 <do_handler_unknown>
   1003c:	83 c4 04             	add    $0x4,%esp
   1003f:	0f a9                	pop    %gs
   10041:	0f a1                	pop    %fs
   10043:	07                   	pop    %es
   10044:	1f                   	pop    %ds
   10045:	61                   	popa   
   10046:	83 c4 08             	add    $0x8,%esp
   10049:	cf                   	iret   

0001004a <exception_handler_divider>:
exception_handler divider,0,0
   1004a:	6a 00                	push   $0x0
   1004c:	6a 00                	push   $0x0
   1004e:	60                   	pusha  
   1004f:	1e                   	push   %ds
   10050:	06                   	push   %es
   10051:	0f a0                	push   %fs
   10053:	0f a8                	push   %gs
   10055:	54                   	push   %esp
   10056:	e8 f6 2a 00 00       	call   12b51 <do_handler_divider>
   1005b:	83 c4 04             	add    $0x4,%esp
   1005e:	0f a9                	pop    %gs
   10060:	0f a1                	pop    %fs
   10062:	07                   	pop    %es
   10063:	1f                   	pop    %ds
   10064:	61                   	popa   
   10065:	83 c4 08             	add    $0x8,%esp
   10068:	cf                   	iret   

00010069 <exception_handler_Debug>:
exception_handler Debug, 1, 0
   10069:	6a 00                	push   $0x0
   1006b:	6a 01                	push   $0x1
   1006d:	60                   	pusha  
   1006e:	1e                   	push   %ds
   1006f:	06                   	push   %es
   10070:	0f a0                	push   %fs
   10072:	0f a8                	push   %gs
   10074:	54                   	push   %esp
   10075:	e8 f3 2a 00 00       	call   12b6d <do_handler_Debug>
   1007a:	83 c4 04             	add    $0x4,%esp
   1007d:	0f a9                	pop    %gs
   1007f:	0f a1                	pop    %fs
   10081:	07                   	pop    %es
   10082:	1f                   	pop    %ds
   10083:	61                   	popa   
   10084:	83 c4 08             	add    $0x8,%esp
   10087:	cf                   	iret   

00010088 <exception_handler_NMI>:
exception_handler NMI, 2, 0
   10088:	6a 00                	push   $0x0
   1008a:	6a 02                	push   $0x2
   1008c:	60                   	pusha  
   1008d:	1e                   	push   %ds
   1008e:	06                   	push   %es
   1008f:	0f a0                	push   %fs
   10091:	0f a8                	push   %gs
   10093:	54                   	push   %esp
   10094:	e8 f0 2a 00 00       	call   12b89 <do_handler_NMI>
   10099:	83 c4 04             	add    $0x4,%esp
   1009c:	0f a9                	pop    %gs
   1009e:	0f a1                	pop    %fs
   100a0:	07                   	pop    %es
   100a1:	1f                   	pop    %ds
   100a2:	61                   	popa   
   100a3:	83 c4 08             	add    $0x8,%esp
   100a6:	cf                   	iret   

000100a7 <exception_handler_breakpoint>:
exception_handler breakpoint, 3, 0
   100a7:	6a 00                	push   $0x0
   100a9:	6a 03                	push   $0x3
   100ab:	60                   	pusha  
   100ac:	1e                   	push   %ds
   100ad:	06                   	push   %es
   100ae:	0f a0                	push   %fs
   100b0:	0f a8                	push   %gs
   100b2:	54                   	push   %esp
   100b3:	e8 ed 2a 00 00       	call   12ba5 <do_handler_breakpoint>
   100b8:	83 c4 04             	add    $0x4,%esp
   100bb:	0f a9                	pop    %gs
   100bd:	0f a1                	pop    %fs
   100bf:	07                   	pop    %es
   100c0:	1f                   	pop    %ds
   100c1:	61                   	popa   
   100c2:	83 c4 08             	add    $0x8,%esp
   100c5:	cf                   	iret   

000100c6 <exception_handler_overflow>:
exception_handler overflow, 4, 0
   100c6:	6a 00                	push   $0x0
   100c8:	6a 04                	push   $0x4
   100ca:	60                   	pusha  
   100cb:	1e                   	push   %ds
   100cc:	06                   	push   %es
   100cd:	0f a0                	push   %fs
   100cf:	0f a8                	push   %gs
   100d1:	54                   	push   %esp
   100d2:	e8 ea 2a 00 00       	call   12bc1 <do_handler_overflow>
   100d7:	83 c4 04             	add    $0x4,%esp
   100da:	0f a9                	pop    %gs
   100dc:	0f a1                	pop    %fs
   100de:	07                   	pop    %es
   100df:	1f                   	pop    %ds
   100e0:	61                   	popa   
   100e1:	83 c4 08             	add    $0x8,%esp
   100e4:	cf                   	iret   

000100e5 <exception_handler_bound_range>:
exception_handler bound_range, 5, 0
   100e5:	6a 00                	push   $0x0
   100e7:	6a 05                	push   $0x5
   100e9:	60                   	pusha  
   100ea:	1e                   	push   %ds
   100eb:	06                   	push   %es
   100ec:	0f a0                	push   %fs
   100ee:	0f a8                	push   %gs
   100f0:	54                   	push   %esp
   100f1:	e8 e7 2a 00 00       	call   12bdd <do_handler_bound_range>
   100f6:	83 c4 04             	add    $0x4,%esp
   100f9:	0f a9                	pop    %gs
   100fb:	0f a1                	pop    %fs
   100fd:	07                   	pop    %es
   100fe:	1f                   	pop    %ds
   100ff:	61                   	popa   
   10100:	83 c4 08             	add    $0x8,%esp
   10103:	cf                   	iret   

00010104 <exception_handler_invalid_opcode>:
exception_handler invalid_opcode, 6, 0
   10104:	6a 00                	push   $0x0
   10106:	6a 06                	push   $0x6
   10108:	60                   	pusha  
   10109:	1e                   	push   %ds
   1010a:	06                   	push   %es
   1010b:	0f a0                	push   %fs
   1010d:	0f a8                	push   %gs
   1010f:	54                   	push   %esp
   10110:	e8 e4 2a 00 00       	call   12bf9 <do_handler_invalid_opcode>
   10115:	83 c4 04             	add    $0x4,%esp
   10118:	0f a9                	pop    %gs
   1011a:	0f a1                	pop    %fs
   1011c:	07                   	pop    %es
   1011d:	1f                   	pop    %ds
   1011e:	61                   	popa   
   1011f:	83 c4 08             	add    $0x8,%esp
   10122:	cf                   	iret   

00010123 <exception_handler_device_unavailable>:
exception_handler device_unavailable, 7, 0
   10123:	6a 00                	push   $0x0
   10125:	6a 07                	push   $0x7
   10127:	60                   	pusha  
   10128:	1e                   	push   %ds
   10129:	06                   	push   %es
   1012a:	0f a0                	push   %fs
   1012c:	0f a8                	push   %gs
   1012e:	54                   	push   %esp
   1012f:	e8 e1 2a 00 00       	call   12c15 <do_handler_device_unavailable>
   10134:	83 c4 04             	add    $0x4,%esp
   10137:	0f a9                	pop    %gs
   10139:	0f a1                	pop    %fs
   1013b:	07                   	pop    %es
   1013c:	1f                   	pop    %ds
   1013d:	61                   	popa   
   1013e:	83 c4 08             	add    $0x8,%esp
   10141:	cf                   	iret   

00010142 <exception_handler_double_fault>:
exception_handler double_fault, 8, 1
   10142:	6a 08                	push   $0x8
   10144:	60                   	pusha  
   10145:	1e                   	push   %ds
   10146:	06                   	push   %es
   10147:	0f a0                	push   %fs
   10149:	0f a8                	push   %gs
   1014b:	54                   	push   %esp
   1014c:	e8 e0 2a 00 00       	call   12c31 <do_handler_double_fault>
   10151:	83 c4 04             	add    $0x4,%esp
   10154:	0f a9                	pop    %gs
   10156:	0f a1                	pop    %fs
   10158:	07                   	pop    %es
   10159:	1f                   	pop    %ds
   1015a:	61                   	popa   
   1015b:	83 c4 08             	add    $0x8,%esp
   1015e:	cf                   	iret   

0001015f <exception_handler_invalid_tss>:
exception_handler invalid_tss, 10, 1
   1015f:	6a 0a                	push   $0xa
   10161:	60                   	pusha  
   10162:	1e                   	push   %ds
   10163:	06                   	push   %es
   10164:	0f a0                	push   %fs
   10166:	0f a8                	push   %gs
   10168:	54                   	push   %esp
   10169:	e8 df 2a 00 00       	call   12c4d <do_handler_invalid_tss>
   1016e:	83 c4 04             	add    $0x4,%esp
   10171:	0f a9                	pop    %gs
   10173:	0f a1                	pop    %fs
   10175:	07                   	pop    %es
   10176:	1f                   	pop    %ds
   10177:	61                   	popa   
   10178:	83 c4 08             	add    $0x8,%esp
   1017b:	cf                   	iret   

0001017c <exception_handler_segment_not_present>:
exception_handler segment_not_present, 11, 1
   1017c:	6a 0b                	push   $0xb
   1017e:	60                   	pusha  
   1017f:	1e                   	push   %ds
   10180:	06                   	push   %es
   10181:	0f a0                	push   %fs
   10183:	0f a8                	push   %gs
   10185:	54                   	push   %esp
   10186:	e8 de 2a 00 00       	call   12c69 <do_handler_segment_not_present>
   1018b:	83 c4 04             	add    $0x4,%esp
   1018e:	0f a9                	pop    %gs
   10190:	0f a1                	pop    %fs
   10192:	07                   	pop    %es
   10193:	1f                   	pop    %ds
   10194:	61                   	popa   
   10195:	83 c4 08             	add    $0x8,%esp
   10198:	cf                   	iret   

00010199 <exception_handler_stack_segment_fault>:
exception_handler stack_segment_fault, 12, 1
   10199:	6a 0c                	push   $0xc
   1019b:	60                   	pusha  
   1019c:	1e                   	push   %ds
   1019d:	06                   	push   %es
   1019e:	0f a0                	push   %fs
   101a0:	0f a8                	push   %gs
   101a2:	54                   	push   %esp
   101a3:	e8 dd 2a 00 00       	call   12c85 <do_handler_stack_segment_fault>
   101a8:	83 c4 04             	add    $0x4,%esp
   101ab:	0f a9                	pop    %gs
   101ad:	0f a1                	pop    %fs
   101af:	07                   	pop    %es
   101b0:	1f                   	pop    %ds
   101b1:	61                   	popa   
   101b2:	83 c4 08             	add    $0x8,%esp
   101b5:	cf                   	iret   

000101b6 <exception_handler_general_protection>:
exception_handler general_protection, 13, 1
   101b6:	6a 0d                	push   $0xd
   101b8:	60                   	pusha  
   101b9:	1e                   	push   %ds
   101ba:	06                   	push   %es
   101bb:	0f a0                	push   %fs
   101bd:	0f a8                	push   %gs
   101bf:	54                   	push   %esp
   101c0:	e8 dc 2a 00 00       	call   12ca1 <do_handler_general_protection>
   101c5:	83 c4 04             	add    $0x4,%esp
   101c8:	0f a9                	pop    %gs
   101ca:	0f a1                	pop    %fs
   101cc:	07                   	pop    %es
   101cd:	1f                   	pop    %ds
   101ce:	61                   	popa   
   101cf:	83 c4 08             	add    $0x8,%esp
   101d2:	cf                   	iret   

000101d3 <exception_handler_page_fault>:
exception_handler page_fault, 14, 1
   101d3:	6a 0e                	push   $0xe
   101d5:	60                   	pusha  
   101d6:	1e                   	push   %ds
   101d7:	06                   	push   %es
   101d8:	0f a0                	push   %fs
   101da:	0f a8                	push   %gs
   101dc:	54                   	push   %esp
   101dd:	e8 97 2b 00 00       	call   12d79 <do_handler_page_fault>
   101e2:	83 c4 04             	add    $0x4,%esp
   101e5:	0f a9                	pop    %gs
   101e7:	0f a1                	pop    %fs
   101e9:	07                   	pop    %es
   101ea:	1f                   	pop    %ds
   101eb:	61                   	popa   
   101ec:	83 c4 08             	add    $0x8,%esp
   101ef:	cf                   	iret   

000101f0 <exception_handler_fpu_error>:
exception_handler fpu_error, 16, 0
   101f0:	6a 00                	push   $0x0
   101f2:	6a 10                	push   $0x10
   101f4:	60                   	pusha  
   101f5:	1e                   	push   %ds
   101f6:	06                   	push   %es
   101f7:	0f a0                	push   %fs
   101f9:	0f a8                	push   %gs
   101fb:	54                   	push   %esp
   101fc:	e8 4c 2c 00 00       	call   12e4d <do_handler_fpu_error>
   10201:	83 c4 04             	add    $0x4,%esp
   10204:	0f a9                	pop    %gs
   10206:	0f a1                	pop    %fs
   10208:	07                   	pop    %es
   10209:	1f                   	pop    %ds
   1020a:	61                   	popa   
   1020b:	83 c4 08             	add    $0x8,%esp
   1020e:	cf                   	iret   

0001020f <exception_handler_alignment_check>:
exception_handler alignment_check, 17, 1
   1020f:	6a 11                	push   $0x11
   10211:	60                   	pusha  
   10212:	1e                   	push   %ds
   10213:	06                   	push   %es
   10214:	0f a0                	push   %fs
   10216:	0f a8                	push   %gs
   10218:	54                   	push   %esp
   10219:	e8 4b 2c 00 00       	call   12e69 <do_handler_alignment_check>
   1021e:	83 c4 04             	add    $0x4,%esp
   10221:	0f a9                	pop    %gs
   10223:	0f a1                	pop    %fs
   10225:	07                   	pop    %es
   10226:	1f                   	pop    %ds
   10227:	61                   	popa   
   10228:	83 c4 08             	add    $0x8,%esp
   1022b:	cf                   	iret   

0001022c <exception_handler_machine_check>:
exception_handler machine_check, 18, 0
   1022c:	6a 00                	push   $0x0
   1022e:	6a 12                	push   $0x12
   10230:	60                   	pusha  
   10231:	1e                   	push   %ds
   10232:	06                   	push   %es
   10233:	0f a0                	push   %fs
   10235:	0f a8                	push   %gs
   10237:	54                   	push   %esp
   10238:	e8 48 2c 00 00       	call   12e85 <do_handler_machine_check>
   1023d:	83 c4 04             	add    $0x4,%esp
   10240:	0f a9                	pop    %gs
   10242:	0f a1                	pop    %fs
   10244:	07                   	pop    %es
   10245:	1f                   	pop    %ds
   10246:	61                   	popa   
   10247:	83 c4 08             	add    $0x8,%esp
   1024a:	cf                   	iret   

0001024b <exception_handler_smd_exception>:
exception_handler smd_exception, 19, 0
   1024b:	6a 00                	push   $0x0
   1024d:	6a 13                	push   $0x13
   1024f:	60                   	pusha  
   10250:	1e                   	push   %ds
   10251:	06                   	push   %es
   10252:	0f a0                	push   %fs
   10254:	0f a8                	push   %gs
   10256:	54                   	push   %esp
   10257:	e8 45 2c 00 00       	call   12ea1 <do_handler_smd_exception>
   1025c:	83 c4 04             	add    $0x4,%esp
   1025f:	0f a9                	pop    %gs
   10261:	0f a1                	pop    %fs
   10263:	07                   	pop    %es
   10264:	1f                   	pop    %ds
   10265:	61                   	popa   
   10266:	83 c4 08             	add    $0x8,%esp
   10269:	cf                   	iret   

0001026a <exception_handler_virtual_exception>:
exception_handler virtual_exception, 20, 0
   1026a:	6a 00                	push   $0x0
   1026c:	6a 14                	push   $0x14
   1026e:	60                   	pusha  
   1026f:	1e                   	push   %ds
   10270:	06                   	push   %es
   10271:	0f a0                	push   %fs
   10273:	0f a8                	push   %gs
   10275:	54                   	push   %esp
   10276:	e8 42 2c 00 00       	call   12ebd <do_handler_virtual_exception>
   1027b:	83 c4 04             	add    $0x4,%esp
   1027e:	0f a9                	pop    %gs
   10280:	0f a1                	pop    %fs
   10282:	07                   	pop    %es
   10283:	1f                   	pop    %ds
   10284:	61                   	popa   
   10285:	83 c4 08             	add    $0x8,%esp
   10288:	cf                   	iret   

00010289 <exception_handler_time>:
exception_handler time,0x20,0
   10289:	6a 00                	push   $0x0
   1028b:	6a 20                	push   $0x20
   1028d:	60                   	pusha  
   1028e:	1e                   	push   %ds
   1028f:	06                   	push   %es
   10290:	0f a0                	push   %fs
   10292:	0f a8                	push   %gs
   10294:	54                   	push   %esp
   10295:	e8 7a 49 00 00       	call   14c14 <do_handler_time>
   1029a:	83 c4 04             	add    $0x4,%esp
   1029d:	0f a9                	pop    %gs
   1029f:	0f a1                	pop    %fs
   102a1:	07                   	pop    %es
   102a2:	1f                   	pop    %ds
   102a3:	61                   	popa   
   102a4:	83 c4 08             	add    $0x8,%esp
   102a7:	cf                   	iret   

000102a8 <exception_handler_kbd>:
exception_handler kbd,0x21,0
   102a8:	6a 00                	push   $0x0
   102aa:	6a 21                	push   $0x21
   102ac:	60                   	pusha  
   102ad:	1e                   	push   %ds
   102ae:	06                   	push   %es
   102af:	0f a0                	push   %fs
   102b1:	0f a8                	push   %gs
   102b3:	54                   	push   %esp
   102b4:	e8 7c 48 00 00       	call   14b35 <do_handler_kbd>
   102b9:	83 c4 04             	add    $0x4,%esp
   102bc:	0f a9                	pop    %gs
   102be:	0f a1                	pop    %fs
   102c0:	07                   	pop    %es
   102c1:	1f                   	pop    %ds
   102c2:	61                   	popa   
   102c3:	83 c4 08             	add    $0x8,%esp
   102c6:	cf                   	iret   

000102c7 <exception_handler_ide_primary>:
exception_handler ide_primary,0x2e,0
   102c7:	6a 00                	push   $0x0
   102c9:	6a 2e                	push   $0x2e
   102cb:	60                   	pusha  
   102cc:	1e                   	push   %ds
   102cd:	06                   	push   %es
   102ce:	0f a0                	push   %fs
   102d0:	0f a8                	push   %gs
   102d2:	54                   	push   %esp
   102d3:	e8 17 45 00 00       	call   147ef <do_handler_ide_primary>
   102d8:	83 c4 04             	add    $0x4,%esp
   102db:	0f a9                	pop    %gs
   102dd:	0f a1                	pop    %fs
   102df:	07                   	pop    %es
   102e0:	1f                   	pop    %ds
   102e1:	61                   	popa   
   102e2:	83 c4 08             	add    $0x8,%esp
   102e5:	cf                   	iret   

000102e6 <exception_handler_syscall>:

    .global exception_handler_syscall
    .extern do_handler_syscall
exception_handler_syscall:
    pusha
   102e6:	60                   	pusha  
    push %ds
   102e7:	1e                   	push   %ds
    push %es
   102e8:	06                   	push   %es
    push %fs
   102e9:	0f a0                	push   %fs
    push %gs
   102eb:	0f a8                	push   %gs
    pushf
   102ed:	9c                   	pushf  

    mov %esp,%eax
   102ee:	89 e0                	mov    %esp,%eax
    push %eax
   102f0:	50                   	push   %eax

    call do_handler_syscall
   102f1:	e8 45 0b 00 00       	call   10e3b <do_handler_syscall>
    add $4,%esp
   102f6:	83 c4 04             	add    $0x4,%esp
    
    popf
   102f9:	9d                   	popf   
    pop %gs
   102fa:	0f a9                	pop    %gs
    pop %fs
   102fc:	0f a1                	pop    %fs
    pop %es
   102fe:	07                   	pop    %es
    pop %ds
   102ff:	1f                   	pop    %ds
    popa
   10300:	61                   	popa   

   10301:	ca 14 00             	lret   $0x14

00010304 <read_cr0>:

/**
 * @brief 读取cr0寄存器
 * @return cr0寄存器的值 
 */
static inline uint32_t read_cr0(void){
   10304:	55                   	push   %ebp
   10305:	89 e5                	mov    %esp,%ebp
   10307:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr0;
    __asm__ __volatile__(
   1030a:	0f 20 c0             	mov    %cr0,%eax
   1030d:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "mov %%cr0, %[v]"
        :[v]"=r"(cr0)
        :
    );
    return cr0;
   10310:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10313:	c9                   	leave  
   10314:	c3                   	ret    

00010315 <write_cr0>:

/**
 * @brief 读取cr0寄存器
 * @return cr0寄存器的值 
 */
static inline void write_cr0(uint32_t v){
   10315:	55                   	push   %ebp
   10316:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10318:	8b 45 08             	mov    0x8(%ebp),%eax
   1031b:	0f 22 c0             	mov    %eax,%cr0
        "mov %[v],%%cr0"
        :
        :[v]"r"(v)
    );
}
   1031e:	90                   	nop
   1031f:	5d                   	pop    %ebp
   10320:	c3                   	ret    

00010321 <write_cr3>:
        :
        :"a"(eflags)
    );
}

static inline void write_cr3(uint32_t v){
   10321:	55                   	push   %ebp
   10322:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10324:	8b 45 08             	mov    0x8(%ebp),%eax
   10327:	0f 22 d8             	mov    %eax,%cr3
        "mov %[v],%%cr3"
        :
        :[v]"r"(v)
    );
}
   1032a:	90                   	nop
   1032b:	5d                   	pop    %ebp
   1032c:	c3                   	ret    

0001032d <write_cr4>:

/**
 * @brief 写入cr4寄存器
 * @param v 要写入的值
 */
static inline void write_cr4(uint32_t v){
   1032d:	55                   	push   %ebp
   1032e:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10330:	8b 45 08             	mov    0x8(%ebp),%eax
   10333:	0f 22 e0             	mov    %eax,%cr4
        "mov %[v],%%cr4"
        :
        :[v]"r"(v)
    );
}
   10336:	90                   	nop
   10337:	5d                   	pop    %ebp
   10338:	c3                   	ret    

00010339 <read_cr4>:

/**
 * @brief 读取cr4寄存器
 * @return cr4寄存器的值 
*/
static inline uint32_t read_cr4(void){
   10339:	55                   	push   %ebp
   1033a:	89 e5                	mov    %esp,%ebp
   1033c:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr4;
    __asm__ __volatile__(
   1033f:	0f 20 e0             	mov    %cr4,%eax
   10342:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "mov %%cr4,%[v]"
        :[v]"=r"(cr4)
        :
    );
    return cr4;
   10345:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10348:	c9                   	leave  
   10349:	c3                   	ret    

0001034a <down2>:
#include <stdarg.h>
#include "comm/types.h"
#include "tools/log.h"
#include "comm/cpu_instr.h"

static inline uint32_t down2(uint32_t size,uint32_t bound){
   1034a:	55                   	push   %ebp
   1034b:	89 e5                	mov    %esp,%ebp
    return size & ~(bound-1);
   1034d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10350:	f7 d8                	neg    %eax
   10352:	23 45 08             	and    0x8(%ebp),%eax
}
   10355:	5d                   	pop    %ebp
   10356:	c3                   	ret    

00010357 <up2>:

static inline uint32_t up2(uint32_t size,uint32_t bound){
   10357:	55                   	push   %ebp
   10358:	89 e5                	mov    %esp,%ebp
    return (size+bound-1) & ~(bound-1);
   1035a:	8b 55 08             	mov    0x8(%ebp),%edx
   1035d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10360:	01 d0                	add    %edx,%eax
   10362:	8d 50 ff             	lea    -0x1(%eax),%edx
   10365:	8b 45 0c             	mov    0xc(%ebp),%eax
   10368:	f7 d8                	neg    %eax
   1036a:	21 d0                	and    %edx,%eax
}
   1036c:	5d                   	pop    %ebp
   1036d:	c3                   	ret    

0001036e <mmu_set_page_dir>:

/**
 * @brief 将页目录的物理地址写入cr3寄存器
 * @param paddr 页目录表的物理地址 
*/
static inline void mmu_set_page_dir(uint32_t paddr){
   1036e:	55                   	push   %ebp
   1036f:	89 e5                	mov    %esp,%ebp
   10371:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr4=read_cr4();
   10374:	e8 c0 ff ff ff       	call   10339 <read_cr4>
   10379:	89 45 fc             	mov    %eax,-0x4(%ebp)
	write_cr4(cr4|CR4_PSE);
   1037c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1037f:	83 c8 10             	or     $0x10,%eax
   10382:	50                   	push   %eax
   10383:	e8 a5 ff ff ff       	call   1032d <write_cr4>
   10388:	83 c4 04             	add    $0x4,%esp
	write_cr3(paddr);
   1038b:	ff 75 08             	pushl  0x8(%ebp)
   1038e:	e8 8e ff ff ff       	call   10321 <write_cr3>
   10393:	83 c4 04             	add    $0x4,%esp
	write_cr0(read_cr0()|CR0_PG);
   10396:	e8 69 ff ff ff       	call   10304 <read_cr0>
   1039b:	0d 00 00 00 80       	or     $0x80000000,%eax
   103a0:	50                   	push   %eax
   103a1:	e8 6f ff ff ff       	call   10315 <write_cr0>
   103a6:	83 c4 04             	add    $0x4,%esp
}
   103a9:	90                   	nop
   103aa:	c9                   	leave  
   103ab:	c3                   	ret    

000103ac <pde_index>:

static inline uint32_t pde_index(uint32_t vaddr){
   103ac:	55                   	push   %ebp
   103ad:	89 e5                	mov    %esp,%ebp
    return vaddr >> 22;
   103af:	8b 45 08             	mov    0x8(%ebp),%eax
   103b2:	c1 e8 16             	shr    $0x16,%eax
}
   103b5:	5d                   	pop    %ebp
   103b6:	c3                   	ret    

000103b7 <pte_index>:

static inline uint32_t pte_index(uint32_t vaddr){
   103b7:	55                   	push   %ebp
   103b8:	89 e5                	mov    %esp,%ebp
    return (vaddr >> 12)  & 0x3FF;
   103ba:	8b 45 08             	mov    0x8(%ebp),%eax
   103bd:	c1 e8 0c             	shr    $0xc,%eax
   103c0:	25 ff 03 00 00       	and    $0x3ff,%eax
}
   103c5:	5d                   	pop    %ebp
   103c6:	c3                   	ret    

000103c7 <pde_paddr>:

static inline uint32_t pde_paddr(pde_t* pde){
   103c7:	55                   	push   %ebp
   103c8:	89 e5                	mov    %esp,%ebp
    return pde->phy_pt_addr << 12;
   103ca:	8b 45 08             	mov    0x8(%ebp),%eax
   103cd:	8b 00                	mov    (%eax),%eax
   103cf:	c1 e8 0c             	shr    $0xc,%eax
   103d2:	c1 e0 0c             	shl    $0xc,%eax
}
   103d5:	5d                   	pop    %ebp
   103d6:	c3                   	ret    

000103d7 <pte_paddr>:

static inline uint32_t pte_paddr(pte_t* pte){
   103d7:	55                   	push   %ebp
   103d8:	89 e5                	mov    %esp,%ebp
    return pte->phy_pt_addr << 12;
   103da:	8b 45 08             	mov    0x8(%ebp),%eax
   103dd:	8b 00                	mov    (%eax),%eax
   103df:	c1 e8 0c             	shr    $0xc,%eax
   103e2:	c1 e0 0c             	shl    $0xc,%eax
}
   103e5:	5d                   	pop    %ebp
   103e6:	c3                   	ret    

000103e7 <get_pte_perm>:

static inline uint32_t get_pte_perm(pte_t* pte){
   103e7:	55                   	push   %ebp
   103e8:	89 e5                	mov    %esp,%ebp
    return (pte->v & 0x1FF);
   103ea:	8b 45 08             	mov    0x8(%ebp),%eax
   103ed:	8b 00                	mov    (%eax),%eax
   103ef:	25 ff 01 00 00       	and    $0x1ff,%eax
}
   103f4:	5d                   	pop    %ebp
   103f5:	c3                   	ret    

000103f6 <addr_alloc_init>:

/// @brief 内核页目录表
static pde_t kernel_page_dir[PDE_CNT] __attribute__((aligned(MEM_PAGE_SIZE)));

static void addr_alloc_init(addr_alloc_t* alloc,uint8_t* bits,
    uint32_t start,uint32_t size,uint32_t page_size){
   103f6:	55                   	push   %ebp
   103f7:	89 e5                	mov    %esp,%ebp
   103f9:	83 ec 08             	sub    $0x8,%esp
        mutex_init(&alloc->mutex);
   103fc:	8b 45 08             	mov    0x8(%ebp),%eax
   103ff:	83 ec 0c             	sub    $0xc,%esp
   10402:	50                   	push   %eax
   10403:	e8 a8 73 00 00       	call   177b0 <mutex_init>
   10408:	83 c4 10             	add    $0x10,%esp
        alloc->start=start;
   1040b:	8b 45 08             	mov    0x8(%ebp),%eax
   1040e:	8b 55 10             	mov    0x10(%ebp),%edx
   10411:	89 50 1c             	mov    %edx,0x1c(%eax)
        alloc->size=size;
   10414:	8b 45 08             	mov    0x8(%ebp),%eax
   10417:	8b 55 14             	mov    0x14(%ebp),%edx
   1041a:	89 50 20             	mov    %edx,0x20(%eax)
        alloc->page_size=page_size;
   1041d:	8b 45 08             	mov    0x8(%ebp),%eax
   10420:	8b 55 18             	mov    0x18(%ebp),%edx
   10423:	89 50 24             	mov    %edx,0x24(%eax)
        bitmap_init(&alloc->bitmap,bits,alloc->size/page_size,0);
   10426:	8b 45 08             	mov    0x8(%ebp),%eax
   10429:	8b 40 20             	mov    0x20(%eax),%eax
   1042c:	ba 00 00 00 00       	mov    $0x0,%edx
   10431:	f7 75 18             	divl   0x18(%ebp)
   10434:	89 c2                	mov    %eax,%edx
   10436:	8b 45 08             	mov    0x8(%ebp),%eax
   10439:	83 c0 14             	add    $0x14,%eax
   1043c:	6a 00                	push   $0x0
   1043e:	52                   	push   %edx
   1043f:	ff 75 0c             	pushl  0xc(%ebp)
   10442:	50                   	push   %eax
   10443:	e8 43 76 00 00       	call   17a8b <bitmap_init>
   10448:	83 c4 10             	add    $0x10,%esp
}
   1044b:	90                   	nop
   1044c:	c9                   	leave  
   1044d:	c3                   	ret    

0001044e <addr_alloc_page>:

static uint32_t addr_alloc_page(addr_alloc_t* alloc,int page_count){
   1044e:	55                   	push   %ebp
   1044f:	89 e5                	mov    %esp,%ebp
   10451:	83 ec 18             	sub    $0x18,%esp
    uint32_t addr=0;
   10454:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    mutex_lock(&alloc->mutex);
   1045b:	8b 45 08             	mov    0x8(%ebp),%eax
   1045e:	83 ec 0c             	sub    $0xc,%esp
   10461:	50                   	push   %eax
   10462:	e8 77 73 00 00       	call   177de <mutex_lock>
   10467:	83 c4 10             	add    $0x10,%esp
    int page_index=bitmap_alloc_nbits(&alloc->bitmap,0,page_count);
   1046a:	8b 45 08             	mov    0x8(%ebp),%eax
   1046d:	83 c0 14             	add    $0x14,%eax
   10470:	83 ec 04             	sub    $0x4,%esp
   10473:	ff 75 0c             	pushl  0xc(%ebp)
   10476:	6a 00                	push   $0x0
   10478:	50                   	push   %eax
   10479:	e8 b5 77 00 00       	call   17c33 <bitmap_alloc_nbits>
   1047e:	83 c4 10             	add    $0x10,%esp
   10481:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(page_index>=0){
   10484:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10488:	78 17                	js     104a1 <addr_alloc_page+0x53>
        addr=alloc->start+page_index*alloc->page_size;
   1048a:	8b 45 08             	mov    0x8(%ebp),%eax
   1048d:	8b 50 1c             	mov    0x1c(%eax),%edx
   10490:	8b 45 08             	mov    0x8(%ebp),%eax
   10493:	8b 48 24             	mov    0x24(%eax),%ecx
   10496:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10499:	0f af c1             	imul   %ecx,%eax
   1049c:	01 d0                	add    %edx,%eax
   1049e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    mutex_unlock(&alloc->mutex);
   104a1:	8b 45 08             	mov    0x8(%ebp),%eax
   104a4:	83 ec 0c             	sub    $0xc,%esp
   104a7:	50                   	push   %eax
   104a8:	e8 c0 73 00 00       	call   1786d <mutex_unlock>
   104ad:	83 c4 10             	add    $0x10,%esp
    return addr;
   104b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   104b3:	c9                   	leave  
   104b4:	c3                   	ret    

000104b5 <addr_free_page>:
 * @brief 释放页表项对应的物理页
 * @param alloc 内存页管理器的指针
 * @param addr 页表项对应的物理页的地址
 * @param page_count 页表项对应的物理页的数量
*/
static void addr_free_page(addr_alloc_t* alloc,uint32_t addr,int page_count){
   104b5:	55                   	push   %ebp
   104b6:	89 e5                	mov    %esp,%ebp
   104b8:	53                   	push   %ebx
   104b9:	83 ec 14             	sub    $0x14,%esp
    mutex_lock(&alloc->mutex);
   104bc:	8b 45 08             	mov    0x8(%ebp),%eax
   104bf:	83 ec 0c             	sub    $0xc,%esp
   104c2:	50                   	push   %eax
   104c3:	e8 16 73 00 00       	call   177de <mutex_lock>
   104c8:	83 c4 10             	add    $0x10,%esp
    uint32_t pg_index=(addr-alloc->start)/alloc->page_size;
   104cb:	8b 45 08             	mov    0x8(%ebp),%eax
   104ce:	8b 40 1c             	mov    0x1c(%eax),%eax
   104d1:	8b 55 0c             	mov    0xc(%ebp),%edx
   104d4:	89 d1                	mov    %edx,%ecx
   104d6:	29 c1                	sub    %eax,%ecx
   104d8:	8b 45 08             	mov    0x8(%ebp),%eax
   104db:	8b 58 24             	mov    0x24(%eax),%ebx
   104de:	89 c8                	mov    %ecx,%eax
   104e0:	ba 00 00 00 00       	mov    $0x0,%edx
   104e5:	f7 f3                	div    %ebx
   104e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bitmap_set_bit(&alloc->bitmap,pg_index,page_count,0);
   104ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
   104ed:	8b 55 08             	mov    0x8(%ebp),%edx
   104f0:	83 c2 14             	add    $0x14,%edx
   104f3:	6a 00                	push   $0x0
   104f5:	ff 75 10             	pushl  0x10(%ebp)
   104f8:	50                   	push   %eax
   104f9:	52                   	push   %edx
   104fa:	e8 2e 76 00 00       	call   17b2d <bitmap_set_bit>
   104ff:	83 c4 10             	add    $0x10,%esp
    mutex_unlock(&alloc->mutex);
   10502:	8b 45 08             	mov    0x8(%ebp),%eax
   10505:	83 ec 0c             	sub    $0xc,%esp
   10508:	50                   	push   %eax
   10509:	e8 5f 73 00 00       	call   1786d <mutex_unlock>
   1050e:	83 c4 10             	add    $0x10,%esp
}
   10511:	90                   	nop
   10512:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10515:	c9                   	leave  
   10516:	c3                   	ret    

00010517 <total_mem_size>:

static uint32_t total_mem_size(boot_info_t* boot_info){
   10517:	55                   	push   %ebp
   10518:	89 e5                	mov    %esp,%ebp
   1051a:	83 ec 10             	sub    $0x10,%esp
    uint32_t mem_size=0;
   1051d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for(int i=0;i<boot_info->ram_region_count;i++){
   10524:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1052b:	eb 11                	jmp    1053e <total_mem_size+0x27>
        mem_size+=boot_info->ram_region_cfg[i].size;
   1052d:	8b 45 08             	mov    0x8(%ebp),%eax
   10530:	8b 55 f8             	mov    -0x8(%ebp),%edx
   10533:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
   10537:	01 45 fc             	add    %eax,-0x4(%ebp)
    for(int i=0;i<boot_info->ram_region_count;i++){
   1053a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1053e:	8b 45 08             	mov    0x8(%ebp),%eax
   10541:	8b 40 50             	mov    0x50(%eax),%eax
   10544:	39 45 f8             	cmp    %eax,-0x8(%ebp)
   10547:	7c e4                	jl     1052d <total_mem_size+0x16>
    }
    return mem_size;
   10549:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1054c:	c9                   	leave  
   1054d:	c3                   	ret    

0001054e <find_pte>:

pte_t* find_pte(pde_t*page_dir,uint32_t vaddr,int alloc){
   1054e:	55                   	push   %ebp
   1054f:	89 e5                	mov    %esp,%ebp
   10551:	83 ec 18             	sub    $0x18,%esp
    pte_t* page_table;
    pde_t* pde=page_dir+pde_index(vaddr);
   10554:	ff 75 0c             	pushl  0xc(%ebp)
   10557:	e8 50 fe ff ff       	call   103ac <pde_index>
   1055c:	83 c4 04             	add    $0x4,%esp
   1055f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10566:	8b 45 08             	mov    0x8(%ebp),%eax
   10569:	01 d0                	add    %edx,%eax
   1056b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(pde->present){
   1056e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10571:	0f b6 00             	movzbl (%eax),%eax
   10574:	83 e0 01             	and    $0x1,%eax
   10577:	84 c0                	test   %al,%al
   10579:	74 10                	je     1058b <find_pte+0x3d>
        page_table=(pte_t*)pde_paddr(pde);
   1057b:	ff 75 f0             	pushl  -0x10(%ebp)
   1057e:	e8 44 fe ff ff       	call   103c7 <pde_paddr>
   10583:	83 c4 04             	add    $0x4,%esp
   10586:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10589:	eb 57                	jmp    105e2 <find_pte+0x94>
    }
    else{
        if(alloc==0){
   1058b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1058f:	75 07                	jne    10598 <find_pte+0x4a>
            return (pte_t*)0;
   10591:	b8 00 00 00 00       	mov    $0x0,%eax
   10596:	eb 64                	jmp    105fc <find_pte+0xae>
        }
        uint32_t pg_paddr=addr_alloc_page(&paddr_alloc,1);
   10598:	83 ec 08             	sub    $0x8,%esp
   1059b:	6a 01                	push   $0x1
   1059d:	68 00 b0 01 00       	push   $0x1b000
   105a2:	e8 a7 fe ff ff       	call   1044e <addr_alloc_page>
   105a7:	83 c4 10             	add    $0x10,%esp
   105aa:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(pg_paddr==0) return (pte_t*)0;
   105ad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   105b1:	75 07                	jne    105ba <find_pte+0x6c>
   105b3:	b8 00 00 00 00       	mov    $0x0,%eax
   105b8:	eb 42                	jmp    105fc <find_pte+0xae>
        pde->v=pg_paddr | PTE_P | PDE_W | PDE_U;
   105ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
   105bd:	83 c8 07             	or     $0x7,%eax
   105c0:	89 c2                	mov    %eax,%edx
   105c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105c5:	89 10                	mov    %edx,(%eax)
        page_table=(pte_t*)pg_paddr;
   105c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   105ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
        kernel_memset(page_table,0,MEM_PAGE_SIZE);
   105cd:	83 ec 04             	sub    $0x4,%esp
   105d0:	68 00 10 00 00       	push   $0x1000
   105d5:	6a 00                	push   $0x0
   105d7:	ff 75 f4             	pushl  -0xc(%ebp)
   105da:	e8 c9 78 00 00       	call   17ea8 <kernel_memset>
   105df:	83 c4 10             	add    $0x10,%esp
    }

    return page_table+pte_index(vaddr);
   105e2:	83 ec 0c             	sub    $0xc,%esp
   105e5:	ff 75 0c             	pushl  0xc(%ebp)
   105e8:	e8 ca fd ff ff       	call   103b7 <pte_index>
   105ed:	83 c4 10             	add    $0x10,%esp
   105f0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   105f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   105fa:	01 d0                	add    %edx,%eax
}
   105fc:	c9                   	leave  
   105fd:	c3                   	ret    

000105fe <memory_create_map>:

int memory_create_map(pde_t* page_dir,uint32_t vaddr,uint32_t paddr,int count,uint32_t perm){
   105fe:	55                   	push   %ebp
   105ff:	89 e5                	mov    %esp,%ebp
   10601:	83 ec 18             	sub    $0x18,%esp
    for(int i=0;i<count;i++){
   10604:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1060b:	eb 7b                	jmp    10688 <memory_create_map+0x8a>
        pte_t* pte=find_pte(page_dir,vaddr,1);
   1060d:	83 ec 04             	sub    $0x4,%esp
   10610:	6a 01                	push   $0x1
   10612:	ff 75 0c             	pushl  0xc(%ebp)
   10615:	ff 75 08             	pushl  0x8(%ebp)
   10618:	e8 31 ff ff ff       	call   1054e <find_pte>
   1061d:	83 c4 10             	add    $0x10,%esp
   10620:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(pte==(pte_t*)0){
   10623:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10627:	75 17                	jne    10640 <memory_create_map+0x42>
            log_printf("create pte failed.pte==0");
   10629:	83 ec 0c             	sub    $0xc,%esp
   1062c:	68 a0 85 01 00       	push   $0x185a0
   10631:	e8 95 7e 00 00       	call   184cb <log_printf>
   10636:	83 c4 10             	add    $0x10,%esp
            return -1;
   10639:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1063e:	eb 59                	jmp    10699 <memory_create_map+0x9b>
        }
        ASSERT(pte->present==0);
   10640:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10643:	0f b6 00             	movzbl (%eax),%eax
   10646:	83 e0 01             	and    $0x1,%eax
   10649:	84 c0                	test   %al,%al
   1064b:	74 19                	je     10666 <memory_create_map+0x68>
   1064d:	68 b9 85 01 00       	push   $0x185b9
   10652:	68 b8 86 01 00       	push   $0x186b8
   10657:	6a 50                	push   $0x50
   10659:	68 cc 85 01 00       	push   $0x185cc
   1065e:	e8 98 7b 00 00       	call   181fb <panic>
   10663:	83 c4 10             	add    $0x10,%esp
        pte->v=paddr | perm | PTE_P;
   10666:	8b 45 10             	mov    0x10(%ebp),%eax
   10669:	0b 45 18             	or     0x18(%ebp),%eax
   1066c:	83 c8 01             	or     $0x1,%eax
   1066f:	89 c2                	mov    %eax,%edx
   10671:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10674:	89 10                	mov    %edx,(%eax)
        vaddr+=MEM_PAGE_SIZE;
   10676:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
        paddr+=MEM_PAGE_SIZE;
   1067d:	81 45 10 00 10 00 00 	addl   $0x1000,0x10(%ebp)
    for(int i=0;i<count;i++){
   10684:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10688:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1068b:	3b 45 14             	cmp    0x14(%ebp),%eax
   1068e:	0f 8c 79 ff ff ff    	jl     1060d <memory_create_map+0xf>
    }
    return 0;
   10694:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10699:	c9                   	leave  
   1069a:	c3                   	ret    

0001069b <create_kernel_table>:

void create_kernel_table(void){
   1069b:	55                   	push   %ebp
   1069c:	89 e5                	mov    %esp,%ebp
   1069e:	83 ec 28             	sub    $0x28,%esp
        {s_data,(void*)(MEM_EBDA_START-1),s_data,PTE_W},
        {(void*)CONSOLE_DISP_ADDR,(void*)CONSOLE_DISP_END,(void*)CONSOLE_DISP_ADDR, PTE_W},
        {(void*)MEM_EXT_START,(void*)MEM_EXT_END,(void*)MEM_EXT_START,PTE_W},
    };

    for(int i=0;i<sizeof(kernel_map)/sizeof(memory_map_t);i++){
   106a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   106a8:	e9 86 00 00 00       	jmp    10733 <create_kernel_table+0x98>
        memory_map_t* map=kernel_map+i;
   106ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   106b0:	c1 e0 04             	shl    $0x4,%eax
   106b3:	05 00 a0 01 00       	add    $0x1a000,%eax
   106b8:	89 45 f0             	mov    %eax,-0x10(%ebp)

        uint32_t vstart=down2((uint32_t)map->vstart,MEM_PAGE_SIZE);
   106bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106be:	8b 00                	mov    (%eax),%eax
   106c0:	68 00 10 00 00       	push   $0x1000
   106c5:	50                   	push   %eax
   106c6:	e8 7f fc ff ff       	call   1034a <down2>
   106cb:	83 c4 08             	add    $0x8,%esp
   106ce:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t vend=up2((uint32_t)map->vend,MEM_PAGE_SIZE);
   106d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106d4:	8b 40 04             	mov    0x4(%eax),%eax
   106d7:	68 00 10 00 00       	push   $0x1000
   106dc:	50                   	push   %eax
   106dd:	e8 75 fc ff ff       	call   10357 <up2>
   106e2:	83 c4 08             	add    $0x8,%esp
   106e5:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t paddr=down2((uint32_t)map->pstart,MEM_PAGE_SIZE);
   106e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106eb:	8b 40 08             	mov    0x8(%eax),%eax
   106ee:	68 00 10 00 00       	push   $0x1000
   106f3:	50                   	push   %eax
   106f4:	e8 51 fc ff ff       	call   1034a <down2>
   106f9:	83 c4 08             	add    $0x8,%esp
   106fc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int page_count=(vend-vstart) / MEM_PAGE_SIZE;
   106ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10702:	2b 45 ec             	sub    -0x14(%ebp),%eax
   10705:	c1 e8 0c             	shr    $0xc,%eax
   10708:	89 45 e0             	mov    %eax,-0x20(%ebp)
        
        
        memory_create_map(kernel_page_dir,vstart,(uint32_t)map->pstart,page_count,map->perm);
   1070b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1070e:	8b 40 0c             	mov    0xc(%eax),%eax
   10711:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10714:	8b 52 08             	mov    0x8(%edx),%edx
   10717:	83 ec 0c             	sub    $0xc,%esp
   1071a:	50                   	push   %eax
   1071b:	ff 75 e0             	pushl  -0x20(%ebp)
   1071e:	52                   	push   %edx
   1071f:	ff 75 ec             	pushl  -0x14(%ebp)
   10722:	68 00 c0 01 00       	push   $0x1c000
   10727:	e8 d2 fe ff ff       	call   105fe <memory_create_map>
   1072c:	83 c4 20             	add    $0x20,%esp
    for(int i=0;i<sizeof(kernel_map)/sizeof(memory_map_t);i++){
   1072f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10733:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10736:	83 f8 04             	cmp    $0x4,%eax
   10739:	0f 86 6e ff ff ff    	jbe    106ad <create_kernel_table+0x12>
    }
}
   1073f:	90                   	nop
   10740:	c9                   	leave  
   10741:	c3                   	ret    

00010742 <memory_init>:

void memory_init(boot_info_t* boot_info){
   10742:	55                   	push   %ebp
   10743:	89 e5                	mov    %esp,%ebp
   10745:	83 ec 18             	sub    $0x18,%esp
   extern uint8_t* mem_free_start;
   uint8_t* mem_free=(uint8_t*)&mem_free_start;
   10748:	c7 45 f4 b9 03 06 00 	movl   $0x603b9,-0xc(%ebp)
   uint32_t mem_up1MB_free=total_mem_size(boot_info)-MEM_EXT_START;
   1074f:	ff 75 08             	pushl  0x8(%ebp)
   10752:	e8 c0 fd ff ff       	call   10517 <total_mem_size>
   10757:	83 c4 04             	add    $0x4,%esp
   1075a:	2d 00 00 10 00       	sub    $0x100000,%eax
   1075f:	89 45 f0             	mov    %eax,-0x10(%ebp)
   mem_up1MB_free=down2(mem_up1MB_free,MEM_PAGE_SIZE);
   10762:	68 00 10 00 00       	push   $0x1000
   10767:	ff 75 f0             	pushl  -0x10(%ebp)
   1076a:	e8 db fb ff ff       	call   1034a <down2>
   1076f:	83 c4 08             	add    $0x8,%esp
   10772:	89 45 f0             	mov    %eax,-0x10(%ebp)
   addr_alloc_init(&paddr_alloc,mem_free,MEM_EXT_START,mem_up1MB_free,MEM_PAGE_SIZE);
   10775:	83 ec 0c             	sub    $0xc,%esp
   10778:	68 00 10 00 00       	push   $0x1000
   1077d:	ff 75 f0             	pushl  -0x10(%ebp)
   10780:	68 00 00 10 00       	push   $0x100000
   10785:	ff 75 f4             	pushl  -0xc(%ebp)
   10788:	68 00 b0 01 00       	push   $0x1b000
   1078d:	e8 64 fc ff ff       	call   103f6 <addr_alloc_init>
   10792:	83 c4 20             	add    $0x20,%esp
   mem_free+=bitmap_byte_count(paddr_alloc.size/MEM_PAGE_SIZE);
   10795:	a1 20 b0 01 00       	mov    0x1b020,%eax
   1079a:	c1 e8 0c             	shr    $0xc,%eax
   1079d:	83 ec 0c             	sub    $0xc,%esp
   107a0:	50                   	push   %eax
   107a1:	e8 cf 72 00 00       	call   17a75 <bitmap_byte_count>
   107a6:	83 c4 10             	add    $0x10,%esp
   107a9:	01 45 f4             	add    %eax,-0xc(%ebp)
   ASSERT(mem_free < (uint8_t *)MEM_EBDA_START);
   107ac:	81 7d f4 ff ff 07 00 	cmpl   $0x7ffff,-0xc(%ebp)
   107b3:	76 19                	jbe    107ce <memory_init+0x8c>
   107b5:	68 04 86 01 00       	push   $0x18604
   107ba:	68 cc 86 01 00       	push   $0x186cc
   107bf:	6a 76                	push   $0x76
   107c1:	68 cc 85 01 00       	push   $0x185cc
   107c6:	e8 30 7a 00 00       	call   181fb <panic>
   107cb:	83 c4 10             	add    $0x10,%esp
   create_kernel_table();
   107ce:	e8 c8 fe ff ff       	call   1069b <create_kernel_table>
   mmu_set_page_dir((uint32_t)kernel_page_dir);
   107d3:	b8 00 c0 01 00       	mov    $0x1c000,%eax
   107d8:	83 ec 0c             	sub    $0xc,%esp
   107db:	50                   	push   %eax
   107dc:	e8 8d fb ff ff       	call   1036e <mmu_set_page_dir>
   107e1:	83 c4 10             	add    $0x10,%esp
}
   107e4:	90                   	nop
   107e5:	c9                   	leave  
   107e6:	c3                   	ret    

000107e7 <memory_create_uvm>:

uint32_t memory_create_uvm(void){
   107e7:	55                   	push   %ebp
   107e8:	89 e5                	mov    %esp,%ebp
   107ea:	83 ec 18             	sub    $0x18,%esp
    pde_t* page_dir=(pde_t*)addr_alloc_page(&paddr_alloc,1);
   107ed:	83 ec 08             	sub    $0x8,%esp
   107f0:	6a 01                	push   $0x1
   107f2:	68 00 b0 01 00       	push   $0x1b000
   107f7:	e8 52 fc ff ff       	call   1044e <addr_alloc_page>
   107fc:	83 c4 10             	add    $0x10,%esp
   107ff:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(page_dir==0){
   10802:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10806:	75 07                	jne    1080f <memory_create_uvm+0x28>
        return 0;
   10808:	b8 00 00 00 00       	mov    $0x0,%eax
   1080d:	eb 5b                	jmp    1086a <memory_create_uvm+0x83>
    }
    kernel_memset((void*)page_dir,0,MEM_PAGE_SIZE);
   1080f:	83 ec 04             	sub    $0x4,%esp
   10812:	68 00 10 00 00       	push   $0x1000
   10817:	6a 00                	push   $0x0
   10819:	ff 75 f0             	pushl  -0x10(%ebp)
   1081c:	e8 87 76 00 00       	call   17ea8 <kernel_memset>
   10821:	83 c4 10             	add    $0x10,%esp
    uint32_t user_pde_start=pde_index(MEMORY_TASK_BASE);
   10824:	83 ec 0c             	sub    $0xc,%esp
   10827:	68 00 00 00 80       	push   $0x80000000
   1082c:	e8 7b fb ff ff       	call   103ac <pde_index>
   10831:	83 c4 10             	add    $0x10,%esp
   10834:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(int i=0;i<user_pde_start;i++){
   10837:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1083e:	eb 1f                	jmp    1085f <memory_create_uvm+0x78>
        page_dir[i].v=kernel_page_dir[i].v;
   10840:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10843:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1084a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1084d:	01 c2                	add    %eax,%edx
   1084f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10852:	8b 04 85 00 c0 01 00 	mov    0x1c000(,%eax,4),%eax
   10859:	89 02                	mov    %eax,(%edx)
    for(int i=0;i<user_pde_start;i++){
   1085b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1085f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10862:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   10865:	77 d9                	ja     10840 <memory_create_uvm+0x59>
    }

    return (uint32_t)page_dir;
   10867:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   1086a:	c9                   	leave  
   1086b:	c3                   	ret    

0001086c <memory_alloc_for_page_dir>:

int memory_alloc_for_page_dir(uint32_t page_dir,uint32_t vaddr,uint32_t size,int perm){
   1086c:	55                   	push   %ebp
   1086d:	89 e5                	mov    %esp,%ebp
   1086f:	83 ec 28             	sub    $0x28,%esp
    uint32_t curr_vaddr=vaddr;
   10872:	8b 45 0c             	mov    0xc(%ebp),%eax
   10875:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int page_count=up2(size,MEM_PAGE_SIZE) / MEM_PAGE_SIZE;
   10878:	68 00 10 00 00       	push   $0x1000
   1087d:	ff 75 10             	pushl  0x10(%ebp)
   10880:	e8 d2 fa ff ff       	call   10357 <up2>
   10885:	83 c4 08             	add    $0x8,%esp
   10888:	c1 e8 0c             	shr    $0xc,%eax
   1088b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(int i=0;i<page_count;i++){
   1088e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   10895:	eb 7b                	jmp    10912 <memory_alloc_for_page_dir+0xa6>
        uint32_t paddr=addr_alloc_page(&paddr_alloc,1);
   10897:	83 ec 08             	sub    $0x8,%esp
   1089a:	6a 01                	push   $0x1
   1089c:	68 00 b0 01 00       	push   $0x1b000
   108a1:	e8 a8 fb ff ff       	call   1044e <addr_alloc_page>
   108a6:	83 c4 10             	add    $0x10,%esp
   108a9:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(paddr==0){
   108ac:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   108b0:	75 17                	jne    108c9 <memory_alloc_for_page_dir+0x5d>
            log_printf("mem alloc failed. no memory");
   108b2:	83 ec 0c             	sub    $0xc,%esp
   108b5:	68 29 86 01 00       	push   $0x18629
   108ba:	e8 0c 7c 00 00       	call   184cb <log_printf>
   108bf:	83 c4 10             	add    $0x10,%esp
            return 0;
   108c2:	b8 00 00 00 00       	mov    $0x0,%eax
   108c7:	eb 55                	jmp    1091e <memory_alloc_for_page_dir+0xb2>
        }

        int err=memory_create_map((pde_t*)page_dir,curr_vaddr,paddr,1,perm);
   108c9:	8b 55 14             	mov    0x14(%ebp),%edx
   108cc:	8b 45 08             	mov    0x8(%ebp),%eax
   108cf:	83 ec 0c             	sub    $0xc,%esp
   108d2:	52                   	push   %edx
   108d3:	6a 01                	push   $0x1
   108d5:	ff 75 e8             	pushl  -0x18(%ebp)
   108d8:	ff 75 f4             	pushl  -0xc(%ebp)
   108db:	50                   	push   %eax
   108dc:	e8 1d fd ff ff       	call   105fe <memory_create_map>
   108e1:	83 c4 20             	add    $0x20,%esp
   108e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(err < 0){
   108e7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   108eb:	79 1a                	jns    10907 <memory_alloc_for_page_dir+0x9b>
            log_printf("create memory failed. err=%d",err);
   108ed:	83 ec 08             	sub    $0x8,%esp
   108f0:	ff 75 e4             	pushl  -0x1c(%ebp)
   108f3:	68 45 86 01 00       	push   $0x18645
   108f8:	e8 ce 7b 00 00       	call   184cb <log_printf>
   108fd:	83 c4 10             	add    $0x10,%esp
            return 0;
   10900:	b8 00 00 00 00       	mov    $0x0,%eax
   10905:	eb 17                	jmp    1091e <memory_alloc_for_page_dir+0xb2>
        }

        curr_vaddr+=MEM_PAGE_SIZE;
   10907:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
    for(int i=0;i<page_count;i++){
   1090e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10912:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10915:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   10918:	0f 8c 79 ff ff ff    	jl     10897 <memory_alloc_for_page_dir+0x2b>

    }
}
   1091e:	c9                   	leave  
   1091f:	c3                   	ret    

00010920 <memory_alloc_page_for>:

int memory_alloc_page_for(uint32_t addr,uint32_t size,int perm){
   10920:	55                   	push   %ebp
   10921:	89 e5                	mov    %esp,%ebp
   10923:	83 ec 08             	sub    $0x8,%esp
    return memory_alloc_for_page_dir(task_current()->tss.cr3,addr,size,perm);
   10926:	e8 d0 0c 00 00       	call   115fb <task_current>
   1092b:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   10931:	ff 75 10             	pushl  0x10(%ebp)
   10934:	ff 75 0c             	pushl  0xc(%ebp)
   10937:	ff 75 08             	pushl  0x8(%ebp)
   1093a:	50                   	push   %eax
   1093b:	e8 2c ff ff ff       	call   1086c <memory_alloc_for_page_dir>
   10940:	83 c4 10             	add    $0x10,%esp
}
   10943:	c9                   	leave  
   10944:	c3                   	ret    

00010945 <memory_alloc_page>:

uint32_t memory_alloc_page(void){
   10945:	55                   	push   %ebp
   10946:	89 e5                	mov    %esp,%ebp
   10948:	83 ec 18             	sub    $0x18,%esp
    uint32_t addr=addr_alloc_page(&paddr_alloc,1);
   1094b:	83 ec 08             	sub    $0x8,%esp
   1094e:	6a 01                	push   $0x1
   10950:	68 00 b0 01 00       	push   $0x1b000
   10955:	e8 f4 fa ff ff       	call   1044e <addr_alloc_page>
   1095a:	83 c4 10             	add    $0x10,%esp
   1095d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return addr;
   10960:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10963:	c9                   	leave  
   10964:	c3                   	ret    

00010965 <curr_page_dir>:

static pde_t* curr_page_dir(void){
   10965:	55                   	push   %ebp
   10966:	89 e5                	mov    %esp,%ebp
   10968:	83 ec 08             	sub    $0x8,%esp
    return (pde_t*)(task_current()->tss.cr3);
   1096b:	e8 8b 0c 00 00       	call   115fb <task_current>
   10970:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
}
   10976:	c9                   	leave  
   10977:	c3                   	ret    

00010978 <memory_free_page>:

void memory_free_page(uint32_t addr){
   10978:	55                   	push   %ebp
   10979:	89 e5                	mov    %esp,%ebp
   1097b:	83 ec 18             	sub    $0x18,%esp
    if(addr < MEMORY_TASK_BASE){
   1097e:	8b 45 08             	mov    0x8(%ebp),%eax
   10981:	85 c0                	test   %eax,%eax
   10983:	78 17                	js     1099c <memory_free_page+0x24>
        addr_free_page(&paddr_alloc,addr,1);
   10985:	83 ec 04             	sub    $0x4,%esp
   10988:	6a 01                	push   $0x1
   1098a:	ff 75 08             	pushl  0x8(%ebp)
   1098d:	68 00 b0 01 00       	push   $0x1b000
   10992:	e8 1e fb ff ff       	call   104b5 <addr_free_page>
   10997:	83 c4 10             	add    $0x10,%esp
        pte_t* pte=find_pte(curr_page_dir(),addr,0);
        ASSERT((pte==(pte_t*)0) &&  pte->present);
        addr_free_page(&paddr_alloc,pte_paddr(pte),1);
        pte->v=0;
    }
}
   1099a:	eb 72                	jmp    10a0e <memory_free_page+0x96>
        pte_t* pte=find_pte(curr_page_dir(),addr,0);
   1099c:	e8 c4 ff ff ff       	call   10965 <curr_page_dir>
   109a1:	83 ec 04             	sub    $0x4,%esp
   109a4:	6a 00                	push   $0x0
   109a6:	ff 75 08             	pushl  0x8(%ebp)
   109a9:	50                   	push   %eax
   109aa:	e8 9f fb ff ff       	call   1054e <find_pte>
   109af:	83 c4 10             	add    $0x10,%esp
   109b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ASSERT((pte==(pte_t*)0) &&  pte->present);
   109b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   109b9:	75 0d                	jne    109c8 <memory_free_page+0x50>
   109bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   109be:	0f b6 00             	movzbl (%eax),%eax
   109c1:	83 e0 01             	and    $0x1,%eax
   109c4:	84 c0                	test   %al,%al
   109c6:	75 1c                	jne    109e4 <memory_free_page+0x6c>
   109c8:	68 64 86 01 00       	push   $0x18664
   109cd:	68 d8 86 01 00       	push   $0x186d8
   109d2:	68 b1 00 00 00       	push   $0xb1
   109d7:	68 cc 85 01 00       	push   $0x185cc
   109dc:	e8 1a 78 00 00       	call   181fb <panic>
   109e1:	83 c4 10             	add    $0x10,%esp
        addr_free_page(&paddr_alloc,pte_paddr(pte),1);
   109e4:	83 ec 0c             	sub    $0xc,%esp
   109e7:	ff 75 f4             	pushl  -0xc(%ebp)
   109ea:	e8 e8 f9 ff ff       	call   103d7 <pte_paddr>
   109ef:	83 c4 10             	add    $0x10,%esp
   109f2:	83 ec 04             	sub    $0x4,%esp
   109f5:	6a 01                	push   $0x1
   109f7:	50                   	push   %eax
   109f8:	68 00 b0 01 00       	push   $0x1b000
   109fd:	e8 b3 fa ff ff       	call   104b5 <addr_free_page>
   10a02:	83 c4 10             	add    $0x10,%esp
        pte->v=0;
   10a05:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a08:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
   10a0e:	90                   	nop
   10a0f:	c9                   	leave  
   10a10:	c3                   	ret    

00010a11 <memory_destroy_uvm>:

void memory_destroy_uvm(uint32_t page_dir){
   10a11:	55                   	push   %ebp
   10a12:	89 e5                	mov    %esp,%ebp
   10a14:	83 ec 28             	sub    $0x28,%esp
    uint32_t user_pde_start=pde_index(MEMORY_TASK_BASE);
   10a17:	68 00 00 00 80       	push   $0x80000000
   10a1c:	e8 8b f9 ff ff       	call   103ac <pde_index>
   10a21:	83 c4 04             	add    $0x4,%esp
   10a24:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    pde_t* pde=(pde_t*)page_dir+user_pde_start;
   10a27:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10a2a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10a31:	8b 45 08             	mov    0x8(%ebp),%eax
   10a34:	01 d0                	add    %edx,%eax
   10a36:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10a39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10a3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10a3f:	e9 8f 00 00 00       	jmp    10ad3 <memory_destroy_uvm+0xc2>
        if(!pde->present){
   10a44:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a47:	0f b6 00             	movzbl (%eax),%eax
   10a4a:	83 e0 01             	and    $0x1,%eax
   10a4d:	84 c0                	test   %al,%al
   10a4f:	74 79                	je     10aca <memory_destroy_uvm+0xb9>
            continue;
        }

        pte_t* pte=(pte_t*)pde_paddr(pde);
   10a51:	ff 75 f4             	pushl  -0xc(%ebp)
   10a54:	e8 6e f9 ff ff       	call   103c7 <pde_paddr>
   10a59:	83 c4 04             	add    $0x4,%esp
   10a5c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(int j=0;j<PTE_CNT;j++,pte++){
   10a5f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10a66:	eb 36                	jmp    10a9e <memory_destroy_uvm+0x8d>
            if(!pte->present){
   10a68:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10a6b:	0f b6 00             	movzbl (%eax),%eax
   10a6e:	83 e0 01             	and    $0x1,%eax
   10a71:	84 c0                	test   %al,%al
   10a73:	74 20                	je     10a95 <memory_destroy_uvm+0x84>
                continue;
            }

            addr_free_page(&paddr_alloc,pte_paddr(pte),1);
   10a75:	ff 75 ec             	pushl  -0x14(%ebp)
   10a78:	e8 5a f9 ff ff       	call   103d7 <pte_paddr>
   10a7d:	83 c4 04             	add    $0x4,%esp
   10a80:	83 ec 04             	sub    $0x4,%esp
   10a83:	6a 01                	push   $0x1
   10a85:	50                   	push   %eax
   10a86:	68 00 b0 01 00       	push   $0x1b000
   10a8b:	e8 25 fa ff ff       	call   104b5 <addr_free_page>
   10a90:	83 c4 10             	add    $0x10,%esp
   10a93:	eb 01                	jmp    10a96 <memory_destroy_uvm+0x85>
                continue;
   10a95:	90                   	nop
        for(int j=0;j<PTE_CNT;j++,pte++){
   10a96:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   10a9a:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   10a9e:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   10aa5:	7e c1                	jle    10a68 <memory_destroy_uvm+0x57>
        }

        addr_free_page(&paddr_alloc,(uint32_t)pde_paddr(pde),1);
   10aa7:	83 ec 0c             	sub    $0xc,%esp
   10aaa:	ff 75 f4             	pushl  -0xc(%ebp)
   10aad:	e8 15 f9 ff ff       	call   103c7 <pde_paddr>
   10ab2:	83 c4 10             	add    $0x10,%esp
   10ab5:	83 ec 04             	sub    $0x4,%esp
   10ab8:	6a 01                	push   $0x1
   10aba:	50                   	push   %eax
   10abb:	68 00 b0 01 00       	push   $0x1b000
   10ac0:	e8 f0 f9 ff ff       	call   104b5 <addr_free_page>
   10ac5:	83 c4 10             	add    $0x10,%esp
   10ac8:	eb 01                	jmp    10acb <memory_destroy_uvm+0xba>
            continue;
   10aca:	90                   	nop
    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10acb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10acf:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   10ad3:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   10ada:	0f 8e 64 ff ff ff    	jle    10a44 <memory_destroy_uvm+0x33>
    }

    addr_free_page(&paddr_alloc,page_dir,1);
   10ae0:	83 ec 04             	sub    $0x4,%esp
   10ae3:	6a 01                	push   $0x1
   10ae5:	ff 75 08             	pushl  0x8(%ebp)
   10ae8:	68 00 b0 01 00       	push   $0x1b000
   10aed:	e8 c3 f9 ff ff       	call   104b5 <addr_free_page>
   10af2:	83 c4 10             	add    $0x10,%esp
}
   10af5:	90                   	nop
   10af6:	c9                   	leave  
   10af7:	c3                   	ret    

00010af8 <memory_copy_uvm>:

uint32_t memory_copy_uvm(uint32_t page_dir){
   10af8:	55                   	push   %ebp
   10af9:	89 e5                	mov    %esp,%ebp
   10afb:	83 ec 38             	sub    $0x38,%esp
    uint32_t to_page_dir=memory_create_uvm();
   10afe:	e8 e4 fc ff ff       	call   107e7 <memory_create_uvm>
   10b03:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(to_page_dir == 0){
   10b06:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10b0a:	0f 84 1b 01 00 00    	je     10c2b <memory_copy_uvm+0x133>
        goto copy_uvm_failed;
    }

    uint32_t user_pde_start=pde_index(MEMORY_TASK_BASE);
   10b10:	83 ec 0c             	sub    $0xc,%esp
   10b13:	68 00 00 00 80       	push   $0x80000000
   10b18:	e8 8f f8 ff ff       	call   103ac <pde_index>
   10b1d:	83 c4 10             	add    $0x10,%esp
   10b20:	89 45 e0             	mov    %eax,-0x20(%ebp)
    pde_t* pde=(pde_t*)page_dir+user_pde_start;
   10b23:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10b26:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10b2d:	8b 45 08             	mov    0x8(%ebp),%eax
   10b30:	01 d0                	add    %edx,%eax
   10b32:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10b35:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10b38:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10b3b:	e9 d9 00 00 00       	jmp    10c19 <memory_copy_uvm+0x121>
        if(!pde->present){
   10b40:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b43:	0f b6 00             	movzbl (%eax),%eax
   10b46:	83 e0 01             	and    $0x1,%eax
   10b49:	84 c0                	test   %al,%al
   10b4b:	0f 84 bf 00 00 00    	je     10c10 <memory_copy_uvm+0x118>
            continue;
        }

        pte_t*pte=(pte_t*)pde_paddr(pde);
   10b51:	83 ec 0c             	sub    $0xc,%esp
   10b54:	ff 75 f4             	pushl  -0xc(%ebp)
   10b57:	e8 6b f8 ff ff       	call   103c7 <pde_paddr>
   10b5c:	83 c4 10             	add    $0x10,%esp
   10b5f:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(int j=0;j<PTE_CNT;j++,pte++){
   10b62:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10b69:	e9 93 00 00 00       	jmp    10c01 <memory_copy_uvm+0x109>
            if(!pte->present){
   10b6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10b71:	0f b6 00             	movzbl (%eax),%eax
   10b74:	83 e0 01             	and    $0x1,%eax
   10b77:	84 c0                	test   %al,%al
   10b79:	74 7d                	je     10bf8 <memory_copy_uvm+0x100>
                continue;
            }

            uint32_t page=addr_alloc_page(&paddr_alloc,1);
   10b7b:	83 ec 08             	sub    $0x8,%esp
   10b7e:	6a 01                	push   $0x1
   10b80:	68 00 b0 01 00       	push   $0x1b000
   10b85:	e8 c4 f8 ff ff       	call   1044e <addr_alloc_page>
   10b8a:	83 c4 10             	add    $0x10,%esp
   10b8d:	89 45 dc             	mov    %eax,-0x24(%ebp)
            if(page==0) {
   10b90:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   10b94:	0f 84 94 00 00 00    	je     10c2e <memory_copy_uvm+0x136>
                goto copy_uvm_failed;
            }
            uint32_t vaddr=(i<<22) | (j<<12);
   10b9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b9d:	c1 e0 16             	shl    $0x16,%eax
   10ba0:	89 c2                	mov    %eax,%edx
   10ba2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ba5:	c1 e0 0c             	shl    $0xc,%eax
   10ba8:	09 d0                	or     %edx,%eax
   10baa:	89 45 d8             	mov    %eax,-0x28(%ebp)
            int err=memory_create_map((pde_t*)to_page_dir,vaddr,page,1,get_pte_perm(pte));
   10bad:	83 ec 0c             	sub    $0xc,%esp
   10bb0:	ff 75 ec             	pushl  -0x14(%ebp)
   10bb3:	e8 2f f8 ff ff       	call   103e7 <get_pte_perm>
   10bb8:	83 c4 10             	add    $0x10,%esp
   10bbb:	89 c2                	mov    %eax,%edx
   10bbd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10bc0:	83 ec 0c             	sub    $0xc,%esp
   10bc3:	52                   	push   %edx
   10bc4:	6a 01                	push   $0x1
   10bc6:	ff 75 dc             	pushl  -0x24(%ebp)
   10bc9:	ff 75 d8             	pushl  -0x28(%ebp)
   10bcc:	50                   	push   %eax
   10bcd:	e8 2c fa ff ff       	call   105fe <memory_create_map>
   10bd2:	83 c4 20             	add    $0x20,%esp
   10bd5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            if(err < 0){
   10bd8:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   10bdc:	78 53                	js     10c31 <memory_copy_uvm+0x139>
                goto copy_uvm_failed;
            }

            kernel_memcpy((void*)page,(void*)vaddr,MEM_PAGE_SIZE);
   10bde:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10be1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10be4:	83 ec 04             	sub    $0x4,%esp
   10be7:	68 00 10 00 00       	push   $0x1000
   10bec:	52                   	push   %edx
   10bed:	50                   	push   %eax
   10bee:	e8 66 72 00 00       	call   17e59 <kernel_memcpy>
   10bf3:	83 c4 10             	add    $0x10,%esp
   10bf6:	eb 01                	jmp    10bf9 <memory_copy_uvm+0x101>
                continue;
   10bf8:	90                   	nop
        for(int j=0;j<PTE_CNT;j++,pte++){
   10bf9:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   10bfd:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   10c01:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   10c08:	0f 8e 60 ff ff ff    	jle    10b6e <memory_copy_uvm+0x76>
   10c0e:	eb 01                	jmp    10c11 <memory_copy_uvm+0x119>
            continue;
   10c10:	90                   	nop
    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10c11:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10c15:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   10c19:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   10c20:	0f 8e 1a ff ff ff    	jle    10b40 <memory_copy_uvm+0x48>
        }
    }

    return to_page_dir;
   10c26:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10c29:	eb 20                	jmp    10c4b <memory_copy_uvm+0x153>
        goto copy_uvm_failed;
   10c2b:	90                   	nop
   10c2c:	eb 04                	jmp    10c32 <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   10c2e:	90                   	nop
   10c2f:	eb 01                	jmp    10c32 <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   10c31:	90                   	nop
copy_uvm_failed:
    if(to_page_dir){
   10c32:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10c36:	74 0e                	je     10c46 <memory_copy_uvm+0x14e>
        memory_destroy_uvm(to_page_dir);
   10c38:	83 ec 0c             	sub    $0xc,%esp
   10c3b:	ff 75 e4             	pushl  -0x1c(%ebp)
   10c3e:	e8 ce fd ff ff       	call   10a11 <memory_destroy_uvm>
   10c43:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   10c46:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   10c4b:	c9                   	leave  
   10c4c:	c3                   	ret    

00010c4d <memory_get_paddr>:
 * @brief 获取页表项对应的物理地址
 * @param page_dir 获取该页物理地址所使用的页表
 * @param vaddr 虚拟地址
 * @return 成功返回物理地址，失败返回0
*/
uint32_t memory_get_paddr(uint32_t page_dir,uint32_t vaddr){
   10c4d:	55                   	push   %ebp
   10c4e:	89 e5                	mov    %esp,%ebp
   10c50:	83 ec 18             	sub    $0x18,%esp
    pte_t* pte=find_pte((pde_t*)page_dir,vaddr,0);
   10c53:	8b 45 08             	mov    0x8(%ebp),%eax
   10c56:	83 ec 04             	sub    $0x4,%esp
   10c59:	6a 00                	push   $0x0
   10c5b:	ff 75 0c             	pushl  0xc(%ebp)
   10c5e:	50                   	push   %eax
   10c5f:	e8 ea f8 ff ff       	call   1054e <find_pte>
   10c64:	83 c4 10             	add    $0x10,%esp
   10c67:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!pte){
   10c6a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10c6e:	75 07                	jne    10c77 <memory_get_paddr+0x2a>
        return 0;
   10c70:	b8 00 00 00 00       	mov    $0x0,%eax
   10c75:	eb 1a                	jmp    10c91 <memory_get_paddr+0x44>
    }

    return pte_paddr(pte) + (vaddr & (MEM_PAGE_SIZE-1));
   10c77:	83 ec 0c             	sub    $0xc,%esp
   10c7a:	ff 75 f4             	pushl  -0xc(%ebp)
   10c7d:	e8 55 f7 ff ff       	call   103d7 <pte_paddr>
   10c82:	83 c4 10             	add    $0x10,%esp
   10c85:	89 c2                	mov    %eax,%edx
   10c87:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c8a:	25 ff 0f 00 00       	and    $0xfff,%eax
   10c8f:	01 d0                	add    %edx,%eax
}
   10c91:	c9                   	leave  
   10c92:	c3                   	ret    

00010c93 <memory_copy_uvm_data>:

int memory_copy_uvm_data(uint32_t to,uint32_t page_dir,uint32_t from,uint32_t size){
   10c93:	55                   	push   %ebp
   10c94:	89 e5                	mov    %esp,%ebp
   10c96:	83 ec 18             	sub    $0x18,%esp
    while(size > 0){
   10c99:	eb 6d                	jmp    10d08 <memory_copy_uvm_data+0x75>
        uint32_t to_paddr=memory_get_paddr(page_dir,to);
   10c9b:	83 ec 08             	sub    $0x8,%esp
   10c9e:	ff 75 08             	pushl  0x8(%ebp)
   10ca1:	ff 75 0c             	pushl  0xc(%ebp)
   10ca4:	e8 a4 ff ff ff       	call   10c4d <memory_get_paddr>
   10ca9:	83 c4 10             	add    $0x10,%esp
   10cac:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(to_paddr == 0){
   10caf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10cb3:	75 07                	jne    10cbc <memory_copy_uvm_data+0x29>
            return -1;
   10cb5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10cba:	eb 57                	jmp    10d13 <memory_copy_uvm_data+0x80>
        }

        uint32_t offset_in_page=to_paddr & (MEM_PAGE_SIZE-1);
   10cbc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10cbf:	25 ff 0f 00 00       	and    $0xfff,%eax
   10cc4:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t curr_size=MEM_PAGE_SIZE-offset_in_page;
   10cc7:	b8 00 10 00 00       	mov    $0x1000,%eax
   10ccc:	2b 45 ec             	sub    -0x14(%ebp),%eax
   10ccf:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(curr_size > size){
   10cd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cd5:	3b 45 14             	cmp    0x14(%ebp),%eax
   10cd8:	76 06                	jbe    10ce0 <memory_copy_uvm_data+0x4d>
            curr_size = size;
   10cda:	8b 45 14             	mov    0x14(%ebp),%eax
   10cdd:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }

        kernel_memcpy((void*)to_paddr,(void*)from,curr_size);
   10ce0:	8b 55 10             	mov    0x10(%ebp),%edx
   10ce3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ce6:	83 ec 04             	sub    $0x4,%esp
   10ce9:	ff 75 f4             	pushl  -0xc(%ebp)
   10cec:	52                   	push   %edx
   10ced:	50                   	push   %eax
   10cee:	e8 66 71 00 00       	call   17e59 <kernel_memcpy>
   10cf3:	83 c4 10             	add    $0x10,%esp
        size -= curr_size;
   10cf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cf9:	29 45 14             	sub    %eax,0x14(%ebp)
        to += curr_size;
   10cfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cff:	01 45 08             	add    %eax,0x8(%ebp)
        from += curr_size;
   10d02:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d05:	01 45 10             	add    %eax,0x10(%ebp)
    while(size > 0){
   10d08:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   10d0c:	75 8d                	jne    10c9b <memory_copy_uvm_data+0x8>
    }
    return 0;
   10d0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10d13:	c9                   	leave  
   10d14:	c3                   	ret    

00010d15 <sys_sbrk>:

char* sys_sbrk(int incr){
   10d15:	55                   	push   %ebp
   10d16:	89 e5                	mov    %esp,%ebp
   10d18:	83 ec 38             	sub    $0x38,%esp
    task_t* task=task_current();
   10d1b:	e8 db 08 00 00       	call   115fb <task_current>
   10d20:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint8_t*pre_heap_end=(uint8_t*) task->heap_end;
   10d23:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d26:	8b 40 10             	mov    0x10(%eax),%eax
   10d29:	89 45 ec             	mov    %eax,-0x14(%ebp)

    ASSERT(incr>=0);
   10d2c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10d30:	79 1c                	jns    10d4e <sys_sbrk+0x39>
   10d32:	68 85 86 01 00       	push   $0x18685
   10d37:	68 ec 86 01 00       	push   $0x186ec
   10d3c:	68 21 01 00 00       	push   $0x121
   10d41:	68 cc 85 01 00       	push   $0x185cc
   10d46:	e8 b0 74 00 00       	call   181fb <panic>
   10d4b:	83 c4 10             	add    $0x10,%esp

    int pre_incr=incr;
   10d4e:	8b 45 08             	mov    0x8(%ebp),%eax
   10d51:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if(incr==0){
   10d54:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10d58:	75 1b                	jne    10d75 <sys_sbrk+0x60>
        log_printf("sbrk(0): end=0x%x",pre_heap_end);
   10d5a:	83 ec 08             	sub    $0x8,%esp
   10d5d:	ff 75 ec             	pushl  -0x14(%ebp)
   10d60:	68 8d 86 01 00       	push   $0x1868d
   10d65:	e8 61 77 00 00       	call   184cb <log_printf>
   10d6a:	83 c4 10             	add    $0x10,%esp
        return pre_heap_end;
   10d6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d70:	e9 aa 00 00 00       	jmp    10e1f <sys_sbrk+0x10a>
    }

    uint32_t start=task->heap_end;
   10d75:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d78:	8b 40 10             	mov    0x10(%eax),%eax
   10d7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t end=start+incr;
   10d7e:	8b 55 08             	mov    0x8(%ebp),%edx
   10d81:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d84:	01 d0                	add    %edx,%eax
   10d86:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    int start_offset=start % MEM_PAGE_SIZE;
   10d89:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d8c:	25 ff 0f 00 00       	and    $0xfff,%eax
   10d91:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(start_offset){
   10d94:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10d98:	74 37                	je     10dd1 <sys_sbrk+0xbc>
        if(start_offset+incr <= MEM_PAGE_SIZE){
   10d9a:	8b 55 e0             	mov    -0x20(%ebp),%edx
   10d9d:	8b 45 08             	mov    0x8(%ebp),%eax
   10da0:	01 d0                	add    %edx,%eax
   10da2:	3d 00 10 00 00       	cmp    $0x1000,%eax
   10da7:	7f 0e                	jg     10db7 <sys_sbrk+0xa2>
            task->heap_end=end;
   10da9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10dac:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10daf:	89 50 10             	mov    %edx,0x10(%eax)
            return pre_heap_end;
   10db2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10db5:	eb 68                	jmp    10e1f <sys_sbrk+0x10a>
        }
        else{
            uint32_t curr_size=MEM_PAGE_SIZE - start_offset;
   10db7:	b8 00 10 00 00       	mov    $0x1000,%eax
   10dbc:	2b 45 e0             	sub    -0x20(%ebp),%eax
   10dbf:	89 45 dc             	mov    %eax,-0x24(%ebp)
            start+=curr_size;
   10dc2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10dc5:	01 45 f4             	add    %eax,-0xc(%ebp)
            incr-=curr_size;
   10dc8:	8b 45 08             	mov    0x8(%ebp),%eax
   10dcb:	2b 45 dc             	sub    -0x24(%ebp),%eax
   10dce:	89 45 08             	mov    %eax,0x8(%ebp)
        }
    }

    if(incr){
   10dd1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10dd5:	74 3c                	je     10e13 <sys_sbrk+0xfe>
        uint32_t curr_size=end-start;
   10dd7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10dda:	2b 45 f4             	sub    -0xc(%ebp),%eax
   10ddd:	89 45 d8             	mov    %eax,-0x28(%ebp)
        int err=memory_alloc_page_for(start,curr_size,PTE_P | PTE_U | PTE_W);
   10de0:	83 ec 04             	sub    $0x4,%esp
   10de3:	6a 07                	push   $0x7
   10de5:	ff 75 d8             	pushl  -0x28(%ebp)
   10de8:	ff 75 f4             	pushl  -0xc(%ebp)
   10deb:	e8 30 fb ff ff       	call   10920 <memory_alloc_page_for>
   10df0:	83 c4 10             	add    $0x10,%esp
   10df3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        if(err<0){
   10df6:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   10dfa:	79 17                	jns    10e13 <sys_sbrk+0xfe>
            log_printf("sbrk: alloc mem failed.");
   10dfc:	83 ec 0c             	sub    $0xc,%esp
   10dff:	68 9f 86 01 00       	push   $0x1869f
   10e04:	e8 c2 76 00 00       	call   184cb <log_printf>
   10e09:	83 c4 10             	add    $0x10,%esp
            return (char*)-1;
   10e0c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10e11:	eb 0c                	jmp    10e1f <sys_sbrk+0x10a>
        }
    }

    task->heap_end=end;
   10e13:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10e16:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10e19:	89 50 10             	mov    %edx,0x10(%eax)
    return (char*)pre_heap_end;
   10e1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e1f:	c9                   	leave  
   10e20:	c3                   	ret    

00010e21 <sys_print_msg>:

/// @brief 系统调用的函数指针，统一以这种方式定义
typedef int (*syscall_handler_t)(uint32_t arg0,uint32_t arg1,uint32_t arg2,uint32_t arg3);


void sys_print_msg(char* fmt,int arg){
   10e21:	55                   	push   %ebp
   10e22:	89 e5                	mov    %esp,%ebp
   10e24:	83 ec 08             	sub    $0x8,%esp
    log_printf(fmt,arg);
   10e27:	83 ec 08             	sub    $0x8,%esp
   10e2a:	ff 75 0c             	pushl  0xc(%ebp)
   10e2d:	ff 75 08             	pushl  0x8(%ebp)
   10e30:	e8 96 76 00 00       	call   184cb <log_printf>
   10e35:	83 c4 10             	add    $0x10,%esp
}
   10e38:	90                   	nop
   10e39:	c9                   	leave  
   10e3a:	c3                   	ret    

00010e3b <do_handler_syscall>:
    [SYS_UNLINK]=(syscall_handler_t)sys_unlink,
    [SYS_PRINT_MSG]=(syscall_handler_t)sys_print_msg,
};


void do_handler_syscall(syscall_frame_t*frame){
   10e3b:	55                   	push   %ebp
   10e3c:	89 e5                	mov    %esp,%ebp
   10e3e:	53                   	push   %ebx
   10e3f:	83 ec 14             	sub    $0x14,%esp
    if(frame->func_id < sizeof(sys_table)/sizeof(sys_table[0])){
   10e42:	8b 45 08             	mov    0x8(%ebp),%eax
   10e45:	8b 40 3c             	mov    0x3c(%eax),%eax
   10e48:	83 f8 64             	cmp    $0x64,%eax
   10e4b:	77 48                	ja     10e95 <do_handler_syscall+0x5a>
        syscall_handler_t handler=sys_table[frame->func_id];
   10e4d:	8b 45 08             	mov    0x8(%ebp),%eax
   10e50:	8b 40 3c             	mov    0x3c(%eax),%eax
   10e53:	8b 04 85 00 87 01 00 	mov    0x18700(,%eax,4),%eax
   10e5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(handler){
   10e5d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e61:	74 32                	je     10e95 <do_handler_syscall+0x5a>
            int ret=handler(frame->arg0,frame->arg1,frame->arg2,frame->arg3);
   10e63:	8b 45 08             	mov    0x8(%ebp),%eax
   10e66:	8b 58 4c             	mov    0x4c(%eax),%ebx
   10e69:	8b 45 08             	mov    0x8(%ebp),%eax
   10e6c:	8b 48 48             	mov    0x48(%eax),%ecx
   10e6f:	8b 45 08             	mov    0x8(%ebp),%eax
   10e72:	8b 50 44             	mov    0x44(%eax),%edx
   10e75:	8b 45 08             	mov    0x8(%ebp),%eax
   10e78:	8b 40 40             	mov    0x40(%eax),%eax
   10e7b:	53                   	push   %ebx
   10e7c:	51                   	push   %ecx
   10e7d:	52                   	push   %edx
   10e7e:	50                   	push   %eax
   10e7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e82:	ff d0                	call   *%eax
   10e84:	83 c4 10             	add    $0x10,%esp
   10e87:	89 45 f0             	mov    %eax,-0x10(%ebp)
            frame->eax=ret;
   10e8a:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10e8d:	8b 45 08             	mov    0x8(%ebp),%eax
   10e90:	89 50 30             	mov    %edx,0x30(%eax)
            return;
   10e93:	eb 30                	jmp    10ec5 <do_handler_syscall+0x8a>
        }
    }

    task_t* task=task_current();
   10e95:	e8 61 07 00 00       	call   115fb <task_current>
   10e9a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    log_printf("task: %s, Unknown syscall: %d",task->name,frame->func_id);
   10e9d:	8b 45 08             	mov    0x8(%ebp),%eax
   10ea0:	8b 40 3c             	mov    0x3c(%eax),%eax
   10ea3:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10ea6:	83 c2 20             	add    $0x20,%edx
   10ea9:	83 ec 04             	sub    $0x4,%esp
   10eac:	50                   	push   %eax
   10ead:	52                   	push   %edx
   10eae:	68 94 88 01 00       	push   $0x18894
   10eb3:	e8 13 76 00 00       	call   184cb <log_printf>
   10eb8:	83 c4 10             	add    $0x10,%esp
    frame->eax=-1;
   10ebb:	8b 45 08             	mov    0x8(%ebp),%eax
   10ebe:	c7 40 30 ff ff ff ff 	movl   $0xffffffff,0x30(%eax)
   10ec5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10ec8:	c9                   	leave  
   10ec9:	c3                   	ret    

00010eca <read_cr0>:
static inline uint32_t read_cr0(void){
   10eca:	55                   	push   %ebp
   10ecb:	89 e5                	mov    %esp,%ebp
   10ecd:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__(
   10ed0:	0f 20 c0             	mov    %cr0,%eax
   10ed3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return cr0;
   10ed6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10ed9:	c9                   	leave  
   10eda:	c3                   	ret    

00010edb <write_cr0>:
static inline void write_cr0(uint32_t v){
   10edb:	55                   	push   %ebp
   10edc:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10ede:	8b 45 08             	mov    0x8(%ebp),%eax
   10ee1:	0f 22 c0             	mov    %eax,%cr0
}
   10ee4:	90                   	nop
   10ee5:	5d                   	pop    %ebp
   10ee6:	c3                   	ret    

00010ee7 <hlt>:
static inline void hlt(void){
   10ee7:	55                   	push   %ebp
   10ee8:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("hlt");
   10eea:	f4                   	hlt    
}
   10eeb:	90                   	nop
   10eec:	5d                   	pop    %ebp
   10eed:	c3                   	ret    

00010eee <write_tr>:
static inline void write_tr(uint16_t tss_sel){
   10eee:	55                   	push   %ebp
   10eef:	89 e5                	mov    %esp,%ebp
   10ef1:	83 ec 04             	sub    $0x4,%esp
   10ef4:	8b 45 08             	mov    0x8(%ebp),%eax
   10ef7:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    __asm__ __volatile__(
   10efb:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
   10eff:	0f 00 d8             	ltr    %ax
}
   10f02:	90                   	nop
   10f03:	c9                   	leave  
   10f04:	c3                   	ret    

00010f05 <write_cr3>:
static inline void write_cr3(uint32_t v){
   10f05:	55                   	push   %ebp
   10f06:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10f08:	8b 45 08             	mov    0x8(%ebp),%eax
   10f0b:	0f 22 d8             	mov    %eax,%cr3
}
   10f0e:	90                   	nop
   10f0f:	5d                   	pop    %ebp
   10f10:	c3                   	ret    

00010f11 <write_cr4>:
static inline void write_cr4(uint32_t v){
   10f11:	55                   	push   %ebp
   10f12:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10f14:	8b 45 08             	mov    0x8(%ebp),%eax
   10f17:	0f 22 e0             	mov    %eax,%cr4
}
   10f1a:	90                   	nop
   10f1b:	5d                   	pop    %ebp
   10f1c:	c3                   	ret    

00010f1d <read_cr4>:
static inline uint32_t read_cr4(void){
   10f1d:	55                   	push   %ebp
   10f1e:	89 e5                	mov    %esp,%ebp
   10f20:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__(
   10f23:	0f 20 e0             	mov    %cr4,%eax
   10f26:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return cr4;
   10f29:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10f2c:	c9                   	leave  
   10f2d:	c3                   	ret    

00010f2e <list_node_init>:
typedef struct _list_node_t{
    struct _list_node_t*pre;
    struct _list_node_t*next;
}list_node_t;

static inline void list_node_init(list_node_t* node){
   10f2e:	55                   	push   %ebp
   10f2f:	89 e5                	mov    %esp,%ebp
    node->pre=node->next=(list_node_t*)0;
   10f31:	8b 45 08             	mov    0x8(%ebp),%eax
   10f34:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   10f3b:	8b 45 08             	mov    0x8(%ebp),%eax
   10f3e:	8b 50 04             	mov    0x4(%eax),%edx
   10f41:	8b 45 08             	mov    0x8(%ebp),%eax
   10f44:	89 10                	mov    %edx,(%eax)
}
   10f46:	90                   	nop
   10f47:	5d                   	pop    %ebp
   10f48:	c3                   	ret    

00010f49 <list_node_next>:

static inline list_node_t* list_node_pre(list_node_t* node){
    return node->pre;
}

static inline list_node_t* list_node_next(list_node_t* node){
   10f49:	55                   	push   %ebp
   10f4a:	89 e5                	mov    %esp,%ebp
    return node->next;
   10f4c:	8b 45 08             	mov    0x8(%ebp),%eax
   10f4f:	8b 40 04             	mov    0x4(%eax),%eax
}
   10f52:	5d                   	pop    %ebp
   10f53:	c3                   	ret    

00010f54 <list_count>:
void list_init(list_t* list);
static inline int list_is_empty(list_t* list){
    return list->count==0;
}

static inline int list_count(list_t* list){
   10f54:	55                   	push   %ebp
   10f55:	89 e5                	mov    %esp,%ebp
    return list->count;
   10f57:	8b 45 08             	mov    0x8(%ebp),%eax
   10f5a:	8b 40 08             	mov    0x8(%eax),%eax
}
   10f5d:	5d                   	pop    %ebp
   10f5e:	c3                   	ret    

00010f5f <list_first>:

static inline list_node_t* list_first(list_t* list){
   10f5f:	55                   	push   %ebp
   10f60:	89 e5                	mov    %esp,%ebp
    return list->first;
   10f62:	8b 45 08             	mov    0x8(%ebp),%eax
   10f65:	8b 00                	mov    (%eax),%eax
}
   10f67:	5d                   	pop    %ebp
   10f68:	c3                   	ret    

00010f69 <mmu_set_page_dir>:
static inline void mmu_set_page_dir(uint32_t paddr){
   10f69:	55                   	push   %ebp
   10f6a:	89 e5                	mov    %esp,%ebp
   10f6c:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr4=read_cr4();
   10f6f:	e8 a9 ff ff ff       	call   10f1d <read_cr4>
   10f74:	89 45 fc             	mov    %eax,-0x4(%ebp)
	write_cr4(cr4|CR4_PSE);
   10f77:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10f7a:	83 c8 10             	or     $0x10,%eax
   10f7d:	50                   	push   %eax
   10f7e:	e8 8e ff ff ff       	call   10f11 <write_cr4>
   10f83:	83 c4 04             	add    $0x4,%esp
	write_cr3(paddr);
   10f86:	ff 75 08             	pushl  0x8(%ebp)
   10f89:	e8 77 ff ff ff       	call   10f05 <write_cr3>
   10f8e:	83 c4 04             	add    $0x4,%esp
	write_cr0(read_cr0()|CR0_PG);
   10f91:	e8 34 ff ff ff       	call   10eca <read_cr0>
   10f96:	0d 00 00 00 80       	or     $0x80000000,%eax
   10f9b:	50                   	push   %eax
   10f9c:	e8 3a ff ff ff       	call   10edb <write_cr0>
   10fa1:	83 c4 04             	add    $0x4,%esp
}
   10fa4:	90                   	nop
   10fa5:	c9                   	leave  
   10fa6:	c3                   	ret    

00010fa7 <tss_init>:
 * @param flag 任务的标志位，设置任务的特权级
 * @param entry 任务的入口地址
 * @param esp 任务的栈顶地址
 * @return 0 成功，-1 失败
 */
static int tss_init(task_t* task,int flag,uint32_t entry,uint32_t esp){
   10fa7:	55                   	push   %ebp
   10fa8:	89 e5                	mov    %esp,%ebp
   10faa:	83 ec 28             	sub    $0x28,%esp
    int tss_sel=gdt_alloc_desc();
   10fad:	e8 45 15 00 00       	call   124f7 <gdt_alloc_desc>
   10fb2:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(tss_sel<0){
   10fb5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10fb9:	79 1a                	jns    10fd5 <tss_init+0x2e>
        log_printf("alloc tss failed.\n");
   10fbb:	83 ec 0c             	sub    $0xc,%esp
   10fbe:	68 b4 88 01 00       	push   $0x188b4
   10fc3:	e8 03 75 00 00       	call   184cb <log_printf>
   10fc8:	83 c4 10             	add    $0x10,%esp
        return -1;
   10fcb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10fd0:	e9 6b 01 00 00       	jmp    11140 <tss_init+0x199>
    }

    // 这里将tss_sel设置为特权级0的TSS段描述符为了防止任意修改tss
    segment_desc_set(tss_sel,(uint32_t)&task->tss,sizeof(tss_t),
   10fd5:	8b 45 08             	mov    0x8(%ebp),%eax
   10fd8:	05 58 02 00 00       	add    $0x258,%eax
   10fdd:	68 89 00 00 00       	push   $0x89
   10fe2:	6a 68                	push   $0x68
   10fe4:	50                   	push   %eax
   10fe5:	ff 75 ec             	pushl  -0x14(%ebp)
   10fe8:	e8 94 13 00 00       	call   12381 <segment_desc_set>
   10fed:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL0 | SEG_TYPE_TSS
    );
    kernel_memset(&task->tss,0,sizeof(tss_t));
   10ff0:	8b 45 08             	mov    0x8(%ebp),%eax
   10ff3:	05 58 02 00 00       	add    $0x258,%eax
   10ff8:	83 ec 04             	sub    $0x4,%esp
   10ffb:	6a 68                	push   $0x68
   10ffd:	6a 00                	push   $0x0
   10fff:	50                   	push   %eax
   11000:	e8 a3 6e 00 00       	call   17ea8 <kernel_memset>
   11005:	83 c4 10             	add    $0x10,%esp

    uint32_t kernel_stack=memory_alloc_page();
   11008:	e8 38 f9 ff ff       	call   10945 <memory_alloc_page>
   1100d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(kernel_stack == 0){
   11010:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11014:	0f 84 fb 00 00 00    	je     11115 <tss_init+0x16e>
        goto tss_init_failed;
    }
    
    int code_sel,data_sel;
    if(flag & TASK_FLAGS_SYSTEM){
   1101a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1101d:	83 e0 01             	and    $0x1,%eax
   11020:	85 c0                	test   %eax,%eax
   11022:	74 10                	je     11034 <tss_init+0x8d>
        code_sel=KERNEL_SELECTOR_CS;
   11024:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
        data_sel=KERNEL_SELECTOR_DS;
   1102b:	c7 45 f0 10 00 00 00 	movl   $0x10,-0x10(%ebp)
   11032:	eb 16                	jmp    1104a <tss_init+0xa3>
    }
    else{
        code_sel=task_manager.app_code_sel | SEG_CPL3;
   11034:	a1 b8 d5 01 00       	mov    0x1d5b8,%eax
   11039:	83 c8 03             	or     $0x3,%eax
   1103c:	89 45 f4             	mov    %eax,-0xc(%ebp)
        data_sel=task_manager.app_data_sel | SEG_CPL3;
   1103f:	a1 bc d5 01 00       	mov    0x1d5bc,%eax
   11044:	83 c8 03             	or     $0x3,%eax
   11047:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    task->tss.eip=entry;
   1104a:	8b 45 08             	mov    0x8(%ebp),%eax
   1104d:	8b 55 10             	mov    0x10(%ebp),%edx
   11050:	89 90 78 02 00 00    	mov    %edx,0x278(%eax)
    task->tss.esp=esp;
   11056:	8b 45 08             	mov    0x8(%ebp),%eax
   11059:	8b 55 14             	mov    0x14(%ebp),%edx
   1105c:	89 90 90 02 00 00    	mov    %edx,0x290(%eax)
    task->tss.esp0=kernel_stack+MEM_PAGE_SIZE;
   11062:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11065:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
   1106b:	8b 45 08             	mov    0x8(%ebp),%eax
   1106e:	89 90 5c 02 00 00    	mov    %edx,0x25c(%eax)
    task->tss.ss=data_sel;
   11074:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11077:	8b 45 08             	mov    0x8(%ebp),%eax
   1107a:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%eax)
    task->tss.ss0=KERNEL_SELECTOR_DS;
   11080:	8b 45 08             	mov    0x8(%ebp),%eax
   11083:	c7 80 60 02 00 00 10 	movl   $0x10,0x260(%eax)
   1108a:	00 00 00 
    task->tss.es=task->tss.ds=task->tss.fs=task->tss.gs=data_sel;
   1108d:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11090:	8b 45 08             	mov    0x8(%ebp),%eax
   11093:	89 90 b4 02 00 00    	mov    %edx,0x2b4(%eax)
   11099:	8b 45 08             	mov    0x8(%ebp),%eax
   1109c:	8b 90 b4 02 00 00    	mov    0x2b4(%eax),%edx
   110a2:	8b 45 08             	mov    0x8(%ebp),%eax
   110a5:	89 90 b0 02 00 00    	mov    %edx,0x2b0(%eax)
   110ab:	8b 45 08             	mov    0x8(%ebp),%eax
   110ae:	8b 90 b0 02 00 00    	mov    0x2b0(%eax),%edx
   110b4:	8b 45 08             	mov    0x8(%ebp),%eax
   110b7:	89 90 ac 02 00 00    	mov    %edx,0x2ac(%eax)
   110bd:	8b 45 08             	mov    0x8(%ebp),%eax
   110c0:	8b 90 ac 02 00 00    	mov    0x2ac(%eax),%edx
   110c6:	8b 45 08             	mov    0x8(%ebp),%eax
   110c9:	89 90 a0 02 00 00    	mov    %edx,0x2a0(%eax)
    task->tss.cs=code_sel;
   110cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
   110d2:	8b 45 08             	mov    0x8(%ebp),%eax
   110d5:	89 90 a4 02 00 00    	mov    %edx,0x2a4(%eax)
    task->tss.eflags=EFLAGS_DEFAULT | EFLAGS_IF;
   110db:	8b 45 08             	mov    0x8(%ebp),%eax
   110de:	c7 80 7c 02 00 00 02 	movl   $0x202,0x27c(%eax)
   110e5:	02 00 00 

    uint32_t page_dir=memory_create_uvm();
   110e8:	e8 fa f6 ff ff       	call   107e7 <memory_create_uvm>
   110ed:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(page_dir == 0){
   110f0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   110f4:	74 22                	je     11118 <tss_init+0x171>
        goto tss_init_failed;
    }
    task->tss.cr3=page_dir;
   110f6:	8b 45 08             	mov    0x8(%ebp),%eax
   110f9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   110fc:	89 90 74 02 00 00    	mov    %edx,0x274(%eax)
    task->tss_sel=tss_sel;
   11102:	8b 45 08             	mov    0x8(%ebp),%eax
   11105:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11108:	89 90 c0 02 00 00    	mov    %edx,0x2c0(%eax)
    return 0;
   1110e:	b8 00 00 00 00       	mov    $0x0,%eax
   11113:	eb 2b                	jmp    11140 <tss_init+0x199>
        goto tss_init_failed;
   11115:	90                   	nop
   11116:	eb 01                	jmp    11119 <tss_init+0x172>
        goto tss_init_failed;
   11118:	90                   	nop
tss_init_failed:
    gdt_free_sel(tss_sel);
   11119:	83 ec 0c             	sub    $0xc,%esp
   1111c:	ff 75 ec             	pushl  -0x14(%ebp)
   1111f:	e8 5c 14 00 00       	call   12580 <gdt_free_sel>
   11124:	83 c4 10             	add    $0x10,%esp
    if(kernel_stack){
   11127:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1112b:	74 0e                	je     1113b <tss_init+0x194>
        memory_free_page(kernel_stack);
   1112d:	83 ec 0c             	sub    $0xc,%esp
   11130:	ff 75 e8             	pushl  -0x18(%ebp)
   11133:	e8 40 f8 ff ff       	call   10978 <memory_free_page>
   11138:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   1113b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
   11140:	c9                   	leave  
   11141:	c3                   	ret    

00011142 <task_init>:

int task_init(task_t* task,const char*name,int flag,uint32_t entry,uint32_t esp){
   11142:	55                   	push   %ebp
   11143:	89 e5                	mov    %esp,%ebp
   11145:	83 ec 18             	sub    $0x18,%esp
    ASSERT(task!=(task_t*)0);
   11148:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1114c:	75 19                	jne    11167 <task_init+0x25>
   1114e:	68 c7 88 01 00       	push   $0x188c7
   11153:	68 d8 89 01 00       	push   $0x189d8
   11158:	6a 52                	push   $0x52
   1115a:	68 d8 88 01 00       	push   $0x188d8
   1115f:	e8 97 70 00 00       	call   181fb <panic>
   11164:	83 c4 10             	add    $0x10,%esp
    int err=tss_init(task,flag,entry,esp);
   11167:	ff 75 18             	pushl  0x18(%ebp)
   1116a:	ff 75 14             	pushl  0x14(%ebp)
   1116d:	ff 75 10             	pushl  0x10(%ebp)
   11170:	ff 75 08             	pushl  0x8(%ebp)
   11173:	e8 2f fe ff ff       	call   10fa7 <tss_init>
   11178:	83 c4 10             	add    $0x10,%esp
   1117b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(err<0){
   1117e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11182:	79 18                	jns    1119c <task_init+0x5a>
        log_printf("init task failed.");
   11184:	83 ec 0c             	sub    $0xc,%esp
   11187:	68 0b 89 01 00       	push   $0x1890b
   1118c:	e8 3a 73 00 00       	call   184cb <log_printf>
   11191:	83 c4 10             	add    $0x10,%esp
        return err;
   11194:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11197:	e9 fd 00 00 00       	jmp    11299 <task_init+0x157>
    }
    kernel_strncpy(task->name,name,TASK_NAME_SIZE);
   1119c:	8b 45 08             	mov    0x8(%ebp),%eax
   1119f:	83 c0 20             	add    $0x20,%eax
   111a2:	83 ec 04             	sub    $0x4,%esp
   111a5:	6a 20                	push   $0x20
   111a7:	ff 75 0c             	pushl  0xc(%ebp)
   111aa:	50                   	push   %eax
   111ab:	e8 84 6b 00 00       	call   17d34 <kernel_strncpy>
   111b0:	83 c4 10             	add    $0x10,%esp

    task->state=TASK_CREATED;
   111b3:	8b 45 08             	mov    0x8(%ebp),%eax
   111b6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    task->time_ticks=TASK_TIME_SLICE_DEFAULT;
   111bc:	8b 45 08             	mov    0x8(%ebp),%eax
   111bf:	c7 40 1c 0a 00 00 00 	movl   $0xa,0x1c(%eax)
    task->slice_ticks=task->time_ticks;
   111c6:	8b 45 08             	mov    0x8(%ebp),%eax
   111c9:	8b 50 1c             	mov    0x1c(%eax),%edx
   111cc:	8b 45 08             	mov    0x8(%ebp),%eax
   111cf:	89 50 18             	mov    %edx,0x18(%eax)
    task->sleep_ticks=0;
   111d2:	8b 45 08             	mov    0x8(%ebp),%eax
   111d5:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    task->status=0;
   111dc:	8b 45 08             	mov    0x8(%ebp),%eax
   111df:	c7 80 c4 02 00 00 00 	movl   $0x0,0x2c4(%eax)
   111e6:	00 00 00 
    
    list_node_init(&task->all_node);
   111e9:	8b 45 08             	mov    0x8(%ebp),%eax
   111ec:	05 48 02 00 00       	add    $0x248,%eax
   111f1:	83 ec 0c             	sub    $0xc,%esp
   111f4:	50                   	push   %eax
   111f5:	e8 34 fd ff ff       	call   10f2e <list_node_init>
   111fa:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->run_node);
   111fd:	8b 45 08             	mov    0x8(%ebp),%eax
   11200:	05 40 02 00 00       	add    $0x240,%eax
   11205:	83 ec 0c             	sub    $0xc,%esp
   11208:	50                   	push   %eax
   11209:	e8 20 fd ff ff       	call   10f2e <list_node_init>
   1120e:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->wait_node);
   11211:	8b 45 08             	mov    0x8(%ebp),%eax
   11214:	05 50 02 00 00       	add    $0x250,%eax
   11219:	83 ec 0c             	sub    $0xc,%esp
   1121c:	50                   	push   %eax
   1121d:	e8 0c fd ff ff       	call   10f2e <list_node_init>
   11222:	83 c4 10             	add    $0x10,%esp
    
    irq_state_t state=irq_enter_protection();
   11225:	e8 da 1c 00 00       	call   12f04 <irq_enter_protection>
   1122a:	89 45 f0             	mov    %eax,-0x10(%ebp)

    task->pid=(uint32_t)task;
   1122d:	8b 55 08             	mov    0x8(%ebp),%edx
   11230:	8b 45 08             	mov    0x8(%ebp),%eax
   11233:	89 50 04             	mov    %edx,0x4(%eax)
    task->parent=(task_t*)0;
   11236:	8b 45 08             	mov    0x8(%ebp),%eax
   11239:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    task->heap_start=0;
   11240:	8b 45 08             	mov    0x8(%ebp),%eax
   11243:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    task->heap_end=0;
   1124a:	8b 45 08             	mov    0x8(%ebp),%eax
   1124d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

    // 对task->file_table进行初始化
    kernel_memset(&task->file_table,0,sizeof(task->file_table));
   11254:	8b 45 08             	mov    0x8(%ebp),%eax
   11257:	83 c0 40             	add    $0x40,%eax
   1125a:	83 ec 04             	sub    $0x4,%esp
   1125d:	68 00 02 00 00       	push   $0x200
   11262:	6a 00                	push   $0x0
   11264:	50                   	push   %eax
   11265:	e8 3e 6c 00 00       	call   17ea8 <kernel_memset>
   1126a:	83 c4 10             	add    $0x10,%esp

    list_insert_last(&task_manager.task_list,&task->all_node);
   1126d:	8b 45 08             	mov    0x8(%ebp),%eax
   11270:	05 48 02 00 00       	add    $0x248,%eax
   11275:	83 ec 08             	sub    $0x8,%esp
   11278:	50                   	push   %eax
   11279:	68 10 d0 01 00       	push   $0x1d010
   1127e:	e8 b8 70 00 00       	call   1833b <list_insert_last>
   11283:	83 c4 10             	add    $0x10,%esp

    irq_leave_protection(state);
   11286:	83 ec 0c             	sub    $0xc,%esp
   11289:	ff 75 f0             	pushl  -0x10(%ebp)
   1128c:	e8 8b 1c 00 00       	call   12f1c <irq_leave_protection>
   11291:	83 c4 10             	add    $0x10,%esp

    return 0;
   11294:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11299:	c9                   	leave  
   1129a:	c3                   	ret    

0001129b <task_start>:

void task_start(task_t* task){
   1129b:	55                   	push   %ebp
   1129c:	89 e5                	mov    %esp,%ebp
   1129e:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   112a1:	e8 5e 1c 00 00       	call   12f04 <irq_enter_protection>
   112a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_set_ready(task);
   112a9:	83 ec 0c             	sub    $0xc,%esp
   112ac:	ff 75 08             	pushl  0x8(%ebp)
   112af:	e8 9f 02 00 00       	call   11553 <task_set_ready>
   112b4:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   112b7:	83 ec 0c             	sub    $0xc,%esp
   112ba:	ff 75 f4             	pushl  -0xc(%ebp)
   112bd:	e8 5a 1c 00 00       	call   12f1c <irq_leave_protection>
   112c2:	83 c4 10             	add    $0x10,%esp
}
   112c5:	90                   	nop
   112c6:	c9                   	leave  
   112c7:	c3                   	ret    

000112c8 <task_uninit>:

/**
 * @brief 释放任务的资源
 * @param task 需要释放的任务结构体
 */
void task_uninit(task_t* task){
   112c8:	55                   	push   %ebp
   112c9:	89 e5                	mov    %esp,%ebp
   112cb:	83 ec 08             	sub    $0x8,%esp
    if(task->tss_sel){
   112ce:	8b 45 08             	mov    0x8(%ebp),%eax
   112d1:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
   112d7:	85 c0                	test   %eax,%eax
   112d9:	74 15                	je     112f0 <task_uninit+0x28>
        gdt_free_sel(task->tss_sel);
   112db:	8b 45 08             	mov    0x8(%ebp),%eax
   112de:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
   112e4:	83 ec 0c             	sub    $0xc,%esp
   112e7:	50                   	push   %eax
   112e8:	e8 93 12 00 00       	call   12580 <gdt_free_sel>
   112ed:	83 c4 10             	add    $0x10,%esp
    }

    if(task->tss.esp0){
   112f0:	8b 45 08             	mov    0x8(%ebp),%eax
   112f3:	8b 80 5c 02 00 00    	mov    0x25c(%eax),%eax
   112f9:	85 c0                	test   %eax,%eax
   112fb:	74 1a                	je     11317 <task_uninit+0x4f>
        memory_free_page(task->tss.esp-MEM_PAGE_SIZE);
   112fd:	8b 45 08             	mov    0x8(%ebp),%eax
   11300:	8b 80 90 02 00 00    	mov    0x290(%eax),%eax
   11306:	2d 00 10 00 00       	sub    $0x1000,%eax
   1130b:	83 ec 0c             	sub    $0xc,%esp
   1130e:	50                   	push   %eax
   1130f:	e8 64 f6 ff ff       	call   10978 <memory_free_page>
   11314:	83 c4 10             	add    $0x10,%esp
    }

    if(task->tss.cr3){
   11317:	8b 45 08             	mov    0x8(%ebp),%eax
   1131a:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   11320:	85 c0                	test   %eax,%eax
   11322:	74 15                	je     11339 <task_uninit+0x71>
        memory_destroy_uvm(task->tss.cr3);
   11324:	8b 45 08             	mov    0x8(%ebp),%eax
   11327:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   1132d:	83 ec 0c             	sub    $0xc,%esp
   11330:	50                   	push   %eax
   11331:	e8 db f6 ff ff       	call   10a11 <memory_destroy_uvm>
   11336:	83 c4 10             	add    $0x10,%esp
    }

    kernel_memset(task,0,sizeof(task));
   11339:	83 ec 04             	sub    $0x4,%esp
   1133c:	6a 04                	push   $0x4
   1133e:	6a 00                	push   $0x0
   11340:	ff 75 08             	pushl  0x8(%ebp)
   11343:	e8 60 6b 00 00       	call   17ea8 <kernel_memset>
   11348:	83 c4 10             	add    $0x10,%esp
}
   1134b:	90                   	nop
   1134c:	c9                   	leave  
   1134d:	c3                   	ret    

0001134e <task_switch_from_to>:

void task_switch_from_to(task_t*from,task_t*to){
   1134e:	55                   	push   %ebp
   1134f:	89 e5                	mov    %esp,%ebp
   11351:	83 ec 08             	sub    $0x8,%esp
    switch_to_tss(to->tss_sel);
   11354:	8b 45 0c             	mov    0xc(%ebp),%eax
   11357:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
   1135d:	83 ec 0c             	sub    $0xc,%esp
   11360:	50                   	push   %eax
   11361:	e8 06 12 00 00       	call   1256c <switch_to_tss>
   11366:	83 c4 10             	add    $0x10,%esp
}
   11369:	90                   	nop
   1136a:	c9                   	leave  
   1136b:	c3                   	ret    

0001136c <idle_task_entry>:

static void idle_task_entry(void){
   1136c:	55                   	push   %ebp
   1136d:	89 e5                	mov    %esp,%ebp
    for(;;){
        hlt();
   1136f:	e8 73 fb ff ff       	call   10ee7 <hlt>
   11374:	eb f9                	jmp    1136f <idle_task_entry+0x3>

00011376 <task_manager_init>:
}

/**
 * @brief 初始化任务管理器
 */
void task_manager_init(void){
   11376:	55                   	push   %ebp
   11377:	89 e5                	mov    %esp,%ebp
   11379:	83 ec 18             	sub    $0x18,%esp

    kernel_memset(task_table,0,sizeof(task_table));
   1137c:	83 ec 04             	sub    $0x4,%esp
   1137f:	68 00 64 01 00       	push   $0x16400
   11384:	6a 00                	push   $0x0
   11386:	68 c0 e5 01 00       	push   $0x1e5c0
   1138b:	e8 18 6b 00 00       	call   17ea8 <kernel_memset>
   11390:	83 c4 10             	add    $0x10,%esp
    mutex_init(&table_mutex);
   11393:	83 ec 0c             	sub    $0xc,%esp
   11396:	68 c0 49 03 00       	push   $0x349c0
   1139b:	e8 10 64 00 00       	call   177b0 <mutex_init>
   113a0:	83 c4 10             	add    $0x10,%esp

    int sel=gdt_alloc_desc();
   113a3:	e8 4f 11 00 00       	call   124f7 <gdt_alloc_desc>
   113a8:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 这里虽然设置的代码段和数据段范围还是0x0-0xFFFFFFFF，但使用该段的段选择子访问的方式为特权级3
    segment_desc_set(sel,0x0,0xFFFFFFFF,
   113ab:	68 f2 40 00 00       	push   $0x40f2
   113b0:	6a ff                	push   $0xffffffff
   113b2:	6a 00                	push   $0x0
   113b4:	ff 75 f4             	pushl  -0xc(%ebp)
   113b7:	e8 c5 0f 00 00       	call   12381 <segment_desc_set>
   113bc:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D
    );
    task_manager.app_data_sel=sel;
   113bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   113c2:	a3 bc d5 01 00       	mov    %eax,0x1d5bc

    sel=gdt_alloc_desc();
   113c7:	e8 2b 11 00 00       	call   124f7 <gdt_alloc_desc>
   113cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(sel,0x0,0xFFFFFFFF,
   113cf:	68 fa 40 00 00       	push   $0x40fa
   113d4:	6a ff                	push   $0xffffffff
   113d6:	6a 00                	push   $0x0
   113d8:	ff 75 f4             	pushl  -0xc(%ebp)
   113db:	e8 a1 0f 00 00       	call   12381 <segment_desc_set>
   113e0:	83 c4 10             	add    $0x10,%esp
           SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL |SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D
    );
    task_manager.app_code_sel=sel;
   113e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   113e6:	a3 b8 d5 01 00       	mov    %eax,0x1d5b8

    list_init(&task_manager.ready_list);
   113eb:	83 ec 0c             	sub    $0xc,%esp
   113ee:	68 04 d0 01 00       	push   $0x1d004
   113f3:	e8 bf 6e 00 00       	call   182b7 <list_init>
   113f8:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.task_list);
   113fb:	83 ec 0c             	sub    $0xc,%esp
   113fe:	68 10 d0 01 00       	push   $0x1d010
   11403:	e8 af 6e 00 00       	call   182b7 <list_init>
   11408:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.sleep_list);
   1140b:	83 ec 0c             	sub    $0xc,%esp
   1140e:	68 1c d0 01 00       	push   $0x1d01c
   11413:	e8 9f 6e 00 00       	call   182b7 <list_init>
   11418:	83 c4 10             	add    $0x10,%esp
    task_manager.curr_task=(task_t*)0;
   1141b:	c7 05 00 d0 01 00 00 	movl   $0x0,0x1d000
   11422:	00 00 00 
    task_init(&task_manager.idle_task,"idle_task",TASK_FLAGS_SYSTEM,(uint32_t)idle_task_entry,
    (uint32_t)(idle_task_stack+IDLE_TASK_SIZE));
   11425:	b8 c0 e5 01 00       	mov    $0x1e5c0,%eax
    task_init(&task_manager.idle_task,"idle_task",TASK_FLAGS_SYSTEM,(uint32_t)idle_task_entry,
   1142a:	89 c2                	mov    %eax,%edx
   1142c:	b8 6c 13 01 00       	mov    $0x1136c,%eax
   11431:	83 ec 0c             	sub    $0xc,%esp
   11434:	52                   	push   %edx
   11435:	50                   	push   %eax
   11436:	6a 01                	push   $0x1
   11438:	68 1d 89 01 00       	push   $0x1891d
   1143d:	68 f0 d2 01 00       	push   $0x1d2f0
   11442:	e8 fb fc ff ff       	call   11142 <task_init>
   11447:	83 c4 20             	add    $0x20,%esp

    task_start(&task_manager.idle_task);
   1144a:	83 ec 0c             	sub    $0xc,%esp
   1144d:	68 f0 d2 01 00       	push   $0x1d2f0
   11452:	e8 44 fe ff ff       	call   1129b <task_start>
   11457:	83 c4 10             	add    $0x10,%esp
}
   1145a:	90                   	nop
   1145b:	c9                   	leave  
   1145c:	c3                   	ret    

0001145d <task_first_init>:

/**
 * @brief 初始化第一个任务
 * @note 该函数的运行的入口地址为first_task_entry，位于first_task_entry.S中
 */
void task_first_init(void){
   1145d:	55                   	push   %ebp
   1145e:	89 e5                	mov    %esp,%ebp
   11460:	83 ec 18             	sub    $0x18,%esp
    void first_task_entry(void);
    extern uint8_t s_first_task[],e_first_task[];

    uint32_t copy_size=(uint32_t)(e_first_task-s_first_task);
   11463:	ba b9 03 06 00       	mov    $0x603b9,%edx
   11468:	b8 20 00 06 00       	mov    $0x60020,%eax
   1146d:	29 c2                	sub    %eax,%edx
   1146f:	89 d0                	mov    %edx,%eax
   11471:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t alloc_size=10*MEM_PAGE_SIZE;
   11474:	c7 45 f0 00 a0 00 00 	movl   $0xa000,-0x10(%ebp)
    ASSERT(copy_size < alloc_size);
   1147b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1147e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   11481:	72 1c                	jb     1149f <task_first_init+0x42>
   11483:	68 27 89 01 00       	push   $0x18927
   11488:	68 e4 89 01 00       	push   $0x189e4
   1148d:	68 c3 00 00 00       	push   $0xc3
   11492:	68 d8 88 01 00       	push   $0x188d8
   11497:	e8 5f 6d 00 00       	call   181fb <panic>
   1149c:	83 c4 10             	add    $0x10,%esp

    uint32_t first_start=(uint32_t)first_task_entry;
   1149f:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%ebp)

    task_init(&task_manager.first_task,"first task",0,first_start,first_start+alloc_size);
   114a6:	8b 55 ec             	mov    -0x14(%ebp),%edx
   114a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   114ac:	01 d0                	add    %edx,%eax
   114ae:	83 ec 0c             	sub    $0xc,%esp
   114b1:	50                   	push   %eax
   114b2:	ff 75 ec             	pushl  -0x14(%ebp)
   114b5:	6a 00                	push   $0x0
   114b7:	68 3e 89 01 00       	push   $0x1893e
   114bc:	68 28 d0 01 00       	push   $0x1d028
   114c1:	e8 7c fc ff ff       	call   11142 <task_init>
   114c6:	83 c4 20             	add    $0x20,%esp

    task_manager.first_task.heap_start=(uint32_t)e_first_task;
   114c9:	b8 b9 03 06 00       	mov    $0x603b9,%eax
   114ce:	a3 34 d0 01 00       	mov    %eax,0x1d034
    task_manager.first_task.heap_end=(uint32_t)e_first_task;
   114d3:	b8 b9 03 06 00       	mov    $0x603b9,%eax
   114d8:	a3 38 d0 01 00       	mov    %eax,0x1d038

    write_tr(task_manager.first_task.tss_sel);
   114dd:	a1 e8 d2 01 00       	mov    0x1d2e8,%eax
   114e2:	0f b7 c0             	movzwl %ax,%eax
   114e5:	83 ec 0c             	sub    $0xc,%esp
   114e8:	50                   	push   %eax
   114e9:	e8 00 fa ff ff       	call   10eee <write_tr>
   114ee:	83 c4 10             	add    $0x10,%esp
    task_manager.curr_task=&task_manager.first_task;
   114f1:	c7 05 00 d0 01 00 28 	movl   $0x1d028,0x1d000
   114f8:	d0 01 00 

    mmu_set_page_dir(task_manager.first_task.tss.cr3);
   114fb:	a1 9c d2 01 00       	mov    0x1d29c,%eax
   11500:	83 ec 0c             	sub    $0xc,%esp
   11503:	50                   	push   %eax
   11504:	e8 60 fa ff ff       	call   10f69 <mmu_set_page_dir>
   11509:	83 c4 10             	add    $0x10,%esp

    memory_alloc_page_for(first_start,alloc_size,PTE_P | PTE_W | PTE_U);
   1150c:	83 ec 04             	sub    $0x4,%esp
   1150f:	6a 07                	push   $0x7
   11511:	ff 75 f0             	pushl  -0x10(%ebp)
   11514:	ff 75 ec             	pushl  -0x14(%ebp)
   11517:	e8 04 f4 ff ff       	call   10920 <memory_alloc_page_for>
   1151c:	83 c4 10             	add    $0x10,%esp
    kernel_memcpy((void*)first_start,s_first_task,copy_size);
   1151f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11522:	83 ec 04             	sub    $0x4,%esp
   11525:	ff 75 f4             	pushl  -0xc(%ebp)
   11528:	68 20 00 06 00       	push   $0x60020
   1152d:	50                   	push   %eax
   1152e:	e8 26 69 00 00       	call   17e59 <kernel_memcpy>
   11533:	83 c4 10             	add    $0x10,%esp

    task_start(&task_manager.first_task);
   11536:	83 ec 0c             	sub    $0xc,%esp
   11539:	68 28 d0 01 00       	push   $0x1d028
   1153e:	e8 58 fd ff ff       	call   1129b <task_start>
   11543:	83 c4 10             	add    $0x10,%esp
}
   11546:	90                   	nop
   11547:	c9                   	leave  
   11548:	c3                   	ret    

00011549 <task_first_task>:

task_t* task_first_task(void){
   11549:	55                   	push   %ebp
   1154a:	89 e5                	mov    %esp,%ebp
    return &task_manager.first_task;
   1154c:	b8 28 d0 01 00       	mov    $0x1d028,%eax
}
   11551:	5d                   	pop    %ebp
   11552:	c3                   	ret    

00011553 <task_set_ready>:
 * @brief 设置任务为就绪状态
 * @param task 需要设置的任务
 * @return 0 成功，-1 失败
 * @note 该函数会将任务插入到就绪队列中，将任务的状态设置为就绪
 */
void task_set_ready(task_t* task){
   11553:	55                   	push   %ebp
   11554:	89 e5                	mov    %esp,%ebp
   11556:	83 ec 08             	sub    $0x8,%esp
    if(task==&task_manager.idle_task){
   11559:	81 7d 08 f0 d2 01 00 	cmpl   $0x1d2f0,0x8(%ebp)
   11560:	74 24                	je     11586 <task_set_ready+0x33>
        return;
    }
    list_insert_last(&task_manager.ready_list,&task->run_node);
   11562:	8b 45 08             	mov    0x8(%ebp),%eax
   11565:	05 40 02 00 00       	add    $0x240,%eax
   1156a:	83 ec 08             	sub    $0x8,%esp
   1156d:	50                   	push   %eax
   1156e:	68 04 d0 01 00       	push   $0x1d004
   11573:	e8 c3 6d 00 00       	call   1833b <list_insert_last>
   11578:	83 c4 10             	add    $0x10,%esp
    task->state=TASK_READY;
   1157b:	8b 45 08             	mov    0x8(%ebp),%eax
   1157e:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   11584:	eb 01                	jmp    11587 <task_set_ready+0x34>
        return;
   11586:	90                   	nop
}
   11587:	c9                   	leave  
   11588:	c3                   	ret    

00011589 <task_set_block>:

void task_set_block(task_t* task){
   11589:	55                   	push   %ebp
   1158a:	89 e5                	mov    %esp,%ebp
   1158c:	83 ec 08             	sub    $0x8,%esp
    if(task==&task_manager.idle_task){
   1158f:	81 7d 08 f0 d2 01 00 	cmpl   $0x1d2f0,0x8(%ebp)
   11596:	74 1b                	je     115b3 <task_set_block+0x2a>
        return;
    }
    list_remove(&task_manager.ready_list,&task->run_node);
   11598:	8b 45 08             	mov    0x8(%ebp),%eax
   1159b:	05 40 02 00 00       	add    $0x240,%eax
   115a0:	83 ec 08             	sub    $0x8,%esp
   115a3:	50                   	push   %eax
   115a4:	68 04 d0 01 00       	push   $0x1d004
   115a9:	e8 69 6e 00 00       	call   18417 <list_remove>
   115ae:	83 c4 10             	add    $0x10,%esp
   115b1:	eb 01                	jmp    115b4 <task_set_block+0x2b>
        return;
   115b3:	90                   	nop
}
   115b4:	c9                   	leave  
   115b5:	c3                   	ret    

000115b6 <task_next_run>:

task_t* task_next_run(void){
   115b6:	55                   	push   %ebp
   115b7:	89 e5                	mov    %esp,%ebp
   115b9:	83 ec 10             	sub    $0x10,%esp
    if(list_count(&task_manager.ready_list)==0){
   115bc:	68 04 d0 01 00       	push   $0x1d004
   115c1:	e8 8e f9 ff ff       	call   10f54 <list_count>
   115c6:	83 c4 04             	add    $0x4,%esp
   115c9:	85 c0                	test   %eax,%eax
   115cb:	75 07                	jne    115d4 <task_next_run+0x1e>
        return &task_manager.idle_task;
   115cd:	b8 f0 d2 01 00       	mov    $0x1d2f0,%eax
   115d2:	eb 25                	jmp    115f9 <task_next_run+0x43>
    }
    list_node_t* task_node=list_first(&task_manager.ready_list);
   115d4:	68 04 d0 01 00       	push   $0x1d004
   115d9:	e8 81 f9 ff ff       	call   10f5f <list_first>
   115de:	83 c4 04             	add    $0x4,%esp
   115e1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return list_node_parent(task_node,task_t,run_node);
   115e4:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   115e8:	74 0a                	je     115f4 <task_next_run+0x3e>
   115ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
   115ed:	2d 40 02 00 00       	sub    $0x240,%eax
   115f2:	eb 05                	jmp    115f9 <task_next_run+0x43>
   115f4:	b8 00 00 00 00       	mov    $0x0,%eax
}
   115f9:	c9                   	leave  
   115fa:	c3                   	ret    

000115fb <task_current>:

task_t* task_current(void){
   115fb:	55                   	push   %ebp
   115fc:	89 e5                	mov    %esp,%ebp
    return task_manager.curr_task;
   115fe:	a1 00 d0 01 00       	mov    0x1d000,%eax
}
   11603:	5d                   	pop    %ebp
   11604:	c3                   	ret    

00011605 <sys_sched_yield>:

int sys_sched_yield(void){
   11605:	55                   	push   %ebp
   11606:	89 e5                	mov    %esp,%ebp
   11608:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   1160b:	e8 f4 18 00 00       	call   12f04 <irq_enter_protection>
   11610:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(list_count(&task_manager.ready_list)>1){
   11613:	83 ec 0c             	sub    $0xc,%esp
   11616:	68 04 d0 01 00       	push   $0x1d004
   1161b:	e8 34 f9 ff ff       	call   10f54 <list_count>
   11620:	83 c4 10             	add    $0x10,%esp
   11623:	83 f8 01             	cmp    $0x1,%eax
   11626:	7e 29                	jle    11651 <sys_sched_yield+0x4c>
        task_t* curr_task=task_current();
   11628:	e8 ce ff ff ff       	call   115fb <task_current>
   1162d:	89 45 f0             	mov    %eax,-0x10(%ebp)

        task_set_block(curr_task);
   11630:	83 ec 0c             	sub    $0xc,%esp
   11633:	ff 75 f0             	pushl  -0x10(%ebp)
   11636:	e8 4e ff ff ff       	call   11589 <task_set_block>
   1163b:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task);
   1163e:	83 ec 0c             	sub    $0xc,%esp
   11641:	ff 75 f0             	pushl  -0x10(%ebp)
   11644:	e8 0a ff ff ff       	call   11553 <task_set_ready>
   11649:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   1164c:	e8 15 00 00 00       	call   11666 <task_dispatch>
    }
    irq_leave_protection(state);
   11651:	83 ec 0c             	sub    $0xc,%esp
   11654:	ff 75 f4             	pushl  -0xc(%ebp)
   11657:	e8 c0 18 00 00       	call   12f1c <irq_leave_protection>
   1165c:	83 c4 10             	add    $0x10,%esp
    return 0;
   1165f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11664:	c9                   	leave  
   11665:	c3                   	ret    

00011666 <task_dispatch>:

void task_dispatch(void){
   11666:	55                   	push   %ebp
   11667:	89 e5                	mov    %esp,%ebp
   11669:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   1166c:	e8 93 18 00 00       	call   12f04 <irq_enter_protection>
   11671:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* to=task_next_run();
   11674:	e8 3d ff ff ff       	call   115b6 <task_next_run>
   11679:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(to!=task_manager.curr_task){
   1167c:	a1 00 d0 01 00       	mov    0x1d000,%eax
   11681:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11684:	74 2a                	je     116b0 <task_dispatch+0x4a>
        task_t* from=task_current();
   11686:	e8 70 ff ff ff       	call   115fb <task_current>
   1168b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_manager.curr_task=to;
   1168e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11691:	a3 00 d0 01 00       	mov    %eax,0x1d000
        to->state=TASK_RUNNING;
   11696:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11699:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        task_switch_from_to(from,to);
   1169f:	83 ec 08             	sub    $0x8,%esp
   116a2:	ff 75 f0             	pushl  -0x10(%ebp)
   116a5:	ff 75 ec             	pushl  -0x14(%ebp)
   116a8:	e8 a1 fc ff ff       	call   1134e <task_switch_from_to>
   116ad:	83 c4 10             	add    $0x10,%esp
    }
    irq_leave_protection(state);
   116b0:	83 ec 0c             	sub    $0xc,%esp
   116b3:	ff 75 f4             	pushl  -0xc(%ebp)
   116b6:	e8 61 18 00 00       	call   12f1c <irq_leave_protection>
   116bb:	83 c4 10             	add    $0x10,%esp
}
   116be:	90                   	nop
   116bf:	c9                   	leave  
   116c0:	c3                   	ret    

000116c1 <task_time_tick>:

void task_time_tick(void){
   116c1:	55                   	push   %ebp
   116c2:	89 e5                	mov    %esp,%ebp
   116c4:	83 ec 28             	sub    $0x28,%esp
    irq_state_t state=irq_enter_protection();
   116c7:	e8 38 18 00 00       	call   12f04 <irq_enter_protection>
   116cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    task_t* curr_task=task_current();
   116cf:	e8 27 ff ff ff       	call   115fb <task_current>
   116d4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(--curr_task->slice_ticks==0){
   116d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116da:	8b 40 18             	mov    0x18(%eax),%eax
   116dd:	8d 50 ff             	lea    -0x1(%eax),%edx
   116e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116e3:	89 50 18             	mov    %edx,0x18(%eax)
   116e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116e9:	8b 40 18             	mov    0x18(%eax),%eax
   116ec:	85 c0                	test   %eax,%eax
   116ee:	75 28                	jne    11718 <task_time_tick+0x57>
        curr_task->slice_ticks=curr_task->time_ticks;
   116f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116f3:	8b 50 1c             	mov    0x1c(%eax),%edx
   116f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116f9:	89 50 18             	mov    %edx,0x18(%eax)
        task_set_block(curr_task);
   116fc:	83 ec 0c             	sub    $0xc,%esp
   116ff:	ff 75 ec             	pushl  -0x14(%ebp)
   11702:	e8 82 fe ff ff       	call   11589 <task_set_block>
   11707:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task);
   1170a:	83 ec 0c             	sub    $0xc,%esp
   1170d:	ff 75 ec             	pushl  -0x14(%ebp)
   11710:	e8 3e fe ff ff       	call   11553 <task_set_ready>
   11715:	83 c4 10             	add    $0x10,%esp
    }
    list_node_t* curr=list_first(&task_manager.sleep_list);
   11718:	83 ec 0c             	sub    $0xc,%esp
   1171b:	68 1c d0 01 00       	push   $0x1d01c
   11720:	e8 3a f8 ff ff       	call   10f5f <list_first>
   11725:	83 c4 10             	add    $0x10,%esp
   11728:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(curr){
   1172b:	eb 64                	jmp    11791 <task_time_tick+0xd0>
        list_node_t*next=list_node_next(curr);
   1172d:	83 ec 0c             	sub    $0xc,%esp
   11730:	ff 75 f4             	pushl  -0xc(%ebp)
   11733:	e8 11 f8 ff ff       	call   10f49 <list_node_next>
   11738:	83 c4 10             	add    $0x10,%esp
   1173b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        task_t* task=list_node_parent(curr,task_t,run_node);
   1173e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11742:	74 0a                	je     1174e <task_time_tick+0x8d>
   11744:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11747:	2d 40 02 00 00       	sub    $0x240,%eax
   1174c:	eb 05                	jmp    11753 <task_time_tick+0x92>
   1174e:	b8 00 00 00 00       	mov    $0x0,%eax
   11753:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(--task->sleep_ticks==0){
   11756:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11759:	8b 40 14             	mov    0x14(%eax),%eax
   1175c:	8d 50 ff             	lea    -0x1(%eax),%edx
   1175f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11762:	89 50 14             	mov    %edx,0x14(%eax)
   11765:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11768:	8b 40 14             	mov    0x14(%eax),%eax
   1176b:	85 c0                	test   %eax,%eax
   1176d:	75 1c                	jne    1178b <task_time_tick+0xca>
            task_set_wakeup(task);
   1176f:	83 ec 0c             	sub    $0xc,%esp
   11772:	ff 75 e4             	pushl  -0x1c(%ebp)
   11775:	e8 6f 00 00 00       	call   117e9 <task_set_wakeup>
   1177a:	83 c4 10             	add    $0x10,%esp
            task_set_ready(task);
   1177d:	83 ec 0c             	sub    $0xc,%esp
   11780:	ff 75 e4             	pushl  -0x1c(%ebp)
   11783:	e8 cb fd ff ff       	call   11553 <task_set_ready>
   11788:	83 c4 10             	add    $0x10,%esp
        }
        curr=next;
   1178b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1178e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(curr){
   11791:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11795:	75 96                	jne    1172d <task_time_tick+0x6c>
    }
    task_dispatch();
   11797:	e8 ca fe ff ff       	call   11666 <task_dispatch>
    irq_leave_protection(state);
   1179c:	83 ec 0c             	sub    $0xc,%esp
   1179f:	ff 75 f0             	pushl  -0x10(%ebp)
   117a2:	e8 75 17 00 00       	call   12f1c <irq_leave_protection>
   117a7:	83 c4 10             	add    $0x10,%esp
}
   117aa:	90                   	nop
   117ab:	c9                   	leave  
   117ac:	c3                   	ret    

000117ad <task_set_sleep>:

void task_set_sleep(task_t* task,uint32_t ticks){
   117ad:	55                   	push   %ebp
   117ae:	89 e5                	mov    %esp,%ebp
   117b0:	83 ec 08             	sub    $0x8,%esp
    if(ticks==0){
   117b3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   117b7:	74 2d                	je     117e6 <task_set_sleep+0x39>
        return;
    }
    task->sleep_ticks=ticks;
   117b9:	8b 55 0c             	mov    0xc(%ebp),%edx
   117bc:	8b 45 08             	mov    0x8(%ebp),%eax
   117bf:	89 50 14             	mov    %edx,0x14(%eax)
    task->state=TASK_SLEEP;
   117c2:	8b 45 08             	mov    0x8(%ebp),%eax
   117c5:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    list_insert_last(&task_manager.sleep_list,&task->run_node);
   117cb:	8b 45 08             	mov    0x8(%ebp),%eax
   117ce:	05 40 02 00 00       	add    $0x240,%eax
   117d3:	83 ec 08             	sub    $0x8,%esp
   117d6:	50                   	push   %eax
   117d7:	68 1c d0 01 00       	push   $0x1d01c
   117dc:	e8 5a 6b 00 00       	call   1833b <list_insert_last>
   117e1:	83 c4 10             	add    $0x10,%esp
   117e4:	eb 01                	jmp    117e7 <task_set_sleep+0x3a>
        return;
   117e6:	90                   	nop
}
   117e7:	c9                   	leave  
   117e8:	c3                   	ret    

000117e9 <task_set_wakeup>:

void task_set_wakeup(task_t* task){
   117e9:	55                   	push   %ebp
   117ea:	89 e5                	mov    %esp,%ebp
   117ec:	83 ec 08             	sub    $0x8,%esp
    list_remove(&task_manager.sleep_list,&task->run_node);
   117ef:	8b 45 08             	mov    0x8(%ebp),%eax
   117f2:	05 40 02 00 00       	add    $0x240,%eax
   117f7:	83 ec 08             	sub    $0x8,%esp
   117fa:	50                   	push   %eax
   117fb:	68 1c d0 01 00       	push   $0x1d01c
   11800:	e8 12 6c 00 00       	call   18417 <list_remove>
   11805:	83 c4 10             	add    $0x10,%esp
}
   11808:	90                   	nop
   11809:	c9                   	leave  
   1180a:	c3                   	ret    

0001180b <sys_msleep>:

void sys_msleep (uint32_t ms) {
   1180b:	55                   	push   %ebp
   1180c:	89 e5                	mov    %esp,%ebp
   1180e:	83 ec 18             	sub    $0x18,%esp
    if (ms < OS_TICK_MS) {
   11811:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
   11815:	77 07                	ja     1181e <sys_msleep+0x13>
        ms = OS_TICK_MS;
   11817:	c7 45 08 0a 00 00 00 	movl   $0xa,0x8(%ebp)
    }

    irq_state_t state = irq_enter_protection();
   1181e:	e8 e1 16 00 00       	call   12f04 <irq_enter_protection>
   11823:	89 45 f4             	mov    %eax,-0xc(%ebp)

    task_set_block(task_manager.curr_task);
   11826:	a1 00 d0 01 00       	mov    0x1d000,%eax
   1182b:	83 ec 0c             	sub    $0xc,%esp
   1182e:	50                   	push   %eax
   1182f:	e8 55 fd ff ff       	call   11589 <task_set_block>
   11834:	83 c4 10             	add    $0x10,%esp
    task_set_sleep(task_manager.curr_task, (ms + (OS_TICK_MS - 1))/ OS_TICK_MS);
   11837:	8b 45 08             	mov    0x8(%ebp),%eax
   1183a:	83 c0 09             	add    $0x9,%eax
   1183d:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
   11842:	f7 e2                	mul    %edx
   11844:	c1 ea 03             	shr    $0x3,%edx
   11847:	a1 00 d0 01 00       	mov    0x1d000,%eax
   1184c:	83 ec 08             	sub    $0x8,%esp
   1184f:	52                   	push   %edx
   11850:	50                   	push   %eax
   11851:	e8 57 ff ff ff       	call   117ad <task_set_sleep>
   11856:	83 c4 10             	add    $0x10,%esp
    
    task_dispatch();
   11859:	e8 08 fe ff ff       	call   11666 <task_dispatch>

    irq_leave_protection(state);
   1185e:	83 ec 0c             	sub    $0xc,%esp
   11861:	ff 75 f4             	pushl  -0xc(%ebp)
   11864:	e8 b3 16 00 00       	call   12f1c <irq_leave_protection>
   11869:	83 c4 10             	add    $0x10,%esp
}
   1186c:	90                   	nop
   1186d:	c9                   	leave  
   1186e:	c3                   	ret    

0001186f <sys_getpid>:

int sys_getpid(void){
   1186f:	55                   	push   %ebp
   11870:	89 e5                	mov    %esp,%ebp
   11872:	83 ec 10             	sub    $0x10,%esp
    task_t* task=task_current();
   11875:	e8 81 fd ff ff       	call   115fb <task_current>
   1187a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return task->pid;
   1187d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11880:	8b 40 04             	mov    0x4(%eax),%eax
}
   11883:	c9                   	leave  
   11884:	c3                   	ret    

00011885 <alloc_task>:

static task_t* alloc_task(void){
   11885:	55                   	push   %ebp
   11886:	89 e5                	mov    %esp,%ebp
   11888:	83 ec 18             	sub    $0x18,%esp
    task_t* task=(task_t*)0;
   1188b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    mutex_lock(&table_mutex);
   11892:	83 ec 0c             	sub    $0xc,%esp
   11895:	68 c0 49 03 00       	push   $0x349c0
   1189a:	e8 3f 5f 00 00       	call   177de <mutex_lock>
   1189f:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<TASK_NR;i++){
   118a2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   118a9:	eb 27                	jmp    118d2 <alloc_task+0x4d>
        task_t* curr=task_table+i;
   118ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
   118ae:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   118b4:	05 c0 e5 01 00       	add    $0x1e5c0,%eax
   118b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(curr->pid==0){
   118bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   118bf:	8b 40 04             	mov    0x4(%eax),%eax
   118c2:	85 c0                	test   %eax,%eax
   118c4:	75 08                	jne    118ce <alloc_task+0x49>
            task=curr;
   118c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   118c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
   118cc:	eb 0a                	jmp    118d8 <alloc_task+0x53>
    for(int i=0;i<TASK_NR;i++){
   118ce:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   118d2:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
   118d6:	7e d3                	jle    118ab <alloc_task+0x26>
        }
    }   
    mutex_unlock(&table_mutex);
   118d8:	83 ec 0c             	sub    $0xc,%esp
   118db:	68 c0 49 03 00       	push   $0x349c0
   118e0:	e8 88 5f 00 00       	call   1786d <mutex_unlock>
   118e5:	83 c4 10             	add    $0x10,%esp

    return task;
   118e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   118eb:	c9                   	leave  
   118ec:	c3                   	ret    

000118ed <free_task>:

static void free_task(task_t* task){
   118ed:	55                   	push   %ebp
   118ee:	89 e5                	mov    %esp,%ebp
   118f0:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&table_mutex);
   118f3:	83 ec 0c             	sub    $0xc,%esp
   118f6:	68 c0 49 03 00       	push   $0x349c0
   118fb:	e8 de 5e 00 00       	call   177de <mutex_lock>
   11900:	83 c4 10             	add    $0x10,%esp
    task->pid=0;
   11903:	8b 45 08             	mov    0x8(%ebp),%eax
   11906:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    mutex_unlock(&table_mutex);
   1190d:	83 ec 0c             	sub    $0xc,%esp
   11910:	68 c0 49 03 00       	push   $0x349c0
   11915:	e8 53 5f 00 00       	call   1786d <mutex_unlock>
   1191a:	83 c4 10             	add    $0x10,%esp
}
   1191d:	90                   	nop
   1191e:	c9                   	leave  
   1191f:	c3                   	ret    

00011920 <copy_opened_files>:

/**
 * @brief 复制父进程打开的文件到子进程
 * @param child_task 子进程
 */
static void copy_opened_files(task_t* child_task){
   11920:	55                   	push   %ebp
   11921:	89 e5                	mov    %esp,%ebp
   11923:	83 ec 18             	sub    $0x18,%esp
    task_t* parent=task_current();
   11926:	e8 d0 fc ff ff       	call   115fb <task_current>
   1192b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(int i=0;i<TASK_OFILE_NR;i++){
   1192e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11935:	eb 36                	jmp    1196d <copy_opened_files+0x4d>

        file_t* file=parent->file_table[i];
   11937:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1193a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1193d:	83 c2 10             	add    $0x10,%edx
   11940:	8b 04 90             	mov    (%eax,%edx,4),%eax
   11943:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(file){
   11946:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1194a:	74 1d                	je     11969 <copy_opened_files+0x49>
            file_inc_ref(file);
   1194c:	83 ec 0c             	sub    $0xc,%esp
   1194f:	ff 75 ec             	pushl  -0x14(%ebp)
   11952:	e8 d5 50 00 00       	call   16a2c <file_inc_ref>
   11957:	83 c4 10             	add    $0x10,%esp
            child_task->file_table[i]=file;
   1195a:	8b 45 08             	mov    0x8(%ebp),%eax
   1195d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11960:	8d 4a 10             	lea    0x10(%edx),%ecx
   11963:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11966:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    for(int i=0;i<TASK_OFILE_NR;i++){
   11969:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1196d:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   11971:	7e c4                	jle    11937 <copy_opened_files+0x17>
        }
    }
}
   11973:	90                   	nop
   11974:	c9                   	leave  
   11975:	c3                   	ret    

00011976 <sys_fork>:

/**
 * @brief 创建一个新的任务
 */
int sys_fork(void){
   11976:	55                   	push   %ebp
   11977:	89 e5                	mov    %esp,%ebp
   11979:	83 ec 28             	sub    $0x28,%esp
    task_t* parent_task=task_current();
   1197c:	e8 7a fc ff ff       	call   115fb <task_current>
   11981:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* child_task=alloc_task();
   11984:	e8 fc fe ff ff       	call   11885 <alloc_task>
   11989:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(child_task==(task_t*)0){
   1198c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11990:	0f 84 32 01 00 00    	je     11ac8 <sys_fork+0x152>
        goto fork_failed;
    }

    syscall_frame_t* frame=(syscall_frame_t*)(parent_task->tss.esp0-sizeof(syscall_frame_t));
   11996:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11999:	8b 80 5c 02 00 00    	mov    0x25c(%eax),%eax
   1199f:	83 e8 58             	sub    $0x58,%eax
   119a2:	89 45 ec             	mov    %eax,-0x14(%ebp)
    int err=task_init(child_task,parent_task->name,0,frame->eip,frame->esp+sizeof(uint32_t)*SYSCALL_PARAM_COUNT);
   119a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119a8:	8b 40 50             	mov    0x50(%eax),%eax
   119ab:	8d 48 14             	lea    0x14(%eax),%ecx
   119ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119b1:	8b 40 34             	mov    0x34(%eax),%eax
   119b4:	8b 55 f4             	mov    -0xc(%ebp),%edx
   119b7:	83 c2 20             	add    $0x20,%edx
   119ba:	83 ec 0c             	sub    $0xc,%esp
   119bd:	51                   	push   %ecx
   119be:	50                   	push   %eax
   119bf:	6a 00                	push   $0x0
   119c1:	52                   	push   %edx
   119c2:	ff 75 f0             	pushl  -0x10(%ebp)
   119c5:	e8 78 f7 ff ff       	call   11142 <task_init>
   119ca:	83 c4 20             	add    $0x20,%esp
   119cd:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(err < 0){
   119d0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   119d4:	0f 88 f1 00 00 00    	js     11acb <sys_fork+0x155>
        goto fork_failed;
    }

    copy_opened_files(child_task);
   119da:	83 ec 0c             	sub    $0xc,%esp
   119dd:	ff 75 f0             	pushl  -0x10(%ebp)
   119e0:	e8 3b ff ff ff       	call   11920 <copy_opened_files>
   119e5:	83 c4 10             	add    $0x10,%esp

    tss_t* tss=&child_task->tss;
   119e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   119eb:	05 58 02 00 00       	add    $0x258,%eax
   119f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tss->eax= 0;
   119f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119f6:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
    tss->ebx=frame->ebx;
   119fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a00:	8b 50 24             	mov    0x24(%eax),%edx
   11a03:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a06:	89 50 34             	mov    %edx,0x34(%eax)
    tss->ecx=frame->ecx;
   11a09:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a0c:	8b 50 2c             	mov    0x2c(%eax),%edx
   11a0f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a12:	89 50 2c             	mov    %edx,0x2c(%eax)
    tss->edx=frame->edx;
   11a15:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a18:	8b 50 28             	mov    0x28(%eax),%edx
   11a1b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a1e:	89 50 30             	mov    %edx,0x30(%eax)
    tss->esi=frame->esi;
   11a21:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a24:	8b 50 18             	mov    0x18(%eax),%edx
   11a27:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a2a:	89 50 40             	mov    %edx,0x40(%eax)
    tss->edi=frame->edi;
   11a2d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a30:	8b 50 14             	mov    0x14(%eax),%edx
   11a33:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a36:	89 50 44             	mov    %edx,0x44(%eax)
    tss->ebp=frame->ebp;
   11a39:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a3c:	8b 50 1c             	mov    0x1c(%eax),%edx
   11a3f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a42:	89 50 3c             	mov    %edx,0x3c(%eax)

    tss->cs=frame->cs;
   11a45:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a48:	8b 50 38             	mov    0x38(%eax),%edx
   11a4b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a4e:	89 50 4c             	mov    %edx,0x4c(%eax)
    tss->ds=frame->ds;
   11a51:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a54:	8b 50 10             	mov    0x10(%eax),%edx
   11a57:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a5a:	89 50 54             	mov    %edx,0x54(%eax)
    tss->es=frame->es;
   11a5d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a60:	8b 50 0c             	mov    0xc(%eax),%edx
   11a63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a66:	89 50 48             	mov    %edx,0x48(%eax)
    tss->fs=frame->fs;
   11a69:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a6c:	8b 50 08             	mov    0x8(%eax),%edx
   11a6f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a72:	89 50 58             	mov    %edx,0x58(%eax)
    tss->gs=frame->gs;
   11a75:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a78:	8b 50 04             	mov    0x4(%eax),%edx
   11a7b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a7e:	89 50 5c             	mov    %edx,0x5c(%eax)
    tss->eflags=frame->eflags;
   11a81:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a84:	8b 10                	mov    (%eax),%edx
   11a86:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a89:	89 50 24             	mov    %edx,0x24(%eax)

    child_task->parent=parent_task;
   11a8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a8f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a92:	89 50 08             	mov    %edx,0x8(%eax)

    if((tss->cr3=memory_copy_uvm(parent_task->tss.cr3))<0){
   11a95:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a98:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   11a9e:	83 ec 0c             	sub    $0xc,%esp
   11aa1:	50                   	push   %eax
   11aa2:	e8 51 f0 ff ff       	call   10af8 <memory_copy_uvm>
   11aa7:	83 c4 10             	add    $0x10,%esp
   11aaa:	89 c2                	mov    %eax,%edx
   11aac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11aaf:	89 50 1c             	mov    %edx,0x1c(%eax)
        goto fork_failed;
    }

    task_start(child_task);
   11ab2:	83 ec 0c             	sub    $0xc,%esp
   11ab5:	ff 75 f0             	pushl  -0x10(%ebp)
   11ab8:	e8 de f7 ff ff       	call   1129b <task_start>
   11abd:	83 c4 10             	add    $0x10,%esp

    return child_task->pid;
   11ac0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ac3:	8b 40 04             	mov    0x4(%eax),%eax
   11ac6:	eb 2b                	jmp    11af3 <sys_fork+0x17d>
        goto fork_failed;
   11ac8:	90                   	nop
   11ac9:	eb 01                	jmp    11acc <sys_fork+0x156>
        goto fork_failed;
   11acb:	90                   	nop

fork_failed:
    if(child_task){
   11acc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11ad0:	74 1c                	je     11aee <sys_fork+0x178>
        task_uninit(child_task);
   11ad2:	83 ec 0c             	sub    $0xc,%esp
   11ad5:	ff 75 f0             	pushl  -0x10(%ebp)
   11ad8:	e8 eb f7 ff ff       	call   112c8 <task_uninit>
   11add:	83 c4 10             	add    $0x10,%esp
        free_task(child_task);
   11ae0:	83 ec 0c             	sub    $0xc,%esp
   11ae3:	ff 75 f0             	pushl  -0x10(%ebp)
   11ae6:	e8 02 fe ff ff       	call   118ed <free_task>
   11aeb:	83 c4 10             	add    $0x10,%esp
    }

    return -1;
   11aee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11af3:	c9                   	leave  
   11af4:	c3                   	ret    

00011af5 <load_phdr>:

static int load_phdr(int file,Elf32_Phdr*phdr ,uint32_t page_dir){
   11af5:	55                   	push   %ebp
   11af6:	89 e5                	mov    %esp,%ebp
   11af8:	83 ec 28             	sub    $0x28,%esp
    int err=memory_alloc_for_page_dir(page_dir,phdr->p_vaddr,phdr->p_memsz,PTE_P|PTE_U|PTE_W);
   11afb:	8b 45 0c             	mov    0xc(%ebp),%eax
   11afe:	8b 50 14             	mov    0x14(%eax),%edx
   11b01:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b04:	8b 40 08             	mov    0x8(%eax),%eax
   11b07:	6a 07                	push   $0x7
   11b09:	52                   	push   %edx
   11b0a:	50                   	push   %eax
   11b0b:	ff 75 10             	pushl  0x10(%ebp)
   11b0e:	e8 59 ed ff ff       	call   1086c <memory_alloc_for_page_dir>
   11b13:	83 c4 10             	add    $0x10,%esp
   11b16:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(err < 0){
   11b19:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11b1d:	79 1a                	jns    11b39 <load_phdr+0x44>
        log_printf("no memory");
   11b1f:	83 ec 0c             	sub    $0xc,%esp
   11b22:	68 49 89 01 00       	push   $0x18949
   11b27:	e8 9f 69 00 00       	call   184cb <log_printf>
   11b2c:	83 c4 10             	add    $0x10,%esp
        return -1;
   11b2f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11b34:	e9 b8 00 00 00       	jmp    11bf1 <load_phdr+0xfc>
    }

    if(sys_lseek(file,phdr->p_offset,0)<0){
   11b39:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b3c:	8b 40 04             	mov    0x4(%eax),%eax
   11b3f:	83 ec 04             	sub    $0x4,%esp
   11b42:	6a 00                	push   $0x0
   11b44:	50                   	push   %eax
   11b45:	ff 75 08             	pushl  0x8(%ebp)
   11b48:	e8 bf 53 00 00       	call   16f0c <sys_lseek>
   11b4d:	83 c4 10             	add    $0x10,%esp
   11b50:	85 c0                	test   %eax,%eax
   11b52:	79 1a                	jns    11b6e <load_phdr+0x79>
        log_printf("read file failed");
   11b54:	83 ec 0c             	sub    $0xc,%esp
   11b57:	68 53 89 01 00       	push   $0x18953
   11b5c:	e8 6a 69 00 00       	call   184cb <log_printf>
   11b61:	83 c4 10             	add    $0x10,%esp
        return -1;
   11b64:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11b69:	e9 83 00 00 00       	jmp    11bf1 <load_phdr+0xfc>
    }

    uint32_t vaddr=phdr->p_vaddr;
   11b6e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b71:	8b 40 08             	mov    0x8(%eax),%eax
   11b74:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t size=phdr->p_filesz;
   11b77:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b7a:	8b 40 10             	mov    0x10(%eax),%eax
   11b7d:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while(size > 0){
   11b80:	eb 64                	jmp    11be6 <load_phdr+0xf1>
        int curr_size=(size > MEM_PAGE_SIZE) ? MEM_PAGE_SIZE : size;
   11b82:	b8 00 10 00 00       	mov    $0x1000,%eax
   11b87:	81 7d f0 00 10 00 00 	cmpl   $0x1000,-0x10(%ebp)
   11b8e:	0f 46 45 f0          	cmovbe -0x10(%ebp),%eax
   11b92:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t paddr=memory_get_paddr(page_dir,vaddr);
   11b95:	83 ec 08             	sub    $0x8,%esp
   11b98:	ff 75 f4             	pushl  -0xc(%ebp)
   11b9b:	ff 75 10             	pushl  0x10(%ebp)
   11b9e:	e8 aa f0 ff ff       	call   10c4d <memory_get_paddr>
   11ba3:	83 c4 10             	add    $0x10,%esp
   11ba6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if(sys_read(file,(char*)paddr,curr_size)<curr_size){
   11ba9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11bac:	83 ec 04             	sub    $0x4,%esp
   11baf:	ff 75 e8             	pushl  -0x18(%ebp)
   11bb2:	50                   	push   %eax
   11bb3:	ff 75 08             	pushl  0x8(%ebp)
   11bb6:	e8 c8 51 00 00       	call   16d83 <sys_read>
   11bbb:	83 c4 10             	add    $0x10,%esp
   11bbe:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   11bc1:	7e 17                	jle    11bda <load_phdr+0xe5>
            log_printf("read file failed.");
   11bc3:	83 ec 0c             	sub    $0xc,%esp
   11bc6:	68 64 89 01 00       	push   $0x18964
   11bcb:	e8 fb 68 00 00       	call   184cb <log_printf>
   11bd0:	83 c4 10             	add    $0x10,%esp
            return -1;
   11bd3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11bd8:	eb 17                	jmp    11bf1 <load_phdr+0xfc>
        }

        size-=curr_size;
   11bda:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11bdd:	29 45 f0             	sub    %eax,-0x10(%ebp)
        vaddr+=curr_size;
   11be0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11be3:	01 45 f4             	add    %eax,-0xc(%ebp)
    while(size > 0){
   11be6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11bea:	75 96                	jne    11b82 <load_phdr+0x8d>
    }

    return 0;
   11bec:	b8 00 00 00 00       	mov    $0x0,%eax

}
   11bf1:	c9                   	leave  
   11bf2:	c3                   	ret    

00011bf3 <load_elf_file>:

static uint32_t load_elf_file(task_t* task,const char* name,uint32_t page_dir){
   11bf3:	55                   	push   %ebp
   11bf4:	89 e5                	mov    %esp,%ebp
   11bf6:	83 ec 78             	sub    $0x78,%esp
    Elf32_Ehdr elf_hdr;
    Elf32_Phdr elf_phdr;

    int file=sys_open(name,0);
   11bf9:	83 ec 08             	sub    $0x8,%esp
   11bfc:	6a 00                	push   $0x0
   11bfe:	ff 75 0c             	pushl  0xc(%ebp)
   11c01:	e8 00 50 00 00       	call   16c06 <sys_open>
   11c06:	83 c4 10             	add    $0x10,%esp
   11c09:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(file<0){
   11c0c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11c10:	79 18                	jns    11c2a <load_elf_file+0x37>
        log_printf("open failed. %s",name);
   11c12:	83 ec 08             	sub    $0x8,%esp
   11c15:	ff 75 0c             	pushl  0xc(%ebp)
   11c18:	68 76 89 01 00       	push   $0x18976
   11c1d:	e8 a9 68 00 00       	call   184cb <log_printf>
   11c22:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11c25:	e9 6c 01 00 00       	jmp    11d96 <load_elf_file+0x1a3>
    }

    int cnt=sys_read(file,(char*)&elf_hdr,sizeof(elf_hdr));
   11c2a:	83 ec 04             	sub    $0x4,%esp
   11c2d:	6a 34                	push   $0x34
   11c2f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   11c32:	50                   	push   %eax
   11c33:	ff 75 ec             	pushl  -0x14(%ebp)
   11c36:	e8 48 51 00 00       	call   16d83 <sys_read>
   11c3b:	83 c4 10             	add    $0x10,%esp
   11c3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(cnt<sizeof(Elf32_Ehdr)){
   11c41:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11c44:	83 f8 33             	cmp    $0x33,%eax
   11c47:	77 18                	ja     11c61 <load_elf_file+0x6e>
        log_printf("elf hdr too small. size=%d",cnt);
   11c49:	83 ec 08             	sub    $0x8,%esp
   11c4c:	ff 75 e8             	pushl  -0x18(%ebp)
   11c4f:	68 86 89 01 00       	push   $0x18986
   11c54:	e8 72 68 00 00       	call   184cb <log_printf>
   11c59:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11c5c:	e9 35 01 00 00       	jmp    11d96 <load_elf_file+0x1a3>
    }

    if((elf_hdr.e_ident[0]!=0x7f)||(elf_hdr.e_ident[1]!='E')
   11c61:	0f b6 45 b0          	movzbl -0x50(%ebp),%eax
   11c65:	3c 7f                	cmp    $0x7f,%al
   11c67:	75 18                	jne    11c81 <load_elf_file+0x8e>
   11c69:	0f b6 45 b1          	movzbl -0x4f(%ebp),%eax
   11c6d:	3c 45                	cmp    $0x45,%al
   11c6f:	75 10                	jne    11c81 <load_elf_file+0x8e>
		|| (elf_hdr.e_ident[2]!='L')||(elf_hdr.e_ident[3]!='F')){
   11c71:	0f b6 45 b2          	movzbl -0x4e(%ebp),%eax
   11c75:	3c 4c                	cmp    $0x4c,%al
   11c77:	75 08                	jne    11c81 <load_elf_file+0x8e>
   11c79:	0f b6 45 b3          	movzbl -0x4d(%ebp),%eax
   11c7d:	3c 46                	cmp    $0x46,%al
   11c7f:	74 15                	je     11c96 <load_elf_file+0xa3>
            log_printf("check elf ident failed.");
   11c81:	83 ec 0c             	sub    $0xc,%esp
   11c84:	68 a1 89 01 00       	push   $0x189a1
   11c89:	e8 3d 68 00 00       	call   184cb <log_printf>
   11c8e:	83 c4 10             	add    $0x10,%esp
			goto load_failed;
   11c91:	e9 00 01 00 00       	jmp    11d96 <load_elf_file+0x1a3>
	}

    uint32_t e_phoff=elf_hdr.e_phoff;
   11c96:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11c99:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(int i=0;i<elf_hdr.e_phnum;i++,e_phoff+=elf_hdr.e_phentsize){
   11c9c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11ca3:	e9 cb 00 00 00       	jmp    11d73 <load_elf_file+0x180>
        if(sys_lseek(file,e_phoff,0)<0){
   11ca8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11cab:	83 ec 04             	sub    $0x4,%esp
   11cae:	6a 00                	push   $0x0
   11cb0:	50                   	push   %eax
   11cb1:	ff 75 ec             	pushl  -0x14(%ebp)
   11cb4:	e8 53 52 00 00       	call   16f0c <sys_lseek>
   11cb9:	83 c4 10             	add    $0x10,%esp
   11cbc:	85 c0                	test   %eax,%eax
   11cbe:	79 15                	jns    11cd5 <load_elf_file+0xe2>
            log_printf("read file failed.");
   11cc0:	83 ec 0c             	sub    $0xc,%esp
   11cc3:	68 64 89 01 00       	push   $0x18964
   11cc8:	e8 fe 67 00 00       	call   184cb <log_printf>
   11ccd:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11cd0:	e9 c1 00 00 00       	jmp    11d96 <load_elf_file+0x1a3>
        }

        cnt=sys_read(file,(char*)&elf_phdr,sizeof(elf_phdr));
   11cd5:	83 ec 04             	sub    $0x4,%esp
   11cd8:	6a 20                	push   $0x20
   11cda:	8d 45 90             	lea    -0x70(%ebp),%eax
   11cdd:	50                   	push   %eax
   11cde:	ff 75 ec             	pushl  -0x14(%ebp)
   11ce1:	e8 9d 50 00 00       	call   16d83 <sys_read>
   11ce6:	83 c4 10             	add    $0x10,%esp
   11ce9:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(cnt<sizeof(elf_phdr)){
   11cec:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11cef:	83 f8 1f             	cmp    $0x1f,%eax
   11cf2:	77 15                	ja     11d09 <load_elf_file+0x116>
            log_printf("read file failed.");
   11cf4:	83 ec 0c             	sub    $0xc,%esp
   11cf7:	68 64 89 01 00       	push   $0x18964
   11cfc:	e8 ca 67 00 00       	call   184cb <log_printf>
   11d01:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11d04:	e9 8d 00 00 00       	jmp    11d96 <load_elf_file+0x1a3>
        }

        if((elf_phdr.p_type!=1)|| (elf_phdr.p_vaddr<MEMORY_TASK_BASE)){
   11d09:	8b 45 90             	mov    -0x70(%ebp),%eax
   11d0c:	83 f8 01             	cmp    $0x1,%eax
   11d0f:	75 53                	jne    11d64 <load_elf_file+0x171>
   11d11:	8b 45 98             	mov    -0x68(%ebp),%eax
   11d14:	85 c0                	test   %eax,%eax
   11d16:	79 4c                	jns    11d64 <load_elf_file+0x171>
            continue;
        }

        int err=load_phdr(file,&elf_phdr,page_dir);
   11d18:	83 ec 04             	sub    $0x4,%esp
   11d1b:	ff 75 10             	pushl  0x10(%ebp)
   11d1e:	8d 45 90             	lea    -0x70(%ebp),%eax
   11d21:	50                   	push   %eax
   11d22:	ff 75 ec             	pushl  -0x14(%ebp)
   11d25:	e8 cb fd ff ff       	call   11af5 <load_phdr>
   11d2a:	83 c4 10             	add    $0x10,%esp
   11d2d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(err<0){
   11d30:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   11d34:	79 12                	jns    11d48 <load_elf_file+0x155>
            log_printf("load program failed.");
   11d36:	83 ec 0c             	sub    $0xc,%esp
   11d39:	68 b9 89 01 00       	push   $0x189b9
   11d3e:	e8 88 67 00 00       	call   184cb <log_printf>
   11d43:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11d46:	eb 4e                	jmp    11d96 <load_elf_file+0x1a3>
        }

        task->heap_start=elf_phdr.p_vaddr+elf_phdr.p_memsz;
   11d48:	8b 55 98             	mov    -0x68(%ebp),%edx
   11d4b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
   11d4e:	01 c2                	add    %eax,%edx
   11d50:	8b 45 08             	mov    0x8(%ebp),%eax
   11d53:	89 50 0c             	mov    %edx,0xc(%eax)
        task->heap_end=task->heap_start;
   11d56:	8b 45 08             	mov    0x8(%ebp),%eax
   11d59:	8b 50 0c             	mov    0xc(%eax),%edx
   11d5c:	8b 45 08             	mov    0x8(%ebp),%eax
   11d5f:	89 50 10             	mov    %edx,0x10(%eax)
   11d62:	eb 01                	jmp    11d65 <load_elf_file+0x172>
            continue;
   11d64:	90                   	nop
    for(int i=0;i<elf_hdr.e_phnum;i++,e_phoff+=elf_hdr.e_phentsize){
   11d65:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d69:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
   11d6d:	0f b7 c0             	movzwl %ax,%eax
   11d70:	01 45 f4             	add    %eax,-0xc(%ebp)
   11d73:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
   11d77:	0f b7 c0             	movzwl %ax,%eax
   11d7a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11d7d:	0f 8c 25 ff ff ff    	jl     11ca8 <load_elf_file+0xb5>
    }


    sys_close(file);
   11d83:	83 ec 0c             	sub    $0xc,%esp
   11d86:	ff 75 ec             	pushl  -0x14(%ebp)
   11d89:	e8 13 52 00 00       	call   16fa1 <sys_close>
   11d8e:	83 c4 10             	add    $0x10,%esp
    return elf_hdr.e_entry;
   11d91:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11d94:	eb 19                	jmp    11daf <load_elf_file+0x1bc>

load_failed:
    if(file){
   11d96:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11d9a:	74 0e                	je     11daa <load_elf_file+0x1b7>
        sys_close(file);
   11d9c:	83 ec 0c             	sub    $0xc,%esp
   11d9f:	ff 75 ec             	pushl  -0x14(%ebp)
   11da2:	e8 fa 51 00 00       	call   16fa1 <sys_close>
   11da7:	83 c4 10             	add    $0x10,%esp
    }
    return 0;
   11daa:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11daf:	c9                   	leave  
   11db0:	c3                   	ret    

00011db1 <copy_args>:

static int copy_args(char* to,uint32_t page_dir,int argc,char**argv){
   11db1:	55                   	push   %ebp
   11db2:	89 e5                	mov    %esp,%ebp
   11db4:	83 ec 38             	sub    $0x38,%esp
    task_args_t task_args;
    task_args.argc=argc;
   11db7:	8b 45 10             	mov    0x10(%ebp),%eax
   11dba:	89 45 d8             	mov    %eax,-0x28(%ebp)
    task_args.argv=(char**)(to+sizeof(task_args_t));
   11dbd:	8b 45 08             	mov    0x8(%ebp),%eax
   11dc0:	83 c0 0c             	add    $0xc,%eax
   11dc3:	89 45 dc             	mov    %eax,-0x24(%ebp)

    char* dest_arg=to+sizeof(task_args_t)+sizeof(char*)*argc;
   11dc6:	8b 45 10             	mov    0x10(%ebp),%eax
   11dc9:	83 c0 03             	add    $0x3,%eax
   11dcc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11dd3:	8b 45 08             	mov    0x8(%ebp),%eax
   11dd6:	01 d0                	add    %edx,%eax
   11dd8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char** dest_argv_tb=(char**)memory_get_paddr(page_dir,(uint32_t)(to+sizeof(task_args_t)));
   11ddb:	8b 45 08             	mov    0x8(%ebp),%eax
   11dde:	83 c0 0c             	add    $0xc,%eax
   11de1:	83 ec 08             	sub    $0x8,%esp
   11de4:	50                   	push   %eax
   11de5:	ff 75 0c             	pushl  0xc(%ebp)
   11de8:	e8 60 ee ff ff       	call   10c4d <memory_get_paddr>
   11ded:	83 c4 10             	add    $0x10,%esp
   11df0:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for(int i=0;i<argc;i++){
   11df3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11dfa:	e9 82 00 00 00       	jmp    11e81 <copy_args+0xd0>
        char* from=argv[i];
   11dff:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e02:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11e09:	8b 45 14             	mov    0x14(%ebp),%eax
   11e0c:	01 d0                	add    %edx,%eax
   11e0e:	8b 00                	mov    (%eax),%eax
   11e10:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int len=kernel_strlen(from)+1;
   11e13:	83 ec 0c             	sub    $0xc,%esp
   11e16:	ff 75 e8             	pushl  -0x18(%ebp)
   11e19:	e8 00 60 00 00       	call   17e1e <kernel_strlen>
   11e1e:	83 c4 10             	add    $0x10,%esp
   11e21:	83 c0 01             	add    $0x1,%eax
   11e24:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int err=memory_copy_uvm_data((uint32_t)dest_arg,page_dir,(uint32_t)from,len);
   11e27:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   11e2a:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11e2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e30:	51                   	push   %ecx
   11e31:	52                   	push   %edx
   11e32:	ff 75 0c             	pushl  0xc(%ebp)
   11e35:	50                   	push   %eax
   11e36:	e8 58 ee ff ff       	call   10c93 <memory_copy_uvm_data>
   11e3b:	83 c4 10             	add    $0x10,%esp
   11e3e:	89 45 e0             	mov    %eax,-0x20(%ebp)
        ASSERT(err >= 0);
   11e41:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11e45:	79 1c                	jns    11e63 <copy_args+0xb2>
   11e47:	68 ce 89 01 00       	push   $0x189ce
   11e4c:	68 f4 89 01 00       	push   $0x189f4
   11e51:	68 10 02 00 00       	push   $0x210
   11e56:	68 d8 88 01 00       	push   $0x188d8
   11e5b:	e8 9b 63 00 00       	call   181fb <panic>
   11e60:	83 c4 10             	add    $0x10,%esp

        dest_argv_tb[i]=dest_arg;
   11e63:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e66:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11e6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11e70:	01 c2                	add    %eax,%edx
   11e72:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e75:	89 02                	mov    %eax,(%edx)
        dest_arg+=len;
   11e77:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11e7a:	01 45 f4             	add    %eax,-0xc(%ebp)
    for(int i=0;i<argc;i++){
   11e7d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11e81:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e84:	3b 45 10             	cmp    0x10(%ebp),%eax
   11e87:	0f 8c 72 ff ff ff    	jl     11dff <copy_args+0x4e>

    // if(argc > 0){
    //     //dest_argv_tb[argc]='\0';
    // }
    
    return memory_copy_uvm_data((uint32_t)to,page_dir,(uint32_t)&task_args,sizeof(task_args));
   11e8d:	8d 55 d4             	lea    -0x2c(%ebp),%edx
   11e90:	8b 45 08             	mov    0x8(%ebp),%eax
   11e93:	6a 0c                	push   $0xc
   11e95:	52                   	push   %edx
   11e96:	ff 75 0c             	pushl  0xc(%ebp)
   11e99:	50                   	push   %eax
   11e9a:	e8 f4 ed ff ff       	call   10c93 <memory_copy_uvm_data>
   11e9f:	83 c4 10             	add    $0x10,%esp

}
   11ea2:	c9                   	leave  
   11ea3:	c3                   	ret    

00011ea4 <sys_execve>:

int sys_execve(char* name,char** argv,char** env){
   11ea4:	55                   	push   %ebp
   11ea5:	89 e5                	mov    %esp,%ebp
   11ea7:	83 ec 28             	sub    $0x28,%esp
    task_t* task=task_current();
   11eaa:	e8 4c f7 ff ff       	call   115fb <task_current>
   11eaf:	89 45 f4             	mov    %eax,-0xc(%ebp)

    kernel_strncpy(task->name,get_file_name(name),TASK_NAME_SIZE);
   11eb2:	83 ec 0c             	sub    $0xc,%esp
   11eb5:	ff 75 08             	pushl  0x8(%ebp)
   11eb8:	e8 a1 63 00 00       	call   1825e <get_file_name>
   11ebd:	83 c4 10             	add    $0x10,%esp
   11ec0:	89 c2                	mov    %eax,%edx
   11ec2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ec5:	83 c0 20             	add    $0x20,%eax
   11ec8:	83 ec 04             	sub    $0x4,%esp
   11ecb:	6a 20                	push   $0x20
   11ecd:	52                   	push   %edx
   11ece:	50                   	push   %eax
   11ecf:	e8 60 5e 00 00       	call   17d34 <kernel_strncpy>
   11ed4:	83 c4 10             	add    $0x10,%esp

    uint32_t old_page_dir=task->tss.cr3;
   11ed7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11eda:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   11ee0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t new_page_dir=memory_create_uvm();
   11ee3:	e8 ff e8 ff ff       	call   107e7 <memory_create_uvm>
   11ee8:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(!new_page_dir){
   11eeb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11eef:	0f 84 1f 01 00 00    	je     12014 <sys_execve+0x170>
        goto exec_failed;
    }

    uint32_t entry=load_elf_file(task,name,new_page_dir);
   11ef5:	83 ec 04             	sub    $0x4,%esp
   11ef8:	ff 75 ec             	pushl  -0x14(%ebp)
   11efb:	ff 75 08             	pushl  0x8(%ebp)
   11efe:	ff 75 f4             	pushl  -0xc(%ebp)
   11f01:	e8 ed fc ff ff       	call   11bf3 <load_elf_file>
   11f06:	83 c4 10             	add    $0x10,%esp
   11f09:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if(entry==0){
   11f0c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11f10:	0f 84 01 01 00 00    	je     12017 <sys_execve+0x173>
        goto exec_failed;
    }

    uint32_t stack_top=MEM_TASK_STACK_TOP-MEM_TASK_ARG_SIZE;
   11f16:	c7 45 e4 00 c0 ff df 	movl   $0xdfffc000,-0x1c(%ebp)

    int err=memory_alloc_for_page_dir(new_page_dir,
   11f1d:	6a 07                	push   $0x7
   11f1f:	68 00 40 1f 00       	push   $0x1f4000
   11f24:	68 00 c0 e0 df       	push   $0xdfe0c000
   11f29:	ff 75 ec             	pushl  -0x14(%ebp)
   11f2c:	e8 3b e9 ff ff       	call   1086c <memory_alloc_for_page_dir>
   11f31:	83 c4 10             	add    $0x10,%esp
   11f34:	89 45 e0             	mov    %eax,-0x20(%ebp)
        MEM_TASK_STACK_TOP-MEM_TASK_STACK_SIZE,MEM_TASK_STACK_SIZE,
        PTE_P | PTE_U | PTE_W
    );

    if(err < 0){
   11f37:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11f3b:	0f 88 d9 00 00 00    	js     1201a <sys_execve+0x176>
        goto exec_failed;
    }
    
    int argc=string_count(argv);
   11f41:	83 ec 0c             	sub    $0xc,%esp
   11f44:	ff 75 0c             	pushl  0xc(%ebp)
   11f47:	e8 e5 62 00 00       	call   18231 <string_count>
   11f4c:	83 c4 10             	add    $0x10,%esp
   11f4f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    err=copy_args((char*)stack_top,new_page_dir,argc,argv);
   11f52:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11f55:	ff 75 0c             	pushl  0xc(%ebp)
   11f58:	ff 75 dc             	pushl  -0x24(%ebp)
   11f5b:	ff 75 ec             	pushl  -0x14(%ebp)
   11f5e:	50                   	push   %eax
   11f5f:	e8 4d fe ff ff       	call   11db1 <copy_args>
   11f64:	83 c4 10             	add    $0x10,%esp
   11f67:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(err<0){
   11f6a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11f6e:	0f 88 a9 00 00 00    	js     1201d <sys_execve+0x179>
        goto exec_failed;
    }

    syscall_frame_t* frame=(syscall_frame_t*)(task->tss.esp0-sizeof(syscall_frame_t));
   11f74:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f77:	8b 80 5c 02 00 00    	mov    0x25c(%eax),%eax
   11f7d:	83 e8 58             	sub    $0x58,%eax
   11f80:	89 45 d8             	mov    %eax,-0x28(%ebp)
    frame->eip=entry;
   11f83:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f86:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11f89:	89 50 34             	mov    %edx,0x34(%eax)
    frame->eax=frame->ebx=frame->edx=0;
   11f8c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f8f:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
   11f96:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f99:	8b 50 28             	mov    0x28(%eax),%edx
   11f9c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f9f:	89 50 24             	mov    %edx,0x24(%eax)
   11fa2:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11fa5:	8b 50 24             	mov    0x24(%eax),%edx
   11fa8:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11fab:	89 50 30             	mov    %edx,0x30(%eax)
    frame->esi=frame->edi=frame->ebp=0;
   11fae:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11fb1:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
   11fb8:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11fbb:	8b 50 1c             	mov    0x1c(%eax),%edx
   11fbe:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11fc1:	89 50 14             	mov    %edx,0x14(%eax)
   11fc4:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11fc7:	8b 50 14             	mov    0x14(%eax),%edx
   11fca:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11fcd:	89 50 18             	mov    %edx,0x18(%eax)
    frame->eflags=EFLAGS_DEFAULT|EFLAGS_IF;
   11fd0:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11fd3:	c7 00 02 02 00 00    	movl   $0x202,(%eax)

    frame->esp=stack_top-sizeof(uint32_t)*SYSCALL_PARAM_COUNT;
   11fd9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11fdc:	8d 50 ec             	lea    -0x14(%eax),%edx
   11fdf:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11fe2:	89 50 50             	mov    %edx,0x50(%eax)

    task->tss.cr3=new_page_dir;
   11fe5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11fe8:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11feb:	89 90 74 02 00 00    	mov    %edx,0x274(%eax)
    mmu_set_page_dir(new_page_dir);
   11ff1:	83 ec 0c             	sub    $0xc,%esp
   11ff4:	ff 75 ec             	pushl  -0x14(%ebp)
   11ff7:	e8 6d ef ff ff       	call   10f69 <mmu_set_page_dir>
   11ffc:	83 c4 10             	add    $0x10,%esp

    memory_destroy_uvm(old_page_dir);
   11fff:	83 ec 0c             	sub    $0xc,%esp
   12002:	ff 75 f0             	pushl  -0x10(%ebp)
   12005:	e8 07 ea ff ff       	call   10a11 <memory_destroy_uvm>
   1200a:	83 c4 10             	add    $0x10,%esp

    return 0;
   1200d:	b8 00 00 00 00       	mov    $0x0,%eax
   12012:	eb 3d                	jmp    12051 <sys_execve+0x1ad>
        goto exec_failed;
   12014:	90                   	nop
   12015:	eb 07                	jmp    1201e <sys_execve+0x17a>
        goto exec_failed;
   12017:	90                   	nop
   12018:	eb 04                	jmp    1201e <sys_execve+0x17a>
        goto exec_failed;
   1201a:	90                   	nop
   1201b:	eb 01                	jmp    1201e <sys_execve+0x17a>
        goto exec_failed;
   1201d:	90                   	nop

exec_failed:
    if(new_page_dir){
   1201e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   12022:	74 28                	je     1204c <sys_execve+0x1a8>
        task->tss.cr3=old_page_dir;
   12024:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12027:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1202a:	89 90 74 02 00 00    	mov    %edx,0x274(%eax)
        mmu_set_page_dir(old_page_dir);
   12030:	83 ec 0c             	sub    $0xc,%esp
   12033:	ff 75 f0             	pushl  -0x10(%ebp)
   12036:	e8 2e ef ff ff       	call   10f69 <mmu_set_page_dir>
   1203b:	83 c4 10             	add    $0x10,%esp

        memory_destroy_uvm(new_page_dir);
   1203e:	83 ec 0c             	sub    $0xc,%esp
   12041:	ff 75 ec             	pushl  -0x14(%ebp)
   12044:	e8 c8 e9 ff ff       	call   10a11 <memory_destroy_uvm>
   12049:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   1204c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   12051:	c9                   	leave  
   12052:	c3                   	ret    

00012053 <task_file>:
/**
 * @brief 获取文件描述符对应的文件
 * @param fd 文件描述符
 * @return 获取成功返回对应的文件指针，不成功返回NULL
 */
file_t* task_file(int fd){
   12053:	55                   	push   %ebp
   12054:	89 e5                	mov    %esp,%ebp
   12056:	83 ec 10             	sub    $0x10,%esp
    if((fd>=0) && (fd<TASK_OFILE_NR)){
   12059:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1205d:	78 1e                	js     1207d <task_file+0x2a>
   1205f:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   12063:	7f 18                	jg     1207d <task_file+0x2a>
        file_t* file=task_current()->file_table[fd];
   12065:	e8 91 f5 ff ff       	call   115fb <task_current>
   1206a:	89 c2                	mov    %eax,%edx
   1206c:	8b 45 08             	mov    0x8(%ebp),%eax
   1206f:	83 c0 10             	add    $0x10,%eax
   12072:	8b 04 82             	mov    (%edx,%eax,4),%eax
   12075:	89 45 fc             	mov    %eax,-0x4(%ebp)
        return file;
   12078:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1207b:	eb 05                	jmp    12082 <task_file+0x2f>
    }

    return (file_t*)0;
   1207d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12082:	c9                   	leave  
   12083:	c3                   	ret    

00012084 <task_alloc_fd>:
/**
 * @brief 给文件分配描述符
 * @param file 指向一个文件的指针
 * @return 如果分配成功返回对应的fd如果分配失败返回-1
 */
int task_alloc_fd(file_t* file){
   12084:	55                   	push   %ebp
   12085:	89 e5                	mov    %esp,%ebp
   12087:	83 ec 10             	sub    $0x10,%esp
    task_t* task=task_current();
   1208a:	e8 6c f5 ff ff       	call   115fb <task_current>
   1208f:	89 45 f8             	mov    %eax,-0x8(%ebp)

    for(int i=0;i<TASK_OFILE_NR;i++){
   12092:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12099:	eb 2d                	jmp    120c8 <task_alloc_fd+0x44>
        file_t* p=task->file_table[i];
   1209b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1209e:	8b 55 fc             	mov    -0x4(%ebp),%edx
   120a1:	83 c2 10             	add    $0x10,%edx
   120a4:	8b 04 90             	mov    (%eax,%edx,4),%eax
   120a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(p==(file_t*)0){
   120aa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   120ae:	75 14                	jne    120c4 <task_alloc_fd+0x40>
            task->file_table[i]=file;
   120b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   120b3:	8b 55 fc             	mov    -0x4(%ebp),%edx
   120b6:	8d 4a 10             	lea    0x10(%edx),%ecx
   120b9:	8b 55 08             	mov    0x8(%ebp),%edx
   120bc:	89 14 88             	mov    %edx,(%eax,%ecx,4)
            return i;
   120bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
   120c2:	eb 0f                	jmp    120d3 <task_alloc_fd+0x4f>
    for(int i=0;i<TASK_OFILE_NR;i++){
   120c4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   120c8:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%ebp)
   120cc:	7e cd                	jle    1209b <task_alloc_fd+0x17>
        }
    }

    return -1;
   120ce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   120d3:	c9                   	leave  
   120d4:	c3                   	ret    

000120d5 <task_remove_fd>:

/**
 * @brief 释放一个文件描述符
 * @param fd 要释放的文件描述符
 */
void task_remove_fd(int fd){
   120d5:	55                   	push   %ebp
   120d6:	89 e5                	mov    %esp,%ebp
   if((fd>=0) && (fd<TASK_OFILE_NR)){
   120d8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   120dc:	78 1a                	js     120f8 <task_remove_fd+0x23>
   120de:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   120e2:	7f 14                	jg     120f8 <task_remove_fd+0x23>
       task_current()->file_table[fd]=(file_t*)0;
   120e4:	e8 12 f5 ff ff       	call   115fb <task_current>
   120e9:	89 c2                	mov    %eax,%edx
   120eb:	8b 45 08             	mov    0x8(%ebp),%eax
   120ee:	83 c0 10             	add    $0x10,%eax
   120f1:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
    }
}
   120f8:	90                   	nop
   120f9:	5d                   	pop    %ebp
   120fa:	c3                   	ret    

000120fb <sys_exit>:

void sys_exit(int status){
   120fb:	55                   	push   %ebp
   120fc:	89 e5                	mov    %esp,%ebp
   120fe:	83 ec 28             	sub    $0x28,%esp
    task_t* curr_task=task_current();
   12101:	e8 f5 f4 ff ff       	call   115fb <task_current>
   12106:	89 45 e8             	mov    %eax,-0x18(%ebp)

    for(int fd=0;fd<TASK_OFILE_NR;fd++){
   12109:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12110:	eb 37                	jmp    12149 <sys_exit+0x4e>
        file_t* file=curr_task->file_table[fd];
   12112:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12115:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12118:	83 c2 10             	add    $0x10,%edx
   1211b:	8b 04 90             	mov    (%eax,%edx,4),%eax
   1211e:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(file){
   12121:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12125:	74 1e                	je     12145 <sys_exit+0x4a>
            sys_close(fd);
   12127:	83 ec 0c             	sub    $0xc,%esp
   1212a:	ff 75 f4             	pushl  -0xc(%ebp)
   1212d:	e8 6f 4e 00 00       	call   16fa1 <sys_close>
   12132:	83 c4 10             	add    $0x10,%esp
            curr_task->file_table[fd]=(file_t*)0;
   12135:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12138:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1213b:	83 c2 10             	add    $0x10,%edx
   1213e:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
    for(int fd=0;fd<TASK_OFILE_NR;fd++){
   12145:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12149:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   1214d:	7e c3                	jle    12112 <sys_exit+0x17>
        }
    }

    int move_child=0;
   1214f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    mutex_lock(&table_mutex);
   12156:	83 ec 0c             	sub    $0xc,%esp
   12159:	68 c0 49 03 00       	push   $0x349c0
   1215e:	e8 7b 56 00 00       	call   177de <mutex_lock>
   12163:	83 c4 10             	add    $0x10,%esp

    for(int i=0;i<TASK_NR;i++){
   12166:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1216d:	eb 3b                	jmp    121aa <sys_exit+0xaf>
        task_t* task=task_table+i;
   1216f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12172:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   12178:	05 c0 e5 01 00       	add    $0x1e5c0,%eax
   1217d:	89 45 dc             	mov    %eax,-0x24(%ebp)
        if(task->parent==curr_task){
   12180:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12183:	8b 40 08             	mov    0x8(%eax),%eax
   12186:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   12189:	75 1b                	jne    121a6 <sys_exit+0xab>
            task->parent=&task_manager.first_task;
   1218b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1218e:	c7 40 08 28 d0 01 00 	movl   $0x1d028,0x8(%eax)
            if(task->state==TASK_ZOMBIE){
   12195:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12198:	8b 00                	mov    (%eax),%eax
   1219a:	83 f8 05             	cmp    $0x5,%eax
   1219d:	75 07                	jne    121a6 <sys_exit+0xab>
                move_child=1;  
   1219f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    for(int i=0;i<TASK_NR;i++){
   121a6:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   121aa:	83 7d ec 7f          	cmpl   $0x7f,-0x14(%ebp)
   121ae:	7e bf                	jle    1216f <sys_exit+0x74>
            }
        }
    }

    mutex_unlock(&table_mutex);
   121b0:	83 ec 0c             	sub    $0xc,%esp
   121b3:	68 c0 49 03 00       	push   $0x349c0
   121b8:	e8 b0 56 00 00       	call   1786d <mutex_unlock>
   121bd:	83 c4 10             	add    $0x10,%esp

    irq_state_t state=irq_enter_protection();
   121c0:	e8 3f 0d 00 00       	call   12f04 <irq_enter_protection>
   121c5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    task_t* parent=curr_task->parent;
   121c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   121cb:	8b 40 08             	mov    0x8(%eax),%eax
   121ce:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(move_child && (parent!=&task_manager.first_task)){
   121d1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   121d5:	74 23                	je     121fa <sys_exit+0xff>
   121d7:	81 7d e0 28 d0 01 00 	cmpl   $0x1d028,-0x20(%ebp)
   121de:	74 1a                	je     121fa <sys_exit+0xff>
        if(task_manager.first_task.state==TASK_WAITING){
   121e0:	a1 28 d0 01 00       	mov    0x1d028,%eax
   121e5:	83 f8 04             	cmp    $0x4,%eax
   121e8:	75 10                	jne    121fa <sys_exit+0xff>
            task_set_ready(&task_manager.first_task);
   121ea:	83 ec 0c             	sub    $0xc,%esp
   121ed:	68 28 d0 01 00       	push   $0x1d028
   121f2:	e8 5c f3 ff ff       	call   11553 <task_set_ready>
   121f7:	83 c4 10             	add    $0x10,%esp
        }
    }

    if(parent->state==TASK_WAITING){
   121fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
   121fd:	8b 00                	mov    (%eax),%eax
   121ff:	83 f8 04             	cmp    $0x4,%eax
   12202:	75 12                	jne    12216 <sys_exit+0x11b>
        task_set_ready(curr_task->parent);
   12204:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12207:	8b 40 08             	mov    0x8(%eax),%eax
   1220a:	83 ec 0c             	sub    $0xc,%esp
   1220d:	50                   	push   %eax
   1220e:	e8 40 f3 ff ff       	call   11553 <task_set_ready>
   12213:	83 c4 10             	add    $0x10,%esp
    }

    curr_task->status=status;
   12216:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12219:	8b 55 08             	mov    0x8(%ebp),%edx
   1221c:	89 90 c4 02 00 00    	mov    %edx,0x2c4(%eax)
    curr_task->state=TASK_ZOMBIE;
   12222:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12225:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    task_set_block(curr_task);
   1222b:	83 ec 0c             	sub    $0xc,%esp
   1222e:	ff 75 e8             	pushl  -0x18(%ebp)
   12231:	e8 53 f3 ff ff       	call   11589 <task_set_block>
   12236:	83 c4 10             	add    $0x10,%esp

    irq_leave_protection(state);
   12239:	83 ec 0c             	sub    $0xc,%esp
   1223c:	ff 75 e4             	pushl  -0x1c(%ebp)
   1223f:	e8 d8 0c 00 00       	call   12f1c <irq_leave_protection>
   12244:	83 c4 10             	add    $0x10,%esp
    
    task_dispatch();
   12247:	e8 1a f4 ff ff       	call   11666 <task_dispatch>


}
   1224c:	90                   	nop
   1224d:	c9                   	leave  
   1224e:	c3                   	ret    

0001224f <sys_wait>:
/**
 * @brief 等待子进程结束
 * @param status 退出状态码
 * @return 返回子进程的pid
 */
int sys_wait(int* status){
   1224f:	55                   	push   %ebp
   12250:	89 e5                	mov    %esp,%ebp
   12252:	83 ec 28             	sub    $0x28,%esp
    task_t* curr_task=task_current();
   12255:	e8 a1 f3 ff ff       	call   115fb <task_current>
   1225a:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // 注意这个for(;;){}的位置
    for(;;){
        mutex_lock(&table_mutex);
   1225d:	83 ec 0c             	sub    $0xc,%esp
   12260:	68 c0 49 03 00       	push   $0x349c0
   12265:	e8 74 55 00 00       	call   177de <mutex_lock>
   1226a:	83 c4 10             	add    $0x10,%esp

        for(int i=0;i<TASK_NR;i++){
   1226d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12274:	eb 7a                	jmp    122f0 <sys_wait+0xa1>
            task_t* task=task_table+i;
   12276:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12279:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   1227f:	05 c0 e5 01 00       	add    $0x1e5c0,%eax
   12284:	89 45 e8             	mov    %eax,-0x18(%ebp)
            if(task->parent != curr_task){
   12287:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1228a:	8b 40 08             	mov    0x8(%eax),%eax
   1228d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12290:	75 59                	jne    122eb <sys_wait+0x9c>
                continue;
            }    

            if(task->state==TASK_ZOMBIE){
   12292:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12295:	8b 00                	mov    (%eax),%eax
   12297:	83 f8 05             	cmp    $0x5,%eax
   1229a:	75 50                	jne    122ec <sys_wait+0x9d>
                int pid=task->pid;
   1229c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1229f:	8b 40 04             	mov    0x4(%eax),%eax
   122a2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                *status=task->status;
   122a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   122a8:	8b 90 c4 02 00 00    	mov    0x2c4(%eax),%edx
   122ae:	8b 45 08             	mov    0x8(%ebp),%eax
   122b1:	89 10                	mov    %edx,(%eax)
                
                task_uninit(task);
   122b3:	83 ec 0c             	sub    $0xc,%esp
   122b6:	ff 75 e8             	pushl  -0x18(%ebp)
   122b9:	e8 0a f0 ff ff       	call   112c8 <task_uninit>
   122be:	83 c4 10             	add    $0x10,%esp
                kernel_memset(task,0,sizeof(task_t));
   122c1:	83 ec 04             	sub    $0x4,%esp
   122c4:	68 c8 02 00 00       	push   $0x2c8
   122c9:	6a 00                	push   $0x0
   122cb:	ff 75 e8             	pushl  -0x18(%ebp)
   122ce:	e8 d5 5b 00 00       	call   17ea8 <kernel_memset>
   122d3:	83 c4 10             	add    $0x10,%esp

                mutex_unlock(&table_mutex);
   122d6:	83 ec 0c             	sub    $0xc,%esp
   122d9:	68 c0 49 03 00       	push   $0x349c0
   122de:	e8 8a 55 00 00       	call   1786d <mutex_unlock>
   122e3:	83 c4 10             	add    $0x10,%esp

                return pid;
   122e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   122e9:	eb 52                	jmp    1233d <sys_wait+0xee>
                continue;
   122eb:	90                   	nop
        for(int i=0;i<TASK_NR;i++){
   122ec:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   122f0:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   122f4:	7e 80                	jle    12276 <sys_wait+0x27>
            }
        }

        irq_state_t state=irq_enter_protection();
   122f6:	e8 09 0c 00 00       	call   12f04 <irq_enter_protection>
   122fb:	89 45 ec             	mov    %eax,-0x14(%ebp)

        task_set_block(curr_task);
   122fe:	83 ec 0c             	sub    $0xc,%esp
   12301:	ff 75 f0             	pushl  -0x10(%ebp)
   12304:	e8 80 f2 ff ff       	call   11589 <task_set_block>
   12309:	83 c4 10             	add    $0x10,%esp
        curr_task->state=TASK_WAITING;
   1230c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1230f:	c7 00 04 00 00 00    	movl   $0x4,(%eax)

        irq_leave_protection(state);
   12315:	83 ec 0c             	sub    $0xc,%esp
   12318:	ff 75 ec             	pushl  -0x14(%ebp)
   1231b:	e8 fc 0b 00 00       	call   12f1c <irq_leave_protection>
   12320:	83 c4 10             	add    $0x10,%esp

        mutex_unlock(&table_mutex);
   12323:	83 ec 0c             	sub    $0xc,%esp
   12326:	68 c0 49 03 00       	push   $0x349c0
   1232b:	e8 3d 55 00 00       	call   1786d <mutex_unlock>
   12330:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   12333:	e8 2e f3 ff ff       	call   11666 <task_dispatch>
    for(;;){
   12338:	e9 20 ff ff ff       	jmp    1225d <sys_wait+0xe>
    }
   1233d:	c9                   	leave  
   1233e:	c3                   	ret    

0001233f <lgdt>:
static inline void lgdt(uint32_t start,uint32_t size){
   1233f:	55                   	push   %ebp
   12340:	89 e5                	mov    %esp,%ebp
   12342:	83 ec 10             	sub    $0x10,%esp
    gdt.start31_16=start>>16;
   12345:	8b 45 08             	mov    0x8(%ebp),%eax
   12348:	c1 e8 10             	shr    $0x10,%eax
   1234b:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    gdt.start15_0=start&0xFFFF;
   1234f:	8b 45 08             	mov    0x8(%ebp),%eax
   12352:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    gdt.limit=size-1;
   12356:	8b 45 0c             	mov    0xc(%ebp),%eax
   12359:	83 e8 01             	sub    $0x1,%eax
   1235c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__(
   12360:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
}
   12364:	90                   	nop
   12365:	c9                   	leave  
   12366:	c3                   	ret    

00012367 <far_jump>:
static inline void far_jump(uint32_t selector,uint32_t offset){
   12367:	55                   	push   %ebp
   12368:	89 e5                	mov    %esp,%ebp
   1236a:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[]={offset,selector};
   1236d:	8b 45 0c             	mov    0xc(%ebp),%eax
   12370:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12373:	8b 45 08             	mov    0x8(%ebp),%eax
   12376:	89 45 fc             	mov    %eax,-0x4(%ebp)
    __asm__ __volatile__(
   12379:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1237c:	ff 28                	ljmp   *(%eax)
}
   1237e:	90                   	nop
   1237f:	c9                   	leave  
   12380:	c3                   	ret    

00012381 <segment_desc_set>:
 * @param base 段基址
 * @param limit 段界限
 * @param attr 段属性
 * @return void
*/
void segment_desc_set(int selector,uint32_t base,uint32_t limit,uint16_t attr){
   12381:	55                   	push   %ebp
   12382:	89 e5                	mov    %esp,%ebp
   12384:	83 ec 14             	sub    $0x14,%esp
   12387:	8b 45 14             	mov    0x14(%ebp),%eax
   1238a:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    segment_desc_t* desc=gdt_table+(selector >> 3);
   1238e:	8b 45 08             	mov    0x8(%ebp),%eax
   12391:	c1 f8 03             	sar    $0x3,%eax
   12394:	c1 e0 03             	shl    $0x3,%eax
   12397:	05 e0 49 03 00       	add    $0x349e0,%eax
   1239c:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // 设置G标志位决定粒度4kb or 1B
    if(limit > 0xFFFFF){
   1239f:	81 7d 10 ff ff 0f 00 	cmpl   $0xfffff,0x10(%ebp)
   123a6:	76 0f                	jbe    123b7 <segment_desc_set+0x36>
        attr|=0x8000;
   123a8:	66 81 4d ec 00 80    	orw    $0x8000,-0x14(%ebp)
        limit/=0x1000;
   123ae:	8b 45 10             	mov    0x10(%ebp),%eax
   123b1:	c1 e8 0c             	shr    $0xc,%eax
   123b4:	89 45 10             	mov    %eax,0x10(%ebp)
    }
    desc->limit15_0=limit&0xFFFF;
   123b7:	8b 45 10             	mov    0x10(%ebp),%eax
   123ba:	89 c2                	mov    %eax,%edx
   123bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123bf:	66 89 10             	mov    %dx,(%eax)
    desc->base15_0=base&0xFFFF;
   123c2:	8b 45 0c             	mov    0xc(%ebp),%eax
   123c5:	89 c2                	mov    %eax,%edx
   123c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123ca:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->base23_16=(base>>16)&0xFF;
   123ce:	8b 45 0c             	mov    0xc(%ebp),%eax
   123d1:	c1 e8 10             	shr    $0x10,%eax
   123d4:	89 c2                	mov    %eax,%edx
   123d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123d9:	88 50 04             	mov    %dl,0x4(%eax)
    desc->attr=attr|(((limit>>16)&0xF)<<8);
   123dc:	8b 45 10             	mov    0x10(%ebp),%eax
   123df:	c1 e8 10             	shr    $0x10,%eax
   123e2:	c1 e0 08             	shl    $0x8,%eax
   123e5:	66 25 00 0f          	and    $0xf00,%ax
   123e9:	66 0b 45 ec          	or     -0x14(%ebp),%ax
   123ed:	89 c2                	mov    %eax,%edx
   123ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123f2:	66 89 50 05          	mov    %dx,0x5(%eax)
    desc->base31_24=(base>>24)&0xFF;
   123f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   123f9:	c1 e8 18             	shr    $0x18,%eax
   123fc:	89 c2                	mov    %eax,%edx
   123fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12401:	88 50 07             	mov    %dl,0x7(%eax)

}
   12404:	90                   	nop
   12405:	c9                   	leave  
   12406:	c3                   	ret    

00012407 <init_gdt>:

// 初始化gdt表
void init_gdt(void){
   12407:	55                   	push   %ebp
   12408:	89 e5                	mov    %esp,%ebp
   1240a:	83 ec 18             	sub    $0x18,%esp
    for(int i=0;i<GDT_TABLE_SIZE;i++){
   1240d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12414:	eb 19                	jmp    1242f <init_gdt+0x28>
        segment_desc_set(i<<3,0,0,0);
   12416:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12419:	c1 e0 03             	shl    $0x3,%eax
   1241c:	6a 00                	push   $0x0
   1241e:	6a 00                	push   $0x0
   12420:	6a 00                	push   $0x0
   12422:	50                   	push   %eax
   12423:	e8 59 ff ff ff       	call   12381 <segment_desc_set>
   12428:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<GDT_TABLE_SIZE;i++){
   1242b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1242f:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   12436:	7e de                	jle    12416 <init_gdt+0xf>
    }
    segment_desc_set(KERNEL_SELECTOR_DS,0,0xFFFFFFFF,
   12438:	68 92 40 00 00       	push   $0x4092
   1243d:	6a ff                	push   $0xffffffff
   1243f:	6a 00                	push   $0x0
   12441:	6a 10                	push   $0x10
   12443:	e8 39 ff ff ff       	call   12381 <segment_desc_set>
   12448:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW
        | SEG_D
    );
    segment_desc_set(KERNEL_SELECTOR_CS, 0x00000000, 0xFFFFFFFF,
   1244b:	68 9a c0 00 00       	push   $0xc09a
   12450:	6a ff                	push   $0xffffffff
   12452:	6a 00                	push   $0x0
   12454:	6a 08                	push   $0x8
   12456:	e8 26 ff ff ff       	call   12381 <segment_desc_set>
   1245b:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE
        | SEG_TYPE_RW | SEG_D | SEG_G);
    gate_desc_set((gate_desc_t*)(gdt_table+(SELECTOR_SYSCALL >> 3)),
   1245e:	ba e6 02 01 00       	mov    $0x102e6,%edx
   12463:	b8 f8 49 03 00       	mov    $0x349f8,%eax
   12468:	68 05 ec 00 00       	push   $0xec05
   1246d:	52                   	push   %edx
   1246e:	6a 08                	push   $0x8
   12470:	50                   	push   %eax
   12471:	e8 1c 00 00 00       	call   12492 <gate_desc_set>
   12476:	83 c4 10             	add    $0x10,%esp
        KERNEL_SELECTOR_CS,(uint32_t)exception_handler_syscall,
        GATE_P_PRESENT | GATE_DPL3 | GATE_TYPE_SYSCALL | SYSCALL_PARAM_COUNT
    );
    lgdt((uint32_t)gdt_table,sizeof(gdt_table));
   12479:	b8 e0 49 03 00       	mov    $0x349e0,%eax
   1247e:	83 ec 08             	sub    $0x8,%esp
   12481:	68 00 08 00 00       	push   $0x800
   12486:	50                   	push   %eax
   12487:	e8 b3 fe ff ff       	call   1233f <lgdt>
   1248c:	83 c4 10             	add    $0x10,%esp
}
   1248f:	90                   	nop
   12490:	c9                   	leave  
   12491:	c3                   	ret    

00012492 <gate_desc_set>:

// 设置idt表项
void gate_desc_set(gate_desc_t* desc,uint16_t selector,uint32_t offset,uint16_t attr){
   12492:	55                   	push   %ebp
   12493:	89 e5                	mov    %esp,%ebp
   12495:	83 ec 08             	sub    $0x8,%esp
   12498:	8b 55 0c             	mov    0xc(%ebp),%edx
   1249b:	8b 45 14             	mov    0x14(%ebp),%eax
   1249e:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   124a2:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    desc->offset15_0=offset&0xFFFF;
   124a6:	8b 45 10             	mov    0x10(%ebp),%eax
   124a9:	89 c2                	mov    %eax,%edx
   124ab:	8b 45 08             	mov    0x8(%ebp),%eax
   124ae:	66 89 10             	mov    %dx,(%eax)
    desc->selector=selector;
   124b1:	8b 45 08             	mov    0x8(%ebp),%eax
   124b4:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   124b8:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->attr=attr;
   124bc:	8b 45 08             	mov    0x8(%ebp),%eax
   124bf:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
   124c3:	66 89 50 04          	mov    %dx,0x4(%eax)
    desc->offset31_16=(offset>>16)&0xFFFF;
   124c7:	8b 45 10             	mov    0x10(%ebp),%eax
   124ca:	c1 e8 10             	shr    $0x10,%eax
   124cd:	89 c2                	mov    %eax,%edx
   124cf:	8b 45 08             	mov    0x8(%ebp),%eax
   124d2:	66 89 50 06          	mov    %dx,0x6(%eax)
}
   124d6:	90                   	nop
   124d7:	c9                   	leave  
   124d8:	c3                   	ret    

000124d9 <cpu_init>:

/**
 * @brief 初始化mutex锁以及gdt表
 * @return void
*/
void cpu_init(void){
   124d9:	55                   	push   %ebp
   124da:	89 e5                	mov    %esp,%ebp
   124dc:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   124df:	83 ec 0c             	sub    $0xc,%esp
   124e2:	68 e0 51 03 00       	push   $0x351e0
   124e7:	e8 c4 52 00 00       	call   177b0 <mutex_init>
   124ec:	83 c4 10             	add    $0x10,%esp
    init_gdt();
   124ef:	e8 13 ff ff ff       	call   12407 <init_gdt>
}
   124f4:	90                   	nop
   124f5:	c9                   	leave  
   124f6:	c3                   	ret    

000124f7 <gdt_alloc_desc>:

/**
 * @brief 分配gdt表项
 * @return 分配成功返回gdt表项的索引，失败返回-1
*/
int gdt_alloc_desc(){
   124f7:	55                   	push   %ebp
   124f8:	89 e5                	mov    %esp,%ebp
   124fa:	83 ec 18             	sub    $0x18,%esp
    mutex_lock(&mutex);
   124fd:	83 ec 0c             	sub    $0xc,%esp
   12500:	68 e0 51 03 00       	push   $0x351e0
   12505:	e8 d4 52 00 00       	call   177de <mutex_lock>
   1250a:	83 c4 10             	add    $0x10,%esp
    for(int i=1;i<GDT_TABLE_SIZE;i++){
   1250d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   12514:	eb 36                	jmp    1254c <gdt_alloc_desc+0x55>
        segment_desc_t* desc=gdt_table+i;
   12516:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12519:	c1 e0 03             	shl    $0x3,%eax
   1251c:	05 e0 49 03 00       	add    $0x349e0,%eax
   12521:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(desc->attr==0){
   12524:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12527:	0f b7 40 05          	movzwl 0x5(%eax),%eax
   1252b:	66 85 c0             	test   %ax,%ax
   1252e:	75 18                	jne    12548 <gdt_alloc_desc+0x51>
            mutex_unlock(&mutex);
   12530:	83 ec 0c             	sub    $0xc,%esp
   12533:	68 e0 51 03 00       	push   $0x351e0
   12538:	e8 30 53 00 00       	call   1786d <mutex_unlock>
   1253d:	83 c4 10             	add    $0x10,%esp
            return i*sizeof(segment_desc_t);
   12540:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12543:	c1 e0 03             	shl    $0x3,%eax
   12546:	eb 22                	jmp    1256a <gdt_alloc_desc+0x73>
    for(int i=1;i<GDT_TABLE_SIZE;i++){
   12548:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1254c:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   12553:	7e c1                	jle    12516 <gdt_alloc_desc+0x1f>
        }
    }
    mutex_unlock(&mutex);
   12555:	83 ec 0c             	sub    $0xc,%esp
   12558:	68 e0 51 03 00       	push   $0x351e0
   1255d:	e8 0b 53 00 00       	call   1786d <mutex_unlock>
   12562:	83 c4 10             	add    $0x10,%esp
    return -1;
   12565:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   1256a:	c9                   	leave  
   1256b:	c3                   	ret    

0001256c <switch_to_tss>:

void switch_to_tss(int tss_sel){
   1256c:	55                   	push   %ebp
   1256d:	89 e5                	mov    %esp,%ebp
    far_jump(tss_sel,0);
   1256f:	8b 45 08             	mov    0x8(%ebp),%eax
   12572:	6a 00                	push   $0x0
   12574:	50                   	push   %eax
   12575:	e8 ed fd ff ff       	call   12367 <far_jump>
   1257a:	83 c4 08             	add    $0x8,%esp
}
   1257d:	90                   	nop
   1257e:	c9                   	leave  
   1257f:	c3                   	ret    

00012580 <gdt_free_sel>:

void gdt_free_sel(int sel){
   12580:	55                   	push   %ebp
   12581:	89 e5                	mov    %esp,%ebp
   12583:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&mutex);
   12586:	83 ec 0c             	sub    $0xc,%esp
   12589:	68 e0 51 03 00       	push   $0x351e0
   1258e:	e8 4b 52 00 00       	call   177de <mutex_lock>
   12593:	83 c4 10             	add    $0x10,%esp
    gdt_table[sel/sizeof(segment_desc_set)].attr=0;
   12596:	8b 45 08             	mov    0x8(%ebp),%eax
   12599:	66 c7 04 c5 e5 49 03 	movw   $0x0,0x349e5(,%eax,8)
   125a0:	00 00 00 
    mutex_unlock(&mutex);
   125a3:	83 ec 0c             	sub    $0xc,%esp
   125a6:	68 e0 51 03 00       	push   $0x351e0
   125ab:	e8 bd 52 00 00       	call   1786d <mutex_unlock>
   125b0:	83 c4 10             	add    $0x10,%esp
   125b3:	90                   	nop
   125b4:	c9                   	leave  
   125b5:	c3                   	ret    

000125b6 <cli>:
static inline void cli(void){
   125b6:	55                   	push   %ebp
   125b7:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("cli");
   125b9:	fa                   	cli    
}
   125ba:	90                   	nop
   125bb:	5d                   	pop    %ebp
   125bc:	c3                   	ret    

000125bd <sti>:
static inline void sti(void){
   125bd:	55                   	push   %ebp
   125be:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("sti");
   125c0:	fb                   	sti    
}
   125c1:	90                   	nop
   125c2:	5d                   	pop    %ebp
   125c3:	c3                   	ret    

000125c4 <inb>:
static inline uint8_t inb(uint16_t port){
   125c4:	55                   	push   %ebp
   125c5:	89 e5                	mov    %esp,%ebp
   125c7:	83 ec 14             	sub    $0x14,%esp
   125ca:	8b 45 08             	mov    0x8(%ebp),%eax
   125cd:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   125d1:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   125d5:	89 c2                	mov    %eax,%edx
   125d7:	ec                   	in     (%dx),%al
   125d8:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   125db:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   125df:	c9                   	leave  
   125e0:	c3                   	ret    

000125e1 <outb>:
static inline void outb(uint16_t port,uint8_t data){
   125e1:	55                   	push   %ebp
   125e2:	89 e5                	mov    %esp,%ebp
   125e4:	83 ec 08             	sub    $0x8,%esp
   125e7:	8b 55 08             	mov    0x8(%ebp),%edx
   125ea:	8b 45 0c             	mov    0xc(%ebp),%eax
   125ed:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   125f1:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   125f4:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   125f8:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   125fc:	ee                   	out    %al,(%dx)
}
   125fd:	90                   	nop
   125fe:	c9                   	leave  
   125ff:	c3                   	ret    

00012600 <lidt>:
static inline void lidt(uint32_t start,uint32_t size){
   12600:	55                   	push   %ebp
   12601:	89 e5                	mov    %esp,%ebp
   12603:	83 ec 10             	sub    $0x10,%esp
    idt.start31_16=start>>16;
   12606:	8b 45 08             	mov    0x8(%ebp),%eax
   12609:	c1 e8 10             	shr    $0x10,%eax
   1260c:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    idt.start15_0=start&0xFFFF;
   12610:	8b 45 08             	mov    0x8(%ebp),%eax
   12613:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    idt.limit=size-1;
   12617:	8b 45 0c             	mov    0xc(%ebp),%eax
   1261a:	83 e8 01             	sub    $0x1,%eax
   1261d:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__(
   12621:	0f 01 5d fa          	lidtl  -0x6(%ebp)
}
   12625:	90                   	nop
   12626:	c9                   	leave  
   12627:	c3                   	ret    

00012628 <hlt>:
static inline void hlt(void){
   12628:	55                   	push   %ebp
   12629:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("hlt");
   1262b:	f4                   	hlt    
}
   1262c:	90                   	nop
   1262d:	5d                   	pop    %ebp
   1262e:	c3                   	ret    

0001262f <read_eflags>:
static inline uint32_t read_eflags(void){
   1262f:	55                   	push   %ebp
   12630:	89 e5                	mov    %esp,%ebp
   12632:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__(
   12635:	9c                   	pushf  
   12636:	58                   	pop    %eax
   12637:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return eflags;
   1263a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1263d:	c9                   	leave  
   1263e:	c3                   	ret    

0001263f <write_eflags>:
static inline void write_eflags(uint32_t eflags){
   1263f:	55                   	push   %ebp
   12640:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   12642:	8b 45 08             	mov    0x8(%ebp),%eax
   12645:	50                   	push   %eax
   12646:	9d                   	popf   
}
   12647:	90                   	nop
   12648:	5d                   	pop    %ebp
   12649:	c3                   	ret    

0001264a <read_cr2>:

/**
 * @brief 读取cr2寄存器
 * @return cr2寄存器的值
 */
static inline uint32_t read_cr2(void){
   1264a:	55                   	push   %ebp
   1264b:	89 e5                	mov    %esp,%ebp
   1264d:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr2;
    __asm__ __volatile__(
   12650:	0f 20 e0             	mov    %cr4,%eax
   12653:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "mov %%cr4,%[v]"
        :[v]"=r"(cr2)
        :
    );
    return cr2;
   12656:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   12659:	c9                   	leave  
   1265a:	c3                   	ret    

0001265b <init_pic>:
#include "cpu/irq.h"
#include "core/task.h"

// 初始化8259，开启中断
static void init_pic(void){
   1265b:	55                   	push   %ebp
   1265c:	89 e5                	mov    %esp,%ebp
	outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   1265e:	6a 11                	push   $0x11
   12660:	6a 20                	push   $0x20
   12662:	e8 7a ff ff ff       	call   125e1 <outb>
   12667:	83 c4 08             	add    $0x8,%esp
	outb(PIC0_ICW2, IRQ_PIC_START);
   1266a:	6a 20                	push   $0x20
   1266c:	6a 21                	push   $0x21
   1266e:	e8 6e ff ff ff       	call   125e1 <outb>
   12673:	83 c4 08             	add    $0x8,%esp
	outb(PIC0_ICW3, 1 << 2);
   12676:	6a 04                	push   $0x4
   12678:	6a 21                	push   $0x21
   1267a:	e8 62 ff ff ff       	call   125e1 <outb>
   1267f:	83 c4 08             	add    $0x8,%esp
	outb(PIC0_ICW4, PIC_ICW4_8086);
   12682:	6a 01                	push   $0x1
   12684:	6a 21                	push   $0x21
   12686:	e8 56 ff ff ff       	call   125e1 <outb>
   1268b:	83 c4 08             	add    $0x8,%esp

	outb(PIC1_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   1268e:	6a 11                	push   $0x11
   12690:	68 a0 00 00 00       	push   $0xa0
   12695:	e8 47 ff ff ff       	call   125e1 <outb>
   1269a:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_ICW2, IRQ_PIC_START+8);
   1269d:	6a 28                	push   $0x28
   1269f:	68 a1 00 00 00       	push   $0xa1
   126a4:	e8 38 ff ff ff       	call   125e1 <outb>
   126a9:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_ICW3, 2);
   126ac:	6a 02                	push   $0x2
   126ae:	68 a1 00 00 00       	push   $0xa1
   126b3:	e8 29 ff ff ff       	call   125e1 <outb>
   126b8:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_ICW4, PIC_ICW4_8086);
   126bb:	6a 01                	push   $0x1
   126bd:	68 a1 00 00 00       	push   $0xa1
   126c2:	e8 1a ff ff ff       	call   125e1 <outb>
   126c7:	83 c4 08             	add    $0x8,%esp

	outb(PIC0_IMR,0xFF & ~(1 << 2));
   126ca:	68 fb 00 00 00       	push   $0xfb
   126cf:	6a 21                	push   $0x21
   126d1:	e8 0b ff ff ff       	call   125e1 <outb>
   126d6:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_IMR, 0xFF);
   126d9:	68 ff 00 00 00       	push   $0xff
   126de:	68 a1 00 00 00       	push   $0xa1
   126e3:	e8 f9 fe ff ff       	call   125e1 <outb>
   126e8:	83 c4 08             	add    $0x8,%esp
}
   126eb:	90                   	nop
   126ec:	c9                   	leave  
   126ed:	c3                   	ret    

000126ee <irq_disable_global>:

// 关中断
void irq_disable_global(void){
   126ee:	55                   	push   %ebp
   126ef:	89 e5                	mov    %esp,%ebp
	cli();
   126f1:	e8 c0 fe ff ff       	call   125b6 <cli>
}
   126f6:	90                   	nop
   126f7:	5d                   	pop    %ebp
   126f8:	c3                   	ret    

000126f9 <irq_enable_global>:

// 开中断
void irq_enable_global(void){
   126f9:	55                   	push   %ebp
   126fa:	89 e5                	mov    %esp,%ebp
	sti();
   126fc:	e8 bc fe ff ff       	call   125bd <sti>
}
   12701:	90                   	nop
   12702:	5d                   	pop    %ebp
   12703:	c3                   	ret    

00012704 <irq_enable>:

// 开启特定中断
void irq_enable(int irq_num){
   12704:	55                   	push   %ebp
   12705:	89 e5                	mov    %esp,%ebp
   12707:	53                   	push   %ebx
   12708:	83 ec 10             	sub    $0x10,%esp
	if(irq_num < IRQ_PIC_START){
   1270b:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   1270f:	7e 78                	jle    12789 <irq_enable+0x85>
		return;
	}
	irq_num-=IRQ_PIC_START;
   12711:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
	if(irq_num<8){
   12715:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12719:	7f 32                	jg     1274d <irq_enable+0x49>
		uint8_t mask=inb(PIC0_IMR) & ~(1<<irq_num);
   1271b:	6a 21                	push   $0x21
   1271d:	e8 a2 fe ff ff       	call   125c4 <inb>
   12722:	83 c4 04             	add    $0x4,%esp
   12725:	89 c2                	mov    %eax,%edx
   12727:	8b 45 08             	mov    0x8(%ebp),%eax
   1272a:	bb 01 00 00 00       	mov    $0x1,%ebx
   1272f:	89 c1                	mov    %eax,%ecx
   12731:	d3 e3                	shl    %cl,%ebx
   12733:	89 d8                	mov    %ebx,%eax
   12735:	f7 d0                	not    %eax
   12737:	21 d0                	and    %edx,%eax
   12739:	88 45 fa             	mov    %al,-0x6(%ebp)
		outb(PIC0_IMR,mask);
   1273c:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   12740:	50                   	push   %eax
   12741:	6a 21                	push   $0x21
   12743:	e8 99 fe ff ff       	call   125e1 <outb>
   12748:	83 c4 08             	add    $0x8,%esp
   1274b:	eb 3d                	jmp    1278a <irq_enable+0x86>
	}
	else{
		irq_num-=8;
   1274d:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
		uint8_t mask=inb(PIC1_IMR) & ~(1<<irq_num);
   12751:	68 a1 00 00 00       	push   $0xa1
   12756:	e8 69 fe ff ff       	call   125c4 <inb>
   1275b:	83 c4 04             	add    $0x4,%esp
   1275e:	89 c2                	mov    %eax,%edx
   12760:	8b 45 08             	mov    0x8(%ebp),%eax
   12763:	bb 01 00 00 00       	mov    $0x1,%ebx
   12768:	89 c1                	mov    %eax,%ecx
   1276a:	d3 e3                	shl    %cl,%ebx
   1276c:	89 d8                	mov    %ebx,%eax
   1276e:	f7 d0                	not    %eax
   12770:	21 d0                	and    %edx,%eax
   12772:	88 45 fb             	mov    %al,-0x5(%ebp)
		outb(PIC1_IMR,mask);
   12775:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   12779:	50                   	push   %eax
   1277a:	68 a1 00 00 00       	push   $0xa1
   1277f:	e8 5d fe ff ff       	call   125e1 <outb>
   12784:	83 c4 08             	add    $0x8,%esp
   12787:	eb 01                	jmp    1278a <irq_enable+0x86>
		return;
   12789:	90                   	nop
	}
}
   1278a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1278d:	c9                   	leave  
   1278e:	c3                   	ret    

0001278f <irq_disable>:

// 关闭特定中断
void irq_disable(int irq_num){
   1278f:	55                   	push   %ebp
   12790:	89 e5                	mov    %esp,%ebp
   12792:	53                   	push   %ebx
   12793:	83 ec 10             	sub    $0x10,%esp
	if(irq_num < IRQ_PIC_START){
   12796:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   1279a:	7e 74                	jle    12810 <irq_disable+0x81>
		return;
	}
	irq_num-=IRQ_PIC_START;
   1279c:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
	if(irq_num<8){
   127a0:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   127a4:	7f 30                	jg     127d6 <irq_disable+0x47>
		uint8_t mask=inb(PIC0_IMR) | (1<<irq_num);
   127a6:	6a 21                	push   $0x21
   127a8:	e8 17 fe ff ff       	call   125c4 <inb>
   127ad:	83 c4 04             	add    $0x4,%esp
   127b0:	89 c3                	mov    %eax,%ebx
   127b2:	8b 45 08             	mov    0x8(%ebp),%eax
   127b5:	ba 01 00 00 00       	mov    $0x1,%edx
   127ba:	89 c1                	mov    %eax,%ecx
   127bc:	d3 e2                	shl    %cl,%edx
   127be:	89 d0                	mov    %edx,%eax
   127c0:	09 d8                	or     %ebx,%eax
   127c2:	88 45 fa             	mov    %al,-0x6(%ebp)
		outb(PIC0_IMR,mask);
   127c5:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   127c9:	50                   	push   %eax
   127ca:	6a 21                	push   $0x21
   127cc:	e8 10 fe ff ff       	call   125e1 <outb>
   127d1:	83 c4 08             	add    $0x8,%esp
   127d4:	eb 3b                	jmp    12811 <irq_disable+0x82>
	}
	else{
		irq_num-=8;
   127d6:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
		uint8_t mask=inb(PIC1_IMR) | (1<<irq_num);
   127da:	68 a1 00 00 00       	push   $0xa1
   127df:	e8 e0 fd ff ff       	call   125c4 <inb>
   127e4:	83 c4 04             	add    $0x4,%esp
   127e7:	89 c3                	mov    %eax,%ebx
   127e9:	8b 45 08             	mov    0x8(%ebp),%eax
   127ec:	ba 01 00 00 00       	mov    $0x1,%edx
   127f1:	89 c1                	mov    %eax,%ecx
   127f3:	d3 e2                	shl    %cl,%edx
   127f5:	89 d0                	mov    %edx,%eax
   127f7:	09 d8                	or     %ebx,%eax
   127f9:	88 45 fb             	mov    %al,-0x5(%ebp)
		outb(PIC1_IMR,mask);
   127fc:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   12800:	50                   	push   %eax
   12801:	68 a1 00 00 00       	push   $0xa1
   12806:	e8 d6 fd ff ff       	call   125e1 <outb>
   1280b:	83 c4 08             	add    $0x8,%esp
   1280e:	eb 01                	jmp    12811 <irq_disable+0x82>
		return;
   12810:	90                   	nop
	}
}
   12811:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12814:	c9                   	leave  
   12815:	c3                   	ret    

00012816 <irq_init>:

/// @brief 中断向量表
static gate_desc_t idt_table[IDT_TABLE_NR];

void irq_init(void){
   12816:	55                   	push   %ebp
   12817:	89 e5                	mov    %esp,%ebp
   12819:	83 ec 18             	sub    $0x18,%esp
    for(uint32_t i=0;i<IDT_TABLE_NR;i++){
   1281c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12823:	eb 25                	jmp    1284a <irq_init+0x34>
        gate_desc_set(idt_table+i,KERNEL_SELECTOR_CS,(uint32_t)exception_handler_unknown,
   12825:	ba 2b 00 01 00       	mov    $0x1002b,%edx
   1282a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1282d:	c1 e0 03             	shl    $0x3,%eax
   12830:	05 00 52 03 00       	add    $0x35200,%eax
   12835:	68 00 8e 00 00       	push   $0x8e00
   1283a:	52                   	push   %edx
   1283b:	6a 08                	push   $0x8
   1283d:	50                   	push   %eax
   1283e:	e8 4f fc ff ff       	call   12492 <gate_desc_set>
   12843:	83 c4 10             	add    $0x10,%esp
    for(uint32_t i=0;i<IDT_TABLE_NR;i++){
   12846:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1284a:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   1284e:	76 d5                	jbe    12825 <irq_init+0xf>
        GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);
    }

    
    irq_install(IRQ0_DE, (irq_handler_t)exception_handler_divider);
   12850:	83 ec 08             	sub    $0x8,%esp
   12853:	68 4a 00 01 00       	push   $0x1004a
   12858:	6a 00                	push   $0x0
   1285a:	e8 65 01 00 00       	call   129c4 <irq_install>
   1285f:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ1_DB, (irq_handler_t)exception_handler_Debug);
   12862:	83 ec 08             	sub    $0x8,%esp
   12865:	68 69 00 01 00       	push   $0x10069
   1286a:	6a 01                	push   $0x1
   1286c:	e8 53 01 00 00       	call   129c4 <irq_install>
   12871:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ2_NMI, (irq_handler_t)exception_handler_NMI);
   12874:	83 ec 08             	sub    $0x8,%esp
   12877:	68 88 00 01 00       	push   $0x10088
   1287c:	6a 02                	push   $0x2
   1287e:	e8 41 01 00 00       	call   129c4 <irq_install>
   12883:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ3_BP, (irq_handler_t)exception_handler_breakpoint);
   12886:	83 ec 08             	sub    $0x8,%esp
   12889:	68 a7 00 01 00       	push   $0x100a7
   1288e:	6a 03                	push   $0x3
   12890:	e8 2f 01 00 00       	call   129c4 <irq_install>
   12895:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ4_OF, (irq_handler_t)exception_handler_overflow);
   12898:	83 ec 08             	sub    $0x8,%esp
   1289b:	68 c6 00 01 00       	push   $0x100c6
   128a0:	6a 04                	push   $0x4
   128a2:	e8 1d 01 00 00       	call   129c4 <irq_install>
   128a7:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ5_BR, (irq_handler_t)exception_handler_bound_range);
   128aa:	83 ec 08             	sub    $0x8,%esp
   128ad:	68 e5 00 01 00       	push   $0x100e5
   128b2:	6a 05                	push   $0x5
   128b4:	e8 0b 01 00 00       	call   129c4 <irq_install>
   128b9:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ6_UD, (irq_handler_t)exception_handler_invalid_opcode);
   128bc:	83 ec 08             	sub    $0x8,%esp
   128bf:	68 04 01 01 00       	push   $0x10104
   128c4:	6a 06                	push   $0x6
   128c6:	e8 f9 00 00 00       	call   129c4 <irq_install>
   128cb:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ7_NM, (irq_handler_t)exception_handler_device_unavailable);
   128ce:	83 ec 08             	sub    $0x8,%esp
   128d1:	68 23 01 01 00       	push   $0x10123
   128d6:	6a 07                	push   $0x7
   128d8:	e8 e7 00 00 00       	call   129c4 <irq_install>
   128dd:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ8_DF, (irq_handler_t)exception_handler_double_fault);
   128e0:	83 ec 08             	sub    $0x8,%esp
   128e3:	68 42 01 01 00       	push   $0x10142
   128e8:	6a 08                	push   $0x8
   128ea:	e8 d5 00 00 00       	call   129c4 <irq_install>
   128ef:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ10_TS, (irq_handler_t)exception_handler_invalid_tss);
   128f2:	83 ec 08             	sub    $0x8,%esp
   128f5:	68 5f 01 01 00       	push   $0x1015f
   128fa:	6a 0a                	push   $0xa
   128fc:	e8 c3 00 00 00       	call   129c4 <irq_install>
   12901:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ11_NP, (irq_handler_t)exception_handler_segment_not_present);
   12904:	83 ec 08             	sub    $0x8,%esp
   12907:	68 7c 01 01 00       	push   $0x1017c
   1290c:	6a 0b                	push   $0xb
   1290e:	e8 b1 00 00 00       	call   129c4 <irq_install>
   12913:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ12_SS, (irq_handler_t)exception_handler_stack_segment_fault);
   12916:	83 ec 08             	sub    $0x8,%esp
   12919:	68 99 01 01 00       	push   $0x10199
   1291e:	6a 0c                	push   $0xc
   12920:	e8 9f 00 00 00       	call   129c4 <irq_install>
   12925:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ13_GP, (irq_handler_t)exception_handler_general_protection);
   12928:	83 ec 08             	sub    $0x8,%esp
   1292b:	68 b6 01 01 00       	push   $0x101b6
   12930:	6a 0d                	push   $0xd
   12932:	e8 8d 00 00 00       	call   129c4 <irq_install>
   12937:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ14_PF, (irq_handler_t)exception_handler_page_fault);
   1293a:	83 ec 08             	sub    $0x8,%esp
   1293d:	68 d3 01 01 00       	push   $0x101d3
   12942:	6a 0e                	push   $0xe
   12944:	e8 7b 00 00 00       	call   129c4 <irq_install>
   12949:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ16_MF, (irq_handler_t)exception_handler_fpu_error);
   1294c:	83 ec 08             	sub    $0x8,%esp
   1294f:	68 f0 01 01 00       	push   $0x101f0
   12954:	6a 10                	push   $0x10
   12956:	e8 69 00 00 00       	call   129c4 <irq_install>
   1295b:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ17_AC, (irq_handler_t)exception_handler_alignment_check);
   1295e:	83 ec 08             	sub    $0x8,%esp
   12961:	68 0f 02 01 00       	push   $0x1020f
   12966:	6a 11                	push   $0x11
   12968:	e8 57 00 00 00       	call   129c4 <irq_install>
   1296d:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ18_MC, (irq_handler_t)exception_handler_machine_check);
   12970:	83 ec 08             	sub    $0x8,%esp
   12973:	68 2c 02 01 00       	push   $0x1022c
   12978:	6a 12                	push   $0x12
   1297a:	e8 45 00 00 00       	call   129c4 <irq_install>
   1297f:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ19_XM, (irq_handler_t)exception_handler_smd_exception);
   12982:	83 ec 08             	sub    $0x8,%esp
   12985:	68 4b 02 01 00       	push   $0x1024b
   1298a:	6a 13                	push   $0x13
   1298c:	e8 33 00 00 00       	call   129c4 <irq_install>
   12991:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ20_VE, (irq_handler_t)exception_handler_virtual_exception);
   12994:	83 ec 08             	sub    $0x8,%esp
   12997:	68 6a 02 01 00       	push   $0x1026a
   1299c:	6a 14                	push   $0x14
   1299e:	e8 21 00 00 00       	call   129c4 <irq_install>
   129a3:	83 c4 10             	add    $0x10,%esp

    lidt((uint32_t)idt_table,sizeof(idt_table));
   129a6:	b8 00 52 03 00       	mov    $0x35200,%eax
   129ab:	83 ec 08             	sub    $0x8,%esp
   129ae:	68 00 04 00 00       	push   $0x400
   129b3:	50                   	push   %eax
   129b4:	e8 47 fc ff ff       	call   12600 <lidt>
   129b9:	83 c4 10             	add    $0x10,%esp

	// 初始化8259用于开启中断
	init_pic();
   129bc:	e8 9a fc ff ff       	call   1265b <init_pic>

}
   129c1:	90                   	nop
   129c2:	c9                   	leave  
   129c3:	c3                   	ret    

000129c4 <irq_install>:
/**
 * @brief 安装中断处理函数
 * @param irq_num 中断号
 * @param handler 中断处理函数
 */
int irq_install(int irq_num,irq_handler_t handler){
   129c4:	55                   	push   %ebp
   129c5:	89 e5                	mov    %esp,%ebp
   129c7:	83 ec 08             	sub    $0x8,%esp
    if(irq_num >= IDT_TABLE_NR){
   129ca:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   129ce:	7e 07                	jle    129d7 <irq_install+0x13>
        return -1;
   129d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   129d5:	eb 25                	jmp    129fc <irq_install+0x38>
    }
    gate_desc_set(idt_table+irq_num,KERNEL_SELECTOR_CS,(uint32_t)handler,
   129d7:	8b 45 0c             	mov    0xc(%ebp),%eax
   129da:	8b 55 08             	mov    0x8(%ebp),%edx
   129dd:	c1 e2 03             	shl    $0x3,%edx
   129e0:	81 c2 00 52 03 00    	add    $0x35200,%edx
   129e6:	68 00 8e 00 00       	push   $0x8e00
   129eb:	50                   	push   %eax
   129ec:	6a 08                	push   $0x8
   129ee:	52                   	push   %edx
   129ef:	e8 9e fa ff ff       	call   12492 <gate_desc_set>
   129f4:	83 c4 10             	add    $0x10,%esp
     GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);
    return 0;
   129f7:	b8 00 00 00 00       	mov    $0x0,%eax
}
   129fc:	c9                   	leave  
   129fd:	c3                   	ret    

000129fe <dump_core_regs>:


static void dump_core_regs(exception_frame_t*frame){
   129fe:	55                   	push   %ebp
   129ff:	89 e5                	mov    %esp,%ebp
   12a01:	57                   	push   %edi
   12a02:	56                   	push   %esi
   12a03:	53                   	push   %ebx
   12a04:	83 ec 2c             	sub    $0x2c,%esp
	log_printf("IRQ: %d, error code: %d",frame->num,frame->error_code);
   12a07:	8b 45 08             	mov    0x8(%ebp),%eax
   12a0a:	8b 50 34             	mov    0x34(%eax),%edx
   12a0d:	8b 45 08             	mov    0x8(%ebp),%eax
   12a10:	8b 40 30             	mov    0x30(%eax),%eax
   12a13:	83 ec 04             	sub    $0x4,%esp
   12a16:	52                   	push   %edx
   12a17:	50                   	push   %eax
   12a18:	68 00 8a 01 00       	push   $0x18a00
   12a1d:	e8 a9 5a 00 00       	call   184cb <log_printf>
   12a22:	83 c4 10             	add    $0x10,%esp
	uint32_t ss,esp;
	if(frame->cs & 0x3){
   12a25:	8b 45 08             	mov    0x8(%ebp),%eax
   12a28:	8b 40 3c             	mov    0x3c(%eax),%eax
   12a2b:	83 e0 03             	and    $0x3,%eax
   12a2e:	85 c0                	test   %eax,%eax
   12a30:	74 14                	je     12a46 <dump_core_regs+0x48>
		ss=frame->ss3;
   12a32:	8b 45 08             	mov    0x8(%ebp),%eax
   12a35:	8b 40 48             	mov    0x48(%eax),%eax
   12a38:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		esp=frame->esp3;
   12a3b:	8b 45 08             	mov    0x8(%ebp),%eax
   12a3e:	8b 40 44             	mov    0x44(%eax),%eax
   12a41:	89 45 e0             	mov    %eax,-0x20(%ebp)
   12a44:	eb 12                	jmp    12a58 <dump_core_regs+0x5a>
	}else{
		ss=frame->ds;
   12a46:	8b 45 08             	mov    0x8(%ebp),%eax
   12a49:	8b 40 0c             	mov    0xc(%eax),%eax
   12a4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		esp=frame->esp;
   12a4f:	8b 45 08             	mov    0x8(%ebp),%eax
   12a52:	8b 40 1c             	mov    0x1c(%eax),%eax
   12a55:	89 45 e0             	mov    %eax,-0x20(%ebp)
	}
	log_printf("CS: %d\nDS: %d\nES: %d\nSS: %d\nFS: %d\nGS: %d",
   12a58:	8b 45 08             	mov    0x8(%ebp),%eax
   12a5b:	8b 18                	mov    (%eax),%ebx
   12a5d:	8b 45 08             	mov    0x8(%ebp),%eax
   12a60:	8b 48 08             	mov    0x8(%eax),%ecx
   12a63:	8b 45 08             	mov    0x8(%ebp),%eax
   12a66:	8b 50 0c             	mov    0xc(%eax),%edx
   12a69:	8b 45 08             	mov    0x8(%ebp),%eax
   12a6c:	8b 40 3c             	mov    0x3c(%eax),%eax
   12a6f:	83 ec 08             	sub    $0x8,%esp
   12a72:	53                   	push   %ebx
   12a73:	ff 75 e4             	pushl  -0x1c(%ebp)
   12a76:	51                   	push   %ecx
   12a77:	52                   	push   %edx
   12a78:	50                   	push   %eax
   12a79:	68 18 8a 01 00       	push   $0x18a18
   12a7e:	e8 48 5a 00 00       	call   184cb <log_printf>
   12a83:	83 c4 20             	add    $0x20,%esp
		frame->cs,frame->ds,frame->es,ss,frame->gs
	);
	log_printf("EAX: 0x%x\nEBX: 0x%x\nECX: 0x%x\nEDX: 0x%x\nEDI: 0x%x\nESI: 0x%x\n"
   12a86:	8b 45 08             	mov    0x8(%ebp),%eax
   12a89:	8b 40 18             	mov    0x18(%eax),%eax
   12a8c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   12a8f:	8b 45 08             	mov    0x8(%ebp),%eax
   12a92:	8b 78 14             	mov    0x14(%eax),%edi
   12a95:	8b 45 08             	mov    0x8(%ebp),%eax
   12a98:	8b 70 10             	mov    0x10(%eax),%esi
   12a9b:	8b 45 08             	mov    0x8(%ebp),%eax
   12a9e:	8b 58 24             	mov    0x24(%eax),%ebx
   12aa1:	8b 45 08             	mov    0x8(%ebp),%eax
   12aa4:	8b 48 28             	mov    0x28(%eax),%ecx
   12aa7:	8b 45 08             	mov    0x8(%ebp),%eax
   12aaa:	8b 50 20             	mov    0x20(%eax),%edx
   12aad:	8b 45 08             	mov    0x8(%ebp),%eax
   12ab0:	8b 40 2c             	mov    0x2c(%eax),%eax
   12ab3:	83 ec 0c             	sub    $0xc,%esp
   12ab6:	ff 75 e0             	pushl  -0x20(%ebp)
   12ab9:	ff 75 d4             	pushl  -0x2c(%ebp)
   12abc:	57                   	push   %edi
   12abd:	56                   	push   %esi
   12abe:	53                   	push   %ebx
   12abf:	51                   	push   %ecx
   12ac0:	52                   	push   %edx
   12ac1:	50                   	push   %eax
   12ac2:	68 44 8a 01 00       	push   $0x18a44
   12ac7:	e8 ff 59 00 00       	call   184cb <log_printf>
   12acc:	83 c4 30             	add    $0x30,%esp
	"EBP: 0x%x\nESP: 0x%x",
		frame->eax,frame->ebx,frame->ecx,frame->edx,
		frame->edi,frame->esi,frame->ebp,esp
	);
	log_printf("EIP: 0x%x\nEFLAGS:0x%x\n",frame->eip,frame->eflags);
   12acf:	8b 45 08             	mov    0x8(%ebp),%eax
   12ad2:	8b 50 40             	mov    0x40(%eax),%edx
   12ad5:	8b 45 08             	mov    0x8(%ebp),%eax
   12ad8:	8b 40 38             	mov    0x38(%eax),%eax
   12adb:	83 ec 04             	sub    $0x4,%esp
   12ade:	52                   	push   %edx
   12adf:	50                   	push   %eax
   12ae0:	68 94 8a 01 00       	push   $0x18a94
   12ae5:	e8 e1 59 00 00       	call   184cb <log_printf>
   12aea:	83 c4 10             	add    $0x10,%esp
}
   12aed:	90                   	nop
   12aee:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12af1:	5b                   	pop    %ebx
   12af2:	5e                   	pop    %esi
   12af3:	5f                   	pop    %edi
   12af4:	5d                   	pop    %ebp
   12af5:	c3                   	ret    

00012af6 <do_default_handler>:

static void do_default_handler(exception_frame_t* frame,char* message){
   12af6:	55                   	push   %ebp
   12af7:	89 e5                	mov    %esp,%ebp
   12af9:	83 ec 08             	sub    $0x8,%esp
	log_printf("---------------");
   12afc:	83 ec 0c             	sub    $0xc,%esp
   12aff:	68 ab 8a 01 00       	push   $0x18aab
   12b04:	e8 c2 59 00 00       	call   184cb <log_printf>
   12b09:	83 c4 10             	add    $0x10,%esp
	log_printf("IRQ/Exception happened: %s",message);
   12b0c:	83 ec 08             	sub    $0x8,%esp
   12b0f:	ff 75 0c             	pushl  0xc(%ebp)
   12b12:	68 bb 8a 01 00       	push   $0x18abb
   12b17:	e8 af 59 00 00       	call   184cb <log_printf>
   12b1c:	83 c4 10             	add    $0x10,%esp
	dump_core_regs(frame);
   12b1f:	83 ec 0c             	sub    $0xc,%esp
   12b22:	ff 75 08             	pushl  0x8(%ebp)
   12b25:	e8 d4 fe ff ff       	call   129fe <dump_core_regs>
   12b2a:	83 c4 10             	add    $0x10,%esp
    hlt();
   12b2d:	e8 f6 fa ff ff       	call   12628 <hlt>
}
   12b32:	90                   	nop
   12b33:	c9                   	leave  
   12b34:	c3                   	ret    

00012b35 <do_handler_unknown>:

// 会被对应exception_handler的call调用
void do_handler_unknown(exception_frame_t* frame){
   12b35:	55                   	push   %ebp
   12b36:	89 e5                	mov    %esp,%ebp
   12b38:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"unknown exception");
   12b3b:	83 ec 08             	sub    $0x8,%esp
   12b3e:	68 d6 8a 01 00       	push   $0x18ad6
   12b43:	ff 75 08             	pushl  0x8(%ebp)
   12b46:	e8 ab ff ff ff       	call   12af6 <do_default_handler>
   12b4b:	83 c4 10             	add    $0x10,%esp
}
   12b4e:	90                   	nop
   12b4f:	c9                   	leave  
   12b50:	c3                   	ret    

00012b51 <do_handler_divider>:

void do_handler_divider(exception_frame_t* frame){
   12b51:	55                   	push   %ebp
   12b52:	89 e5                	mov    %esp,%ebp
   12b54:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"Divider exception");
   12b57:	83 ec 08             	sub    $0x8,%esp
   12b5a:	68 e8 8a 01 00       	push   $0x18ae8
   12b5f:	ff 75 08             	pushl  0x8(%ebp)
   12b62:	e8 8f ff ff ff       	call   12af6 <do_default_handler>
   12b67:	83 c4 10             	add    $0x10,%esp
}
   12b6a:	90                   	nop
   12b6b:	c9                   	leave  
   12b6c:	c3                   	ret    

00012b6d <do_handler_Debug>:

void do_handler_Debug(exception_frame_t * frame) {
   12b6d:	55                   	push   %ebp
   12b6e:	89 e5                	mov    %esp,%ebp
   12b70:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Debug Exception");
   12b73:	83 ec 08             	sub    $0x8,%esp
   12b76:	68 fa 8a 01 00       	push   $0x18afa
   12b7b:	ff 75 08             	pushl  0x8(%ebp)
   12b7e:	e8 73 ff ff ff       	call   12af6 <do_default_handler>
   12b83:	83 c4 10             	add    $0x10,%esp
}
   12b86:	90                   	nop
   12b87:	c9                   	leave  
   12b88:	c3                   	ret    

00012b89 <do_handler_NMI>:

void do_handler_NMI(exception_frame_t * frame) {
   12b89:	55                   	push   %ebp
   12b8a:	89 e5                	mov    %esp,%ebp
   12b8c:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "NMI Interrupt.");
   12b8f:	83 ec 08             	sub    $0x8,%esp
   12b92:	68 0a 8b 01 00       	push   $0x18b0a
   12b97:	ff 75 08             	pushl  0x8(%ebp)
   12b9a:	e8 57 ff ff ff       	call   12af6 <do_default_handler>
   12b9f:	83 c4 10             	add    $0x10,%esp
}
   12ba2:	90                   	nop
   12ba3:	c9                   	leave  
   12ba4:	c3                   	ret    

00012ba5 <do_handler_breakpoint>:

void do_handler_breakpoint(exception_frame_t * frame) {
   12ba5:	55                   	push   %ebp
   12ba6:	89 e5                	mov    %esp,%ebp
   12ba8:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Breakpoint.");
   12bab:	83 ec 08             	sub    $0x8,%esp
   12bae:	68 19 8b 01 00       	push   $0x18b19
   12bb3:	ff 75 08             	pushl  0x8(%ebp)
   12bb6:	e8 3b ff ff ff       	call   12af6 <do_default_handler>
   12bbb:	83 c4 10             	add    $0x10,%esp
}
   12bbe:	90                   	nop
   12bbf:	c9                   	leave  
   12bc0:	c3                   	ret    

00012bc1 <do_handler_overflow>:

void do_handler_overflow(exception_frame_t * frame) {
   12bc1:	55                   	push   %ebp
   12bc2:	89 e5                	mov    %esp,%ebp
   12bc4:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Overflow.");
   12bc7:	83 ec 08             	sub    $0x8,%esp
   12bca:	68 25 8b 01 00       	push   $0x18b25
   12bcf:	ff 75 08             	pushl  0x8(%ebp)
   12bd2:	e8 1f ff ff ff       	call   12af6 <do_default_handler>
   12bd7:	83 c4 10             	add    $0x10,%esp
}
   12bda:	90                   	nop
   12bdb:	c9                   	leave  
   12bdc:	c3                   	ret    

00012bdd <do_handler_bound_range>:

void do_handler_bound_range(exception_frame_t * frame) {
   12bdd:	55                   	push   %ebp
   12bde:	89 e5                	mov    %esp,%ebp
   12be0:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "BOUND Range Exceeded.");
   12be3:	83 ec 08             	sub    $0x8,%esp
   12be6:	68 2f 8b 01 00       	push   $0x18b2f
   12beb:	ff 75 08             	pushl  0x8(%ebp)
   12bee:	e8 03 ff ff ff       	call   12af6 <do_default_handler>
   12bf3:	83 c4 10             	add    $0x10,%esp
}
   12bf6:	90                   	nop
   12bf7:	c9                   	leave  
   12bf8:	c3                   	ret    

00012bf9 <do_handler_invalid_opcode>:

void do_handler_invalid_opcode(exception_frame_t * frame) {
   12bf9:	55                   	push   %ebp
   12bfa:	89 e5                	mov    %esp,%ebp
   12bfc:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Invalid Opcode.");
   12bff:	83 ec 08             	sub    $0x8,%esp
   12c02:	68 45 8b 01 00       	push   $0x18b45
   12c07:	ff 75 08             	pushl  0x8(%ebp)
   12c0a:	e8 e7 fe ff ff       	call   12af6 <do_default_handler>
   12c0f:	83 c4 10             	add    $0x10,%esp
}
   12c12:	90                   	nop
   12c13:	c9                   	leave  
   12c14:	c3                   	ret    

00012c15 <do_handler_device_unavailable>:

void do_handler_device_unavailable(exception_frame_t * frame) {
   12c15:	55                   	push   %ebp
   12c16:	89 e5                	mov    %esp,%ebp
   12c18:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Device Not Available.");
   12c1b:	83 ec 08             	sub    $0x8,%esp
   12c1e:	68 55 8b 01 00       	push   $0x18b55
   12c23:	ff 75 08             	pushl  0x8(%ebp)
   12c26:	e8 cb fe ff ff       	call   12af6 <do_default_handler>
   12c2b:	83 c4 10             	add    $0x10,%esp
}
   12c2e:	90                   	nop
   12c2f:	c9                   	leave  
   12c30:	c3                   	ret    

00012c31 <do_handler_double_fault>:

void do_handler_double_fault(exception_frame_t * frame) {
   12c31:	55                   	push   %ebp
   12c32:	89 e5                	mov    %esp,%ebp
   12c34:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Double Fault.");
   12c37:	83 ec 08             	sub    $0x8,%esp
   12c3a:	68 6b 8b 01 00       	push   $0x18b6b
   12c3f:	ff 75 08             	pushl  0x8(%ebp)
   12c42:	e8 af fe ff ff       	call   12af6 <do_default_handler>
   12c47:	83 c4 10             	add    $0x10,%esp
}
   12c4a:	90                   	nop
   12c4b:	c9                   	leave  
   12c4c:	c3                   	ret    

00012c4d <do_handler_invalid_tss>:

void do_handler_invalid_tss(exception_frame_t * frame) {
   12c4d:	55                   	push   %ebp
   12c4e:	89 e5                	mov    %esp,%ebp
   12c50:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Invalid TSS");
   12c53:	83 ec 08             	sub    $0x8,%esp
   12c56:	68 79 8b 01 00       	push   $0x18b79
   12c5b:	ff 75 08             	pushl  0x8(%ebp)
   12c5e:	e8 93 fe ff ff       	call   12af6 <do_default_handler>
   12c63:	83 c4 10             	add    $0x10,%esp
}
   12c66:	90                   	nop
   12c67:	c9                   	leave  
   12c68:	c3                   	ret    

00012c69 <do_handler_segment_not_present>:

void do_handler_segment_not_present(exception_frame_t * frame) {
   12c69:	55                   	push   %ebp
   12c6a:	89 e5                	mov    %esp,%ebp
   12c6c:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Segment Not Present.");
   12c6f:	83 ec 08             	sub    $0x8,%esp
   12c72:	68 85 8b 01 00       	push   $0x18b85
   12c77:	ff 75 08             	pushl  0x8(%ebp)
   12c7a:	e8 77 fe ff ff       	call   12af6 <do_default_handler>
   12c7f:	83 c4 10             	add    $0x10,%esp
}
   12c82:	90                   	nop
   12c83:	c9                   	leave  
   12c84:	c3                   	ret    

00012c85 <do_handler_stack_segment_fault>:

void do_handler_stack_segment_fault(exception_frame_t * frame) {
   12c85:	55                   	push   %ebp
   12c86:	89 e5                	mov    %esp,%ebp
   12c88:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Stack-Segment Fault.");
   12c8b:	83 ec 08             	sub    $0x8,%esp
   12c8e:	68 9a 8b 01 00       	push   $0x18b9a
   12c93:	ff 75 08             	pushl  0x8(%ebp)
   12c96:	e8 5b fe ff ff       	call   12af6 <do_default_handler>
   12c9b:	83 c4 10             	add    $0x10,%esp
}
   12c9e:	90                   	nop
   12c9f:	c9                   	leave  
   12ca0:	c3                   	ret    

00012ca1 <do_handler_general_protection>:

void do_handler_general_protection(exception_frame_t * frame) {
   12ca1:	55                   	push   %ebp
   12ca2:	89 e5                	mov    %esp,%ebp
   12ca4:	83 ec 08             	sub    $0x8,%esp
	log_printf("--------------------------------");
   12ca7:	83 ec 0c             	sub    $0xc,%esp
   12caa:	68 b0 8b 01 00       	push   $0x18bb0
   12caf:	e8 17 58 00 00       	call   184cb <log_printf>
   12cb4:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: General Protection.");
   12cb7:	83 ec 0c             	sub    $0xc,%esp
   12cba:	68 d4 8b 01 00       	push   $0x18bd4
   12cbf:	e8 07 58 00 00       	call   184cb <log_printf>
   12cc4:	83 c4 10             	add    $0x10,%esp
    if (frame->error_code & ERR_EXT) {
   12cc7:	8b 45 08             	mov    0x8(%ebp),%eax
   12cca:	8b 40 34             	mov    0x34(%eax),%eax
   12ccd:	83 e0 01             	and    $0x1,%eax
   12cd0:	85 c0                	test   %eax,%eax
   12cd2:	74 12                	je     12ce6 <do_handler_general_protection+0x45>
        log_printf("the exception occurred during delivery of an "
   12cd4:	83 ec 0c             	sub    $0xc,%esp
   12cd7:	68 00 8c 01 00       	push   $0x18c00
   12cdc:	e8 ea 57 00 00       	call   184cb <log_printf>
   12ce1:	83 c4 10             	add    $0x10,%esp
   12ce4:	eb 10                	jmp    12cf6 <do_handler_general_protection+0x55>
                "event external to the program, such as an interrupt"
                "or an earlier exception.");
    } else {
        log_printf("the exception occurred during delivery of a"
   12ce6:	83 ec 0c             	sub    $0xc,%esp
   12ce9:	68 7c 8c 01 00       	push   $0x18c7c
   12cee:	e8 d8 57 00 00       	call   184cb <log_printf>
   12cf3:	83 c4 10             	add    $0x10,%esp
                    "software interrupt (INT n, INT3, or INTO).");
    }
    
    if (frame->error_code & ERR_IDT) {
   12cf6:	8b 45 08             	mov    0x8(%ebp),%eax
   12cf9:	8b 40 34             	mov    0x34(%eax),%eax
   12cfc:	83 e0 02             	and    $0x2,%eax
   12cff:	85 c0                	test   %eax,%eax
   12d01:	74 12                	je     12d15 <do_handler_general_protection+0x74>
        log_printf("the index portion of the error code refers "
   12d03:	83 ec 0c             	sub    $0xc,%esp
   12d06:	68 d4 8c 01 00       	push   $0x18cd4
   12d0b:	e8 bb 57 00 00       	call   184cb <log_printf>
   12d10:	83 c4 10             	add    $0x10,%esp
   12d13:	eb 10                	jmp    12d25 <do_handler_general_protection+0x84>
                    "to a gate descriptor in the IDT");
    } else {
        log_printf("the index refers to a descriptor in the GDT");
   12d15:	83 ec 0c             	sub    $0xc,%esp
   12d18:	68 20 8d 01 00       	push   $0x18d20
   12d1d:	e8 a9 57 00 00       	call   184cb <log_printf>
   12d22:	83 c4 10             	add    $0x10,%esp
    }
    
    log_printf("segment index: %d", frame->error_code & 0xFFF8);
   12d25:	8b 45 08             	mov    0x8(%ebp),%eax
   12d28:	8b 40 34             	mov    0x34(%eax),%eax
   12d2b:	25 f8 ff 00 00       	and    $0xfff8,%eax
   12d30:	83 ec 08             	sub    $0x8,%esp
   12d33:	50                   	push   %eax
   12d34:	68 4c 8d 01 00       	push   $0x18d4c
   12d39:	e8 8d 57 00 00       	call   184cb <log_printf>
   12d3e:	83 c4 10             	add    $0x10,%esp

    dump_core_regs(frame);
   12d41:	83 ec 0c             	sub    $0xc,%esp
   12d44:	ff 75 08             	pushl  0x8(%ebp)
   12d47:	e8 b2 fc ff ff       	call   129fe <dump_core_regs>
   12d4c:	83 c4 10             	add    $0x10,%esp

	// 判断是否是用户态异常直接退出，如果是内核态异常则陷入死循环
	if(frame->cs & 0x3){
   12d4f:	8b 45 08             	mov    0x8(%ebp),%eax
   12d52:	8b 40 3c             	mov    0x3c(%eax),%eax
   12d55:	83 e0 03             	and    $0x3,%eax
   12d58:	85 c0                	test   %eax,%eax
   12d5a:	74 14                	je     12d70 <do_handler_general_protection+0xcf>
		sys_exit(frame->error_code);
   12d5c:	8b 45 08             	mov    0x8(%ebp),%eax
   12d5f:	8b 40 34             	mov    0x34(%eax),%eax
   12d62:	83 ec 0c             	sub    $0xc,%esp
   12d65:	50                   	push   %eax
   12d66:	e8 90 f3 ff ff       	call   120fb <sys_exit>
   12d6b:	83 c4 10             	add    $0x10,%esp
	else{
		while (1) {
        	hlt();
    	}	
	}
}
   12d6e:	eb 07                	jmp    12d77 <do_handler_general_protection+0xd6>
        	hlt();
   12d70:	e8 b3 f8 ff ff       	call   12628 <hlt>
   12d75:	eb f9                	jmp    12d70 <do_handler_general_protection+0xcf>
}
   12d77:	c9                   	leave  
   12d78:	c3                   	ret    

00012d79 <do_handler_page_fault>:

void do_handler_page_fault(exception_frame_t * frame) {
   12d79:	55                   	push   %ebp
   12d7a:	89 e5                	mov    %esp,%ebp
   12d7c:	83 ec 08             	sub    $0x8,%esp
	log_printf("--------------------------------");
   12d7f:	83 ec 0c             	sub    $0xc,%esp
   12d82:	68 b0 8b 01 00       	push   $0x18bb0
   12d87:	e8 3f 57 00 00       	call   184cb <log_printf>
   12d8c:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: Page fault.");
   12d8f:	83 ec 0c             	sub    $0xc,%esp
   12d92:	68 60 8d 01 00       	push   $0x18d60
   12d97:	e8 2f 57 00 00       	call   184cb <log_printf>
   12d9c:	83 c4 10             	add    $0x10,%esp
    if (frame->error_code & ERR_PAGE_P) {
   12d9f:	8b 45 08             	mov    0x8(%ebp),%eax
   12da2:	8b 40 34             	mov    0x34(%eax),%eax
   12da5:	83 e0 01             	and    $0x1,%eax
   12da8:	85 c0                	test   %eax,%eax
   12daa:	74 18                	je     12dc4 <do_handler_page_fault+0x4b>
        log_printf("\tpage-level protection violation: 0x%x.", read_cr2());
   12dac:	e8 99 f8 ff ff       	call   1264a <read_cr2>
   12db1:	83 ec 08             	sub    $0x8,%esp
   12db4:	50                   	push   %eax
   12db5:	68 84 8d 01 00       	push   $0x18d84
   12dba:	e8 0c 57 00 00       	call   184cb <log_printf>
   12dbf:	83 c4 10             	add    $0x10,%esp
   12dc2:	eb 16                	jmp    12dda <do_handler_page_fault+0x61>
    } else {
         log_printf("\tPage doesn't present 0x%x", read_cr2());
   12dc4:	e8 81 f8 ff ff       	call   1264a <read_cr2>
   12dc9:	83 ec 08             	sub    $0x8,%esp
   12dcc:	50                   	push   %eax
   12dcd:	68 ac 8d 01 00       	push   $0x18dac
   12dd2:	e8 f4 56 00 00       	call   184cb <log_printf>
   12dd7:	83 c4 10             	add    $0x10,%esp
   }
    
    if (frame->error_code & ERR_PAGE_WR) {
   12dda:	8b 45 08             	mov    0x8(%ebp),%eax
   12ddd:	8b 40 34             	mov    0x34(%eax),%eax
   12de0:	83 e0 02             	and    $0x2,%eax
   12de3:	85 c0                	test   %eax,%eax
   12de5:	74 12                	je     12df9 <do_handler_page_fault+0x80>
        log_printf("\tThe access causing the fault was a read.");
   12de7:	83 ec 0c             	sub    $0xc,%esp
   12dea:	68 c8 8d 01 00       	push   $0x18dc8
   12def:	e8 d7 56 00 00       	call   184cb <log_printf>
   12df4:	83 c4 10             	add    $0x10,%esp
   12df7:	eb 10                	jmp    12e09 <do_handler_page_fault+0x90>
    } else {
        log_printf("\tThe access causing the fault was a write.");
   12df9:	83 ec 0c             	sub    $0xc,%esp
   12dfc:	68 f4 8d 01 00       	push   $0x18df4
   12e01:	e8 c5 56 00 00       	call   184cb <log_printf>
   12e06:	83 c4 10             	add    $0x10,%esp
    }
    
    if (frame->error_code & ERR_PAGE_US) {
   12e09:	8b 45 08             	mov    0x8(%ebp),%eax
   12e0c:	8b 40 34             	mov    0x34(%eax),%eax
   12e0f:	83 e0 02             	and    $0x2,%eax
   12e12:	85 c0                	test   %eax,%eax
   12e14:	74 12                	je     12e28 <do_handler_page_fault+0xaf>
        log_printf("\tA supervisor-mode access caused the fault.");
   12e16:	83 ec 0c             	sub    $0xc,%esp
   12e19:	68 20 8e 01 00       	push   $0x18e20
   12e1e:	e8 a8 56 00 00       	call   184cb <log_printf>
   12e23:	83 c4 10             	add    $0x10,%esp
   12e26:	eb 10                	jmp    12e38 <do_handler_page_fault+0xbf>
    } else {
        log_printf("\tA user-mode access caused the fault.");
   12e28:	83 ec 0c             	sub    $0xc,%esp
   12e2b:	68 4c 8e 01 00       	push   $0x18e4c
   12e30:	e8 96 56 00 00       	call   184cb <log_printf>
   12e35:	83 c4 10             	add    $0x10,%esp
    }

    dump_core_regs(frame);
   12e38:	83 ec 0c             	sub    $0xc,%esp
   12e3b:	ff 75 08             	pushl  0x8(%ebp)
   12e3e:	e8 bb fb ff ff       	call   129fe <dump_core_regs>
   12e43:	83 c4 10             	add    $0x10,%esp
    while (1) {
        hlt();
   12e46:	e8 dd f7 ff ff       	call   12628 <hlt>
   12e4b:	eb f9                	jmp    12e46 <do_handler_page_fault+0xcd>

00012e4d <do_handler_fpu_error>:
    }
}

void do_handler_fpu_error(exception_frame_t * frame) {
   12e4d:	55                   	push   %ebp
   12e4e:	89 e5                	mov    %esp,%ebp
   12e50:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "X87 FPU Floating Point Error.");
   12e53:	83 ec 08             	sub    $0x8,%esp
   12e56:	68 72 8e 01 00       	push   $0x18e72
   12e5b:	ff 75 08             	pushl  0x8(%ebp)
   12e5e:	e8 93 fc ff ff       	call   12af6 <do_default_handler>
   12e63:	83 c4 10             	add    $0x10,%esp
}
   12e66:	90                   	nop
   12e67:	c9                   	leave  
   12e68:	c3                   	ret    

00012e69 <do_handler_alignment_check>:

void do_handler_alignment_check(exception_frame_t * frame) {
   12e69:	55                   	push   %ebp
   12e6a:	89 e5                	mov    %esp,%ebp
   12e6c:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Alignment Check.");
   12e6f:	83 ec 08             	sub    $0x8,%esp
   12e72:	68 90 8e 01 00       	push   $0x18e90
   12e77:	ff 75 08             	pushl  0x8(%ebp)
   12e7a:	e8 77 fc ff ff       	call   12af6 <do_default_handler>
   12e7f:	83 c4 10             	add    $0x10,%esp
}
   12e82:	90                   	nop
   12e83:	c9                   	leave  
   12e84:	c3                   	ret    

00012e85 <do_handler_machine_check>:

void do_handler_machine_check(exception_frame_t * frame) {
   12e85:	55                   	push   %ebp
   12e86:	89 e5                	mov    %esp,%ebp
   12e88:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Machine Check.");
   12e8b:	83 ec 08             	sub    $0x8,%esp
   12e8e:	68 a1 8e 01 00       	push   $0x18ea1
   12e93:	ff 75 08             	pushl  0x8(%ebp)
   12e96:	e8 5b fc ff ff       	call   12af6 <do_default_handler>
   12e9b:	83 c4 10             	add    $0x10,%esp
}
   12e9e:	90                   	nop
   12e9f:	c9                   	leave  
   12ea0:	c3                   	ret    

00012ea1 <do_handler_smd_exception>:

void do_handler_smd_exception(exception_frame_t * frame) {
   12ea1:	55                   	push   %ebp
   12ea2:	89 e5                	mov    %esp,%ebp
   12ea4:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "SIMD Floating Point Exception.");
   12ea7:	83 ec 08             	sub    $0x8,%esp
   12eaa:	68 b0 8e 01 00       	push   $0x18eb0
   12eaf:	ff 75 08             	pushl  0x8(%ebp)
   12eb2:	e8 3f fc ff ff       	call   12af6 <do_default_handler>
   12eb7:	83 c4 10             	add    $0x10,%esp
}
   12eba:	90                   	nop
   12ebb:	c9                   	leave  
   12ebc:	c3                   	ret    

00012ebd <do_handler_virtual_exception>:

void do_handler_virtual_exception(exception_frame_t * frame) {
   12ebd:	55                   	push   %ebp
   12ebe:	89 e5                	mov    %esp,%ebp
   12ec0:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Virtualization Exception.");
   12ec3:	83 ec 08             	sub    $0x8,%esp
   12ec6:	68 cf 8e 01 00       	push   $0x18ecf
   12ecb:	ff 75 08             	pushl  0x8(%ebp)
   12ece:	e8 23 fc ff ff       	call   12af6 <do_default_handler>
   12ed3:	83 c4 10             	add    $0x10,%esp
}
   12ed6:	90                   	nop
   12ed7:	c9                   	leave  
   12ed8:	c3                   	ret    

00012ed9 <pic_send_eoi>:

void pic_send_eoi(int irq_num){
   12ed9:	55                   	push   %ebp
   12eda:	89 e5                	mov    %esp,%ebp
	irq_num-=IRQ_PIC_START;
   12edc:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
	if(irq_num >=8){
   12ee0:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12ee4:	7e 0f                	jle    12ef5 <pic_send_eoi+0x1c>
		outb(PIC1_OCW2,PIC_OCW2_EOI);
   12ee6:	6a 20                	push   $0x20
   12ee8:	68 a0 00 00 00       	push   $0xa0
   12eed:	e8 ef f6 ff ff       	call   125e1 <outb>
   12ef2:	83 c4 08             	add    $0x8,%esp
	}
	outb(PIC0_OCW2,PIC_OCW2_EOI);
   12ef5:	6a 20                	push   $0x20
   12ef7:	6a 20                	push   $0x20
   12ef9:	e8 e3 f6 ff ff       	call   125e1 <outb>
   12efe:	83 c4 08             	add    $0x8,%esp
}
   12f01:	90                   	nop
   12f02:	c9                   	leave  
   12f03:	c3                   	ret    

00012f04 <irq_enter_protection>:

/**
 * @brief 进入临界区
 * @return 进入临界区时的状态
 */
irq_state_t irq_enter_protection(void){
   12f04:	55                   	push   %ebp
   12f05:	89 e5                	mov    %esp,%ebp
   12f07:	83 ec 10             	sub    $0x10,%esp
	irq_state_t state=read_eflags();
   12f0a:	e8 20 f7 ff ff       	call   1262f <read_eflags>
   12f0f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	irq_disable_global();
   12f12:	e8 d7 f7 ff ff       	call   126ee <irq_disable_global>
	return state;
   12f17:	8b 45 fc             	mov    -0x4(%ebp),%eax
	
}
   12f1a:	c9                   	leave  
   12f1b:	c3                   	ret    

00012f1c <irq_leave_protection>:

/**
 * @brief 退出临界区
 * @param state 进入临界区时的状态
 */
void irq_leave_protection(irq_state_t state){
   12f1c:	55                   	push   %ebp
   12f1d:	89 e5                	mov    %esp,%ebp
	write_eflags(state);
   12f1f:	ff 75 08             	pushl  0x8(%ebp)
   12f22:	e8 18 f7 ff ff       	call   1263f <write_eflags>
   12f27:	83 c4 04             	add    $0x4,%esp
}
   12f2a:	90                   	nop
   12f2b:	c9                   	leave  
   12f2c:	c3                   	ret    

00012f2d <inb>:
static inline uint8_t inb(uint16_t port){
   12f2d:	55                   	push   %ebp
   12f2e:	89 e5                	mov    %esp,%ebp
   12f30:	83 ec 14             	sub    $0x14,%esp
   12f33:	8b 45 08             	mov    0x8(%ebp),%eax
   12f36:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   12f3a:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   12f3e:	89 c2                	mov    %eax,%edx
   12f40:	ec                   	in     (%dx),%al
   12f41:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   12f44:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   12f48:	c9                   	leave  
   12f49:	c3                   	ret    

00012f4a <outb>:
static inline void outb(uint16_t port,uint8_t data){
   12f4a:	55                   	push   %ebp
   12f4b:	89 e5                	mov    %esp,%ebp
   12f4d:	83 ec 08             	sub    $0x8,%esp
   12f50:	8b 55 08             	mov    0x8(%ebp),%edx
   12f53:	8b 45 0c             	mov    0xc(%ebp),%eax
   12f56:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   12f5a:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   12f5d:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12f61:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   12f65:	ee                   	out    %al,(%dx)
}
   12f66:	90                   	nop
   12f67:	c9                   	leave  
   12f68:	c3                   	ret    

00012f69 <read_cursor_pos>:

/**
 * @brief 读取光标位置
 * @return 光标位置
*/
static int read_cursor_pos(void){
   12f69:	55                   	push   %ebp
   12f6a:	89 e5                	mov    %esp,%ebp
   12f6c:	83 ec 18             	sub    $0x18,%esp
    int pos;

    irq_state_t state=irq_enter_protection();
   12f6f:	e8 90 ff ff ff       	call   12f04 <irq_enter_protection>
   12f74:	89 45 f4             	mov    %eax,-0xc(%ebp)

    outb(0x3D4,0xF);
   12f77:	83 ec 08             	sub    $0x8,%esp
   12f7a:	6a 0f                	push   $0xf
   12f7c:	68 d4 03 00 00       	push   $0x3d4
   12f81:	e8 c4 ff ff ff       	call   12f4a <outb>
   12f86:	83 c4 10             	add    $0x10,%esp
    pos=inb(0x3d5);
   12f89:	83 ec 0c             	sub    $0xc,%esp
   12f8c:	68 d5 03 00 00       	push   $0x3d5
   12f91:	e8 97 ff ff ff       	call   12f2d <inb>
   12f96:	83 c4 10             	add    $0x10,%esp
   12f99:	0f b6 c0             	movzbl %al,%eax
   12f9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    outb(0x3D4,0xE);
   12f9f:	83 ec 08             	sub    $0x8,%esp
   12fa2:	6a 0e                	push   $0xe
   12fa4:	68 d4 03 00 00       	push   $0x3d4
   12fa9:	e8 9c ff ff ff       	call   12f4a <outb>
   12fae:	83 c4 10             	add    $0x10,%esp
    pos |= inb(0x3d5) << 8;
   12fb1:	83 ec 0c             	sub    $0xc,%esp
   12fb4:	68 d5 03 00 00       	push   $0x3d5
   12fb9:	e8 6f ff ff ff       	call   12f2d <inb>
   12fbe:	83 c4 10             	add    $0x10,%esp
   12fc1:	0f b6 c0             	movzbl %al,%eax
   12fc4:	c1 e0 08             	shl    $0x8,%eax
   12fc7:	09 45 f0             	or     %eax,-0x10(%ebp)

    irq_leave_protection(state);
   12fca:	83 ec 0c             	sub    $0xc,%esp
   12fcd:	ff 75 f4             	pushl  -0xc(%ebp)
   12fd0:	e8 47 ff ff ff       	call   12f1c <irq_leave_protection>
   12fd5:	83 c4 10             	add    $0x10,%esp
    return pos;
   12fd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   12fdb:	c9                   	leave  
   12fdc:	c3                   	ret    

00012fdd <update_cursor_pos>:

/**
 * @brief 更新光标位置
 * @param console 要更新光标的console
*/
static int update_cursor_pos(console_t* console){
   12fdd:	55                   	push   %ebp
   12fde:	89 e5                	mov    %esp,%ebp
   12fe0:	83 ec 18             	sub    $0x18,%esp
    int pos = (console - console_buf)*console->display_cols*console->display_rows;
   12fe3:	8b 45 08             	mov    0x8(%ebp),%eax
   12fe6:	ba 00 56 03 00       	mov    $0x35600,%edx
   12feb:	29 d0                	sub    %edx,%eax
   12fed:	c1 f8 03             	sar    $0x3,%eax
   12ff0:	69 c0 c5 4e ec c4    	imul   $0xc4ec4ec5,%eax,%eax
   12ff6:	89 c2                	mov    %eax,%edx
   12ff8:	8b 45 08             	mov    0x8(%ebp),%eax
   12ffb:	8b 40 14             	mov    0x14(%eax),%eax
   12ffe:	0f af d0             	imul   %eax,%edx
   13001:	8b 45 08             	mov    0x8(%ebp),%eax
   13004:	8b 40 10             	mov    0x10(%eax),%eax
   13007:	0f af c2             	imul   %edx,%eax
   1300a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    pos += console->cursor_row * console->display_cols + console->cursor_col;
   1300d:	8b 45 08             	mov    0x8(%ebp),%eax
   13010:	8b 50 08             	mov    0x8(%eax),%edx
   13013:	8b 45 08             	mov    0x8(%ebp),%eax
   13016:	8b 40 14             	mov    0x14(%eax),%eax
   13019:	0f af d0             	imul   %eax,%edx
   1301c:	8b 45 08             	mov    0x8(%ebp),%eax
   1301f:	8b 40 0c             	mov    0xc(%eax),%eax
   13022:	01 d0                	add    %edx,%eax
   13024:	01 45 f4             	add    %eax,-0xc(%ebp)

    irq_state_t state=irq_enter_protection();
   13027:	e8 d8 fe ff ff       	call   12f04 <irq_enter_protection>
   1302c:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // 0xE和0xF分别是光标的高8位和低8位寄存器
    outb(0x3D4,0xF);
   1302f:	83 ec 08             	sub    $0x8,%esp
   13032:	6a 0f                	push   $0xf
   13034:	68 d4 03 00 00       	push   $0x3d4
   13039:	e8 0c ff ff ff       	call   12f4a <outb>
   1303e:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5,(uint8_t)(pos & 0xFF));
   13041:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13044:	0f b6 c0             	movzbl %al,%eax
   13047:	83 ec 08             	sub    $0x8,%esp
   1304a:	50                   	push   %eax
   1304b:	68 d5 03 00 00       	push   $0x3d5
   13050:	e8 f5 fe ff ff       	call   12f4a <outb>
   13055:	83 c4 10             	add    $0x10,%esp
    outb(0x3D4,0xE);
   13058:	83 ec 08             	sub    $0x8,%esp
   1305b:	6a 0e                	push   $0xe
   1305d:	68 d4 03 00 00       	push   $0x3d4
   13062:	e8 e3 fe ff ff       	call   12f4a <outb>
   13067:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5,(uint8_t)((pos >> 8) & 0xFF));
   1306a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1306d:	c1 f8 08             	sar    $0x8,%eax
   13070:	0f b6 c0             	movzbl %al,%eax
   13073:	83 ec 08             	sub    $0x8,%esp
   13076:	50                   	push   %eax
   13077:	68 d5 03 00 00       	push   $0x3d5
   1307c:	e8 c9 fe ff ff       	call   12f4a <outb>
   13081:	83 c4 10             	add    $0x10,%esp

    irq_leave_protection(state);
   13084:	83 ec 0c             	sub    $0xc,%esp
   13087:	ff 75 f0             	pushl  -0x10(%ebp)
   1308a:	e8 8d fe ff ff       	call   12f1c <irq_leave_protection>
   1308f:	83 c4 10             	add    $0x10,%esp

    return pos;
   13092:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13095:	c9                   	leave  
   13096:	c3                   	ret    

00013097 <erase_rows>:

static void erase_rows(console_t*console,int start,int end){
   13097:	55                   	push   %ebp
   13098:	89 e5                	mov    %esp,%ebp
   1309a:	83 ec 10             	sub    $0x10,%esp
    disp_char_t* disp_start=console->disp_base+console->display_cols*start;
   1309d:	8b 45 08             	mov    0x8(%ebp),%eax
   130a0:	8b 50 04             	mov    0x4(%eax),%edx
   130a3:	8b 45 08             	mov    0x8(%ebp),%eax
   130a6:	8b 40 14             	mov    0x14(%eax),%eax
   130a9:	0f af 45 0c          	imul   0xc(%ebp),%eax
   130ad:	01 c0                	add    %eax,%eax
   130af:	01 d0                	add    %edx,%eax
   130b1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    disp_char_t* disp_end=console->disp_base+console->display_cols*(end+1);
   130b4:	8b 45 08             	mov    0x8(%ebp),%eax
   130b7:	8b 50 04             	mov    0x4(%eax),%edx
   130ba:	8b 45 08             	mov    0x8(%ebp),%eax
   130bd:	8b 40 14             	mov    0x14(%eax),%eax
   130c0:	8b 4d 10             	mov    0x10(%ebp),%ecx
   130c3:	83 c1 01             	add    $0x1,%ecx
   130c6:	0f af c1             	imul   %ecx,%eax
   130c9:	01 c0                	add    %eax,%eax
   130cb:	01 d0                	add    %edx,%eax
   130cd:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while(disp_start < disp_end){
   130d0:	eb 4d                	jmp    1311f <erase_rows+0x88>
        disp_start->c=' ';
   130d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   130d5:	c6 00 20             	movb   $0x20,(%eax)
        disp_start->foreground=console->foreground;
   130d8:	8b 45 08             	mov    0x8(%ebp),%eax
   130db:	8b 40 18             	mov    0x18(%eax),%eax
   130de:	c1 e0 04             	shl    $0x4,%eax
   130e1:	c0 f8 04             	sar    $0x4,%al
   130e4:	8b 55 fc             	mov    -0x4(%ebp),%edx
   130e7:	83 e0 0f             	and    $0xf,%eax
   130ea:	89 c1                	mov    %eax,%ecx
   130ec:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   130f0:	83 e0 f0             	and    $0xfffffff0,%eax
   130f3:	09 c8                	or     %ecx,%eax
   130f5:	88 42 01             	mov    %al,0x1(%edx)
        disp_start->background=console->background;
   130f8:	8b 45 08             	mov    0x8(%ebp),%eax
   130fb:	8b 40 1c             	mov    0x1c(%eax),%eax
   130fe:	c1 e0 05             	shl    $0x5,%eax
   13101:	c0 f8 05             	sar    $0x5,%al
   13104:	8b 55 fc             	mov    -0x4(%ebp),%edx
   13107:	83 e0 07             	and    $0x7,%eax
   1310a:	c1 e0 04             	shl    $0x4,%eax
   1310d:	89 c1                	mov    %eax,%ecx
   1310f:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   13113:	83 e0 8f             	and    $0xffffff8f,%eax
   13116:	09 c8                	or     %ecx,%eax
   13118:	88 42 01             	mov    %al,0x1(%edx)

        disp_start++;
   1311b:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
    while(disp_start < disp_end){
   1311f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13122:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   13125:	72 ab                	jb     130d2 <erase_rows+0x3b>
    }
}
   13127:	90                   	nop
   13128:	c9                   	leave  
   13129:	c3                   	ret    

0001312a <scroll_up>:

static void scroll_up(console_t* console,int lines){
   1312a:	55                   	push   %ebp
   1312b:	89 e5                	mov    %esp,%ebp
   1312d:	83 ec 18             	sub    $0x18,%esp
    disp_char_t* dest=console->disp_base;
   13130:	8b 45 08             	mov    0x8(%ebp),%eax
   13133:	8b 40 04             	mov    0x4(%eax),%eax
   13136:	89 45 f4             	mov    %eax,-0xc(%ebp)
    disp_char_t* src=console->disp_base+console->display_cols*lines;
   13139:	8b 45 08             	mov    0x8(%ebp),%eax
   1313c:	8b 50 04             	mov    0x4(%eax),%edx
   1313f:	8b 45 08             	mov    0x8(%ebp),%eax
   13142:	8b 40 14             	mov    0x14(%eax),%eax
   13145:	0f af 45 0c          	imul   0xc(%ebp),%eax
   13149:	01 c0                	add    %eax,%eax
   1314b:	01 d0                	add    %edx,%eax
   1314d:	89 45 f0             	mov    %eax,-0x10(%ebp)

    uint32_t size=(console->display_rows-lines)*console->display_cols*sizeof(disp_char_t);
   13150:	8b 45 08             	mov    0x8(%ebp),%eax
   13153:	8b 40 10             	mov    0x10(%eax),%eax
   13156:	2b 45 0c             	sub    0xc(%ebp),%eax
   13159:	89 c2                	mov    %eax,%edx
   1315b:	8b 45 08             	mov    0x8(%ebp),%eax
   1315e:	8b 40 14             	mov    0x14(%eax),%eax
   13161:	0f af c2             	imul   %edx,%eax
   13164:	01 c0                	add    %eax,%eax
   13166:	89 45 ec             	mov    %eax,-0x14(%ebp)
    kernel_memcpy(dest,src,size);
   13169:	83 ec 04             	sub    $0x4,%esp
   1316c:	ff 75 ec             	pushl  -0x14(%ebp)
   1316f:	ff 75 f0             	pushl  -0x10(%ebp)
   13172:	ff 75 f4             	pushl  -0xc(%ebp)
   13175:	e8 df 4c 00 00       	call   17e59 <kernel_memcpy>
   1317a:	83 c4 10             	add    $0x10,%esp

    erase_rows(console,console->display_rows-lines,console->display_rows-1);
   1317d:	8b 45 08             	mov    0x8(%ebp),%eax
   13180:	8b 40 10             	mov    0x10(%eax),%eax
   13183:	8d 50 ff             	lea    -0x1(%eax),%edx
   13186:	8b 45 08             	mov    0x8(%ebp),%eax
   13189:	8b 40 10             	mov    0x10(%eax),%eax
   1318c:	2b 45 0c             	sub    0xc(%ebp),%eax
   1318f:	83 ec 04             	sub    $0x4,%esp
   13192:	52                   	push   %edx
   13193:	50                   	push   %eax
   13194:	ff 75 08             	pushl  0x8(%ebp)
   13197:	e8 fb fe ff ff       	call   13097 <erase_rows>
   1319c:	83 c4 10             	add    $0x10,%esp
    console->cursor_row-=lines;
   1319f:	8b 45 08             	mov    0x8(%ebp),%eax
   131a2:	8b 40 08             	mov    0x8(%eax),%eax
   131a5:	2b 45 0c             	sub    0xc(%ebp),%eax
   131a8:	89 c2                	mov    %eax,%edx
   131aa:	8b 45 08             	mov    0x8(%ebp),%eax
   131ad:	89 50 08             	mov    %edx,0x8(%eax)
}
   131b0:	90                   	nop
   131b1:	c9                   	leave  
   131b2:	c3                   	ret    

000131b3 <clear_display>:

static void clear_display(console_t*console){
   131b3:	55                   	push   %ebp
   131b4:	89 e5                	mov    %esp,%ebp
   131b6:	83 ec 10             	sub    $0x10,%esp
    int size=console->display_cols*console->display_rows;
   131b9:	8b 45 08             	mov    0x8(%ebp),%eax
   131bc:	8b 50 14             	mov    0x14(%eax),%edx
   131bf:	8b 45 08             	mov    0x8(%ebp),%eax
   131c2:	8b 40 10             	mov    0x10(%eax),%eax
   131c5:	0f af c2             	imul   %edx,%eax
   131c8:	89 45 f4             	mov    %eax,-0xc(%ebp)

    disp_char_t* start=console->disp_base;
   131cb:	8b 45 08             	mov    0x8(%ebp),%eax
   131ce:	8b 40 04             	mov    0x4(%eax),%eax
   131d1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    for(int i=0;i<size;i++,start++){
   131d4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   131db:	eb 51                	jmp    1322e <clear_display+0x7b>
        start->c=' ';
   131dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
   131e0:	c6 00 20             	movb   $0x20,(%eax)
        start->foreground=console->foreground;
   131e3:	8b 45 08             	mov    0x8(%ebp),%eax
   131e6:	8b 40 18             	mov    0x18(%eax),%eax
   131e9:	c1 e0 04             	shl    $0x4,%eax
   131ec:	c0 f8 04             	sar    $0x4,%al
   131ef:	8b 55 fc             	mov    -0x4(%ebp),%edx
   131f2:	83 e0 0f             	and    $0xf,%eax
   131f5:	89 c1                	mov    %eax,%ecx
   131f7:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   131fb:	83 e0 f0             	and    $0xfffffff0,%eax
   131fe:	09 c8                	or     %ecx,%eax
   13200:	88 42 01             	mov    %al,0x1(%edx)
        start->background=console->background; 
   13203:	8b 45 08             	mov    0x8(%ebp),%eax
   13206:	8b 40 1c             	mov    0x1c(%eax),%eax
   13209:	c1 e0 05             	shl    $0x5,%eax
   1320c:	c0 f8 05             	sar    $0x5,%al
   1320f:	8b 55 fc             	mov    -0x4(%ebp),%edx
   13212:	83 e0 07             	and    $0x7,%eax
   13215:	c1 e0 04             	shl    $0x4,%eax
   13218:	89 c1                	mov    %eax,%ecx
   1321a:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   1321e:	83 e0 8f             	and    $0xffffff8f,%eax
   13221:	09 c8                	or     %ecx,%eax
   13223:	88 42 01             	mov    %al,0x1(%edx)
    for(int i=0;i<size;i++,start++){
   13226:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1322a:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   1322e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13231:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   13234:	7c a7                	jl     131dd <clear_display+0x2a>
    }
}
   13236:	90                   	nop
   13237:	c9                   	leave  
   13238:	c3                   	ret    

00013239 <move_to_col0>:

static void move_to_col0(console_t* console){
   13239:	55                   	push   %ebp
   1323a:	89 e5                	mov    %esp,%ebp
    console->cursor_col=0;
   1323c:	8b 45 08             	mov    0x8(%ebp),%eax
   1323f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
   13246:	90                   	nop
   13247:	5d                   	pop    %ebp
   13248:	c3                   	ret    

00013249 <move_next_line>:

static void move_next_line(console_t*console){
   13249:	55                   	push   %ebp
   1324a:	89 e5                	mov    %esp,%ebp
   1324c:	83 ec 08             	sub    $0x8,%esp
    console->cursor_row++;
   1324f:	8b 45 08             	mov    0x8(%ebp),%eax
   13252:	8b 40 08             	mov    0x8(%eax),%eax
   13255:	8d 50 01             	lea    0x1(%eax),%edx
   13258:	8b 45 08             	mov    0x8(%ebp),%eax
   1325b:	89 50 08             	mov    %edx,0x8(%eax)
    if(console->cursor_row >= console->display_rows){
   1325e:	8b 45 08             	mov    0x8(%ebp),%eax
   13261:	8b 50 08             	mov    0x8(%eax),%edx
   13264:	8b 45 08             	mov    0x8(%ebp),%eax
   13267:	8b 40 10             	mov    0x10(%eax),%eax
   1326a:	39 c2                	cmp    %eax,%edx
   1326c:	7c 10                	jl     1327e <move_next_line+0x35>
        scroll_up(console,1);
   1326e:	83 ec 08             	sub    $0x8,%esp
   13271:	6a 01                	push   $0x1
   13273:	ff 75 08             	pushl  0x8(%ebp)
   13276:	e8 af fe ff ff       	call   1312a <scroll_up>
   1327b:	83 c4 10             	add    $0x10,%esp
    }
}
   1327e:	90                   	nop
   1327f:	c9                   	leave  
   13280:	c3                   	ret    

00013281 <move_forward>:

static void move_forward(console_t* console,int n){
   13281:	55                   	push   %ebp
   13282:	89 e5                	mov    %esp,%ebp
   13284:	83 ec 18             	sub    $0x18,%esp
    for(int i=0;i<n;i++){
   13287:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1328e:	eb 5c                	jmp    132ec <move_forward+0x6b>
        if(++console->cursor_col >= console->display_cols){
   13290:	8b 45 08             	mov    0x8(%ebp),%eax
   13293:	8b 40 0c             	mov    0xc(%eax),%eax
   13296:	8d 50 01             	lea    0x1(%eax),%edx
   13299:	8b 45 08             	mov    0x8(%ebp),%eax
   1329c:	89 50 0c             	mov    %edx,0xc(%eax)
   1329f:	8b 45 08             	mov    0x8(%ebp),%eax
   132a2:	8b 50 0c             	mov    0xc(%eax),%edx
   132a5:	8b 45 08             	mov    0x8(%ebp),%eax
   132a8:	8b 40 14             	mov    0x14(%eax),%eax
   132ab:	39 c2                	cmp    %eax,%edx
   132ad:	7c 39                	jl     132e8 <move_forward+0x67>
            console->cursor_row++;
   132af:	8b 45 08             	mov    0x8(%ebp),%eax
   132b2:	8b 40 08             	mov    0x8(%eax),%eax
   132b5:	8d 50 01             	lea    0x1(%eax),%edx
   132b8:	8b 45 08             	mov    0x8(%ebp),%eax
   132bb:	89 50 08             	mov    %edx,0x8(%eax)
            console->cursor_col=0;
   132be:	8b 45 08             	mov    0x8(%ebp),%eax
   132c1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            
            if(console->cursor_row >= console->display_rows){
   132c8:	8b 45 08             	mov    0x8(%ebp),%eax
   132cb:	8b 50 08             	mov    0x8(%eax),%edx
   132ce:	8b 45 08             	mov    0x8(%ebp),%eax
   132d1:	8b 40 10             	mov    0x10(%eax),%eax
   132d4:	39 c2                	cmp    %eax,%edx
   132d6:	7c 10                	jl     132e8 <move_forward+0x67>
                scroll_up(console,1);
   132d8:	83 ec 08             	sub    $0x8,%esp
   132db:	6a 01                	push   $0x1
   132dd:	ff 75 08             	pushl  0x8(%ebp)
   132e0:	e8 45 fe ff ff       	call   1312a <scroll_up>
   132e5:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<n;i++){
   132e8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   132ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
   132ef:	3b 45 0c             	cmp    0xc(%ebp),%eax
   132f2:	7c 9c                	jl     13290 <move_forward+0xf>
            }
        }
    }
}
   132f4:	90                   	nop
   132f5:	c9                   	leave  
   132f6:	c3                   	ret    

000132f7 <move_backword>:

static int move_backword(console_t* console,int n){
   132f7:	55                   	push   %ebp
   132f8:	89 e5                	mov    %esp,%ebp
   132fa:	83 ec 10             	sub    $0x10,%esp
    int status=-1;
   132fd:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
    for(int i=0;i<n;i++){
   13304:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1330b:	eb 55                	jmp    13362 <move_backword+0x6b>
        if(console->cursor_col > 0){
   1330d:	8b 45 08             	mov    0x8(%ebp),%eax
   13310:	8b 40 0c             	mov    0xc(%eax),%eax
   13313:	85 c0                	test   %eax,%eax
   13315:	7e 18                	jle    1332f <move_backword+0x38>
            console->cursor_col--;
   13317:	8b 45 08             	mov    0x8(%ebp),%eax
   1331a:	8b 40 0c             	mov    0xc(%eax),%eax
   1331d:	8d 50 ff             	lea    -0x1(%eax),%edx
   13320:	8b 45 08             	mov    0x8(%ebp),%eax
   13323:	89 50 0c             	mov    %edx,0xc(%eax)
            status=0;
   13326:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1332d:	eb 2f                	jmp    1335e <move_backword+0x67>
        }
        else if(console->cursor_row > 0){
   1332f:	8b 45 08             	mov    0x8(%ebp),%eax
   13332:	8b 40 08             	mov    0x8(%eax),%eax
   13335:	85 c0                	test   %eax,%eax
   13337:	7e 25                	jle    1335e <move_backword+0x67>
            console->cursor_row--;
   13339:	8b 45 08             	mov    0x8(%ebp),%eax
   1333c:	8b 40 08             	mov    0x8(%eax),%eax
   1333f:	8d 50 ff             	lea    -0x1(%eax),%edx
   13342:	8b 45 08             	mov    0x8(%ebp),%eax
   13345:	89 50 08             	mov    %edx,0x8(%eax)
            console->cursor_col=console->display_cols-1;
   13348:	8b 45 08             	mov    0x8(%ebp),%eax
   1334b:	8b 40 14             	mov    0x14(%eax),%eax
   1334e:	8d 50 ff             	lea    -0x1(%eax),%edx
   13351:	8b 45 08             	mov    0x8(%ebp),%eax
   13354:	89 50 0c             	mov    %edx,0xc(%eax)
            status=0;
   13357:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for(int i=0;i<n;i++){
   1335e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   13362:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13365:	3b 45 0c             	cmp    0xc(%ebp),%eax
   13368:	7c a3                	jl     1330d <move_backword+0x16>
        }

    }
    
    return status;
   1336a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1336d:	c9                   	leave  
   1336e:	c3                   	ret    

0001336f <console_init>:


int console_init(int idx){
   1336f:	55                   	push   %ebp
   13370:	89 e5                	mov    %esp,%ebp
   13372:	83 ec 18             	sub    $0x18,%esp

    console_t* console=console_buf+idx;
   13375:	8b 45 08             	mov    0x8(%ebp),%eax
   13378:	6b c0 68             	imul   $0x68,%eax,%eax
   1337b:	05 00 56 03 00       	add    $0x35600,%eax
   13380:	89 45 f4             	mov    %eax,-0xc(%ebp)

    console->display_cols=CONSOLE_COL_MAX;
   13383:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13386:	c7 40 14 50 00 00 00 	movl   $0x50,0x14(%eax)
    console->display_rows=CONSOLE_ROW_MAX;
   1338d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13390:	c7 40 10 19 00 00 00 	movl   $0x19,0x10(%eax)
    console->disp_base=(disp_char_t*)CONSOLE_DISP_ADDR+idx*(CONSOLE_COL_MAX*CONSOLE_ROW_MAX);
   13397:	8b 45 08             	mov    0x8(%ebp),%eax
   1339a:	69 c0 a0 0f 00 00    	imul   $0xfa0,%eax,%eax
   133a0:	8d 90 00 80 0b 00    	lea    0xb8000(%eax),%edx
   133a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   133a9:	89 50 04             	mov    %edx,0x4(%eax)

    console->foreground=WHITE;
   133ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
   133af:	c7 40 18 0f 00 00 00 	movl   $0xf,0x18(%eax)
    console->background=BLACK;
   133b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   133b9:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

    if(idx==0){
   133c0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   133c4:	75 30                	jne    133f6 <console_init+0x87>
        int cursor_pos=read_cursor_pos();
   133c6:	e8 9e fb ff ff       	call   12f69 <read_cursor_pos>
   133cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
        console->cursor_row=cursor_pos / console->display_cols;        
   133ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
   133d1:	8b 48 14             	mov    0x14(%eax),%ecx
   133d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   133d7:	99                   	cltd   
   133d8:	f7 f9                	idiv   %ecx
   133da:	89 c2                	mov    %eax,%edx
   133dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   133df:	89 50 08             	mov    %edx,0x8(%eax)
        console->cursor_col=cursor_pos % console->display_cols;
   133e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   133e5:	8b 48 14             	mov    0x14(%eax),%ecx
   133e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   133eb:	99                   	cltd   
   133ec:	f7 f9                	idiv   %ecx
   133ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
   133f1:	89 50 0c             	mov    %edx,0xc(%eax)
   133f4:	eb 22                	jmp    13418 <console_init+0xa9>
    }
    else{
        console->cursor_row=0;
   133f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   133f9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        console->cursor_col=0;
   13400:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13403:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
        clear_display(console);
   1340a:	83 ec 0c             	sub    $0xc,%esp
   1340d:	ff 75 f4             	pushl  -0xc(%ebp)
   13410:	e8 9e fd ff ff       	call   131b3 <clear_display>
   13415:	83 c4 10             	add    $0x10,%esp
    }

    console->old_cursor_col=console->cursor_col;
   13418:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1341b:	8b 50 0c             	mov    0xc(%eax),%edx
   1341e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13421:	89 50 20             	mov    %edx,0x20(%eax)
    console->old_cursor_row=console->cursor_row;
   13424:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13427:	8b 50 08             	mov    0x8(%eax),%edx
   1342a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1342d:	89 50 24             	mov    %edx,0x24(%eax)

    console->write_state=CONSOLE_WRITE_NORMAL; 
   13430:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13433:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    mutex_init(&console->mutex);
   13439:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1343c:	83 c0 54             	add    $0x54,%eax
   1343f:	83 ec 0c             	sub    $0xc,%esp
   13442:	50                   	push   %eax
   13443:	e8 68 43 00 00       	call   177b0 <mutex_init>
   13448:	83 c4 10             	add    $0x10,%esp
    return 0;
   1344b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13450:	c9                   	leave  
   13451:	c3                   	ret    

00013452 <show_char>:

static void show_char(console_t* console,char c){
   13452:	55                   	push   %ebp
   13453:	89 e5                	mov    %esp,%ebp
   13455:	83 ec 28             	sub    $0x28,%esp
   13458:	8b 45 0c             	mov    0xc(%ebp),%eax
   1345b:	88 45 e4             	mov    %al,-0x1c(%ebp)
    int offset=console->cursor_col+console->cursor_row*console->display_cols;
   1345e:	8b 45 08             	mov    0x8(%ebp),%eax
   13461:	8b 50 0c             	mov    0xc(%eax),%edx
   13464:	8b 45 08             	mov    0x8(%ebp),%eax
   13467:	8b 48 08             	mov    0x8(%eax),%ecx
   1346a:	8b 45 08             	mov    0x8(%ebp),%eax
   1346d:	8b 40 14             	mov    0x14(%eax),%eax
   13470:	0f af c1             	imul   %ecx,%eax
   13473:	01 d0                	add    %edx,%eax
   13475:	89 45 f4             	mov    %eax,-0xc(%ebp)
    disp_char_t* p=console->disp_base+offset;
   13478:	8b 45 08             	mov    0x8(%ebp),%eax
   1347b:	8b 40 04             	mov    0x4(%eax),%eax
   1347e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   13481:	01 d2                	add    %edx,%edx
   13483:	01 d0                	add    %edx,%eax
   13485:	89 45 f0             	mov    %eax,-0x10(%ebp)
    p->c=c;
   13488:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1348b:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
   1348f:	88 10                	mov    %dl,(%eax)
    p->foreground=console->foreground;
   13491:	8b 45 08             	mov    0x8(%ebp),%eax
   13494:	8b 40 18             	mov    0x18(%eax),%eax
   13497:	c1 e0 04             	shl    $0x4,%eax
   1349a:	c0 f8 04             	sar    $0x4,%al
   1349d:	8b 55 f0             	mov    -0x10(%ebp),%edx
   134a0:	83 e0 0f             	and    $0xf,%eax
   134a3:	89 c1                	mov    %eax,%ecx
   134a5:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   134a9:	83 e0 f0             	and    $0xfffffff0,%eax
   134ac:	09 c8                	or     %ecx,%eax
   134ae:	88 42 01             	mov    %al,0x1(%edx)
    p->background=console->background;
   134b1:	8b 45 08             	mov    0x8(%ebp),%eax
   134b4:	8b 40 1c             	mov    0x1c(%eax),%eax
   134b7:	c1 e0 05             	shl    $0x5,%eax
   134ba:	c0 f8 05             	sar    $0x5,%al
   134bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
   134c0:	83 e0 07             	and    $0x7,%eax
   134c3:	c1 e0 04             	shl    $0x4,%eax
   134c6:	89 c1                	mov    %eax,%ecx
   134c8:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   134cc:	83 e0 8f             	and    $0xffffff8f,%eax
   134cf:	09 c8                	or     %ecx,%eax
   134d1:	88 42 01             	mov    %al,0x1(%edx)
    move_forward(console,1);
   134d4:	83 ec 08             	sub    $0x8,%esp
   134d7:	6a 01                	push   $0x1
   134d9:	ff 75 08             	pushl  0x8(%ebp)
   134dc:	e8 a0 fd ff ff       	call   13281 <move_forward>
   134e1:	83 c4 10             	add    $0x10,%esp
}
   134e4:	90                   	nop
   134e5:	c9                   	leave  
   134e6:	c3                   	ret    

000134e7 <erase_backword>:

static void erase_backword(console_t*console){
   134e7:	55                   	push   %ebp
   134e8:	89 e5                	mov    %esp,%ebp
   134ea:	83 ec 08             	sub    $0x8,%esp
    if(move_backword(console,1)==0){
   134ed:	6a 01                	push   $0x1
   134ef:	ff 75 08             	pushl  0x8(%ebp)
   134f2:	e8 00 fe ff ff       	call   132f7 <move_backword>
   134f7:	83 c4 08             	add    $0x8,%esp
   134fa:	85 c0                	test   %eax,%eax
   134fc:	75 20                	jne    1351e <erase_backword+0x37>
        show_char(console,' ');
   134fe:	83 ec 08             	sub    $0x8,%esp
   13501:	6a 20                	push   $0x20
   13503:	ff 75 08             	pushl  0x8(%ebp)
   13506:	e8 47 ff ff ff       	call   13452 <show_char>
   1350b:	83 c4 10             	add    $0x10,%esp
        move_backword(console,1);
   1350e:	83 ec 08             	sub    $0x8,%esp
   13511:	6a 01                	push   $0x1
   13513:	ff 75 08             	pushl  0x8(%ebp)
   13516:	e8 dc fd ff ff       	call   132f7 <move_backword>
   1351b:	83 c4 10             	add    $0x10,%esp
    }

}
   1351e:	90                   	nop
   1351f:	c9                   	leave  
   13520:	c3                   	ret    

00013521 <save_cursor>:

static void save_cursor(console_t* console){
   13521:	55                   	push   %ebp
   13522:	89 e5                	mov    %esp,%ebp
    console->old_cursor_col=console->cursor_col;
   13524:	8b 45 08             	mov    0x8(%ebp),%eax
   13527:	8b 50 0c             	mov    0xc(%eax),%edx
   1352a:	8b 45 08             	mov    0x8(%ebp),%eax
   1352d:	89 50 20             	mov    %edx,0x20(%eax)
    console->old_cursor_row=console->cursor_row;
   13530:	8b 45 08             	mov    0x8(%ebp),%eax
   13533:	8b 50 08             	mov    0x8(%eax),%edx
   13536:	8b 45 08             	mov    0x8(%ebp),%eax
   13539:	89 50 24             	mov    %edx,0x24(%eax)
}
   1353c:	90                   	nop
   1353d:	5d                   	pop    %ebp
   1353e:	c3                   	ret    

0001353f <restore_cursor>:

static void restore_cursor(console_t* console){
   1353f:	55                   	push   %ebp
   13540:	89 e5                	mov    %esp,%ebp
    console->cursor_col=console->old_cursor_col;
   13542:	8b 45 08             	mov    0x8(%ebp),%eax
   13545:	8b 50 20             	mov    0x20(%eax),%edx
   13548:	8b 45 08             	mov    0x8(%ebp),%eax
   1354b:	89 50 0c             	mov    %edx,0xc(%eax)
    console->cursor_row=console->old_cursor_row;
   1354e:	8b 45 08             	mov    0x8(%ebp),%eax
   13551:	8b 50 24             	mov    0x24(%eax),%edx
   13554:	8b 45 08             	mov    0x8(%ebp),%eax
   13557:	89 50 08             	mov    %edx,0x8(%eax)
}
   1355a:	90                   	nop
   1355b:	5d                   	pop    %ebp
   1355c:	c3                   	ret    

0001355d <clear_esc_param>:

static void clear_esc_param(console_t* console){
   1355d:	55                   	push   %ebp
   1355e:	89 e5                	mov    %esp,%ebp
   13560:	83 ec 08             	sub    $0x8,%esp
    kernel_memset(console->esc_param,0,sizeof(console->esc_param));
   13563:	8b 45 08             	mov    0x8(%ebp),%eax
   13566:	83 c0 28             	add    $0x28,%eax
   13569:	83 ec 04             	sub    $0x4,%esp
   1356c:	6a 28                	push   $0x28
   1356e:	6a 00                	push   $0x0
   13570:	50                   	push   %eax
   13571:	e8 32 49 00 00       	call   17ea8 <kernel_memset>
   13576:	83 c4 10             	add    $0x10,%esp
    console->curr_param_index=0;
   13579:	8b 45 08             	mov    0x8(%ebp),%eax
   1357c:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
}
   13583:	90                   	nop
   13584:	c9                   	leave  
   13585:	c3                   	ret    

00013586 <write_esc>:

static void write_esc(console_t* console,char c){
   13586:	55                   	push   %ebp
   13587:	89 e5                	mov    %esp,%ebp
   13589:	83 ec 18             	sub    $0x18,%esp
   1358c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1358f:	88 45 f4             	mov    %al,-0xc(%ebp)
    switch (c)
   13592:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   13596:	83 f8 38             	cmp    $0x38,%eax
   13599:	74 20                	je     135bb <write_esc+0x35>
   1359b:	83 f8 5b             	cmp    $0x5b,%eax
   1359e:	74 31                	je     135d1 <write_esc+0x4b>
   135a0:	83 f8 37             	cmp    $0x37,%eax
   135a3:	75 45                	jne    135ea <write_esc+0x64>
    {
    case '7':
        save_cursor(console);
   135a5:	ff 75 08             	pushl  0x8(%ebp)
   135a8:	e8 74 ff ff ff       	call   13521 <save_cursor>
   135ad:	83 c4 04             	add    $0x4,%esp
        console->write_state=CONSOLE_WRITE_NORMAL;
   135b0:	8b 45 08             	mov    0x8(%ebp),%eax
   135b3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        break;
   135b9:	eb 39                	jmp    135f4 <write_esc+0x6e>
    case '8':
        restore_cursor(console);
   135bb:	ff 75 08             	pushl  0x8(%ebp)
   135be:	e8 7c ff ff ff       	call   1353f <restore_cursor>
   135c3:	83 c4 04             	add    $0x4,%esp
        console->write_state=CONSOLE_WRITE_NORMAL;
   135c6:	8b 45 08             	mov    0x8(%ebp),%eax
   135c9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        break;
   135cf:	eb 23                	jmp    135f4 <write_esc+0x6e>
    case '[':
        clear_esc_param(console);
   135d1:	83 ec 0c             	sub    $0xc,%esp
   135d4:	ff 75 08             	pushl  0x8(%ebp)
   135d7:	e8 81 ff ff ff       	call   1355d <clear_esc_param>
   135dc:	83 c4 10             	add    $0x10,%esp
        console->write_state=CONSOLE_WRITE_SQUARE;
   135df:	8b 45 08             	mov    0x8(%ebp),%eax
   135e2:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        break;
   135e8:	eb 0a                	jmp    135f4 <write_esc+0x6e>
    default:
        console->write_state=CONSOLE_WRITE_NORMAL;
   135ea:	8b 45 08             	mov    0x8(%ebp),%eax
   135ed:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        break;
   135f3:	90                   	nop
    }
}
   135f4:	90                   	nop
   135f5:	c9                   	leave  
   135f6:	c3                   	ret    

000135f7 <set_font_style>:

static void set_font_style(console_t* console){
   135f7:	55                   	push   %ebp
   135f8:	89 e5                	mov    %esp,%ebp
   135fa:	83 ec 10             	sub    $0x10,%esp
    static const color_t color_table[]={
        BLACK,RED,GREEN,YELLOW,BLUE,
        MAGENTA,CYAN,WHITE
    };

    for(int i=0;i<=console->curr_param_index;i++){
   135fd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   13604:	eb 78                	jmp    1367e <set_font_style+0x87>
        int param=console->esc_param[i];
   13606:	8b 45 08             	mov    0x8(%ebp),%eax
   13609:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1360c:	83 c2 08             	add    $0x8,%edx
   1360f:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   13613:	89 45 f8             	mov    %eax,-0x8(%ebp)
        if((param>=30) && (param <= 37)){
   13616:	83 7d f8 1d          	cmpl   $0x1d,-0x8(%ebp)
   1361a:	7e 1b                	jle    13637 <set_font_style+0x40>
   1361c:	83 7d f8 25          	cmpl   $0x25,-0x8(%ebp)
   13620:	7f 15                	jg     13637 <set_font_style+0x40>
            console->foreground=color_table[param-30];
   13622:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13625:	83 e8 1e             	sub    $0x1e,%eax
   13628:	8b 14 85 c0 8f 01 00 	mov    0x18fc0(,%eax,4),%edx
   1362f:	8b 45 08             	mov    0x8(%ebp),%eax
   13632:	89 50 18             	mov    %edx,0x18(%eax)
   13635:	eb 43                	jmp    1367a <set_font_style+0x83>
        }
        else if((param >= 40)&&(param <= 47)){
   13637:	83 7d f8 27          	cmpl   $0x27,-0x8(%ebp)
   1363b:	7e 1b                	jle    13658 <set_font_style+0x61>
   1363d:	83 7d f8 2f          	cmpl   $0x2f,-0x8(%ebp)
   13641:	7f 15                	jg     13658 <set_font_style+0x61>
            console->background=color_table[param-40];
   13643:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13646:	83 e8 28             	sub    $0x28,%eax
   13649:	8b 14 85 c0 8f 01 00 	mov    0x18fc0(,%eax,4),%edx
   13650:	8b 45 08             	mov    0x8(%ebp),%eax
   13653:	89 50 1c             	mov    %edx,0x1c(%eax)
   13656:	eb 22                	jmp    1367a <set_font_style+0x83>
        }
        else if(param == 39){
   13658:	83 7d f8 27          	cmpl   $0x27,-0x8(%ebp)
   1365c:	75 0c                	jne    1366a <set_font_style+0x73>
            console->foreground=WHITE;
   1365e:	8b 45 08             	mov    0x8(%ebp),%eax
   13661:	c7 40 18 0f 00 00 00 	movl   $0xf,0x18(%eax)
   13668:	eb 10                	jmp    1367a <set_font_style+0x83>
        }
        else if(param == 49){
   1366a:	83 7d f8 31          	cmpl   $0x31,-0x8(%ebp)
   1366e:	75 0a                	jne    1367a <set_font_style+0x83>
            console->background=BLACK;
   13670:	8b 45 08             	mov    0x8(%ebp),%eax
   13673:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    for(int i=0;i<=console->curr_param_index;i++){
   1367a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1367e:	8b 45 08             	mov    0x8(%ebp),%eax
   13681:	8b 40 50             	mov    0x50(%eax),%eax
   13684:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   13687:	0f 8e 79 ff ff ff    	jle    13606 <set_font_style+0xf>
        }
    }

}
   1368d:	90                   	nop
   1368e:	c9                   	leave  
   1368f:	c3                   	ret    

00013690 <erase_in_display>:

static void erase_in_display(console_t* console){
   13690:	55                   	push   %ebp
   13691:	89 e5                	mov    %esp,%ebp
   13693:	83 ec 10             	sub    $0x10,%esp
    if(console->curr_param_index < 0){
   13696:	8b 45 08             	mov    0x8(%ebp),%eax
   13699:	8b 40 50             	mov    0x50(%eax),%eax
   1369c:	85 c0                	test   %eax,%eax
   1369e:	78 3e                	js     136de <erase_in_display+0x4e>
        return;
    }

    int param=console->esc_param[0];
   136a0:	8b 45 08             	mov    0x8(%ebp),%eax
   136a3:	8b 40 28             	mov    0x28(%eax),%eax
   136a6:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if(param==2){
   136a9:	83 7d fc 02          	cmpl   $0x2,-0x4(%ebp)
   136ad:	75 30                	jne    136df <erase_in_display+0x4f>
        erase_rows(console,0,console->display_cols-1);
   136af:	8b 45 08             	mov    0x8(%ebp),%eax
   136b2:	8b 40 14             	mov    0x14(%eax),%eax
   136b5:	83 e8 01             	sub    $0x1,%eax
   136b8:	50                   	push   %eax
   136b9:	6a 00                	push   $0x0
   136bb:	ff 75 08             	pushl  0x8(%ebp)
   136be:	e8 d4 f9 ff ff       	call   13097 <erase_rows>
   136c3:	83 c4 0c             	add    $0xc,%esp
        console->cursor_col=console->cursor_row=0;
   136c6:	8b 45 08             	mov    0x8(%ebp),%eax
   136c9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   136d0:	8b 45 08             	mov    0x8(%ebp),%eax
   136d3:	8b 50 08             	mov    0x8(%eax),%edx
   136d6:	8b 45 08             	mov    0x8(%ebp),%eax
   136d9:	89 50 0c             	mov    %edx,0xc(%eax)
   136dc:	eb 01                	jmp    136df <erase_in_display+0x4f>
        return;
   136de:	90                   	nop
    }

}
   136df:	c9                   	leave  
   136e0:	c3                   	ret    

000136e1 <move_cursor>:

static void move_cursor(console_t* console){
   136e1:	55                   	push   %ebp
   136e2:	89 e5                	mov    %esp,%ebp
    console->cursor_row=console->esc_param[0];
   136e4:	8b 45 08             	mov    0x8(%ebp),%eax
   136e7:	8b 50 28             	mov    0x28(%eax),%edx
   136ea:	8b 45 08             	mov    0x8(%ebp),%eax
   136ed:	89 50 08             	mov    %edx,0x8(%eax)
    console->cursor_col=console->esc_param[1];
   136f0:	8b 45 08             	mov    0x8(%ebp),%eax
   136f3:	8b 50 2c             	mov    0x2c(%eax),%edx
   136f6:	8b 45 08             	mov    0x8(%ebp),%eax
   136f9:	89 50 0c             	mov    %edx,0xc(%eax)
}
   136fc:	90                   	nop
   136fd:	5d                   	pop    %ebp
   136fe:	c3                   	ret    

000136ff <move_left>:

static void move_left(console_t* console,int n){
   136ff:	55                   	push   %ebp
   13700:	89 e5                	mov    %esp,%ebp
   13702:	83 ec 10             	sub    $0x10,%esp
    if(n==0){
   13705:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13709:	75 07                	jne    13712 <move_left+0x13>
        n=1;
   1370b:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
    }

    int col=console->cursor_col-n;
   13712:	8b 45 08             	mov    0x8(%ebp),%eax
   13715:	8b 40 0c             	mov    0xc(%eax),%eax
   13718:	2b 45 0c             	sub    0xc(%ebp),%eax
   1371b:	89 45 fc             	mov    %eax,-0x4(%ebp)

    console->cursor_col=(col>=0)?col:0;
   1371e:	b8 00 00 00 00       	mov    $0x0,%eax
   13723:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   13727:	0f 49 45 fc          	cmovns -0x4(%ebp),%eax
   1372b:	89 c2                	mov    %eax,%edx
   1372d:	8b 45 08             	mov    0x8(%ebp),%eax
   13730:	89 50 0c             	mov    %edx,0xc(%eax)
}
   13733:	90                   	nop
   13734:	c9                   	leave  
   13735:	c3                   	ret    

00013736 <move_right>:

static void move_right(console_t* console,int n){
   13736:	55                   	push   %ebp
   13737:	89 e5                	mov    %esp,%ebp
   13739:	83 ec 10             	sub    $0x10,%esp
    if(n==0){
   1373c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13740:	75 07                	jne    13749 <move_right+0x13>
        n=1;
   13742:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
    }

    int col=console->cursor_col+n;
   13749:	8b 45 08             	mov    0x8(%ebp),%eax
   1374c:	8b 50 0c             	mov    0xc(%eax),%edx
   1374f:	8b 45 0c             	mov    0xc(%ebp),%eax
   13752:	01 d0                	add    %edx,%eax
   13754:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if(col >= console->display_cols){
   13757:	8b 45 08             	mov    0x8(%ebp),%eax
   1375a:	8b 40 14             	mov    0x14(%eax),%eax
   1375d:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   13760:	7c 11                	jl     13773 <move_right+0x3d>
        console->cursor_col=console->display_cols-1;
   13762:	8b 45 08             	mov    0x8(%ebp),%eax
   13765:	8b 40 14             	mov    0x14(%eax),%eax
   13768:	8d 50 ff             	lea    -0x1(%eax),%edx
   1376b:	8b 45 08             	mov    0x8(%ebp),%eax
   1376e:	89 50 0c             	mov    %edx,0xc(%eax)
    }
    else{
        console->cursor_col=col;
    }
}
   13771:	eb 09                	jmp    1377c <move_right+0x46>
        console->cursor_col=col;
   13773:	8b 45 08             	mov    0x8(%ebp),%eax
   13776:	8b 55 fc             	mov    -0x4(%ebp),%edx
   13779:	89 50 0c             	mov    %edx,0xc(%eax)
}
   1377c:	90                   	nop
   1377d:	c9                   	leave  
   1377e:	c3                   	ret    

0001377f <write_esc_square>:

static void write_esc_square(console_t* console,char c){
   1377f:	55                   	push   %ebp
   13780:	89 e5                	mov    %esp,%ebp
   13782:	83 ec 14             	sub    $0x14,%esp
   13785:	8b 45 0c             	mov    0xc(%ebp),%eax
   13788:	88 45 ec             	mov    %al,-0x14(%ebp)
    if((c>='0') && (c<='9')){
   1378b:	80 7d ec 2f          	cmpb   $0x2f,-0x14(%ebp)
   1378f:	7e 44                	jle    137d5 <write_esc_square+0x56>
   13791:	80 7d ec 39          	cmpb   $0x39,-0x14(%ebp)
   13795:	7f 3e                	jg     137d5 <write_esc_square+0x56>
        int *param=&console->esc_param[console->curr_param_index];
   13797:	8b 45 08             	mov    0x8(%ebp),%eax
   1379a:	8b 40 50             	mov    0x50(%eax),%eax
   1379d:	83 c0 08             	add    $0x8,%eax
   137a0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   137a7:	8b 45 08             	mov    0x8(%ebp),%eax
   137aa:	01 d0                	add    %edx,%eax
   137ac:	83 c0 08             	add    $0x8,%eax
   137af:	89 45 fc             	mov    %eax,-0x4(%ebp)
        *param=*param*10+c-'0';
   137b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   137b5:	8b 10                	mov    (%eax),%edx
   137b7:	89 d0                	mov    %edx,%eax
   137b9:	c1 e0 02             	shl    $0x2,%eax
   137bc:	01 d0                	add    %edx,%eax
   137be:	01 c0                	add    %eax,%eax
   137c0:	89 c2                	mov    %eax,%edx
   137c2:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
   137c6:	01 d0                	add    %edx,%eax
   137c8:	8d 50 d0             	lea    -0x30(%eax),%edx
   137cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   137ce:	89 10                	mov    %edx,(%eax)
    if((c>='0') && (c<='9')){
   137d0:	e9 9b 00 00 00       	jmp    13870 <write_esc_square+0xf1>
    }
    else if((c==';') && (console->curr_param_index < ESC_PARAM_MAX)){
   137d5:	80 7d ec 3b          	cmpb   $0x3b,-0x14(%ebp)
   137d9:	75 1c                	jne    137f7 <write_esc_square+0x78>
   137db:	8b 45 08             	mov    0x8(%ebp),%eax
   137de:	8b 40 50             	mov    0x50(%eax),%eax
   137e1:	83 f8 09             	cmp    $0x9,%eax
   137e4:	7f 11                	jg     137f7 <write_esc_square+0x78>
        console->curr_param_index++;
   137e6:	8b 45 08             	mov    0x8(%ebp),%eax
   137e9:	8b 40 50             	mov    0x50(%eax),%eax
   137ec:	8d 50 01             	lea    0x1(%eax),%edx
   137ef:	8b 45 08             	mov    0x8(%ebp),%eax
   137f2:	89 50 50             	mov    %edx,0x50(%eax)
   137f5:	eb 79                	jmp    13870 <write_esc_square+0xf1>
    }
    else{
        switch(c){
   137f7:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
   137fb:	83 e8 43             	sub    $0x43,%eax
   137fe:	83 f8 2a             	cmp    $0x2a,%eax
   13801:	77 63                	ja     13866 <write_esc_square+0xe7>
   13803:	8b 04 85 00 8f 01 00 	mov    0x18f00(,%eax,4),%eax
   1380a:	ff e0                	jmp    *%eax
            case 'm':
                set_font_style(console);
   1380c:	ff 75 08             	pushl  0x8(%ebp)
   1380f:	e8 e3 fd ff ff       	call   135f7 <set_font_style>
   13814:	83 c4 04             	add    $0x4,%esp
                break;
   13817:	eb 4e                	jmp    13867 <write_esc_square+0xe8>
            case 'D':
                move_left(console,console->esc_param[0]);
   13819:	8b 45 08             	mov    0x8(%ebp),%eax
   1381c:	8b 40 28             	mov    0x28(%eax),%eax
   1381f:	50                   	push   %eax
   13820:	ff 75 08             	pushl  0x8(%ebp)
   13823:	e8 d7 fe ff ff       	call   136ff <move_left>
   13828:	83 c4 08             	add    $0x8,%esp
                break;
   1382b:	eb 3a                	jmp    13867 <write_esc_square+0xe8>
            case 'C':
                move_right(console,console->esc_param[0]);
   1382d:	8b 45 08             	mov    0x8(%ebp),%eax
   13830:	8b 40 28             	mov    0x28(%eax),%eax
   13833:	50                   	push   %eax
   13834:	ff 75 08             	pushl  0x8(%ebp)
   13837:	e8 fa fe ff ff       	call   13736 <move_right>
   1383c:	83 c4 08             	add    $0x8,%esp
                break;
   1383f:	eb 26                	jmp    13867 <write_esc_square+0xe8>
            case 'H':
                move_cursor(console);
   13841:	ff 75 08             	pushl  0x8(%ebp)
   13844:	e8 98 fe ff ff       	call   136e1 <move_cursor>
   13849:	83 c4 04             	add    $0x4,%esp
                break;
   1384c:	eb 19                	jmp    13867 <write_esc_square+0xe8>
            case 'f':
                 move_cursor(console);
   1384e:	ff 75 08             	pushl  0x8(%ebp)
   13851:	e8 8b fe ff ff       	call   136e1 <move_cursor>
   13856:	83 c4 04             	add    $0x4,%esp
                break;
   13859:	eb 0c                	jmp    13867 <write_esc_square+0xe8>
            case 'J':
                erase_in_display(console);
   1385b:	ff 75 08             	pushl  0x8(%ebp)
   1385e:	e8 2d fe ff ff       	call   13690 <erase_in_display>
   13863:	83 c4 04             	add    $0x4,%esp
            default:
                break;
   13866:	90                   	nop
        }
        console->write_state=CONSOLE_WRITE_NORMAL;
   13867:	8b 45 08             	mov    0x8(%ebp),%eax
   1386a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
   13870:	90                   	nop
   13871:	c9                   	leave  
   13872:	c3                   	ret    

00013873 <write_normal>:

static void write_normal(console_t* console,char c){
   13873:	55                   	push   %ebp
   13874:	89 e5                	mov    %esp,%ebp
   13876:	83 ec 18             	sub    $0x18,%esp
   13879:	8b 45 0c             	mov    0xc(%ebp),%eax
   1387c:	88 45 f4             	mov    %al,-0xc(%ebp)
    switch (c)
   1387f:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   13883:	83 f8 0d             	cmp    $0xd,%eax
   13886:	74 4a                	je     138d2 <write_normal+0x5f>
   13888:	83 f8 0d             	cmp    $0xd,%eax
   1388b:	7f 0c                	jg     13899 <write_normal+0x26>
   1388d:	83 f8 08             	cmp    $0x8,%eax
   13890:	74 2e                	je     138c0 <write_normal+0x4d>
   13892:	83 f8 0a             	cmp    $0xa,%eax
   13895:	74 4b                	je     138e2 <write_normal+0x6f>
   13897:	eb 59                	jmp    138f2 <write_normal+0x7f>
   13899:	83 f8 1b             	cmp    $0x1b,%eax
   1389c:	74 07                	je     138a5 <write_normal+0x32>
   1389e:	83 f8 7f             	cmp    $0x7f,%eax
   138a1:	74 0d                	je     138b0 <write_normal+0x3d>
   138a3:	eb 4d                	jmp    138f2 <write_normal+0x7f>
    {
        case ASCII_ESC:
            console->write_state=CONSOLE_WRITE_ESC;
   138a5:	8b 45 08             	mov    0x8(%ebp),%eax
   138a8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
            break;
   138ae:	eb 62                	jmp    13912 <write_normal+0x9f>
        case 0x7F:
            erase_backword(console);
   138b0:	83 ec 0c             	sub    $0xc,%esp
   138b3:	ff 75 08             	pushl  0x8(%ebp)
   138b6:	e8 2c fc ff ff       	call   134e7 <erase_backword>
   138bb:	83 c4 10             	add    $0x10,%esp
            break;
   138be:	eb 52                	jmp    13912 <write_normal+0x9f>
        case '\b':
            move_backword(console,1);
   138c0:	83 ec 08             	sub    $0x8,%esp
   138c3:	6a 01                	push   $0x1
   138c5:	ff 75 08             	pushl  0x8(%ebp)
   138c8:	e8 2a fa ff ff       	call   132f7 <move_backword>
   138cd:	83 c4 10             	add    $0x10,%esp
            break;
   138d0:	eb 40                	jmp    13912 <write_normal+0x9f>
        case '\r':
            move_to_col0(console);
   138d2:	83 ec 0c             	sub    $0xc,%esp
   138d5:	ff 75 08             	pushl  0x8(%ebp)
   138d8:	e8 5c f9 ff ff       	call   13239 <move_to_col0>
   138dd:	83 c4 10             	add    $0x10,%esp
            break;
   138e0:	eb 30                	jmp    13912 <write_normal+0x9f>
        case '\n':  
            move_next_line(console);
   138e2:	83 ec 0c             	sub    $0xc,%esp
   138e5:	ff 75 08             	pushl  0x8(%ebp)
   138e8:	e8 5c f9 ff ff       	call   13249 <move_next_line>
   138ed:	83 c4 10             	add    $0x10,%esp
            break;
   138f0:	eb 20                	jmp    13912 <write_normal+0x9f>
        default:
            if((c >= ' ') && (c <= '~')){
   138f2:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
   138f6:	7e 19                	jle    13911 <write_normal+0x9e>
   138f8:	80 7d f4 7f          	cmpb   $0x7f,-0xc(%ebp)
   138fc:	74 13                	je     13911 <write_normal+0x9e>
                show_char(console,c);
   138fe:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   13902:	83 ec 08             	sub    $0x8,%esp
   13905:	50                   	push   %eax
   13906:	ff 75 08             	pushl  0x8(%ebp)
   13909:	e8 44 fb ff ff       	call   13452 <show_char>
   1390e:	83 c4 10             	add    $0x10,%esp
            }
            break;
   13911:	90                   	nop
    }
}
   13912:	90                   	nop
   13913:	c9                   	leave  
   13914:	c3                   	ret    

00013915 <console_write>:

int console_write(tty_t* tty){
   13915:	55                   	push   %ebp
   13916:	89 e5                	mov    %esp,%ebp
   13918:	83 ec 18             	sub    $0x18,%esp
    console_t* console=console_buf+tty->console_index;
   1391b:	8b 45 08             	mov    0x8(%ebp),%eax
   1391e:	8b 80 28 04 00 00    	mov    0x428(%eax),%eax
   13924:	6b c0 68             	imul   $0x68,%eax,%eax
   13927:	05 00 56 03 00       	add    $0x35600,%eax
   1392c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int len=0;
   1392f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    mutex_lock(&console->mutex);
   13936:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13939:	83 c0 54             	add    $0x54,%eax
   1393c:	83 ec 0c             	sub    $0xc,%esp
   1393f:	50                   	push   %eax
   13940:	e8 99 3e 00 00       	call   177de <mutex_lock>
   13945:	83 c4 10             	add    $0x10,%esp
    do{
        char c;
        int err=tty_fifo_get(&tty->ofifo,&c);
   13948:	8b 45 08             	mov    0x8(%ebp),%eax
   1394b:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
   13951:	83 ec 08             	sub    $0x8,%esp
   13954:	8d 45 eb             	lea    -0x15(%ebp),%eax
   13957:	50                   	push   %eax
   13958:	52                   	push   %edx
   13959:	e8 66 14 00 00       	call   14dc4 <tty_fifo_get>
   1395e:	83 c4 10             	add    $0x10,%esp
   13961:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(err<0){
   13964:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   13968:	79 29                	jns    13993 <console_write+0x7e>
        }
        
        len++;
    }while(1);

    mutex_unlock(&console->mutex);
   1396a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1396d:	83 c0 54             	add    $0x54,%eax
   13970:	83 ec 0c             	sub    $0xc,%esp
   13973:	50                   	push   %eax
   13974:	e8 f4 3e 00 00       	call   1786d <mutex_unlock>
   13979:	83 c4 10             	add    $0x10,%esp
    
    if(tty->console_index==curr_console_idx){
   1397c:	8b 45 08             	mov    0x8(%ebp),%eax
   1397f:	8b 90 28 04 00 00    	mov    0x428(%eax),%edx
   13985:	a1 40 59 03 00       	mov    0x35940,%eax
   1398a:	39 c2                	cmp    %eax,%edx
   1398c:	74 7f                	je     13a0d <console_write+0xf8>
   1398e:	e9 88 00 00 00       	jmp    13a1b <console_write+0x106>
        sem_notify(&tty->osem);
   13993:	8b 45 08             	mov    0x8(%ebp),%eax
   13996:	05 2c 04 00 00       	add    $0x42c,%eax
   1399b:	83 ec 0c             	sub    $0xc,%esp
   1399e:	50                   	push   %eax
   1399f:	e8 24 40 00 00       	call   179c8 <sem_notify>
   139a4:	83 c4 10             	add    $0x10,%esp
        switch(console->write_state){
   139a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   139aa:	8b 00                	mov    (%eax),%eax
   139ac:	83 f8 01             	cmp    $0x1,%eax
   139af:	74 24                	je     139d5 <console_write+0xc0>
   139b1:	83 f8 01             	cmp    $0x1,%eax
   139b4:	72 07                	jb     139bd <console_write+0xa8>
   139b6:	83 f8 02             	cmp    $0x2,%eax
   139b9:	74 32                	je     139ed <console_write+0xd8>
                break;
   139bb:	eb 47                	jmp    13a04 <console_write+0xef>
                write_normal(console,c);
   139bd:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   139c1:	0f be c0             	movsbl %al,%eax
   139c4:	83 ec 08             	sub    $0x8,%esp
   139c7:	50                   	push   %eax
   139c8:	ff 75 f0             	pushl  -0x10(%ebp)
   139cb:	e8 a3 fe ff ff       	call   13873 <write_normal>
   139d0:	83 c4 10             	add    $0x10,%esp
                break;
   139d3:	eb 2f                	jmp    13a04 <console_write+0xef>
                write_esc(console,c);
   139d5:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   139d9:	0f be c0             	movsbl %al,%eax
   139dc:	83 ec 08             	sub    $0x8,%esp
   139df:	50                   	push   %eax
   139e0:	ff 75 f0             	pushl  -0x10(%ebp)
   139e3:	e8 9e fb ff ff       	call   13586 <write_esc>
   139e8:	83 c4 10             	add    $0x10,%esp
                break;
   139eb:	eb 17                	jmp    13a04 <console_write+0xef>
                write_esc_square(console,c);
   139ed:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   139f1:	0f be c0             	movsbl %al,%eax
   139f4:	83 ec 08             	sub    $0x8,%esp
   139f7:	50                   	push   %eax
   139f8:	ff 75 f0             	pushl  -0x10(%ebp)
   139fb:	e8 7f fd ff ff       	call   1377f <write_esc_square>
   13a00:	83 c4 10             	add    $0x10,%esp
                break;
   13a03:	90                   	nop
        len++;
   13a04:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    do{
   13a08:	e9 3b ff ff ff       	jmp    13948 <console_write+0x33>
        update_cursor_pos(console);
   13a0d:	83 ec 0c             	sub    $0xc,%esp
   13a10:	ff 75 f0             	pushl  -0x10(%ebp)
   13a13:	e8 c5 f5 ff ff       	call   12fdd <update_cursor_pos>
   13a18:	83 c4 10             	add    $0x10,%esp
    }

    return len;
   13a1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13a1e:	c9                   	leave  
   13a1f:	c3                   	ret    

00013a20 <console_close>:

void console_close(int console){
   13a20:	55                   	push   %ebp
   13a21:	89 e5                	mov    %esp,%ebp
    
}
   13a23:	90                   	nop
   13a24:	5d                   	pop    %ebp
   13a25:	c3                   	ret    

00013a26 <console_select>:

/** 
 * @brief 选择对应的console 
 * @param idx 要切换到的console的索引号
*/ 
void console_select(int idx){
   13a26:	55                   	push   %ebp
   13a27:	89 e5                	mov    %esp,%ebp
   13a29:	83 ec 18             	sub    $0x18,%esp
    console_t* console=console_buf+idx;
   13a2c:	8b 45 08             	mov    0x8(%ebp),%eax
   13a2f:	6b c0 68             	imul   $0x68,%eax,%eax
   13a32:	05 00 56 03 00       	add    $0x35600,%eax
   13a37:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    // 如果显存地址为0说明未初始化，要初始化对应的console
    if(console->disp_base==0){
   13a3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a3d:	8b 40 04             	mov    0x4(%eax),%eax
   13a40:	85 c0                	test   %eax,%eax
   13a42:	75 0e                	jne    13a52 <console_select+0x2c>
        console_init(idx);
   13a44:	83 ec 0c             	sub    $0xc,%esp
   13a47:	ff 75 08             	pushl  0x8(%ebp)
   13a4a:	e8 20 f9 ff ff       	call   1336f <console_init>
   13a4f:	83 c4 10             	add    $0x10,%esp
    }

    uint16_t pos=idx*console->display_cols*console->display_rows;
   13a52:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a55:	8b 40 14             	mov    0x14(%eax),%eax
   13a58:	89 c2                	mov    %eax,%edx
   13a5a:	8b 45 08             	mov    0x8(%ebp),%eax
   13a5d:	0f af d0             	imul   %eax,%edx
   13a60:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a63:	8b 40 10             	mov    0x10(%eax),%eax
   13a66:	0f af c2             	imul   %edx,%eax
   13a69:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

    // 向端口 0x3D4 写入值 0xC，这是用于选择 VGA 控制器的初始屏幕的位置的高八位
    outb(0x3D4,0xC);
   13a6d:	83 ec 08             	sub    $0x8,%esp
   13a70:	6a 0c                	push   $0xc
   13a72:	68 d4 03 00 00       	push   $0x3d4
   13a77:	e8 ce f4 ff ff       	call   12f4a <outb>
   13a7c:	83 c4 10             	add    $0x10,%esp
    
    // 写入高八位
    outb(0x3D5,(uint8_t)((pos >> 8) & 0xFF));
   13a7f:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   13a83:	66 c1 e8 08          	shr    $0x8,%ax
   13a87:	0f b6 c0             	movzbl %al,%eax
   13a8a:	83 ec 08             	sub    $0x8,%esp
   13a8d:	50                   	push   %eax
   13a8e:	68 d5 03 00 00       	push   $0x3d5
   13a93:	e8 b2 f4 ff ff       	call   12f4a <outb>
   13a98:	83 c4 10             	add    $0x10,%esp

    // 向端口 0x3D4 写入值 0xD，这是用于选择 VGA 控制器的初始屏幕的位置的低八位
    outb(0x3D4,0xD);
   13a9b:	83 ec 08             	sub    $0x8,%esp
   13a9e:	6a 0d                	push   $0xd
   13aa0:	68 d4 03 00 00       	push   $0x3d4
   13aa5:	e8 a0 f4 ff ff       	call   12f4a <outb>
   13aaa:	83 c4 10             	add    $0x10,%esp

    // 写入低八位
    outb(0x3D5,(uint8_t)(pos & 0xFF));
   13aad:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   13ab1:	0f b6 c0             	movzbl %al,%eax
   13ab4:	83 ec 08             	sub    $0x8,%esp
   13ab7:	50                   	push   %eax
   13ab8:	68 d5 03 00 00       	push   $0x3d5
   13abd:	e8 88 f4 ff ff       	call   12f4a <outb>
   13ac2:	83 c4 10             	add    $0x10,%esp

    curr_console_idx=idx;
   13ac5:	8b 45 08             	mov    0x8(%ebp),%eax
   13ac8:	a3 40 59 03 00       	mov    %eax,0x35940

    update_cursor_pos(console);
   13acd:	83 ec 0c             	sub    $0xc,%esp
   13ad0:	ff 75 f4             	pushl  -0xc(%ebp)
   13ad3:	e8 05 f5 ff ff       	call   12fdd <update_cursor_pos>
   13ad8:	83 c4 10             	add    $0x10,%esp
}
   13adb:	90                   	nop
   13adc:	c9                   	leave  
   13add:	c3                   	ret    

00013ade <is_devid_bad>:
    &dev_disk_desc,
};

static device_t dev_tb[DEV_TABLE_SIZE];

static int is_devid_bad(int dev_id){
   13ade:	55                   	push   %ebp
   13adf:	89 e5                	mov    %esp,%ebp
    if((dev_id<0) || (dev_id>=DEV_TABLE_SIZE)){
   13ae1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13ae5:	78 06                	js     13aed <is_devid_bad+0xf>
   13ae7:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   13aeb:	7e 07                	jle    13af4 <is_devid_bad+0x16>
        return 1;
   13aed:	b8 01 00 00 00       	mov    $0x1,%eax
   13af2:	eb 24                	jmp    13b18 <is_devid_bad+0x3a>
    }

    if(dev_tb[dev_id].desc==(dev_desc_t*)0){
   13af4:	8b 55 08             	mov    0x8(%ebp),%edx
   13af7:	89 d0                	mov    %edx,%eax
   13af9:	c1 e0 02             	shl    $0x2,%eax
   13afc:	01 d0                	add    %edx,%eax
   13afe:	c1 e0 02             	shl    $0x2,%eax
   13b01:	05 60 59 03 00       	add    $0x35960,%eax
   13b06:	8b 00                	mov    (%eax),%eax
   13b08:	85 c0                	test   %eax,%eax
   13b0a:	75 07                	jne    13b13 <is_devid_bad+0x35>
        return 1;
   13b0c:	b8 01 00 00 00       	mov    $0x1,%eax
   13b11:	eb 05                	jmp    13b18 <is_devid_bad+0x3a>
    }

    return 0;
   13b13:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13b18:	5d                   	pop    %ebp
   13b19:	c3                   	ret    

00013b1a <dev_open>:
 * @param major 主设备号
 * @param minor 从设备号
 * @param data 设备传入的参数
 * @return 设备id，失败返回-1
*/
int dev_open(int major,int minor,void* data){
   13b1a:	55                   	push   %ebp
   13b1b:	89 e5                	mov    %esp,%ebp
   13b1d:	83 ec 28             	sub    $0x28,%esp
    irq_state_t state=irq_enter_protection();
   13b20:	e8 df f3 ff ff       	call   12f04 <irq_enter_protection>
   13b25:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    device_t* free_dev=(device_t*)0;
   13b28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    for(int i=0;i<sizeof(dev_tb)/sizeof(dev_tb[0]);i++){
   13b2f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13b36:	eb 68                	jmp    13ba0 <dev_open+0x86>
        device_t* dev=dev_tb+i;
   13b38:	8b 55 f0             	mov    -0x10(%ebp),%edx
   13b3b:	89 d0                	mov    %edx,%eax
   13b3d:	c1 e0 02             	shl    $0x2,%eax
   13b40:	01 d0                	add    %edx,%eax
   13b42:	c1 e0 02             	shl    $0x2,%eax
   13b45:	05 60 59 03 00       	add    $0x35960,%eax
   13b4a:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if(dev->open_count == 0){
   13b4d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13b50:	8b 40 10             	mov    0x10(%eax),%eax
   13b53:	85 c0                	test   %eax,%eax
   13b55:	75 08                	jne    13b5f <dev_open+0x45>
            free_dev=dev;
   13b57:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13b5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
   13b5d:	eb 49                	jmp    13ba8 <dev_open+0x8e>
        }
        else if((dev->desc->major == major) && (dev->minor == minor)){
   13b5f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13b62:	8b 00                	mov    (%eax),%eax
   13b64:	8b 40 20             	mov    0x20(%eax),%eax
   13b67:	39 45 08             	cmp    %eax,0x8(%ebp)
   13b6a:	75 30                	jne    13b9c <dev_open+0x82>
   13b6c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13b6f:	8b 40 08             	mov    0x8(%eax),%eax
   13b72:	39 45 0c             	cmp    %eax,0xc(%ebp)
   13b75:	75 25                	jne    13b9c <dev_open+0x82>
            dev->open_count++;
   13b77:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13b7a:	8b 40 10             	mov    0x10(%eax),%eax
   13b7d:	8d 50 01             	lea    0x1(%eax),%edx
   13b80:	8b 45 e0             	mov    -0x20(%ebp),%eax
   13b83:	89 50 10             	mov    %edx,0x10(%eax)
            irq_leave_protection(state);
   13b86:	83 ec 0c             	sub    $0xc,%esp
   13b89:	ff 75 e4             	pushl  -0x1c(%ebp)
   13b8c:	e8 8b f3 ff ff       	call   12f1c <irq_leave_protection>
   13b91:	83 c4 10             	add    $0x10,%esp
            return i;
   13b94:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13b97:	e9 ce 00 00 00       	jmp    13c6a <dev_open+0x150>
    for(int i=0;i<sizeof(dev_tb)/sizeof(dev_tb[0]);i++){
   13b9c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   13ba0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13ba3:	83 f8 7f             	cmp    $0x7f,%eax
   13ba6:	76 90                	jbe    13b38 <dev_open+0x1e>
        }
    }

    dev_desc_t* desc=(dev_desc_t*)0;
   13ba8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(int i=0;i<sizeof(dev_desc_tbl)/sizeof(dev_desc_tbl[0]);i++){
   13baf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   13bb6:	eb 25                	jmp    13bdd <dev_open+0xc3>
        if(dev_desc_tbl[i]->major == major){
   13bb8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13bbb:	8b 04 85 50 a0 01 00 	mov    0x1a050(,%eax,4),%eax
   13bc2:	8b 40 20             	mov    0x20(%eax),%eax
   13bc5:	39 45 08             	cmp    %eax,0x8(%ebp)
   13bc8:	75 0f                	jne    13bd9 <dev_open+0xbf>
            desc=dev_desc_tbl[i];
   13bca:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13bcd:	8b 04 85 50 a0 01 00 	mov    0x1a050(,%eax,4),%eax
   13bd4:	89 45 ec             	mov    %eax,-0x14(%ebp)
            break;
   13bd7:	eb 0c                	jmp    13be5 <dev_open+0xcb>
    for(int i=0;i<sizeof(dev_desc_tbl)/sizeof(dev_desc_tbl[0]);i++){
   13bd9:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   13bdd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13be0:	83 f8 01             	cmp    $0x1,%eax
   13be3:	76 d3                	jbe    13bb8 <dev_open+0x9e>
        }
    }

    if(desc && free_dev){
   13be5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   13be9:	74 6c                	je     13c57 <dev_open+0x13d>
   13beb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13bef:	74 66                	je     13c57 <dev_open+0x13d>
       free_dev->minor=minor;
   13bf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13bf4:	8b 55 0c             	mov    0xc(%ebp),%edx
   13bf7:	89 50 08             	mov    %edx,0x8(%eax)
       free_dev->desc=desc;
   13bfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13bfd:	8b 55 ec             	mov    -0x14(%ebp),%edx
   13c00:	89 10                	mov    %edx,(%eax)
       free_dev->data=data;
   13c02:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13c05:	8b 55 10             	mov    0x10(%ebp),%edx
   13c08:	89 50 0c             	mov    %edx,0xc(%eax)

       int err=desc->open(free_dev);
   13c0b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13c0e:	8b 40 24             	mov    0x24(%eax),%eax
   13c11:	83 ec 0c             	sub    $0xc,%esp
   13c14:	ff 75 f4             	pushl  -0xc(%ebp)
   13c17:	ff d0                	call   *%eax
   13c19:	83 c4 10             	add    $0x10,%esp
   13c1c:	89 45 dc             	mov    %eax,-0x24(%ebp)
       if(err==0){
   13c1f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   13c23:	75 32                	jne    13c57 <dev_open+0x13d>
           free_dev->open_count++;
   13c25:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13c28:	8b 40 10             	mov    0x10(%eax),%eax
   13c2b:	8d 50 01             	lea    0x1(%eax),%edx
   13c2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13c31:	89 50 10             	mov    %edx,0x10(%eax)
           irq_leave_protection(state);
   13c34:	83 ec 0c             	sub    $0xc,%esp
   13c37:	ff 75 e4             	pushl  -0x1c(%ebp)
   13c3a:	e8 dd f2 ff ff       	call   12f1c <irq_leave_protection>
   13c3f:	83 c4 10             	add    $0x10,%esp

           // dev_tb是起始位置，free_dev是当前位置，两者相减得到当前位置的偏移量
           return free_dev-dev_tb;
   13c42:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13c45:	ba 60 59 03 00       	mov    $0x35960,%edx
   13c4a:	29 d0                	sub    %edx,%eax
   13c4c:	c1 f8 02             	sar    $0x2,%eax
   13c4f:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
   13c55:	eb 13                	jmp    13c6a <dev_open+0x150>
       }
    }

    irq_leave_protection(state);
   13c57:	83 ec 0c             	sub    $0xc,%esp
   13c5a:	ff 75 e4             	pushl  -0x1c(%ebp)
   13c5d:	e8 ba f2 ff ff       	call   12f1c <irq_leave_protection>
   13c62:	83 c4 10             	add    $0x10,%esp
    return -1;
   13c65:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   13c6a:	c9                   	leave  
   13c6b:	c3                   	ret    

00013c6c <dev_read>:

// dev_id:设备id，addr:从哪里开始读取
int dev_read(int dev_id,int addr,char* buf,int size){
   13c6c:	55                   	push   %ebp
   13c6d:	89 e5                	mov    %esp,%ebp
   13c6f:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   13c72:	ff 75 08             	pushl  0x8(%ebp)
   13c75:	e8 64 fe ff ff       	call   13ade <is_devid_bad>
   13c7a:	83 c4 04             	add    $0x4,%esp
   13c7d:	85 c0                	test   %eax,%eax
   13c7f:	74 07                	je     13c88 <dev_read+0x1c>
        return -1;
   13c81:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13c86:	eb 2e                	jmp    13cb6 <dev_read+0x4a>
    }

    device_t* dev=dev_tb+dev_id;
   13c88:	8b 55 08             	mov    0x8(%ebp),%edx
   13c8b:	89 d0                	mov    %edx,%eax
   13c8d:	c1 e0 02             	shl    $0x2,%eax
   13c90:	01 d0                	add    %edx,%eax
   13c92:	c1 e0 02             	shl    $0x2,%eax
   13c95:	05 60 59 03 00       	add    $0x35960,%eax
   13c9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return dev->desc->read(dev,addr,buf,size);
   13c9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13ca0:	8b 00                	mov    (%eax),%eax
   13ca2:	8b 40 28             	mov    0x28(%eax),%eax
   13ca5:	ff 75 14             	pushl  0x14(%ebp)
   13ca8:	ff 75 10             	pushl  0x10(%ebp)
   13cab:	ff 75 0c             	pushl  0xc(%ebp)
   13cae:	ff 75 f4             	pushl  -0xc(%ebp)
   13cb1:	ff d0                	call   *%eax
   13cb3:	83 c4 10             	add    $0x10,%esp
}
   13cb6:	c9                   	leave  
   13cb7:	c3                   	ret    

00013cb8 <dev_write>:

int dev_write(int dev_id,int addr,char* buf,int size){
   13cb8:	55                   	push   %ebp
   13cb9:	89 e5                	mov    %esp,%ebp
   13cbb:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   13cbe:	ff 75 08             	pushl  0x8(%ebp)
   13cc1:	e8 18 fe ff ff       	call   13ade <is_devid_bad>
   13cc6:	83 c4 04             	add    $0x4,%esp
   13cc9:	85 c0                	test   %eax,%eax
   13ccb:	74 07                	je     13cd4 <dev_write+0x1c>
        return -1;
   13ccd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13cd2:	eb 2e                	jmp    13d02 <dev_write+0x4a>
    }

    device_t* dev=dev_tb+dev_id;
   13cd4:	8b 55 08             	mov    0x8(%ebp),%edx
   13cd7:	89 d0                	mov    %edx,%eax
   13cd9:	c1 e0 02             	shl    $0x2,%eax
   13cdc:	01 d0                	add    %edx,%eax
   13cde:	c1 e0 02             	shl    $0x2,%eax
   13ce1:	05 60 59 03 00       	add    $0x35960,%eax
   13ce6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return dev->desc->write(dev,addr,buf,size);
   13ce9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13cec:	8b 00                	mov    (%eax),%eax
   13cee:	8b 40 2c             	mov    0x2c(%eax),%eax
   13cf1:	ff 75 14             	pushl  0x14(%ebp)
   13cf4:	ff 75 10             	pushl  0x10(%ebp)
   13cf7:	ff 75 0c             	pushl  0xc(%ebp)
   13cfa:	ff 75 f4             	pushl  -0xc(%ebp)
   13cfd:	ff d0                	call   *%eax
   13cff:	83 c4 10             	add    $0x10,%esp
}
   13d02:	c9                   	leave  
   13d03:	c3                   	ret    

00013d04 <dev_control>:

int dev_control(int dev_id,int cmd,int arg0,int arg1){
   13d04:	55                   	push   %ebp
   13d05:	89 e5                	mov    %esp,%ebp
   13d07:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   13d0a:	ff 75 08             	pushl  0x8(%ebp)
   13d0d:	e8 cc fd ff ff       	call   13ade <is_devid_bad>
   13d12:	83 c4 04             	add    $0x4,%esp
   13d15:	85 c0                	test   %eax,%eax
   13d17:	74 07                	je     13d20 <dev_control+0x1c>
        return -1;
   13d19:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13d1e:	eb 2e                	jmp    13d4e <dev_control+0x4a>
    }

    device_t* dev=dev_tb+dev_id;
   13d20:	8b 55 08             	mov    0x8(%ebp),%edx
   13d23:	89 d0                	mov    %edx,%eax
   13d25:	c1 e0 02             	shl    $0x2,%eax
   13d28:	01 d0                	add    %edx,%eax
   13d2a:	c1 e0 02             	shl    $0x2,%eax
   13d2d:	05 60 59 03 00       	add    $0x35960,%eax
   13d32:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return dev->desc->control(dev,cmd,arg0,arg1);
   13d35:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13d38:	8b 00                	mov    (%eax),%eax
   13d3a:	8b 40 30             	mov    0x30(%eax),%eax
   13d3d:	ff 75 14             	pushl  0x14(%ebp)
   13d40:	ff 75 10             	pushl  0x10(%ebp)
   13d43:	ff 75 0c             	pushl  0xc(%ebp)
   13d46:	ff 75 f4             	pushl  -0xc(%ebp)
   13d49:	ff d0                	call   *%eax
   13d4b:	83 c4 10             	add    $0x10,%esp
}
   13d4e:	c9                   	leave  
   13d4f:	c3                   	ret    

00013d50 <dev_close>:

void dev_close(int dev_id){
   13d50:	55                   	push   %ebp
   13d51:	89 e5                	mov    %esp,%ebp
   13d53:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   13d56:	ff 75 08             	pushl  0x8(%ebp)
   13d59:	e8 80 fd ff ff       	call   13ade <is_devid_bad>
   13d5e:	83 c4 04             	add    $0x4,%esp
   13d61:	85 c0                	test   %eax,%eax
   13d63:	75 6c                	jne    13dd1 <dev_close+0x81>
        return;
    }
    
    device_t* dev=dev_tb+dev_id;
   13d65:	8b 55 08             	mov    0x8(%ebp),%edx
   13d68:	89 d0                	mov    %edx,%eax
   13d6a:	c1 e0 02             	shl    $0x2,%eax
   13d6d:	01 d0                	add    %edx,%eax
   13d6f:	c1 e0 02             	shl    $0x2,%eax
   13d72:	05 60 59 03 00       	add    $0x35960,%eax
   13d77:	89 45 f4             	mov    %eax,-0xc(%ebp)

    irq_state_t state=irq_enter_protection();
   13d7a:	e8 85 f1 ff ff       	call   12f04 <irq_enter_protection>
   13d7f:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(--dev->open_count == 0){
   13d82:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13d85:	8b 40 10             	mov    0x10(%eax),%eax
   13d88:	8d 50 ff             	lea    -0x1(%eax),%edx
   13d8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13d8e:	89 50 10             	mov    %edx,0x10(%eax)
   13d91:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13d94:	8b 40 10             	mov    0x10(%eax),%eax
   13d97:	85 c0                	test   %eax,%eax
   13d99:	75 25                	jne    13dc0 <dev_close+0x70>
        dev->desc->close(dev);
   13d9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13d9e:	8b 00                	mov    (%eax),%eax
   13da0:	8b 40 34             	mov    0x34(%eax),%eax
   13da3:	83 ec 0c             	sub    $0xc,%esp
   13da6:	ff 75 f4             	pushl  -0xc(%ebp)
   13da9:	ff d0                	call   *%eax
   13dab:	83 c4 10             	add    $0x10,%esp
        kernel_memset(dev,0,sizeof(device_t));
   13dae:	83 ec 04             	sub    $0x4,%esp
   13db1:	6a 14                	push   $0x14
   13db3:	6a 00                	push   $0x0
   13db5:	ff 75 f4             	pushl  -0xc(%ebp)
   13db8:	e8 eb 40 00 00       	call   17ea8 <kernel_memset>
   13dbd:	83 c4 10             	add    $0x10,%esp
    }

    irq_leave_protection(state);
   13dc0:	83 ec 0c             	sub    $0xc,%esp
   13dc3:	ff 75 f0             	pushl  -0x10(%ebp)
   13dc6:	e8 51 f1 ff ff       	call   12f1c <irq_leave_protection>
   13dcb:	83 c4 10             	add    $0x10,%esp
    
    return;
   13dce:	90                   	nop
   13dcf:	eb 01                	jmp    13dd2 <dev_close+0x82>
        return;
   13dd1:	90                   	nop
}
   13dd2:	c9                   	leave  
   13dd3:	c3                   	ret    

00013dd4 <inb>:
static inline uint8_t inb(uint16_t port){
   13dd4:	55                   	push   %ebp
   13dd5:	89 e5                	mov    %esp,%ebp
   13dd7:	83 ec 14             	sub    $0x14,%esp
   13dda:	8b 45 08             	mov    0x8(%ebp),%eax
   13ddd:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   13de1:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   13de5:	89 c2                	mov    %eax,%edx
   13de7:	ec                   	in     (%dx),%al
   13de8:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   13deb:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   13def:	c9                   	leave  
   13df0:	c3                   	ret    

00013df1 <inw>:
static inline uint16_t inw(uint16_t  port) {
   13df1:	55                   	push   %ebp
   13df2:	89 e5                	mov    %esp,%ebp
   13df4:	83 ec 14             	sub    $0x14,%esp
   13df7:	8b 45 08             	mov    0x8(%ebp),%eax
   13dfa:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("in %1, %0" : "=a" (rv) : "dN" (port));
   13dfe:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   13e02:	89 c2                	mov    %eax,%edx
   13e04:	66 ed                	in     (%dx),%ax
   13e06:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
	return rv;
   13e0a:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   13e0e:	c9                   	leave  
   13e0f:	c3                   	ret    

00013e10 <outw>:
static inline void outw(uint16_t port,uint16_t data){
   13e10:	55                   	push   %ebp
   13e11:	89 e5                	mov    %esp,%ebp
   13e13:	83 ec 08             	sub    $0x8,%esp
   13e16:	8b 55 08             	mov    0x8(%ebp),%edx
   13e19:	8b 45 0c             	mov    0xc(%ebp),%eax
   13e1c:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   13e20:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    __asm__ __volatile__(
   13e24:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   13e28:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
   13e2c:	66 ef                	out    %ax,(%dx)
}
   13e2e:	90                   	nop
   13e2f:	c9                   	leave  
   13e30:	c3                   	ret    

00013e31 <outb>:
static inline void outb(uint16_t port,uint8_t data){
   13e31:	55                   	push   %ebp
   13e32:	89 e5                	mov    %esp,%ebp
   13e34:	83 ec 08             	sub    $0x8,%esp
   13e37:	8b 55 08             	mov    0x8(%ebp),%edx
   13e3a:	8b 45 0c             	mov    0xc(%ebp),%eax
   13e3d:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   13e41:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   13e44:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   13e48:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   13e4c:	ee                   	out    %al,(%dx)
}
   13e4d:	90                   	nop
   13e4e:	c9                   	leave  
   13e4f:	c3                   	ret    

00013e50 <disk_send_cmd>:
 * @param disk 磁盘结构体指针
 * @param start_sector 起始扇区号
 * @param sector_count 扇区数
 * @param cmd 命令
 */
static void disk_send_cmd(disk_t* disk,uint32_t start_sector,uint32_t sector_count,int cmd){
   13e50:	55                   	push   %ebp
   13e51:	89 e5                	mov    %esp,%ebp
    outb(DISK_DRIVE(disk), DISK_DRIVE_BASE | disk->drive);		// 使用LBA寻址，并设置驱动器
   13e53:	8b 45 08             	mov    0x8(%ebp),%eax
   13e56:	8b 40 28             	mov    0x28(%eax),%eax
   13e59:	83 c8 e0             	or     $0xffffffe0,%eax
   13e5c:	0f b6 d0             	movzbl %al,%edx
   13e5f:	8b 45 08             	mov    0x8(%ebp),%eax
   13e62:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   13e66:	83 c0 06             	add    $0x6,%eax
   13e69:	0f b7 c0             	movzwl %ax,%eax
   13e6c:	52                   	push   %edx
   13e6d:	50                   	push   %eax
   13e6e:	e8 be ff ff ff       	call   13e31 <outb>
   13e73:	83 c4 08             	add    $0x8,%esp

	// 必须先写高字节
	outb(DISK_SECTOR_COUNT(disk), (uint8_t) (sector_count >> 8));	// 扇区数高8位
   13e76:	8b 45 10             	mov    0x10(%ebp),%eax
   13e79:	c1 e8 08             	shr    $0x8,%eax
   13e7c:	0f b6 d0             	movzbl %al,%edx
   13e7f:	8b 45 08             	mov    0x8(%ebp),%eax
   13e82:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   13e86:	83 c0 02             	add    $0x2,%eax
   13e89:	0f b7 c0             	movzwl %ax,%eax
   13e8c:	52                   	push   %edx
   13e8d:	50                   	push   %eax
   13e8e:	e8 9e ff ff ff       	call   13e31 <outb>
   13e93:	83 c4 08             	add    $0x8,%esp
	outb(DISK_LBA_LO(disk), (uint8_t) (start_sector >> 24));		// LBA参数的24~31位
   13e96:	8b 45 0c             	mov    0xc(%ebp),%eax
   13e99:	c1 e8 18             	shr    $0x18,%eax
   13e9c:	0f b6 d0             	movzbl %al,%edx
   13e9f:	8b 45 08             	mov    0x8(%ebp),%eax
   13ea2:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   13ea6:	83 c0 03             	add    $0x3,%eax
   13ea9:	0f b7 c0             	movzwl %ax,%eax
   13eac:	52                   	push   %edx
   13ead:	50                   	push   %eax
   13eae:	e8 7e ff ff ff       	call   13e31 <outb>
   13eb3:	83 c4 08             	add    $0x8,%esp
	outb(DISK_LBA_MID(disk), 0);									// 高于32位不支持
   13eb6:	8b 45 08             	mov    0x8(%ebp),%eax
   13eb9:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   13ebd:	83 c0 04             	add    $0x4,%eax
   13ec0:	0f b7 c0             	movzwl %ax,%eax
   13ec3:	6a 00                	push   $0x0
   13ec5:	50                   	push   %eax
   13ec6:	e8 66 ff ff ff       	call   13e31 <outb>
   13ecb:	83 c4 08             	add    $0x8,%esp
	outb(DISK_LBA_HI(disk), 0);										// 高于32位不支持
   13ece:	8b 45 08             	mov    0x8(%ebp),%eax
   13ed1:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   13ed5:	83 c0 05             	add    $0x5,%eax
   13ed8:	0f b7 c0             	movzwl %ax,%eax
   13edb:	6a 00                	push   $0x0
   13edd:	50                   	push   %eax
   13ede:	e8 4e ff ff ff       	call   13e31 <outb>
   13ee3:	83 c4 08             	add    $0x8,%esp
	outb(DISK_SECTOR_COUNT(disk), (uint8_t) (sector_count));		// 扇区数量低8位
   13ee6:	8b 45 10             	mov    0x10(%ebp),%eax
   13ee9:	0f b6 d0             	movzbl %al,%edx
   13eec:	8b 45 08             	mov    0x8(%ebp),%eax
   13eef:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   13ef3:	83 c0 02             	add    $0x2,%eax
   13ef6:	0f b7 c0             	movzwl %ax,%eax
   13ef9:	52                   	push   %edx
   13efa:	50                   	push   %eax
   13efb:	e8 31 ff ff ff       	call   13e31 <outb>
   13f00:	83 c4 08             	add    $0x8,%esp
	outb(DISK_LBA_LO(disk), (uint8_t) (start_sector >> 0));			// LBA参数的0-7
   13f03:	8b 45 0c             	mov    0xc(%ebp),%eax
   13f06:	0f b6 d0             	movzbl %al,%edx
   13f09:	8b 45 08             	mov    0x8(%ebp),%eax
   13f0c:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   13f10:	83 c0 03             	add    $0x3,%eax
   13f13:	0f b7 c0             	movzwl %ax,%eax
   13f16:	52                   	push   %edx
   13f17:	50                   	push   %eax
   13f18:	e8 14 ff ff ff       	call   13e31 <outb>
   13f1d:	83 c4 08             	add    $0x8,%esp
	outb(DISK_LBA_MID(disk), (uint8_t) (start_sector >> 8));		// LBA参数的8-15位
   13f20:	8b 45 0c             	mov    0xc(%ebp),%eax
   13f23:	c1 e8 08             	shr    $0x8,%eax
   13f26:	0f b6 d0             	movzbl %al,%edx
   13f29:	8b 45 08             	mov    0x8(%ebp),%eax
   13f2c:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   13f30:	83 c0 04             	add    $0x4,%eax
   13f33:	0f b7 c0             	movzwl %ax,%eax
   13f36:	52                   	push   %edx
   13f37:	50                   	push   %eax
   13f38:	e8 f4 fe ff ff       	call   13e31 <outb>
   13f3d:	83 c4 08             	add    $0x8,%esp
	outb(DISK_LBA_HI(disk), (uint8_t) (start_sector >> 16));		// LBA参数的16-23位
   13f40:	8b 45 0c             	mov    0xc(%ebp),%eax
   13f43:	c1 e8 10             	shr    $0x10,%eax
   13f46:	0f b6 d0             	movzbl %al,%edx
   13f49:	8b 45 08             	mov    0x8(%ebp),%eax
   13f4c:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   13f50:	83 c0 05             	add    $0x5,%eax
   13f53:	0f b7 c0             	movzwl %ax,%eax
   13f56:	52                   	push   %edx
   13f57:	50                   	push   %eax
   13f58:	e8 d4 fe ff ff       	call   13e31 <outb>
   13f5d:	83 c4 08             	add    $0x8,%esp

	// 选择对应的主-从磁盘
	outb(DISK_CMD(disk), (uint8_t)cmd);
   13f60:	8b 45 14             	mov    0x14(%ebp),%eax
   13f63:	0f b6 d0             	movzbl %al,%edx
   13f66:	8b 45 08             	mov    0x8(%ebp),%eax
   13f69:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   13f6d:	83 c0 07             	add    $0x7,%eax
   13f70:	0f b7 c0             	movzwl %ax,%eax
   13f73:	52                   	push   %edx
   13f74:	50                   	push   %eax
   13f75:	e8 b7 fe ff ff       	call   13e31 <outb>
   13f7a:	83 c4 08             	add    $0x8,%esp
}
   13f7d:	90                   	nop
   13f7e:	c9                   	leave  
   13f7f:	c3                   	ret    

00013f80 <disk_read_data>:
/**
 * @brief 从磁盘中读数据
 * @param disk 磁盘结构体指针
 * @param buf 缓冲区指针
 */
static inline void disk_read_data(disk_t* disk, void* buf,int size){
   13f80:	55                   	push   %ebp
   13f81:	89 e5                	mov    %esp,%ebp
   13f83:	53                   	push   %ebx
   13f84:	83 ec 10             	sub    $0x10,%esp
    uint16_t * c = (uint16_t *)buf;
   13f87:	8b 45 0c             	mov    0xc(%ebp),%eax
   13f8a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int i = 0; i < size / 2; i++) {
   13f8d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   13f94:	eb 23                	jmp    13fb9 <disk_read_data+0x39>
        *c++ = inw(DISK_DATA(disk));
   13f96:	8b 45 08             	mov    0x8(%ebp),%eax
   13f99:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   13f9d:	0f b7 c0             	movzwl %ax,%eax
   13fa0:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   13fa3:	8d 53 02             	lea    0x2(%ebx),%edx
   13fa6:	89 55 f8             	mov    %edx,-0x8(%ebp)
   13fa9:	50                   	push   %eax
   13faa:	e8 42 fe ff ff       	call   13df1 <inw>
   13faf:	83 c4 04             	add    $0x4,%esp
   13fb2:	66 89 03             	mov    %ax,(%ebx)
    for (int i = 0; i < size / 2; i++) {
   13fb5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   13fb9:	8b 45 10             	mov    0x10(%ebp),%eax
   13fbc:	89 c2                	mov    %eax,%edx
   13fbe:	c1 ea 1f             	shr    $0x1f,%edx
   13fc1:	01 d0                	add    %edx,%eax
   13fc3:	d1 f8                	sar    %eax
   13fc5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   13fc8:	7c cc                	jl     13f96 <disk_read_data+0x16>
    }
}
   13fca:	90                   	nop
   13fcb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   13fce:	c9                   	leave  
   13fcf:	c3                   	ret    

00013fd0 <disk_write_data>:
/**
 * @brief 向磁盘中写数据
 * @param disk 磁盘结构体指针
 * @param buf 缓冲区指针
 */
static inline void disk_write_data(disk_t*disk,void* buf,int size){
   13fd0:	55                   	push   %ebp
   13fd1:	89 e5                	mov    %esp,%ebp
   13fd3:	83 ec 10             	sub    $0x10,%esp
    uint16_t * c = (uint16_t *)buf;
   13fd6:	8b 45 0c             	mov    0xc(%ebp),%eax
   13fd9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    for (int i = 0; i < size / 2; i++) {
   13fdc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   13fe3:	eb 27                	jmp    1400c <disk_write_data+0x3c>
        outw(DISK_DATA(disk), *c++);
   13fe5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13fe8:	8d 50 02             	lea    0x2(%eax),%edx
   13feb:	89 55 fc             	mov    %edx,-0x4(%ebp)
   13fee:	0f b7 00             	movzwl (%eax),%eax
   13ff1:	0f b7 d0             	movzwl %ax,%edx
   13ff4:	8b 45 08             	mov    0x8(%ebp),%eax
   13ff7:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   13ffb:	0f b7 c0             	movzwl %ax,%eax
   13ffe:	52                   	push   %edx
   13fff:	50                   	push   %eax
   14000:	e8 0b fe ff ff       	call   13e10 <outw>
   14005:	83 c4 08             	add    $0x8,%esp
    for (int i = 0; i < size / 2; i++) {
   14008:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1400c:	8b 45 10             	mov    0x10(%ebp),%eax
   1400f:	89 c2                	mov    %eax,%edx
   14011:	c1 ea 1f             	shr    $0x1f,%edx
   14014:	01 d0                	add    %edx,%eax
   14016:	d1 f8                	sar    %eax
   14018:	39 45 f8             	cmp    %eax,-0x8(%ebp)
   1401b:	7c c8                	jl     13fe5 <disk_write_data+0x15>
    }
}
   1401d:	90                   	nop
   1401e:	c9                   	leave  
   1401f:	c3                   	ret    

00014020 <disk_wait_data>:
/**
 * @brief 等待磁盘直到磁盘不是忙的状态返回
 * @param disk 磁盘结构体指针
 * @return 如果磁盘状态为错误则返回-1，否则返回0
 */
static int disk_wait_data(disk_t* disk){
   14020:	55                   	push   %ebp
   14021:	89 e5                	mov    %esp,%ebp
   14023:	83 ec 10             	sub    $0x10,%esp
    uint8_t status;
	do {
        // 等待数据或者有错误
        status = inb(DISK_STATUS(disk));
   14026:	8b 45 08             	mov    0x8(%ebp),%eax
   14029:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   1402d:	83 c0 07             	add    $0x7,%eax
   14030:	0f b7 c0             	movzwl %ax,%eax
   14033:	50                   	push   %eax
   14034:	e8 9b fd ff ff       	call   13dd4 <inb>
   14039:	83 c4 04             	add    $0x4,%esp
   1403c:	88 45 ff             	mov    %al,-0x1(%ebp)

        // 这里的几个宏的位置不能替换要么会发生错误
        if((status & (DISK_STATUS_BUSY | DISK_STATUS_DRQ | DISK_STATUS_ERR)) != DISK_STATUS_BUSY){
   1403f:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
   14043:	25 89 00 00 00       	and    $0x89,%eax
   14048:	3d 80 00 00 00       	cmp    $0x80,%eax
   1404d:	75 02                	jne    14051 <disk_wait_data+0x31>
        status = inb(DISK_STATUS(disk));
   1404f:	eb d5                	jmp    14026 <disk_wait_data+0x6>
                break;
   14051:	90                   	nop
        }   
    }while (1);

    // 检查是否有错误
    return (status & DISK_STATUS_ERR) ? -1 : 0;
   14052:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
   14056:	83 e0 01             	and    $0x1,%eax
   14059:	85 c0                	test   %eax,%eax
   1405b:	74 07                	je     14064 <disk_wait_data+0x44>
   1405d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14062:	eb 05                	jmp    14069 <disk_wait_data+0x49>
   14064:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14069:	c9                   	leave  
   1406a:	c3                   	ret    

0001406b <print_disk_info>:

/**
 * @brief 通过disk_t结构体中的字段打印磁盘信息
 * @param disk 磁盘结构体指针
 */
static void print_disk_info(disk_t* disk){
   1406b:	55                   	push   %ebp
   1406c:	89 e5                	mov    %esp,%ebp
   1406e:	53                   	push   %ebx
   1406f:	83 ec 14             	sub    $0x14,%esp
    log_printf("%s",disk->name);
   14072:	8b 45 08             	mov    0x8(%ebp),%eax
   14075:	83 ec 08             	sub    $0x8,%esp
   14078:	50                   	push   %eax
   14079:	68 e0 8f 01 00       	push   $0x18fe0
   1407e:	e8 48 44 00 00       	call   184cb <log_printf>
   14083:	83 c4 10             	add    $0x10,%esp
    log_printf("port base: %x",disk->port_base);
   14086:	8b 45 08             	mov    0x8(%ebp),%eax
   14089:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   1408d:	0f b7 c0             	movzwl %ax,%eax
   14090:	83 ec 08             	sub    $0x8,%esp
   14093:	50                   	push   %eax
   14094:	68 e3 8f 01 00       	push   $0x18fe3
   14099:	e8 2d 44 00 00       	call   184cb <log_printf>
   1409e:	83 c4 10             	add    $0x10,%esp
    log_printf("total size: %dMB",(disk->sector_size * disk->sector_count) / 1024 / 1024);
   140a1:	8b 45 08             	mov    0x8(%ebp),%eax
   140a4:	8b 50 20             	mov    0x20(%eax),%edx
   140a7:	8b 45 08             	mov    0x8(%ebp),%eax
   140aa:	8b 40 24             	mov    0x24(%eax),%eax
   140ad:	0f af c2             	imul   %edx,%eax
   140b0:	8d 90 ff ff 0f 00    	lea    0xfffff(%eax),%edx
   140b6:	85 c0                	test   %eax,%eax
   140b8:	0f 48 c2             	cmovs  %edx,%eax
   140bb:	c1 f8 14             	sar    $0x14,%eax
   140be:	83 ec 08             	sub    $0x8,%esp
   140c1:	50                   	push   %eax
   140c2:	68 f1 8f 01 00       	push   $0x18ff1
   140c7:	e8 ff 43 00 00       	call   184cb <log_printf>
   140cc:	83 c4 10             	add    $0x10,%esp

    for(int i=0;i<DISK_PRIMARY_PART_NR;i++){
   140cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   140d6:	eb 4e                	jmp    14126 <print_disk_info+0xbb>
        partinfo_t* partinfo=disk->partinfo+i;
   140d8:	8b 45 08             	mov    0x8(%ebp),%eax
   140db:	8d 48 30             	lea    0x30(%eax),%ecx
   140de:	8b 55 f4             	mov    -0xc(%ebp),%edx
   140e1:	89 d0                	mov    %edx,%eax
   140e3:	01 c0                	add    %eax,%eax
   140e5:	01 d0                	add    %edx,%eax
   140e7:	c1 e0 04             	shl    $0x4,%eax
   140ea:	01 c8                	add    %ecx,%eax
   140ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(partinfo->type!=FS_INVALID){
   140ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
   140f2:	8b 40 24             	mov    0x24(%eax),%eax
   140f5:	85 c0                	test   %eax,%eax
   140f7:	74 29                	je     14122 <print_disk_info+0xb7>
            log_printf("%s:type:%x, start_sector:%d, count:%d",
   140f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   140fc:	8b 58 2c             	mov    0x2c(%eax),%ebx
   140ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14102:	8b 48 28             	mov    0x28(%eax),%ecx
                partinfo->name,partinfo->type,partinfo->start_sector,partinfo->total_sector
   14105:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14108:	8b 50 24             	mov    0x24(%eax),%edx
   1410b:	8b 45 f0             	mov    -0x10(%ebp),%eax
            log_printf("%s:type:%x, start_sector:%d, count:%d",
   1410e:	83 ec 0c             	sub    $0xc,%esp
   14111:	53                   	push   %ebx
   14112:	51                   	push   %ecx
   14113:	52                   	push   %edx
   14114:	50                   	push   %eax
   14115:	68 04 90 01 00       	push   $0x19004
   1411a:	e8 ac 43 00 00       	call   184cb <log_printf>
   1411f:	83 c4 20             	add    $0x20,%esp
    for(int i=0;i<DISK_PRIMARY_PART_NR;i++){
   14122:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14126:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
   1412a:	7e ac                	jle    140d8 <print_disk_info+0x6d>
           );
        }
    }
}
   1412c:	90                   	nop
   1412d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14130:	c9                   	leave  
   14131:	c3                   	ret    

00014132 <detect_part_info>:

static int detect_part_info(disk_t* disk){
   14132:	55                   	push   %ebp
   14133:	89 e5                	mov    %esp,%ebp
   14135:	81 ec 18 02 00 00    	sub    $0x218,%esp
    mbr_t mbr;
    
    // 读取磁盘第0个扇区
    disk_send_cmd(disk,0,1,DISK_CMD_READ);
   1413b:	6a 24                	push   $0x24
   1413d:	6a 01                	push   $0x1
   1413f:	6a 00                	push   $0x0
   14141:	ff 75 08             	pushl  0x8(%ebp)
   14144:	e8 07 fd ff ff       	call   13e50 <disk_send_cmd>
   14149:	83 c4 10             	add    $0x10,%esp

    int err=disk_wait_data(disk);
   1414c:	ff 75 08             	pushl  0x8(%ebp)
   1414f:	e8 cc fe ff ff       	call   14020 <disk_wait_data>
   14154:	83 c4 04             	add    $0x4,%esp
   14157:	89 45 e8             	mov    %eax,-0x18(%ebp)
    
    if(err < 0){
   1415a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1415e:	79 18                	jns    14178 <detect_part_info+0x46>
        log_printf("read mbr failed.");
   14160:	83 ec 0c             	sub    $0xc,%esp
   14163:	68 2a 90 01 00       	push   $0x1902a
   14168:	e8 5e 43 00 00       	call   184cb <log_printf>
   1416d:	83 c4 10             	add    $0x10,%esp
        return err;
   14170:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14173:	e9 d1 00 00 00       	jmp    14249 <detect_part_info+0x117>
    }

    disk_read_data(disk,&mbr,sizeof(mbr));
   14178:	83 ec 04             	sub    $0x4,%esp
   1417b:	68 00 02 00 00       	push   $0x200
   14180:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
   14186:	50                   	push   %eax
   14187:	ff 75 08             	pushl  0x8(%ebp)
   1418a:	e8 f1 fd ff ff       	call   13f80 <disk_read_data>
   1418f:	83 c4 10             	add    $0x10,%esp
    part_item_t* item=mbr.part_item;
   14192:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
   14198:	05 be 01 00 00       	add    $0x1be,%eax
   1419d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    partinfo_t* part_info=disk->partinfo+1;
   141a0:	8b 45 08             	mov    0x8(%ebp),%eax
   141a3:	83 c0 30             	add    $0x30,%eax
   141a6:	83 c0 30             	add    $0x30,%eax
   141a9:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // 读取mbr_t内容并将其内容写入part_info数组对应的元素
    for(int i=0;i<MBR_PRIMARY_PART_NR;i++,item++,part_info++){
   141ac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   141b3:	e9 87 00 00 00       	jmp    1423f <detect_part_info+0x10d>
        part_info->type = item->system_id;
   141b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   141bb:	0f b6 40 04          	movzbl 0x4(%eax),%eax
   141bf:	0f b6 d0             	movzbl %al,%edx
   141c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   141c5:	89 50 24             	mov    %edx,0x24(%eax)

        if(part_info->type==FS_INVALID){
   141c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   141cb:	8b 40 24             	mov    0x24(%eax),%eax
   141ce:	85 c0                	test   %eax,%eax
   141d0:	75 20                	jne    141f2 <detect_part_info+0xc0>
            part_info->total_sector=0;
   141d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   141d5:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
            part_info->start_sector=0;
   141dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   141df:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
            part_info->disk=(disk_t*)0;
   141e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   141e9:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
   141f0:	eb 41                	jmp    14233 <detect_part_info+0x101>
        }
        else{
            kernel_sprintf(part_info->name,"%s%d",disk->name,i+1);
   141f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   141f5:	8d 48 01             	lea    0x1(%eax),%ecx
   141f8:	8b 55 08             	mov    0x8(%ebp),%edx
   141fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   141fe:	51                   	push   %ecx
   141ff:	52                   	push   %edx
   14200:	68 3b 90 01 00       	push   $0x1903b
   14205:	50                   	push   %eax
   14206:	e8 42 3d 00 00       	call   17f4d <kernel_sprintf>
   1420b:	83 c4 10             	add    $0x10,%esp
            part_info->start_sector=item->relative_sectors;
   1420e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14211:	8b 40 08             	mov    0x8(%eax),%eax
   14214:	89 c2                	mov    %eax,%edx
   14216:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14219:	89 50 28             	mov    %edx,0x28(%eax)
            part_info->total_sector=item->total_sectors;
   1421c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1421f:	8b 40 0c             	mov    0xc(%eax),%eax
   14222:	89 c2                	mov    %eax,%edx
   14224:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14227:	89 50 2c             	mov    %edx,0x2c(%eax)
            part_info->disk=disk;
   1422a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1422d:	8b 55 08             	mov    0x8(%ebp),%edx
   14230:	89 50 20             	mov    %edx,0x20(%eax)
    for(int i=0;i<MBR_PRIMARY_PART_NR;i++,item++,part_info++){
   14233:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   14237:	83 45 f4 10          	addl   $0x10,-0xc(%ebp)
   1423b:	83 45 f0 30          	addl   $0x30,-0x10(%ebp)
   1423f:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
   14243:	0f 8e 6f ff ff ff    	jle    141b8 <detect_part_info+0x86>
        }
    }
}
   14249:	c9                   	leave  
   1424a:	c3                   	ret    

0001424b <identify_disk>:
/**
 * @brief 识别磁盘
 * @param disk 磁盘结构体指针
 * @return 如果磁盘存在则返回0，否则返回-1
 */
static int identify_disk(disk_t* disk){
   1424b:	55                   	push   %ebp
   1424c:	89 e5                	mov    %esp,%ebp
   1424e:	81 ec 18 02 00 00    	sub    $0x218,%esp
    // 发送识别磁盘命令
    disk_send_cmd(disk,0,0,DISK_CMD_IDENTIFY);
   14254:	68 ec 00 00 00       	push   $0xec
   14259:	6a 00                	push   $0x0
   1425b:	6a 00                	push   $0x0
   1425d:	ff 75 08             	pushl  0x8(%ebp)
   14260:	e8 eb fb ff ff       	call   13e50 <disk_send_cmd>
   14265:	83 c4 10             	add    $0x10,%esp

    // 判断磁盘是否存在
    int err=inb(DISK_STATUS(disk));
   14268:	8b 45 08             	mov    0x8(%ebp),%eax
   1426b:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
   1426f:	83 c0 07             	add    $0x7,%eax
   14272:	0f b7 c0             	movzwl %ax,%eax
   14275:	50                   	push   %eax
   14276:	e8 59 fb ff ff       	call   13dd4 <inb>
   1427b:	83 c4 04             	add    $0x4,%esp
   1427e:	0f b6 c0             	movzbl %al,%eax
   14281:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(err == 0){
   14284:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14288:	75 1e                	jne    142a8 <identify_disk+0x5d>
        log_printf("%s doesn't exist\n",disk->name);
   1428a:	8b 45 08             	mov    0x8(%ebp),%eax
   1428d:	83 ec 08             	sub    $0x8,%esp
   14290:	50                   	push   %eax
   14291:	68 40 90 01 00       	push   $0x19040
   14296:	e8 30 42 00 00       	call   184cb <log_printf>
   1429b:	83 c4 10             	add    $0x10,%esp
        return -1; // 磁盘不存在
   1429e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   142a3:	e9 c8 00 00 00       	jmp    14370 <identify_disk+0x125>
    }

    // 等待磁盘准备好
    err=disk_wait_data(disk);
   142a8:	83 ec 0c             	sub    $0xc,%esp
   142ab:	ff 75 08             	pushl  0x8(%ebp)
   142ae:	e8 6d fd ff ff       	call   14020 <disk_wait_data>
   142b3:	83 c4 10             	add    $0x10,%esp
   142b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(err < 0){
   142b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   142bd:	79 1c                	jns    142db <identify_disk+0x90>
        log_printf("disk[%s]: read disk failed\n",disk->name);
   142bf:	8b 45 08             	mov    0x8(%ebp),%eax
   142c2:	83 ec 08             	sub    $0x8,%esp
   142c5:	50                   	push   %eax
   142c6:	68 52 90 01 00       	push   $0x19052
   142cb:	e8 fb 41 00 00       	call   184cb <log_printf>
   142d0:	83 c4 10             	add    $0x10,%esp
        return err;
   142d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   142d6:	e9 95 00 00 00       	jmp    14370 <identify_disk+0x125>
    }

    uint16_t buf[256];
    disk_read_data(disk,buf,sizeof(buf));
   142db:	83 ec 04             	sub    $0x4,%esp
   142de:	68 00 02 00 00       	push   $0x200
   142e3:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
   142e9:	50                   	push   %eax
   142ea:	ff 75 08             	pushl  0x8(%ebp)
   142ed:	e8 8e fc ff ff       	call   13f80 <disk_read_data>
   142f2:	83 c4 10             	add    $0x10,%esp
    disk->sector_count=*(uint32_t*)(buf + 100);
   142f5:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
   142fb:	05 c8 00 00 00       	add    $0xc8,%eax
   14300:	8b 00                	mov    (%eax),%eax
   14302:	89 c2                	mov    %eax,%edx
   14304:	8b 45 08             	mov    0x8(%ebp),%eax
   14307:	89 50 24             	mov    %edx,0x24(%eax)
    disk->sector_size=SECTOR_SIZE;
   1430a:	8b 45 08             	mov    0x8(%ebp),%eax
   1430d:	c7 40 20 00 02 00 00 	movl   $0x200,0x20(%eax)

    // 设置第一个分区表项，将第一个分区设置为FS_INBALID不使用
    partinfo_t* part=disk->partinfo+0;
   14314:	8b 45 08             	mov    0x8(%ebp),%eax
   14317:	83 c0 30             	add    $0x30,%eax
   1431a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    part->disk=disk;
   1431d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14320:	8b 55 08             	mov    0x8(%ebp),%edx
   14323:	89 50 20             	mov    %edx,0x20(%eax)
    kernel_sprintf(part->name,"%s%d",disk->name,0);
   14326:	8b 55 08             	mov    0x8(%ebp),%edx
   14329:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1432c:	6a 00                	push   $0x0
   1432e:	52                   	push   %edx
   1432f:	68 3b 90 01 00       	push   $0x1903b
   14334:	50                   	push   %eax
   14335:	e8 13 3c 00 00       	call   17f4d <kernel_sprintf>
   1433a:	83 c4 10             	add    $0x10,%esp
    part->start_sector=0;
   1433d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14340:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
    part->total_sector=disk->sector_count;
   14347:	8b 45 08             	mov    0x8(%ebp),%eax
   1434a:	8b 50 24             	mov    0x24(%eax),%edx
   1434d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14350:	89 50 2c             	mov    %edx,0x2c(%eax)
    part->type=FS_INVALID;
   14353:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14356:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)

    // 读取mbr中分区表的信息设置别的分区partinfo_t结构体
    detect_part_info(disk);
   1435d:	83 ec 0c             	sub    $0xc,%esp
   14360:	ff 75 08             	pushl  0x8(%ebp)
   14363:	e8 ca fd ff ff       	call   14132 <detect_part_info>
   14368:	83 c4 10             	add    $0x10,%esp

    return 0;
   1436b:	b8 00 00 00 00       	mov    $0x0,%eax

}
   14370:	c9                   	leave  
   14371:	c3                   	ret    

00014372 <disk_init>:

/**
 * @brief 磁盘初始化函数  
 */ 
void disk_init(void){
   14372:	55                   	push   %ebp
   14373:	89 e5                	mov    %esp,%ebp
   14375:	83 ec 18             	sub    $0x18,%esp
    log_printf("Check disk...\n");
   14378:	83 ec 0c             	sub    $0xc,%esp
   1437b:	68 6e 90 01 00       	push   $0x1906e
   14380:	e8 46 41 00 00       	call   184cb <log_printf>
   14385:	83 c4 10             	add    $0x10,%esp

    mutex_init(&disk_mutex);
   14388:	83 ec 0c             	sub    $0xc,%esp
   1438b:	68 60 63 03 00       	push   $0x36360
   14390:	e8 1b 34 00 00       	call   177b0 <mutex_init>
   14395:	83 c4 10             	add    $0x10,%esp
    sem_init(&op_sem,0);
   14398:	83 ec 08             	sub    $0x8,%esp
   1439b:	6a 00                	push   $0x0
   1439d:	68 74 63 03 00       	push   $0x36374
   143a2:	e8 90 35 00 00       	call   17937 <sem_init>
   143a7:	83 c4 10             	add    $0x10,%esp

    kernel_memset(disk_buf,0,sizeof(disk_buf));
   143aa:	83 ec 04             	sub    $0x4,%esp
   143ad:	68 50 02 00 00       	push   $0x250
   143b2:	6a 00                	push   $0x0
   143b4:	68 a0 63 03 00       	push   $0x363a0
   143b9:	e8 ea 3a 00 00       	call   17ea8 <kernel_memset>
   143be:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<DISK_CNT;i++){
   143c1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   143c8:	e9 90 00 00 00       	jmp    1445d <disk_init+0xeb>
        disk_t* disk=disk_buf+i;
   143cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143d0:	69 c0 28 01 00 00    	imul   $0x128,%eax,%eax
   143d6:	05 a0 63 03 00       	add    $0x363a0,%eax
   143db:	89 45 f0             	mov    %eax,-0x10(%ebp)

        // 磁盘以sda表示第一块儿,sdb表示第二块儿
        kernel_sprintf(disk->name,"sd%c",i+'a');
   143de:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143e1:	8d 50 61             	lea    0x61(%eax),%edx
   143e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   143e7:	83 ec 04             	sub    $0x4,%esp
   143ea:	52                   	push   %edx
   143eb:	68 7d 90 01 00       	push   $0x1907d
   143f0:	50                   	push   %eax
   143f1:	e8 57 3b 00 00       	call   17f4d <kernel_sprintf>
   143f6:	83 c4 10             	add    $0x10,%esp
        disk->drive=(i==0)?DISK_MASTER:DISK_SLAVE;
   143f9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   143fd:	75 07                	jne    14406 <disk_init+0x94>
   143ff:	ba 00 00 00 00       	mov    $0x0,%edx
   14404:	eb 05                	jmp    1440b <disk_init+0x99>
   14406:	ba 10 00 00 00       	mov    $0x10,%edx
   1440b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1440e:	89 50 28             	mov    %edx,0x28(%eax)
        disk->port_base=IOBASE_PRIMARY;
   14411:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14414:	66 c7 40 2c f0 01    	movw   $0x1f0,0x2c(%eax)

        disk->mutex=&disk_mutex;
   1441a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1441d:	c7 80 20 01 00 00 60 	movl   $0x36360,0x120(%eax)
   14424:	63 03 00 
        disk->op_sem=&op_sem;
   14427:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1442a:	c7 80 24 01 00 00 74 	movl   $0x36374,0x124(%eax)
   14431:	63 03 00 

        int err=identify_disk(disk);
   14434:	83 ec 0c             	sub    $0xc,%esp
   14437:	ff 75 f0             	pushl  -0x10(%ebp)
   1443a:	e8 0c fe ff ff       	call   1424b <identify_disk>
   1443f:	83 c4 10             	add    $0x10,%esp
   14442:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(err == 0){
   14445:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14449:	75 0e                	jne    14459 <disk_init+0xe7>
            print_disk_info(disk);
   1444b:	83 ec 0c             	sub    $0xc,%esp
   1444e:	ff 75 f0             	pushl  -0x10(%ebp)
   14451:	e8 15 fc ff ff       	call   1406b <print_disk_info>
   14456:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<DISK_CNT;i++){
   14459:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1445d:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
   14461:	0f 8e 66 ff ff ff    	jle    143cd <disk_init+0x5b>
        }


    }
}
   14467:	90                   	nop
   14468:	c9                   	leave  
   14469:	c3                   	ret    

0001446a <disk_open>:
/**
 * @brief 打开磁盘设备
 * @param dev 设备结构体指针
 * @return 如果打开成功则返回0，否则返回-1
 */
int disk_open(device_t* dev){
   1446a:	55                   	push   %ebp
   1446b:	89 e5                	mov    %esp,%ebp
   1446d:	83 ec 18             	sub    $0x18,%esp
    int disk_idx=(dev->minor >> 4) - 0xa;
   14470:	8b 45 08             	mov    0x8(%ebp),%eax
   14473:	8b 40 08             	mov    0x8(%eax),%eax
   14476:	c1 f8 04             	sar    $0x4,%eax
   14479:	83 e8 0a             	sub    $0xa,%eax
   1447c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int part_idx= dev->minor & 0xf;
   1447f:	8b 45 08             	mov    0x8(%ebp),%eax
   14482:	8b 40 08             	mov    0x8(%eax),%eax
   14485:	83 e0 0f             	and    $0xf,%eax
   14488:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if((disk_idx >= DISK_CNT) || (part_idx >= DISK_PRIMARY_PART_NR)){
   1448b:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
   1448f:	7f 06                	jg     14497 <disk_open+0x2d>
   14491:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
   14495:	7e 21                	jle    144b8 <disk_open+0x4e>
        log_printf("device minor error: %d\n",dev->minor);
   14497:	8b 45 08             	mov    0x8(%ebp),%eax
   1449a:	8b 40 08             	mov    0x8(%eax),%eax
   1449d:	83 ec 08             	sub    $0x8,%esp
   144a0:	50                   	push   %eax
   144a1:	68 82 90 01 00       	push   $0x19082
   144a6:	e8 20 40 00 00       	call   184cb <log_printf>
   144ab:	83 c4 10             	add    $0x10,%esp
        return -1;
   144ae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   144b3:	e9 a5 00 00 00       	jmp    1455d <disk_open+0xf3>
    }

    disk_t* disk=disk_buf + disk_idx;
   144b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144bb:	69 c0 28 01 00 00    	imul   $0x128,%eax,%eax
   144c1:	05 a0 63 03 00       	add    $0x363a0,%eax
   144c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(disk->sector_count == 0){
   144c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   144cc:	8b 40 24             	mov    0x24(%eax),%eax
   144cf:	85 c0                	test   %eax,%eax
   144d1:	75 1e                	jne    144f1 <disk_open+0x87>
        log_printf("disk not exist, dev:sd%x",dev->minor);
   144d3:	8b 45 08             	mov    0x8(%ebp),%eax
   144d6:	8b 40 08             	mov    0x8(%eax),%eax
   144d9:	83 ec 08             	sub    $0x8,%esp
   144dc:	50                   	push   %eax
   144dd:	68 9a 90 01 00       	push   $0x1909a
   144e2:	e8 e4 3f 00 00       	call   184cb <log_printf>
   144e7:	83 c4 10             	add    $0x10,%esp
        return -1;
   144ea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   144ef:	eb 6c                	jmp    1455d <disk_open+0xf3>
    }

    partinfo_t* part_info=disk->partinfo + part_idx;
   144f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   144f4:	8d 48 30             	lea    0x30(%eax),%ecx
   144f7:	8b 55 f0             	mov    -0x10(%ebp),%edx
   144fa:	89 d0                	mov    %edx,%eax
   144fc:	01 c0                	add    %eax,%eax
   144fe:	01 d0                	add    %edx,%eax
   14500:	c1 e0 04             	shl    $0x4,%eax
   14503:	01 c8                	add    %ecx,%eax
   14505:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(part_info->total_sector == 0){
   14508:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1450b:	8b 40 2c             	mov    0x2c(%eax),%eax
   1450e:	85 c0                	test   %eax,%eax
   14510:	75 1e                	jne    14530 <disk_open+0xc6>
        log_printf("part not exist, dev:sd%x",dev->minor);
   14512:	8b 45 08             	mov    0x8(%ebp),%eax
   14515:	8b 40 08             	mov    0x8(%eax),%eax
   14518:	83 ec 08             	sub    $0x8,%esp
   1451b:	50                   	push   %eax
   1451c:	68 b3 90 01 00       	push   $0x190b3
   14521:	e8 a5 3f 00 00       	call   184cb <log_printf>
   14526:	83 c4 10             	add    $0x10,%esp
        return -1;
   14529:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1452e:	eb 2d                	jmp    1455d <disk_open+0xf3>
    }

    // 将分区信息直接保存在data里面这样以后直接从分区中读取相关信息
    dev->data=part_info;
   14530:	8b 45 08             	mov    0x8(%ebp),%eax
   14533:	8b 55 e8             	mov    -0x18(%ebp),%edx
   14536:	89 50 0c             	mov    %edx,0xc(%eax)

    irq_install(IRQ14_HARDDISK_PRIMARY,(irq_handler_t)exception_handler_ide_primary);
   14539:	83 ec 08             	sub    $0x8,%esp
   1453c:	68 c7 02 01 00       	push   $0x102c7
   14541:	6a 2e                	push   $0x2e
   14543:	e8 7c e4 ff ff       	call   129c4 <irq_install>
   14548:	83 c4 10             	add    $0x10,%esp
    irq_enable(IRQ14_HARDDISK_PRIMARY);
   1454b:	83 ec 0c             	sub    $0xc,%esp
   1454e:	6a 2e                	push   $0x2e
   14550:	e8 af e1 ff ff       	call   12704 <irq_enable>
   14555:	83 c4 10             	add    $0x10,%esp

    return 0;
   14558:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1455d:	c9                   	leave  
   1455e:	c3                   	ret    

0001455f <disk_read>:

int disk_read(device_t* dev,int addr,char* buf,int size){
   1455f:	55                   	push   %ebp
   14560:	89 e5                	mov    %esp,%ebp
   14562:	83 ec 18             	sub    $0x18,%esp
    partinfo_t* partinfo=(partinfo_t*)dev->data;
   14565:	8b 45 08             	mov    0x8(%ebp),%eax
   14568:	8b 40 0c             	mov    0xc(%eax),%eax
   1456b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(partinfo == (partinfo_t*)0){
   1456e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14572:	75 21                	jne    14595 <disk_read+0x36>
        log_printf("Get part info failed. device: %d",dev->minor);;
   14574:	8b 45 08             	mov    0x8(%ebp),%eax
   14577:	8b 40 08             	mov    0x8(%eax),%eax
   1457a:	83 ec 08             	sub    $0x8,%esp
   1457d:	50                   	push   %eax
   1457e:	68 cc 90 01 00       	push   $0x190cc
   14583:	e8 43 3f 00 00       	call   184cb <log_printf>
   14588:	83 c4 10             	add    $0x10,%esp
        return -1;
   1458b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14590:	e9 08 01 00 00       	jmp    1469d <disk_read+0x13e>
    }

    disk_t* disk=partinfo->disk;
   14595:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14598:	8b 40 20             	mov    0x20(%eax),%eax
   1459b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(disk == (disk_t*)0){
   1459e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   145a2:	75 21                	jne    145c5 <disk_read+0x66>
        log_printf("No disk. device: %d",dev->minor);
   145a4:	8b 45 08             	mov    0x8(%ebp),%eax
   145a7:	8b 40 08             	mov    0x8(%eax),%eax
   145aa:	83 ec 08             	sub    $0x8,%esp
   145ad:	50                   	push   %eax
   145ae:	68 ed 90 01 00       	push   $0x190ed
   145b3:	e8 13 3f 00 00       	call   184cb <log_printf>
   145b8:	83 c4 10             	add    $0x10,%esp
        return -1;
   145bb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   145c0:	e9 d8 00 00 00       	jmp    1469d <disk_read+0x13e>
    }

    mutex_lock(disk->mutex);
   145c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   145c8:	8b 80 20 01 00 00    	mov    0x120(%eax),%eax
   145ce:	83 ec 0c             	sub    $0xc,%esp
   145d1:	50                   	push   %eax
   145d2:	e8 07 32 00 00       	call   177de <mutex_lock>
   145d7:	83 c4 10             	add    $0x10,%esp

    task_on_op=1;
   145da:	c7 05 84 63 03 00 01 	movl   $0x1,0x36384
   145e1:	00 00 00 

    disk_send_cmd(disk,partinfo->start_sector + addr, size, DISK_CMD_READ);
   145e4:	8b 45 14             	mov    0x14(%ebp),%eax
   145e7:	8b 55 f0             	mov    -0x10(%ebp),%edx
   145ea:	8b 4a 28             	mov    0x28(%edx),%ecx
   145ed:	8b 55 0c             	mov    0xc(%ebp),%edx
   145f0:	01 ca                	add    %ecx,%edx
   145f2:	6a 24                	push   $0x24
   145f4:	50                   	push   %eax
   145f5:	52                   	push   %edx
   145f6:	ff 75 ec             	pushl  -0x14(%ebp)
   145f9:	e8 52 f8 ff ff       	call   13e50 <disk_send_cmd>
   145fe:	83 c4 10             	add    $0x10,%esp
    int cnt;
    for(cnt=0;cnt<size;cnt++,buf+=disk->sector_size){
   14601:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14608:	eb 73                	jmp    1467d <disk_read+0x11e>
        if(task_current()){
   1460a:	e8 ec cf ff ff       	call   115fb <task_current>
   1460f:	85 c0                	test   %eax,%eax
   14611:	74 15                	je     14628 <disk_read+0xc9>
            sem_wait(disk->op_sem);
   14613:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14616:	8b 80 24 01 00 00    	mov    0x124(%eax),%eax
   1461c:	83 ec 0c             	sub    $0xc,%esp
   1461f:	50                   	push   %eax
   14620:	e8 35 33 00 00       	call   1795a <sem_wait>
   14625:	83 c4 10             	add    $0x10,%esp
        }

        int err=disk_wait_data(disk);
   14628:	83 ec 0c             	sub    $0xc,%esp
   1462b:	ff 75 ec             	pushl  -0x14(%ebp)
   1462e:	e8 ed f9 ff ff       	call   14020 <disk_wait_data>
   14633:	83 c4 10             	add    $0x10,%esp
   14636:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(err < 0){
   14639:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1463d:	79 19                	jns    14658 <disk_read+0xf9>
            log_printf("disk(%s) read error, start sector: %d,count: %d",
                disk->name,addr,size
   1463f:	8b 45 ec             	mov    -0x14(%ebp),%eax
            log_printf("disk(%s) read error, start sector: %d,count: %d",
   14642:	ff 75 14             	pushl  0x14(%ebp)
   14645:	ff 75 0c             	pushl  0xc(%ebp)
   14648:	50                   	push   %eax
   14649:	68 04 91 01 00       	push   $0x19104
   1464e:	e8 78 3e 00 00       	call   184cb <log_printf>
   14653:	83 c4 10             	add    $0x10,%esp
            );
            break;
   14656:	eb 2d                	jmp    14685 <disk_read+0x126>
        }

        disk_read_data(disk,buf,disk->sector_size);
   14658:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1465b:	8b 40 20             	mov    0x20(%eax),%eax
   1465e:	83 ec 04             	sub    $0x4,%esp
   14661:	50                   	push   %eax
   14662:	ff 75 10             	pushl  0x10(%ebp)
   14665:	ff 75 ec             	pushl  -0x14(%ebp)
   14668:	e8 13 f9 ff ff       	call   13f80 <disk_read_data>
   1466d:	83 c4 10             	add    $0x10,%esp
    for(cnt=0;cnt<size;cnt++,buf+=disk->sector_size){
   14670:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14674:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14677:	8b 40 20             	mov    0x20(%eax),%eax
   1467a:	01 45 10             	add    %eax,0x10(%ebp)
   1467d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14680:	3b 45 14             	cmp    0x14(%ebp),%eax
   14683:	7c 85                	jl     1460a <disk_read+0xab>

    }

    mutex_unlock(disk->mutex);
   14685:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14688:	8b 80 20 01 00 00    	mov    0x120(%eax),%eax
   1468e:	83 ec 0c             	sub    $0xc,%esp
   14691:	50                   	push   %eax
   14692:	e8 d6 31 00 00       	call   1786d <mutex_unlock>
   14697:	83 c4 10             	add    $0x10,%esp

    return cnt;
   1469a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1469d:	c9                   	leave  
   1469e:	c3                   	ret    

0001469f <disk_write>:

int disk_write(device_t* dev,int addr,char* buf,int size){
   1469f:	55                   	push   %ebp
   146a0:	89 e5                	mov    %esp,%ebp
   146a2:	83 ec 18             	sub    $0x18,%esp
    partinfo_t* partinfo=(partinfo_t*)dev->data;
   146a5:	8b 45 08             	mov    0x8(%ebp),%eax
   146a8:	8b 40 0c             	mov    0xc(%eax),%eax
   146ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(partinfo == (partinfo_t*)0){
   146ae:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   146b2:	75 21                	jne    146d5 <disk_write+0x36>
        log_printf("Get part info failed. device: %d",dev->minor);;
   146b4:	8b 45 08             	mov    0x8(%ebp),%eax
   146b7:	8b 40 08             	mov    0x8(%eax),%eax
   146ba:	83 ec 08             	sub    $0x8,%esp
   146bd:	50                   	push   %eax
   146be:	68 cc 90 01 00       	push   $0x190cc
   146c3:	e8 03 3e 00 00       	call   184cb <log_printf>
   146c8:	83 c4 10             	add    $0x10,%esp
        return -1;
   146cb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   146d0:	e9 08 01 00 00       	jmp    147dd <disk_write+0x13e>
    }

    disk_t* disk=partinfo->disk;
   146d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   146d8:	8b 40 20             	mov    0x20(%eax),%eax
   146db:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(disk == (disk_t*)0){
   146de:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   146e2:	75 21                	jne    14705 <disk_write+0x66>
        log_printf("No disk. device: %d",dev->minor);
   146e4:	8b 45 08             	mov    0x8(%ebp),%eax
   146e7:	8b 40 08             	mov    0x8(%eax),%eax
   146ea:	83 ec 08             	sub    $0x8,%esp
   146ed:	50                   	push   %eax
   146ee:	68 ed 90 01 00       	push   $0x190ed
   146f3:	e8 d3 3d 00 00       	call   184cb <log_printf>
   146f8:	83 c4 10             	add    $0x10,%esp
        return -1;
   146fb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14700:	e9 d8 00 00 00       	jmp    147dd <disk_write+0x13e>
    }

    mutex_lock(disk->mutex);
   14705:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14708:	8b 80 20 01 00 00    	mov    0x120(%eax),%eax
   1470e:	83 ec 0c             	sub    $0xc,%esp
   14711:	50                   	push   %eax
   14712:	e8 c7 30 00 00       	call   177de <mutex_lock>
   14717:	83 c4 10             	add    $0x10,%esp

    task_on_op=1;
   1471a:	c7 05 84 63 03 00 01 	movl   $0x1,0x36384
   14721:	00 00 00 

    disk_send_cmd(disk,partinfo->start_sector + addr, size, DISK_CMD_WRITE);
   14724:	8b 45 14             	mov    0x14(%ebp),%eax
   14727:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1472a:	8b 4a 28             	mov    0x28(%edx),%ecx
   1472d:	8b 55 0c             	mov    0xc(%ebp),%edx
   14730:	01 ca                	add    %ecx,%edx
   14732:	6a 34                	push   $0x34
   14734:	50                   	push   %eax
   14735:	52                   	push   %edx
   14736:	ff 75 ec             	pushl  -0x14(%ebp)
   14739:	e8 12 f7 ff ff       	call   13e50 <disk_send_cmd>
   1473e:	83 c4 10             	add    $0x10,%esp

    int cnt;
    for(cnt=0;cnt<size;cnt++,buf+=disk->sector_size){
   14741:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14748:	eb 73                	jmp    147bd <disk_write+0x11e>
        disk_write_data(disk,buf,disk->sector_size);
   1474a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1474d:	8b 40 20             	mov    0x20(%eax),%eax
   14750:	83 ec 04             	sub    $0x4,%esp
   14753:	50                   	push   %eax
   14754:	ff 75 10             	pushl  0x10(%ebp)
   14757:	ff 75 ec             	pushl  -0x14(%ebp)
   1475a:	e8 71 f8 ff ff       	call   13fd0 <disk_write_data>
   1475f:	83 c4 10             	add    $0x10,%esp

        if(task_current()){
   14762:	e8 94 ce ff ff       	call   115fb <task_current>
   14767:	85 c0                	test   %eax,%eax
   14769:	74 15                	je     14780 <disk_write+0xe1>
            sem_wait(disk->op_sem);
   1476b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1476e:	8b 80 24 01 00 00    	mov    0x124(%eax),%eax
   14774:	83 ec 0c             	sub    $0xc,%esp
   14777:	50                   	push   %eax
   14778:	e8 dd 31 00 00       	call   1795a <sem_wait>
   1477d:	83 c4 10             	add    $0x10,%esp
        }

        int err=disk_wait_data(disk);
   14780:	83 ec 0c             	sub    $0xc,%esp
   14783:	ff 75 ec             	pushl  -0x14(%ebp)
   14786:	e8 95 f8 ff ff       	call   14020 <disk_wait_data>
   1478b:	83 c4 10             	add    $0x10,%esp
   1478e:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(err < 0){
   14791:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   14795:	79 19                	jns    147b0 <disk_write+0x111>
            log_printf("disk(%s) read error, start sector: %d,count: %d",
                disk->name,addr,size
   14797:	8b 45 ec             	mov    -0x14(%ebp),%eax
            log_printf("disk(%s) read error, start sector: %d,count: %d",
   1479a:	ff 75 14             	pushl  0x14(%ebp)
   1479d:	ff 75 0c             	pushl  0xc(%ebp)
   147a0:	50                   	push   %eax
   147a1:	68 04 91 01 00       	push   $0x19104
   147a6:	e8 20 3d 00 00       	call   184cb <log_printf>
   147ab:	83 c4 10             	add    $0x10,%esp
            );
            break;
   147ae:	eb 15                	jmp    147c5 <disk_write+0x126>
    for(cnt=0;cnt<size;cnt++,buf+=disk->sector_size){
   147b0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   147b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   147b7:	8b 40 20             	mov    0x20(%eax),%eax
   147ba:	01 45 10             	add    %eax,0x10(%ebp)
   147bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   147c0:	3b 45 14             	cmp    0x14(%ebp),%eax
   147c3:	7c 85                	jl     1474a <disk_write+0xab>
        }

    }

    mutex_unlock(disk->mutex);
   147c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   147c8:	8b 80 20 01 00 00    	mov    0x120(%eax),%eax
   147ce:	83 ec 0c             	sub    $0xc,%esp
   147d1:	50                   	push   %eax
   147d2:	e8 96 30 00 00       	call   1786d <mutex_unlock>
   147d7:	83 c4 10             	add    $0x10,%esp

    return cnt;
   147da:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   147dd:	c9                   	leave  
   147de:	c3                   	ret    

000147df <disk_control>:

int disk_control(device_t* dev,int cmd,int arg0,int arg1){
   147df:	55                   	push   %ebp
   147e0:	89 e5                	mov    %esp,%ebp
    return -1;
   147e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   147e7:	5d                   	pop    %ebp
   147e8:	c3                   	ret    

000147e9 <disk_close>:

void disk_close(device_t* dev){
   147e9:	55                   	push   %ebp
   147ea:	89 e5                	mov    %esp,%ebp

}
   147ec:	90                   	nop
   147ed:	5d                   	pop    %ebp
   147ee:	c3                   	ret    

000147ef <do_handler_ide_primary>:

void do_handler_ide_primary(exception_frame_t* frame){
   147ef:	55                   	push   %ebp
   147f0:	89 e5                	mov    %esp,%ebp
   147f2:	83 ec 08             	sub    $0x8,%esp
    pic_send_eoi(IRQ14_HARDDISK_PRIMARY);
   147f5:	83 ec 0c             	sub    $0xc,%esp
   147f8:	6a 2e                	push   $0x2e
   147fa:	e8 da e6 ff ff       	call   12ed9 <pic_send_eoi>
   147ff:	83 c4 10             	add    $0x10,%esp

    if(task_on_op && task_current()){
   14802:	a1 84 63 03 00       	mov    0x36384,%eax
   14807:	85 c0                	test   %eax,%eax
   14809:	74 19                	je     14824 <do_handler_ide_primary+0x35>
   1480b:	e8 eb cd ff ff       	call   115fb <task_current>
   14810:	85 c0                	test   %eax,%eax
   14812:	74 10                	je     14824 <do_handler_ide_primary+0x35>
       sem_notify(&op_sem); 
   14814:	83 ec 0c             	sub    $0xc,%esp
   14817:	68 74 63 03 00       	push   $0x36374
   1481c:	e8 a7 31 00 00       	call   179c8 <sem_notify>
   14821:	83 c4 10             	add    $0x10,%esp
    }
}
   14824:	90                   	nop
   14825:	c9                   	leave  
   14826:	c3                   	ret    

00014827 <inb>:
static inline uint8_t inb(uint16_t port){
   14827:	55                   	push   %ebp
   14828:	89 e5                	mov    %esp,%ebp
   1482a:	83 ec 14             	sub    $0x14,%esp
   1482d:	8b 45 08             	mov    0x8(%ebp),%eax
   14830:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   14834:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   14838:	89 c2                	mov    %eax,%edx
   1483a:	ec                   	in     (%dx),%al
   1483b:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   1483e:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   14842:	c9                   	leave  
   14843:	c3                   	ret    

00014844 <kbd_init>:

/**
 * @brief 键盘初始化函数，将键盘中断处理函数注册到中断向量表中
 * @param none
*/
void kbd_init(void){
   14844:	55                   	push   %ebp
   14845:	89 e5                	mov    %esp,%ebp
   14847:	83 ec 08             	sub    $0x8,%esp
    static int inited=0;

    if(!inited){
   1484a:	a1 f4 65 03 00       	mov    0x365f4,%eax
   1484f:	85 c0                	test   %eax,%eax
   14851:	75 3d                	jne    14890 <kbd_init+0x4c>
        kernel_memset(&kbd_stat,0,sizeof(kbd_stat));
   14853:	83 ec 04             	sub    $0x4,%esp
   14856:	6a 04                	push   $0x4
   14858:	6a 00                	push   $0x0
   1485a:	68 f0 65 03 00       	push   $0x365f0
   1485f:	e8 44 36 00 00       	call   17ea8 <kernel_memset>
   14864:	83 c4 10             	add    $0x10,%esp
        irq_install(IRQ1_KEYBOARD,(irq_handler_t)exception_handler_kbd);
   14867:	83 ec 08             	sub    $0x8,%esp
   1486a:	68 a8 02 01 00       	push   $0x102a8
   1486f:	6a 21                	push   $0x21
   14871:	e8 4e e1 ff ff       	call   129c4 <irq_install>
   14876:	83 c4 10             	add    $0x10,%esp
        irq_enable(IRQ1_KEYBOARD);
   14879:	83 ec 0c             	sub    $0xc,%esp
   1487c:	6a 21                	push   $0x21
   1487e:	e8 81 de ff ff       	call   12704 <irq_enable>
   14883:	83 c4 10             	add    $0x10,%esp

        inited=1;
   14886:	c7 05 f4 65 03 00 01 	movl   $0x1,0x365f4
   1488d:	00 00 00 
    }

}
   14890:	90                   	nop
   14891:	c9                   	leave  
   14892:	c3                   	ret    

00014893 <is_make_code>:

static inline int is_make_code(uint8_t key_code){
   14893:	55                   	push   %ebp
   14894:	89 e5                	mov    %esp,%ebp
   14896:	83 ec 04             	sub    $0x4,%esp
   14899:	8b 45 08             	mov    0x8(%ebp),%eax
   1489c:	88 45 fc             	mov    %al,-0x4(%ebp)
    return !(key_code & 0x80);
   1489f:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
   148a3:	f7 d0                	not    %eax
   148a5:	c0 e8 07             	shr    $0x7,%al
   148a8:	0f b6 c0             	movzbl %al,%eax
}
   148ab:	c9                   	leave  
   148ac:	c3                   	ret    

000148ad <get_key>:

static inline char get_key(uint8_t key_code){
   148ad:	55                   	push   %ebp
   148ae:	89 e5                	mov    %esp,%ebp
   148b0:	83 ec 04             	sub    $0x4,%esp
   148b3:	8b 45 08             	mov    0x8(%ebp),%eax
   148b6:	88 45 fc             	mov    %al,-0x4(%ebp)
    return key_code & 0x7f;
   148b9:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
   148bd:	83 e0 7f             	and    $0x7f,%eax
}
   148c0:	c9                   	leave  
   148c1:	c3                   	ret    

000148c2 <do_fx_key>:

/**
 * @brief 根据F1-F8的按键值，切换到对应的屏幕，通过ctrl+F1-F8来切换
 * @param key F1-F8的按键值
*/
static void do_fx_key(int key){
   148c2:	55                   	push   %ebp
   148c3:	89 e5                	mov    %esp,%ebp
   148c5:	83 ec 18             	sub    $0x18,%esp
    int index=key-KEY_F1;
   148c8:	8b 45 08             	mov    0x8(%ebp),%eax
   148cb:	83 e8 3b             	sub    $0x3b,%eax
   148ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(kbd_stat.lctrl_press || kbd_stat.rctrl_press){
   148d1:	0f b6 05 f0 65 03 00 	movzbl 0x365f0,%eax
   148d8:	83 e0 20             	and    $0x20,%eax
   148db:	84 c0                	test   %al,%al
   148dd:	75 0e                	jne    148ed <do_fx_key+0x2b>
   148df:	0f b6 05 f0 65 03 00 	movzbl 0x365f0,%eax
   148e6:	83 e0 40             	and    $0x40,%eax
   148e9:	84 c0                	test   %al,%al
   148eb:	74 0e                	je     148fb <do_fx_key+0x39>
        tty_select(index);
   148ed:	83 ec 0c             	sub    $0xc,%esp
   148f0:	ff 75 f4             	pushl  -0xc(%ebp)
   148f3:	e8 46 09 00 00       	call   1523e <tty_select>
   148f8:	83 c4 10             	add    $0x10,%esp
    }
}
   148fb:	90                   	nop
   148fc:	c9                   	leave  
   148fd:	c3                   	ret    

000148fe <do_normal_key>:

static void do_normal_key(uint8_t raw_code){
   148fe:	55                   	push   %ebp
   148ff:	89 e5                	mov    %esp,%ebp
   14901:	83 ec 28             	sub    $0x28,%esp
   14904:	8b 45 08             	mov    0x8(%ebp),%eax
   14907:	88 45 e4             	mov    %al,-0x1c(%ebp)
    char key=get_key(raw_code);
   1490a:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   1490e:	50                   	push   %eax
   1490f:	e8 99 ff ff ff       	call   148ad <get_key>
   14914:	83 c4 04             	add    $0x4,%esp
   14917:	88 45 f7             	mov    %al,-0x9(%ebp)
    int is_make=is_make_code(raw_code);
   1491a:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   1491e:	50                   	push   %eax
   1491f:	e8 6f ff ff ff       	call   14893 <is_make_code>
   14924:	83 c4 04             	add    $0x4,%esp
   14927:	89 45 f0             	mov    %eax,-0x10(%ebp)

    switch(key)
   1492a:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   1492e:	83 e8 1d             	sub    $0x1d,%eax
   14931:	83 f8 25             	cmp    $0x25,%eax
   14934:	0f 87 fc 00 00 00    	ja     14a36 <do_normal_key+0x138>
   1493a:	8b 04 85 b4 91 01 00 	mov    0x191b4(,%eax,4),%eax
   14941:	ff e0                	jmp    *%eax
    {
    case KEY_RSHIFT:
        kbd_stat.rshift_press=is_make ? 1 : 0;
   14943:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14947:	0f 95 c0             	setne  %al
   1494a:	c1 e0 07             	shl    $0x7,%eax
   1494d:	c0 f8 07             	sar    $0x7,%al
   14950:	83 e0 01             	and    $0x1,%eax
   14953:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1495a:	0f b6 05 f0 65 03 00 	movzbl 0x365f0,%eax
   14961:	83 e0 fb             	and    $0xfffffffb,%eax
   14964:	09 d0                	or     %edx,%eax
   14966:	a2 f0 65 03 00       	mov    %al,0x365f0
        break;
   1496b:	e9 5e 01 00 00       	jmp    14ace <do_normal_key+0x1d0>
    case KEY_LSHIFT:
        kbd_stat.lshift_press=is_make ? 1 : 0;
   14970:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14974:	0f 95 c0             	setne  %al
   14977:	c1 e0 07             	shl    $0x7,%eax
   1497a:	c0 f8 07             	sar    $0x7,%al
   1497d:	83 e0 01             	and    $0x1,%eax
   14980:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14983:	0f b6 05 f0 65 03 00 	movzbl 0x365f0,%eax
   1498a:	83 e0 fd             	and    $0xfffffffd,%eax
   1498d:	09 d0                	or     %edx,%eax
   1498f:	a2 f0 65 03 00       	mov    %al,0x365f0
        break;
   14994:	e9 35 01 00 00       	jmp    14ace <do_normal_key+0x1d0>
    case KEY_CAPS:
        if(is_make){
   14999:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1499d:	0f 84 27 01 00 00    	je     14aca <do_normal_key+0x1cc>
            kbd_stat.caps_lock=~kbd_stat.caps_lock;
   149a3:	0f b6 05 f0 65 03 00 	movzbl 0x365f0,%eax
   149aa:	c1 e0 07             	shl    $0x7,%eax
   149ad:	c0 f8 07             	sar    $0x7,%al
   149b0:	f7 d0                	not    %eax
   149b2:	c1 e0 07             	shl    $0x7,%eax
   149b5:	c0 f8 07             	sar    $0x7,%al
   149b8:	83 e0 01             	and    $0x1,%eax
   149bb:	89 c2                	mov    %eax,%edx
   149bd:	0f b6 05 f0 65 03 00 	movzbl 0x365f0,%eax
   149c4:	83 e0 fe             	and    $0xfffffffe,%eax
   149c7:	09 d0                	or     %edx,%eax
   149c9:	a2 f0 65 03 00       	mov    %al,0x365f0
        }
        break;
   149ce:	e9 f7 00 00 00       	jmp    14aca <do_normal_key+0x1cc>
    case KEY_ALT:
        kbd_stat.lalt_press=is_make;
   149d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   149d6:	c1 e0 07             	shl    $0x7,%eax
   149d9:	c0 f8 07             	sar    $0x7,%al
   149dc:	83 e0 01             	and    $0x1,%eax
   149df:	c1 e0 04             	shl    $0x4,%eax
   149e2:	89 c2                	mov    %eax,%edx
   149e4:	0f b6 05 f0 65 03 00 	movzbl 0x365f0,%eax
   149eb:	83 e0 ef             	and    $0xffffffef,%eax
   149ee:	09 d0                	or     %edx,%eax
   149f0:	a2 f0 65 03 00       	mov    %al,0x365f0
        break;
   149f5:	e9 d4 00 00 00       	jmp    14ace <do_normal_key+0x1d0>
    case KEY_CTRL:
        kbd_stat.lctrl_press=is_make;
   149fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
   149fd:	c1 e0 07             	shl    $0x7,%eax
   14a00:	c0 f8 07             	sar    $0x7,%al
   14a03:	83 e0 01             	and    $0x1,%eax
   14a06:	c1 e0 05             	shl    $0x5,%eax
   14a09:	89 c2                	mov    %eax,%edx
   14a0b:	0f b6 05 f0 65 03 00 	movzbl 0x365f0,%eax
   14a12:	83 e0 df             	and    $0xffffffdf,%eax
   14a15:	09 d0                	or     %edx,%eax
   14a17:	a2 f0 65 03 00       	mov    %al,0x365f0
        break;
   14a1c:	e9 ad 00 00 00       	jmp    14ace <do_normal_key+0x1d0>
    case KEY_F4:
    case KEY_F5:
    case KEY_F6:
    case KEY_F7:
    case KEY_F8:
        do_fx_key(key);
   14a21:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   14a25:	83 ec 0c             	sub    $0xc,%esp
   14a28:	50                   	push   %eax
   14a29:	e8 94 fe ff ff       	call   148c2 <do_fx_key>
   14a2e:	83 c4 10             	add    $0x10,%esp
        break;
   14a31:	e9 98 00 00 00       	jmp    14ace <do_normal_key+0x1d0>
    default:
        if(is_make){
   14a36:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14a3a:	0f 84 8d 00 00 00    	je     14acd <do_normal_key+0x1cf>
            if(kbd_stat.lshift_press || kbd_stat.rshift_press){
   14a40:	0f b6 05 f0 65 03 00 	movzbl 0x365f0,%eax
   14a47:	83 e0 02             	and    $0x2,%eax
   14a4a:	84 c0                	test   %al,%al
   14a4c:	75 0e                	jne    14a5c <do_normal_key+0x15e>
   14a4e:	0f b6 05 f0 65 03 00 	movzbl 0x365f0,%eax
   14a55:	83 e0 04             	and    $0x4,%eax
   14a58:	84 c0                	test   %al,%al
   14a5a:	74 11                	je     14a6d <do_normal_key+0x16f>
                key=map_table[key].func;
   14a5c:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   14a60:	0f b6 84 00 41 91 01 	movzbl 0x19141(%eax,%eax,1),%eax
   14a67:	00 
   14a68:	88 45 f7             	mov    %al,-0x9(%ebp)
   14a6b:	eb 0f                	jmp    14a7c <do_normal_key+0x17e>
            }
            else{
                key=map_table[key].normal;
   14a6d:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   14a71:	0f b6 84 00 40 91 01 	movzbl 0x19140(%eax,%eax,1),%eax
   14a78:	00 
   14a79:	88 45 f7             	mov    %al,-0x9(%ebp)
            }

            if(kbd_stat.caps_lock){
   14a7c:	0f b6 05 f0 65 03 00 	movzbl 0x365f0,%eax
   14a83:	83 e0 01             	and    $0x1,%eax
   14a86:	84 c0                	test   %al,%al
   14a88:	74 2e                	je     14ab8 <do_normal_key+0x1ba>
                if((key>='A') && (key <='Z')){
   14a8a:	80 7d f7 40          	cmpb   $0x40,-0x9(%ebp)
   14a8e:	7e 12                	jle    14aa2 <do_normal_key+0x1a4>
   14a90:	80 7d f7 5a          	cmpb   $0x5a,-0x9(%ebp)
   14a94:	7f 0c                	jg     14aa2 <do_normal_key+0x1a4>
                    key=key-'A'+'a';
   14a96:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   14a9a:	83 c0 20             	add    $0x20,%eax
   14a9d:	88 45 f7             	mov    %al,-0x9(%ebp)
   14aa0:	eb 16                	jmp    14ab8 <do_normal_key+0x1ba>
                }
                else if((key >= 'a') && (key <= 'z')){
   14aa2:	80 7d f7 60          	cmpb   $0x60,-0x9(%ebp)
   14aa6:	7e 10                	jle    14ab8 <do_normal_key+0x1ba>
   14aa8:	80 7d f7 7a          	cmpb   $0x7a,-0x9(%ebp)
   14aac:	7f 0a                	jg     14ab8 <do_normal_key+0x1ba>
                    key=key-'a'+'A';
   14aae:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   14ab2:	83 e8 20             	sub    $0x20,%eax
   14ab5:	88 45 f7             	mov    %al,-0x9(%ebp)
                }
            }

            tty_in(key);
   14ab8:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   14abc:	83 ec 0c             	sub    $0xc,%esp
   14abf:	50                   	push   %eax
   14ac0:	e8 0c 07 00 00       	call   151d1 <tty_in>
   14ac5:	83 c4 10             	add    $0x10,%esp
        }
        break;
   14ac8:	eb 03                	jmp    14acd <do_normal_key+0x1cf>
        break;
   14aca:	90                   	nop
   14acb:	eb 01                	jmp    14ace <do_normal_key+0x1d0>
        break;
   14acd:	90                   	nop
    }
}
   14ace:	90                   	nop
   14acf:	c9                   	leave  
   14ad0:	c3                   	ret    

00014ad1 <do_e0_key>:

void do_e0_key(uint8_t raw_code){
   14ad1:	55                   	push   %ebp
   14ad2:	89 e5                	mov    %esp,%ebp
   14ad4:	83 ec 14             	sub    $0x14,%esp
   14ad7:	8b 45 08             	mov    0x8(%ebp),%eax
   14ada:	88 45 ec             	mov    %al,-0x14(%ebp)
    char key=get_key(raw_code);
   14add:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
   14ae1:	50                   	push   %eax
   14ae2:	e8 c6 fd ff ff       	call   148ad <get_key>
   14ae7:	83 c4 04             	add    $0x4,%esp
   14aea:	88 45 ff             	mov    %al,-0x1(%ebp)
    int is_make=is_make_code(raw_code);
   14aed:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
   14af1:	50                   	push   %eax
   14af2:	e8 9c fd ff ff       	call   14893 <is_make_code>
   14af7:	83 c4 04             	add    $0x4,%esp
   14afa:	89 45 f8             	mov    %eax,-0x8(%ebp)

    switch (key)
   14afd:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
   14b01:	83 f8 1d             	cmp    $0x1d,%eax
   14b04:	74 07                	je     14b0d <do_e0_key+0x3c>
   14b06:	83 f8 38             	cmp    $0x38,%eax
   14b09:	74 26                	je     14b31 <do_e0_key+0x60>
        break;
    case KEY_ALT:
        kbd_stat.ralt_press;
        break;
    default:
        break;
   14b0b:	eb 25                	jmp    14b32 <do_e0_key+0x61>
        kbd_stat.rctrl_press=is_make;
   14b0d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14b10:	c1 e0 07             	shl    $0x7,%eax
   14b13:	c0 f8 07             	sar    $0x7,%al
   14b16:	83 e0 01             	and    $0x1,%eax
   14b19:	c1 e0 06             	shl    $0x6,%eax
   14b1c:	89 c2                	mov    %eax,%edx
   14b1e:	0f b6 05 f0 65 03 00 	movzbl 0x365f0,%eax
   14b25:	83 e0 bf             	and    $0xffffffbf,%eax
   14b28:	09 d0                	or     %edx,%eax
   14b2a:	a2 f0 65 03 00       	mov    %al,0x365f0
        break;
   14b2f:	eb 01                	jmp    14b32 <do_e0_key+0x61>
        break;
   14b31:	90                   	nop
    }
}
   14b32:	90                   	nop
   14b33:	c9                   	leave  
   14b34:	c3                   	ret    

00014b35 <do_handler_kbd>:

void do_handler_kbd(exception_frame_t *frame){
   14b35:	55                   	push   %ebp
   14b36:	89 e5                	mov    %esp,%ebp
   14b38:	83 ec 18             	sub    $0x18,%esp
    static enum{
        NORMAL,
        BEGIN_E0,
        BEGIN_E1,
    }recv_state=NORMAL;
    uint8_t status=inb(KBD_PORT_STAT);
   14b3b:	6a 64                	push   $0x64
   14b3d:	e8 e5 fc ff ff       	call   14827 <inb>
   14b42:	83 c4 04             	add    $0x4,%esp
   14b45:	88 45 f7             	mov    %al,-0x9(%ebp)

    if(!(status & KBD_STAT_RECV_READY)){
   14b48:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   14b4c:	83 e0 01             	and    $0x1,%eax
   14b4f:	85 c0                	test   %eax,%eax
   14b51:	75 12                	jne    14b65 <do_handler_kbd+0x30>
        pic_send_eoi(IRQ1_KEYBOARD);
   14b53:	83 ec 0c             	sub    $0xc,%esp
   14b56:	6a 21                	push   $0x21
   14b58:	e8 7c e3 ff ff       	call   12ed9 <pic_send_eoi>
   14b5d:	83 c4 10             	add    $0x10,%esp
        return;
   14b60:	e9 8e 00 00 00       	jmp    14bf3 <do_handler_kbd+0xbe>
    }

    uint8_t raw_code=inb(KBD_PORT_DATA);
   14b65:	83 ec 0c             	sub    $0xc,%esp
   14b68:	6a 60                	push   $0x60
   14b6a:	e8 b8 fc ff ff       	call   14827 <inb>
   14b6f:	83 c4 10             	add    $0x10,%esp
   14b72:	88 45 f6             	mov    %al,-0xa(%ebp)

    if(raw_code == KEY_E0){
   14b75:	80 7d f6 e0          	cmpb   $0xe0,-0xa(%ebp)
   14b79:	75 0a                	jne    14b85 <do_handler_kbd+0x50>
        recv_state=BEGIN_E0;
   14b7b:	c7 05 f8 65 03 00 01 	movl   $0x1,0x365f8
   14b82:	00 00 00 
    }

    if(raw_code == KEY_E1){
   14b85:	80 7d f6 e1          	cmpb   $0xe1,-0xa(%ebp)
   14b89:	75 0c                	jne    14b97 <do_handler_kbd+0x62>
        recv_state=BEGIN_E1;
   14b8b:	c7 05 f8 65 03 00 02 	movl   $0x2,0x365f8
   14b92:	00 00 00 
   14b95:	eb 4f                	jmp    14be6 <do_handler_kbd+0xb1>
    }
    else{
        switch (recv_state)
   14b97:	a1 f8 65 03 00       	mov    0x365f8,%eax
   14b9c:	83 f8 01             	cmp    $0x1,%eax
   14b9f:	74 1e                	je     14bbf <do_handler_kbd+0x8a>
   14ba1:	83 f8 01             	cmp    $0x1,%eax
   14ba4:	72 07                	jb     14bad <do_handler_kbd+0x78>
   14ba6:	83 f8 02             	cmp    $0x2,%eax
   14ba9:	74 30                	je     14bdb <do_handler_kbd+0xa6>
            break;
        case BEGIN_E1:
            recv_state=NORMAL;
            break;
        default:
            break;
   14bab:	eb 39                	jmp    14be6 <do_handler_kbd+0xb1>
            do_normal_key(raw_code);
   14bad:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
   14bb1:	83 ec 0c             	sub    $0xc,%esp
   14bb4:	50                   	push   %eax
   14bb5:	e8 44 fd ff ff       	call   148fe <do_normal_key>
   14bba:	83 c4 10             	add    $0x10,%esp
            break;
   14bbd:	eb 27                	jmp    14be6 <do_handler_kbd+0xb1>
            do_e0_key(raw_code);
   14bbf:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
   14bc3:	83 ec 0c             	sub    $0xc,%esp
   14bc6:	50                   	push   %eax
   14bc7:	e8 05 ff ff ff       	call   14ad1 <do_e0_key>
   14bcc:	83 c4 10             	add    $0x10,%esp
            recv_state=NORMAL;
   14bcf:	c7 05 f8 65 03 00 00 	movl   $0x0,0x365f8
   14bd6:	00 00 00 
            break;
   14bd9:	eb 0b                	jmp    14be6 <do_handler_kbd+0xb1>
            recv_state=NORMAL;
   14bdb:	c7 05 f8 65 03 00 00 	movl   $0x0,0x365f8
   14be2:	00 00 00 
            break;
   14be5:	90                   	nop
        }
    }

    pic_send_eoi(IRQ1_KEYBOARD);
   14be6:	83 ec 0c             	sub    $0xc,%esp
   14be9:	6a 21                	push   $0x21
   14beb:	e8 e9 e2 ff ff       	call   12ed9 <pic_send_eoi>
   14bf0:	83 c4 10             	add    $0x10,%esp
   14bf3:	c9                   	leave  
   14bf4:	c3                   	ret    

00014bf5 <outb>:
static inline void outb(uint16_t port,uint8_t data){
   14bf5:	55                   	push   %ebp
   14bf6:	89 e5                	mov    %esp,%ebp
   14bf8:	83 ec 08             	sub    $0x8,%esp
   14bfb:	8b 55 08             	mov    0x8(%ebp),%edx
   14bfe:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c01:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   14c05:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   14c08:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   14c0c:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   14c10:	ee                   	out    %al,(%dx)
}
   14c11:	90                   	nop
   14c12:	c9                   	leave  
   14c13:	c3                   	ret    

00014c14 <do_handler_time>:
#include "dev/time.h"

// 定时器计数
static uint32_t sys_tick;

void do_handler_time(exception_frame_t* frame){
   14c14:	55                   	push   %ebp
   14c15:	89 e5                	mov    %esp,%ebp
   14c17:	83 ec 08             	sub    $0x8,%esp
    sys_tick++;
   14c1a:	a1 fc 65 03 00       	mov    0x365fc,%eax
   14c1f:	83 c0 01             	add    $0x1,%eax
   14c22:	a3 fc 65 03 00       	mov    %eax,0x365fc
    pic_send_eoi(IRQ0_TIMER);
   14c27:	83 ec 0c             	sub    $0xc,%esp
   14c2a:	6a 20                	push   $0x20
   14c2c:	e8 a8 e2 ff ff       	call   12ed9 <pic_send_eoi>
   14c31:	83 c4 10             	add    $0x10,%esp
    task_time_tick();
   14c34:	e8 88 ca ff ff       	call   116c1 <task_time_tick>
}
   14c39:	90                   	nop
   14c3a:	c9                   	leave  
   14c3b:	c3                   	ret    

00014c3c <init_pit>:

// 定时器硬件初始化
static void init_pit(void){
   14c3c:	55                   	push   %ebp
   14c3d:	89 e5                	mov    %esp,%ebp
   14c3f:	83 ec 18             	sub    $0x18,%esp
    
    uint32_t reload_count = PIT_OSC_FREQ / (1000.0 / OS_TICK_MS);
   14c42:	c7 45 f4 9b 2e 00 00 	movl   $0x2e9b,-0xc(%ebp)
    // 设置多少秒产生中断
    outb(PIT_COMMAND_MODE_PORT, PIT_CHANNEL0 | PIT_LOAD_LOHI | PIT_MODE3);
   14c49:	6a 36                	push   $0x36
   14c4b:	6a 43                	push   $0x43
   14c4d:	e8 a3 ff ff ff       	call   14bf5 <outb>
   14c52:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, reload_count & 0xFF);   // 加载低8位
   14c55:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14c58:	0f b6 c0             	movzbl %al,%eax
   14c5b:	50                   	push   %eax
   14c5c:	6a 40                	push   $0x40
   14c5e:	e8 92 ff ff ff       	call   14bf5 <outb>
   14c63:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, (reload_count >> 8) & 0xFF); // 再加载高8位
   14c66:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14c69:	c1 e8 08             	shr    $0x8,%eax
   14c6c:	0f b6 c0             	movzbl %al,%eax
   14c6f:	50                   	push   %eax
   14c70:	6a 40                	push   $0x40
   14c72:	e8 7e ff ff ff       	call   14bf5 <outb>
   14c77:	83 c4 08             	add    $0x8,%esp

    irq_install(IRQ0_TIMER, (irq_handler_t)exception_handler_time);
   14c7a:	83 ec 08             	sub    $0x8,%esp
   14c7d:	68 89 02 01 00       	push   $0x10289
   14c82:	6a 20                	push   $0x20
   14c84:	e8 3b dd ff ff       	call   129c4 <irq_install>
   14c89:	83 c4 10             	add    $0x10,%esp
    irq_enable(IRQ0_TIMER);
   14c8c:	83 ec 0c             	sub    $0xc,%esp
   14c8f:	6a 20                	push   $0x20
   14c91:	e8 6e da ff ff       	call   12704 <irq_enable>
   14c96:	83 c4 10             	add    $0x10,%esp
}
   14c99:	90                   	nop
   14c9a:	c9                   	leave  
   14c9b:	c3                   	ret    

00014c9c <time_init>:

// 定时器初始化
void time_init(void){
   14c9c:	55                   	push   %ebp
   14c9d:	89 e5                	mov    %esp,%ebp
   14c9f:	83 ec 08             	sub    $0x8,%esp
    sys_tick=0;
   14ca2:	c7 05 fc 65 03 00 00 	movl   $0x0,0x365fc
   14ca9:	00 00 00 
    init_pit();
   14cac:	e8 8b ff ff ff       	call   14c3c <init_pit>
   14cb1:	90                   	nop
   14cb2:	c9                   	leave  
   14cb3:	c3                   	ret    

00014cb4 <get_tty>:
static tty_t tty_devs[TTY_NR];

/// @brief 当前使用的tty设备的索引
static int curr_tty=0;

static tty_t* get_tty(device_t* dev){
   14cb4:	55                   	push   %ebp
   14cb5:	89 e5                	mov    %esp,%ebp
   14cb7:	83 ec 18             	sub    $0x18,%esp
    int idx=dev->minor;
   14cba:	8b 45 08             	mov    0x8(%ebp),%eax
   14cbd:	8b 40 08             	mov    0x8(%eax),%eax
   14cc0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if((idx<0) || (idx>=TTY_NR) || (!dev->open_count)){
   14cc3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14cc7:	78 10                	js     14cd9 <get_tty+0x25>
   14cc9:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14ccd:	7f 0a                	jg     14cd9 <get_tty+0x25>
   14ccf:	8b 45 08             	mov    0x8(%ebp),%eax
   14cd2:	8b 40 10             	mov    0x10(%eax),%eax
   14cd5:	85 c0                	test   %eax,%eax
   14cd7:	75 1a                	jne    14cf3 <get_tty+0x3f>
        log_printf("tty is not opened. tty=%d\n",idx);
   14cd9:	83 ec 08             	sub    $0x8,%esp
   14cdc:	ff 75 f4             	pushl  -0xc(%ebp)
   14cdf:	68 4c 92 01 00       	push   $0x1924c
   14ce4:	e8 e2 37 00 00       	call   184cb <log_printf>
   14ce9:	83 c4 10             	add    $0x10,%esp
        return (tty_t*)0;
   14cec:	b8 00 00 00 00       	mov    $0x0,%eax
   14cf1:	eb 0e                	jmp    14d01 <get_tty+0x4d>
    }

    return tty_devs+idx;
   14cf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14cf6:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   14cfc:	05 00 66 03 00       	add    $0x36600,%eax
}
   14d01:	c9                   	leave  
   14d02:	c3                   	ret    

00014d03 <tty_fifo_init>:

void tty_fifo_init(tty_fifo_t* fifo,char* buf,int size){
   14d03:	55                   	push   %ebp
   14d04:	89 e5                	mov    %esp,%ebp
    fifo->buf=buf;
   14d06:	8b 45 08             	mov    0x8(%ebp),%eax
   14d09:	8b 55 0c             	mov    0xc(%ebp),%edx
   14d0c:	89 10                	mov    %edx,(%eax)
    fifo->size=size;
   14d0e:	8b 45 08             	mov    0x8(%ebp),%eax
   14d11:	8b 55 10             	mov    0x10(%ebp),%edx
   14d14:	89 50 04             	mov    %edx,0x4(%eax)
    fifo->count=0;
   14d17:	8b 45 08             	mov    0x8(%ebp),%eax
   14d1a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    fifo->read=fifo->write=0;
   14d21:	8b 45 08             	mov    0x8(%ebp),%eax
   14d24:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   14d2b:	8b 45 08             	mov    0x8(%ebp),%eax
   14d2e:	8b 50 0c             	mov    0xc(%eax),%edx
   14d31:	8b 45 08             	mov    0x8(%ebp),%eax
   14d34:	89 50 08             	mov    %edx,0x8(%eax)
}
   14d37:	90                   	nop
   14d38:	5d                   	pop    %ebp
   14d39:	c3                   	ret    

00014d3a <tty_fifo_put>:
 * @brief 向tty的输出缓存中写入一个字符
 * @param fifo tty的输出缓存
 * @param c 要写入的字符
 * @return 0 成功，-1 失败
 */
int tty_fifo_put(tty_fifo_t* fifo,char c){
   14d3a:	55                   	push   %ebp
   14d3b:	89 e5                	mov    %esp,%ebp
   14d3d:	53                   	push   %ebx
   14d3e:	83 ec 24             	sub    $0x24,%esp
   14d41:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d44:	88 45 e4             	mov    %al,-0x1c(%ebp)
    irq_state_t state=irq_enter_protection();
   14d47:	e8 b8 e1 ff ff       	call   12f04 <irq_enter_protection>
   14d4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(fifo->count>=fifo->size){
   14d4f:	8b 45 08             	mov    0x8(%ebp),%eax
   14d52:	8b 50 10             	mov    0x10(%eax),%edx
   14d55:	8b 45 08             	mov    0x8(%ebp),%eax
   14d58:	8b 40 04             	mov    0x4(%eax),%eax
   14d5b:	39 c2                	cmp    %eax,%edx
   14d5d:	7c 15                	jl     14d74 <tty_fifo_put+0x3a>

        irq_leave_protection(state);
   14d5f:	83 ec 0c             	sub    $0xc,%esp
   14d62:	ff 75 f4             	pushl  -0xc(%ebp)
   14d65:	e8 b2 e1 ff ff       	call   12f1c <irq_leave_protection>
   14d6a:	83 c4 10             	add    $0x10,%esp
        return -1;
   14d6d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14d72:	eb 4b                	jmp    14dbf <tty_fifo_put+0x85>
    }

    fifo->buf[fifo->write++]=c;
   14d74:	8b 45 08             	mov    0x8(%ebp),%eax
   14d77:	8b 18                	mov    (%eax),%ebx
   14d79:	8b 45 08             	mov    0x8(%ebp),%eax
   14d7c:	8b 40 0c             	mov    0xc(%eax),%eax
   14d7f:	8d 48 01             	lea    0x1(%eax),%ecx
   14d82:	8b 55 08             	mov    0x8(%ebp),%edx
   14d85:	89 4a 0c             	mov    %ecx,0xc(%edx)
   14d88:	8d 14 03             	lea    (%ebx,%eax,1),%edx
   14d8b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   14d8f:	88 02                	mov    %al,(%edx)
    if(fifo->write>=fifo->size){
   14d91:	8b 45 08             	mov    0x8(%ebp),%eax
   14d94:	8b 50 0c             	mov    0xc(%eax),%edx
   14d97:	8b 45 08             	mov    0x8(%ebp),%eax
   14d9a:	8b 40 04             	mov    0x4(%eax),%eax
   14d9d:	39 c2                	cmp    %eax,%edx
   14d9f:	7c 0a                	jl     14dab <tty_fifo_put+0x71>
        fifo->write=0;
   14da1:	8b 45 08             	mov    0x8(%ebp),%eax
   14da4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    }
    
    fifo->count++;
   14dab:	8b 45 08             	mov    0x8(%ebp),%eax
   14dae:	8b 40 10             	mov    0x10(%eax),%eax
   14db1:	8d 50 01             	lea    0x1(%eax),%edx
   14db4:	8b 45 08             	mov    0x8(%ebp),%eax
   14db7:	89 50 10             	mov    %edx,0x10(%eax)

    return 0;
   14dba:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14dbf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14dc2:	c9                   	leave  
   14dc3:	c3                   	ret    

00014dc4 <tty_fifo_get>:

int tty_fifo_get(tty_fifo_t* fifo,char* c){
   14dc4:	55                   	push   %ebp
   14dc5:	89 e5                	mov    %esp,%ebp
   14dc7:	53                   	push   %ebx
   14dc8:	83 ec 14             	sub    $0x14,%esp
    irq_state_t state=irq_enter_protection();
   14dcb:	e8 34 e1 ff ff       	call   12f04 <irq_enter_protection>
   14dd0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(fifo->count<=0){
   14dd3:	8b 45 08             	mov    0x8(%ebp),%eax
   14dd6:	8b 40 10             	mov    0x10(%eax),%eax
   14dd9:	85 c0                	test   %eax,%eax
   14ddb:	7f 15                	jg     14df2 <tty_fifo_get+0x2e>
        irq_leave_protection(state);
   14ddd:	83 ec 0c             	sub    $0xc,%esp
   14de0:	ff 75 f4             	pushl  -0xc(%ebp)
   14de3:	e8 34 e1 ff ff       	call   12f1c <irq_leave_protection>
   14de8:	83 c4 10             	add    $0x10,%esp
        return -1;
   14deb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14df0:	eb 5a                	jmp    14e4c <tty_fifo_get+0x88>
    }

    *c=fifo->buf[fifo->read++];
   14df2:	8b 45 08             	mov    0x8(%ebp),%eax
   14df5:	8b 18                	mov    (%eax),%ebx
   14df7:	8b 45 08             	mov    0x8(%ebp),%eax
   14dfa:	8b 40 08             	mov    0x8(%eax),%eax
   14dfd:	8d 48 01             	lea    0x1(%eax),%ecx
   14e00:	8b 55 08             	mov    0x8(%ebp),%edx
   14e03:	89 4a 08             	mov    %ecx,0x8(%edx)
   14e06:	01 d8                	add    %ebx,%eax
   14e08:	0f b6 10             	movzbl (%eax),%edx
   14e0b:	8b 45 0c             	mov    0xc(%ebp),%eax
   14e0e:	88 10                	mov    %dl,(%eax)
    if(fifo->read>=fifo->size){
   14e10:	8b 45 08             	mov    0x8(%ebp),%eax
   14e13:	8b 50 08             	mov    0x8(%eax),%edx
   14e16:	8b 45 08             	mov    0x8(%ebp),%eax
   14e19:	8b 40 04             	mov    0x4(%eax),%eax
   14e1c:	39 c2                	cmp    %eax,%edx
   14e1e:	7c 0a                	jl     14e2a <tty_fifo_get+0x66>
        fifo->read=0;
   14e20:	8b 45 08             	mov    0x8(%ebp),%eax
   14e23:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    }
    fifo->count--;
   14e2a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e2d:	8b 40 10             	mov    0x10(%eax),%eax
   14e30:	8d 50 ff             	lea    -0x1(%eax),%edx
   14e33:	8b 45 08             	mov    0x8(%ebp),%eax
   14e36:	89 50 10             	mov    %edx,0x10(%eax)

    irq_leave_protection(state);
   14e39:	83 ec 0c             	sub    $0xc,%esp
   14e3c:	ff 75 f4             	pushl  -0xc(%ebp)
   14e3f:	e8 d8 e0 ff ff       	call   12f1c <irq_leave_protection>
   14e44:	83 c4 10             	add    $0x10,%esp
    return 0;
   14e47:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14e4c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14e4f:	c9                   	leave  
   14e50:	c3                   	ret    

00014e51 <tty_open>:

int tty_open(device_t* dev){
   14e51:	55                   	push   %ebp
   14e52:	89 e5                	mov    %esp,%ebp
   14e54:	83 ec 18             	sub    $0x18,%esp
    int idx=dev->minor;
   14e57:	8b 45 08             	mov    0x8(%ebp),%eax
   14e5a:	8b 40 08             	mov    0x8(%eax),%eax
   14e5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if((idx<0)&&(idx>=TTY_NR)){
   14e60:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14e64:	79 23                	jns    14e89 <tty_open+0x38>
   14e66:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14e6a:	7e 1d                	jle    14e89 <tty_open+0x38>
        log_printf("open tty failed. incorrect tty num=%d\n",idx);
   14e6c:	83 ec 08             	sub    $0x8,%esp
   14e6f:	ff 75 f4             	pushl  -0xc(%ebp)
   14e72:	68 68 92 01 00       	push   $0x19268
   14e77:	e8 4f 36 00 00       	call   184cb <log_printf>
   14e7c:	83 c4 10             	add    $0x10,%esp
        return -1;
   14e7f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14e84:	e9 c6 00 00 00       	jmp    14f4f <tty_open+0xfe>
    }

    tty_t* tty=tty_devs+idx;
   14e89:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14e8c:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   14e92:	05 00 66 03 00       	add    $0x36600,%eax
   14e97:	89 45 f0             	mov    %eax,-0x10(%ebp)

    tty_fifo_init(&tty->ofifo,tty->obuf,TTY_OBUF_SIZE);
   14e9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14e9d:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14ea0:	81 c2 00 04 00 00    	add    $0x400,%edx
   14ea6:	83 ec 04             	sub    $0x4,%esp
   14ea9:	68 00 02 00 00       	push   $0x200
   14eae:	50                   	push   %eax
   14eaf:	52                   	push   %edx
   14eb0:	e8 4e fe ff ff       	call   14d03 <tty_fifo_init>
   14eb5:	83 c4 10             	add    $0x10,%esp
    sem_init(&tty->osem,TTY_OBUF_SIZE);
   14eb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ebb:	05 2c 04 00 00       	add    $0x42c,%eax
   14ec0:	83 ec 08             	sub    $0x8,%esp
   14ec3:	68 00 02 00 00       	push   $0x200
   14ec8:	50                   	push   %eax
   14ec9:	e8 69 2a 00 00       	call   17937 <sem_init>
   14ece:	83 c4 10             	add    $0x10,%esp
    tty_fifo_init(&tty->ififo,tty->ibuf,TTY_IBUF_SIZE);
   14ed1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ed4:	8d 90 00 02 00 00    	lea    0x200(%eax),%edx
   14eda:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14edd:	05 14 04 00 00       	add    $0x414,%eax
   14ee2:	83 ec 04             	sub    $0x4,%esp
   14ee5:	68 00 02 00 00       	push   $0x200
   14eea:	52                   	push   %edx
   14eeb:	50                   	push   %eax
   14eec:	e8 12 fe ff ff       	call   14d03 <tty_fifo_init>
   14ef1:	83 c4 10             	add    $0x10,%esp
    sem_init(&tty->isem,0);
   14ef4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ef7:	05 3c 04 00 00       	add    $0x43c,%eax
   14efc:	83 ec 08             	sub    $0x8,%esp
   14eff:	6a 00                	push   $0x0
   14f01:	50                   	push   %eax
   14f02:	e8 30 2a 00 00       	call   17937 <sem_init>
   14f07:	83 c4 10             	add    $0x10,%esp

    tty->oflags=TTY_OCRLF;
   14f0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f0d:	c7 80 50 04 00 00 01 	movl   $0x1,0x450(%eax)
   14f14:	00 00 00 
    tty->console_index=idx;
   14f17:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f1a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14f1d:	89 90 28 04 00 00    	mov    %edx,0x428(%eax)

    tty->iflags=TTY_IECHO | TTY_INCLR;
   14f23:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f26:	c7 80 4c 04 00 00 03 	movl   $0x3,0x44c(%eax)
   14f2d:	00 00 00 

    kbd_init();    
   14f30:	e8 0f f9 ff ff       	call   14844 <kbd_init>
    console_init(tty->console_index);
   14f35:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f38:	8b 80 28 04 00 00    	mov    0x428(%eax),%eax
   14f3e:	83 ec 0c             	sub    $0xc,%esp
   14f41:	50                   	push   %eax
   14f42:	e8 28 e4 ff ff       	call   1336f <console_init>
   14f47:	83 c4 10             	add    $0x10,%esp
    
    return 0;
   14f4a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14f4f:	c9                   	leave  
   14f50:	c3                   	ret    

00014f51 <tty_read>:
 * @param addr 读的起始地址，暂时不使用
 * @param buf 读到的字符存放的地址
 * @param size 读的字符的个数
 * @return 读到的字符的个数，失败返回-1
 */
int tty_read(device_t* dev,int addr,char* buf,int size){
   14f51:	55                   	push   %ebp
   14f52:	89 e5                	mov    %esp,%ebp
   14f54:	83 ec 18             	sub    $0x18,%esp
    if(size < 0){
   14f57:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   14f5b:	79 0a                	jns    14f67 <tty_read+0x16>
        return -1;
   14f5d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14f62:	e9 09 01 00 00       	jmp    15070 <tty_read+0x11f>
    }

    tty_t* tty=get_tty(dev);
   14f67:	83 ec 0c             	sub    $0xc,%esp
   14f6a:	ff 75 08             	pushl  0x8(%ebp)
   14f6d:	e8 42 fd ff ff       	call   14cb4 <get_tty>
   14f72:	83 c4 10             	add    $0x10,%esp
   14f75:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char* pbuf=buf;
   14f78:	8b 45 10             	mov    0x10(%ebp),%eax
   14f7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int len=0;
   14f7e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while(len < size){
   14f85:	e9 d7 00 00 00       	jmp    15061 <tty_read+0x110>
        sem_wait(&tty->isem);
   14f8a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f8d:	05 3c 04 00 00       	add    $0x43c,%eax
   14f92:	83 ec 0c             	sub    $0xc,%esp
   14f95:	50                   	push   %eax
   14f96:	e8 bf 29 00 00       	call   1795a <sem_wait>
   14f9b:	83 c4 10             	add    $0x10,%esp

        char ch;
        tty_fifo_get(&tty->ififo,&ch);
   14f9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14fa1:	8d 90 14 04 00 00    	lea    0x414(%eax),%edx
   14fa7:	83 ec 08             	sub    $0x8,%esp
   14faa:	8d 45 eb             	lea    -0x15(%ebp),%eax
   14fad:	50                   	push   %eax
   14fae:	52                   	push   %edx
   14faf:	e8 10 fe ff ff       	call   14dc4 <tty_fifo_get>
   14fb4:	83 c4 10             	add    $0x10,%esp
        switch(ch){
   14fb7:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   14fbb:	0f be c0             	movsbl %al,%eax
   14fbe:	83 f8 0a             	cmp    $0xa,%eax
   14fc1:	74 1a                	je     14fdd <tty_read+0x8c>
   14fc3:	83 f8 7f             	cmp    $0x7f,%eax
   14fc6:	75 52                	jne    1501a <tty_read+0xc9>
            
            // 处理推格键
            case 0x7F:
                if(len == 0){
   14fc8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14fcc:	75 05                	jne    14fd3 <tty_read+0x82>
   14fce:	e9 8e 00 00 00       	jmp    15061 <tty_read+0x110>
                   continue;
                }

                len--;
   14fd3:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
                pbuf--;
   14fd7:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
                break;
   14fdb:	eb 51                	jmp    1502e <tty_read+0xdd>
            case '\n':
                if((tty->iflags & TTY_INCLR) && (len < size-1)){
   14fdd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14fe0:	8b 80 4c 04 00 00    	mov    0x44c(%eax),%eax
   14fe6:	83 e0 01             	and    $0x1,%eax
   14fe9:	85 c0                	test   %eax,%eax
   14feb:	74 1b                	je     15008 <tty_read+0xb7>
   14fed:	8b 45 14             	mov    0x14(%ebp),%eax
   14ff0:	83 e8 01             	sub    $0x1,%eax
   14ff3:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   14ff6:	7d 10                	jge    15008 <tty_read+0xb7>
                    *pbuf++='\r';
   14ff8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14ffb:	8d 50 01             	lea    0x1(%eax),%edx
   14ffe:	89 55 f4             	mov    %edx,-0xc(%ebp)
   15001:	c6 00 0d             	movb   $0xd,(%eax)
                    len++;
   15004:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
                }
                *pbuf++='\n';
   15008:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1500b:	8d 50 01             	lea    0x1(%eax),%edx
   1500e:	89 55 f4             	mov    %edx,-0xc(%ebp)
   15011:	c6 00 0a             	movb   $0xa,(%eax)
                len++;
   15014:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
                break;
   15018:	eb 14                	jmp    1502e <tty_read+0xdd>
            default:
                *pbuf++=ch;
   1501a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1501d:	8d 50 01             	lea    0x1(%eax),%edx
   15020:	89 55 f4             	mov    %edx,-0xc(%ebp)
   15023:	0f b6 55 eb          	movzbl -0x15(%ebp),%edx
   15027:	88 10                	mov    %dl,(%eax)
                len++;
   15029:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
                break;
   1502d:	90                   	nop
        }

        // 处理回显
        if(tty->iflags & TTY_IECHO){
   1502e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15031:	8b 80 4c 04 00 00    	mov    0x44c(%eax),%eax
   15037:	83 e0 02             	and    $0x2,%eax
   1503a:	85 c0                	test   %eax,%eax
   1503c:	74 13                	je     15051 <tty_read+0x100>
            tty_write(dev,0,&ch,1);
   1503e:	6a 01                	push   $0x1
   15040:	8d 45 eb             	lea    -0x15(%ebp),%eax
   15043:	50                   	push   %eax
   15044:	6a 00                	push   $0x0
   15046:	ff 75 08             	pushl  0x8(%ebp)
   15049:	e8 24 00 00 00       	call   15072 <tty_write>
   1504e:	83 c4 10             	add    $0x10,%esp
        }

        if((ch == '\n') || (ch == '\r')){
   15051:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   15055:	3c 0a                	cmp    $0xa,%al
   15057:	74 14                	je     1506d <tty_read+0x11c>
   15059:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   1505d:	3c 0d                	cmp    $0xd,%al
   1505f:	74 0c                	je     1506d <tty_read+0x11c>
    while(len < size){
   15061:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15064:	3b 45 14             	cmp    0x14(%ebp),%eax
   15067:	0f 8c 1d ff ff ff    	jl     14f8a <tty_read+0x39>
            break;
        }
    }
    return len;
   1506d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   15070:	c9                   	leave  
   15071:	c3                   	ret    

00015072 <tty_write>:

int tty_write(device_t* dev,int addr,char* buf,int size){
   15072:	55                   	push   %ebp
   15073:	89 e5                	mov    %esp,%ebp
   15075:	83 ec 28             	sub    $0x28,%esp
    if (size < 0){
   15078:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   1507c:	79 0a                	jns    15088 <tty_write+0x16>
        return -1;
   1507e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15083:	e9 e5 00 00 00       	jmp    1516d <tty_write+0xfb>
    }

    tty_t* tty=get_tty(dev);
   15088:	83 ec 0c             	sub    $0xc,%esp
   1508b:	ff 75 08             	pushl  0x8(%ebp)
   1508e:	e8 21 fc ff ff       	call   14cb4 <get_tty>
   15093:	83 c4 10             	add    $0x10,%esp
   15096:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (!tty){
   15099:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1509d:	75 0a                	jne    150a9 <tty_write+0x37>
        return -1;
   1509f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   150a4:	e9 c4 00 00 00       	jmp    1516d <tty_write+0xfb>
    }

    int len =0;
   150a9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(size){
   150b0:	e9 a5 00 00 00       	jmp    1515a <tty_write+0xe8>
        char c=*buf++;
   150b5:	8b 45 10             	mov    0x10(%ebp),%eax
   150b8:	8d 50 01             	lea    0x1(%eax),%edx
   150bb:	89 55 10             	mov    %edx,0x10(%ebp)
   150be:	0f b6 00             	movzbl (%eax),%eax
   150c1:	88 45 ef             	mov    %al,-0x11(%ebp)

        if(c == '\n' && (tty->oflags & TTY_OCRLF)){
   150c4:	80 7d ef 0a          	cmpb   $0xa,-0x11(%ebp)
   150c8:	75 43                	jne    1510d <tty_write+0x9b>
   150ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
   150cd:	8b 80 50 04 00 00    	mov    0x450(%eax),%eax
   150d3:	83 e0 01             	and    $0x1,%eax
   150d6:	85 c0                	test   %eax,%eax
   150d8:	74 33                	je     1510d <tty_write+0x9b>
            sem_wait(&tty->osem);
   150da:	8b 45 f0             	mov    -0x10(%ebp),%eax
   150dd:	05 2c 04 00 00       	add    $0x42c,%eax
   150e2:	83 ec 0c             	sub    $0xc,%esp
   150e5:	50                   	push   %eax
   150e6:	e8 6f 28 00 00       	call   1795a <sem_wait>
   150eb:	83 c4 10             	add    $0x10,%esp
            int err=tty_fifo_put(&tty->ofifo,'\r');
   150ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
   150f1:	05 00 04 00 00       	add    $0x400,%eax
   150f6:	83 ec 08             	sub    $0x8,%esp
   150f9:	6a 0d                	push   $0xd
   150fb:	50                   	push   %eax
   150fc:	e8 39 fc ff ff       	call   14d3a <tty_fifo_put>
   15101:	83 c4 10             	add    $0x10,%esp
   15104:	89 45 e8             	mov    %eax,-0x18(%ebp)
            if (err<0){
   15107:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1510b:	78 59                	js     15166 <tty_write+0xf4>
                break;
            }
        }

        sem_wait(&tty->osem);
   1510d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15110:	05 2c 04 00 00       	add    $0x42c,%eax
   15115:	83 ec 0c             	sub    $0xc,%esp
   15118:	50                   	push   %eax
   15119:	e8 3c 28 00 00       	call   1795a <sem_wait>
   1511e:	83 c4 10             	add    $0x10,%esp
        int err=tty_fifo_put(&tty->ofifo,c);
   15121:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
   15125:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15128:	81 c2 00 04 00 00    	add    $0x400,%edx
   1512e:	83 ec 08             	sub    $0x8,%esp
   15131:	50                   	push   %eax
   15132:	52                   	push   %edx
   15133:	e8 02 fc ff ff       	call   14d3a <tty_fifo_put>
   15138:	83 c4 10             	add    $0x10,%esp
   1513b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (err<0){
   1513e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   15142:	78 25                	js     15169 <tty_write+0xf7>
            break;
        }
        len++;
   15144:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        size--;
   15148:	83 6d 14 01          	subl   $0x1,0x14(%ebp)

        console_write(tty);
   1514c:	83 ec 0c             	sub    $0xc,%esp
   1514f:	ff 75 f0             	pushl  -0x10(%ebp)
   15152:	e8 be e7 ff ff       	call   13915 <console_write>
   15157:	83 c4 10             	add    $0x10,%esp
    while(size){
   1515a:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   1515e:	0f 85 51 ff ff ff    	jne    150b5 <tty_write+0x43>
   15164:	eb 04                	jmp    1516a <tty_write+0xf8>
                break;
   15166:	90                   	nop
   15167:	eb 01                	jmp    1516a <tty_write+0xf8>
            break;
   15169:	90                   	nop
    }

    return len;
   1516a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1516d:	c9                   	leave  
   1516e:	c3                   	ret    

0001516f <tty_control>:

int tty_control(device_t*dev,int cmd,int arg0,int arg1){
   1516f:	55                   	push   %ebp
   15170:	89 e5                	mov    %esp,%ebp
   15172:	83 ec 18             	sub    $0x18,%esp

    tty_t* tty=get_tty(dev);
   15175:	83 ec 0c             	sub    $0xc,%esp
   15178:	ff 75 08             	pushl  0x8(%ebp)
   1517b:	e8 34 fb ff ff       	call   14cb4 <get_tty>
   15180:	83 c4 10             	add    $0x10,%esp
   15183:	89 45 f4             	mov    %eax,-0xc(%ebp)
    switch(cmd){
   15186:	8b 45 0c             	mov    0xc(%ebp),%eax
   15189:	83 f8 01             	cmp    $0x1,%eax
   1518c:	75 36                	jne    151c4 <tty_control+0x55>
        case TTY_CMD_ECHO:
            if(arg0){
   1518e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   15192:	74 19                	je     151ad <tty_control+0x3e>
                tty->iflags |= TTY_IECHO;
   15194:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15197:	8b 80 4c 04 00 00    	mov    0x44c(%eax),%eax
   1519d:	83 c8 02             	or     $0x2,%eax
   151a0:	89 c2                	mov    %eax,%edx
   151a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151a5:	89 90 4c 04 00 00    	mov    %edx,0x44c(%eax)
   151ab:	eb 17                	jmp    151c4 <tty_control+0x55>
            }
            else{
                tty->iflags &= ~TTY_IECHO;
   151ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151b0:	8b 80 4c 04 00 00    	mov    0x44c(%eax),%eax
   151b6:	83 e0 fd             	and    $0xfffffffd,%eax
   151b9:	89 c2                	mov    %eax,%edx
   151bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151be:	89 90 4c 04 00 00    	mov    %edx,0x44c(%eax)
            }
    }
    return 0;
   151c4:	b8 00 00 00 00       	mov    $0x0,%eax
}
   151c9:	c9                   	leave  
   151ca:	c3                   	ret    

000151cb <tty_close>:

void tty_close(device_t* dev){
   151cb:	55                   	push   %ebp
   151cc:	89 e5                	mov    %esp,%ebp

}
   151ce:	90                   	nop
   151cf:	5d                   	pop    %ebp
   151d0:	c3                   	ret    

000151d1 <tty_in>:

/**
* @brief 选择curr_tty索引的tty设备，然后将ch放入tty的输入缓存中
* @param ch 要放入tty设备的输入缓存中的字符
*/ 
void tty_in(char ch){
   151d1:	55                   	push   %ebp
   151d2:	89 e5                	mov    %esp,%ebp
   151d4:	83 ec 28             	sub    $0x28,%esp
   151d7:	8b 45 08             	mov    0x8(%ebp),%eax
   151da:	88 45 e4             	mov    %al,-0x1c(%ebp)
    tty_t* tty=tty_devs+curr_tty;
   151dd:	a1 a0 88 03 00       	mov    0x388a0,%eax
   151e2:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   151e8:	05 00 66 03 00       	add    $0x36600,%eax
   151ed:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(sem_count(&tty->isem) >= TTY_IBUF_SIZE){
   151f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151f3:	05 3c 04 00 00       	add    $0x43c,%eax
   151f8:	83 ec 0c             	sub    $0xc,%esp
   151fb:	50                   	push   %eax
   151fc:	e8 4b 28 00 00       	call   17a4c <sem_count>
   15201:	83 c4 10             	add    $0x10,%esp
   15204:	3d ff 01 00 00       	cmp    $0x1ff,%eax
   15209:	7f 30                	jg     1523b <tty_in+0x6a>
        return;
    }

    tty_fifo_put(&tty->ififo,ch);
   1520b:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
   1520f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15212:	81 c2 14 04 00 00    	add    $0x414,%edx
   15218:	83 ec 08             	sub    $0x8,%esp
   1521b:	50                   	push   %eax
   1521c:	52                   	push   %edx
   1521d:	e8 18 fb ff ff       	call   14d3a <tty_fifo_put>
   15222:	83 c4 10             	add    $0x10,%esp
    sem_notify(&tty->isem);
   15225:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15228:	05 3c 04 00 00       	add    $0x43c,%eax
   1522d:	83 ec 0c             	sub    $0xc,%esp
   15230:	50                   	push   %eax
   15231:	e8 92 27 00 00       	call   179c8 <sem_notify>
   15236:	83 c4 10             	add    $0x10,%esp
   15239:	eb 01                	jmp    1523c <tty_in+0x6b>
        return;
   1523b:	90                   	nop

}
   1523c:	c9                   	leave  
   1523d:	c3                   	ret    

0001523e <tty_select>:

/**
 * @brief 选择tty设备
 * @param tty 要切换的tty设备的索引号
*/
void tty_select(int tty){
   1523e:	55                   	push   %ebp
   1523f:	89 e5                	mov    %esp,%ebp
   15241:	83 ec 08             	sub    $0x8,%esp
    if(tty!=curr_tty){
   15244:	a1 a0 88 03 00       	mov    0x388a0,%eax
   15249:	39 45 08             	cmp    %eax,0x8(%ebp)
   1524c:	74 16                	je     15264 <tty_select+0x26>
        console_select(tty);
   1524e:	83 ec 0c             	sub    $0xc,%esp
   15251:	ff 75 08             	pushl  0x8(%ebp)
   15254:	e8 cd e7 ff ff       	call   13a26 <console_select>
   15259:	83 c4 10             	add    $0x10,%esp
        curr_tty=tty;
   1525c:	8b 45 08             	mov    0x8(%ebp),%eax
   1525f:	a3 a0 88 03 00       	mov    %eax,0x388a0
    }
}
   15264:	90                   	nop
   15265:	c9                   	leave  
   15266:	c3                   	ret    

00015267 <devfs_mount>:
        .dev_type=DEV_TTY,
        .file_type=FILE_TYPE_TTY,
    },
};

int devfs_mount(struct _fs_t* fs,int major,int minor){
   15267:	55                   	push   %ebp
   15268:	89 e5                	mov    %esp,%ebp
    fs->type=FS_DEVFS;
   1526a:	8b 45 08             	mov    0x8(%ebp),%eax
   1526d:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%eax)
   15274:	00 00 00 
}
   15277:	90                   	nop
   15278:	5d                   	pop    %ebp
   15279:	c3                   	ret    

0001527a <devfs_unmount>:

void devfs_unmount(struct _fs_t* fs){
   1527a:	55                   	push   %ebp
   1527b:	89 e5                	mov    %esp,%ebp

}
   1527d:	90                   	nop
   1527e:	5d                   	pop    %ebp
   1527f:	c3                   	ret    

00015280 <devfs_open>:


int devfs_open(struct _fs_t* fs,const char* path,file_t* file){
   15280:	55                   	push   %ebp
   15281:	89 e5                	mov    %esp,%ebp
   15283:	83 ec 28             	sub    $0x28,%esp
    for(int i=0;i<sizeof(devfs_type_list)/sizeof(devfs_type_list[0]);i++){
   15286:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1528d:	e9 05 01 00 00       	jmp    15397 <devfs_open+0x117>
        devfs_type_t* type=devfs_type_list+i;
   15292:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15295:	89 d0                	mov    %edx,%eax
   15297:	01 c0                	add    %eax,%eax
   15299:	01 d0                	add    %edx,%eax
   1529b:	c1 e0 02             	shl    $0x2,%eax
   1529e:	05 e0 a0 01 00       	add    $0x1a0e0,%eax
   152a3:	89 45 f0             	mov    %eax,-0x10(%ebp)

        int type_name_len=kernel_strlen(type->name);
   152a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   152a9:	8b 00                	mov    (%eax),%eax
   152ab:	83 ec 0c             	sub    $0xc,%esp
   152ae:	50                   	push   %eax
   152af:	e8 6a 2b 00 00       	call   17e1e <kernel_strlen>
   152b4:	83 c4 10             	add    $0x10,%esp
   152b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(kernel_strncmp(path,type->name,type_name_len)==0){
   152ba:	8b 55 ec             	mov    -0x14(%ebp),%edx
   152bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   152c0:	8b 00                	mov    (%eax),%eax
   152c2:	83 ec 04             	sub    $0x4,%esp
   152c5:	52                   	push   %edx
   152c6:	50                   	push   %eax
   152c7:	ff 75 0c             	pushl  0xc(%ebp)
   152ca:	e8 d5 2a 00 00       	call   17da4 <kernel_strncmp>
   152cf:	83 c4 10             	add    $0x10,%esp
   152d2:	85 c0                	test   %eax,%eax
   152d4:	0f 85 b9 00 00 00    	jne    15393 <devfs_open+0x113>
            int minor;
            if((kernel_strlen(path) > type_name_len) && (path_to_num(path+type_name_len,&minor)<0)){
   152da:	83 ec 0c             	sub    $0xc,%esp
   152dd:	ff 75 0c             	pushl  0xc(%ebp)
   152e0:	e8 39 2b 00 00       	call   17e1e <kernel_strlen>
   152e5:	83 c4 10             	add    $0x10,%esp
   152e8:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   152eb:	7d 34                	jge    15321 <devfs_open+0xa1>
   152ed:	8b 55 ec             	mov    -0x14(%ebp),%edx
   152f0:	8b 45 0c             	mov    0xc(%ebp),%eax
   152f3:	01 c2                	add    %eax,%edx
   152f5:	83 ec 08             	sub    $0x8,%esp
   152f8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   152fb:	50                   	push   %eax
   152fc:	52                   	push   %edx
   152fd:	e8 94 17 00 00       	call   16a96 <path_to_num>
   15302:	83 c4 10             	add    $0x10,%esp
   15305:	85 c0                	test   %eax,%eax
   15307:	79 18                	jns    15321 <devfs_open+0xa1>
                log_printf("Get device num failed. %s",path);
   15309:	83 ec 08             	sub    $0x8,%esp
   1530c:	ff 75 0c             	pushl  0xc(%ebp)
   1530f:	68 93 92 01 00       	push   $0x19293
   15314:	e8 b2 31 00 00       	call   184cb <log_printf>
   15319:	83 c4 10             	add    $0x10,%esp
                break;
   1531c:	e9 80 00 00 00       	jmp    153a1 <devfs_open+0x121>
            }

            int dev_id=dev_open(type->dev_type,minor,(void*)0);
   15321:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15324:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15327:	8b 40 04             	mov    0x4(%eax),%eax
   1532a:	83 ec 04             	sub    $0x4,%esp
   1532d:	6a 00                	push   $0x0
   1532f:	52                   	push   %edx
   15330:	50                   	push   %eax
   15331:	e8 e4 e7 ff ff       	call   13b1a <dev_open>
   15336:	83 c4 10             	add    $0x10,%esp
   15339:	89 45 e8             	mov    %eax,-0x18(%ebp)
            if(dev_id<0){
   1533c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15340:	79 16                	jns    15358 <devfs_open+0xd8>
                log_printf("Open device failed: %s",path);
   15342:	83 ec 08             	sub    $0x8,%esp
   15345:	ff 75 0c             	pushl  0xc(%ebp)
   15348:	68 ad 92 01 00       	push   $0x192ad
   1534d:	e8 79 31 00 00       	call   184cb <log_printf>
   15352:	83 c4 10             	add    $0x10,%esp
                break;
   15355:	90                   	nop
   15356:	eb 49                	jmp    153a1 <devfs_open+0x121>
            }

            file->dev_id=dev_id;
   15358:	8b 45 10             	mov    0x10(%ebp),%eax
   1535b:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1535e:	89 50 2c             	mov    %edx,0x2c(%eax)
            file->fs=fs;
   15361:	8b 45 10             	mov    0x10(%ebp),%eax
   15364:	8b 55 08             	mov    0x8(%ebp),%edx
   15367:	89 50 38             	mov    %edx,0x38(%eax)
            file->pos=0;
   1536a:	8b 45 10             	mov    0x10(%ebp),%eax
   1536d:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
            file->size=0;
   15374:	8b 45 10             	mov    0x10(%ebp),%eax
   15377:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
            file->type=type->file_type;
   1537e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15381:	8b 40 08             	mov    0x8(%eax),%eax
   15384:	89 c2                	mov    %eax,%edx
   15386:	8b 45 10             	mov    0x10(%ebp),%eax
   15389:	89 50 20             	mov    %edx,0x20(%eax)
            return 0;
   1538c:	b8 00 00 00 00       	mov    $0x0,%eax
   15391:	eb 13                	jmp    153a6 <devfs_open+0x126>
    for(int i=0;i<sizeof(devfs_type_list)/sizeof(devfs_type_list[0]);i++){
   15393:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15397:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1539b:	0f 84 f1 fe ff ff    	je     15292 <devfs_open+0x12>
        }

    }

    return -1;
   153a1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   153a6:	c9                   	leave  
   153a7:	c3                   	ret    

000153a8 <devfs_read>:

int devfs_read(char* buf,int size,file_t* file){
   153a8:	55                   	push   %ebp
   153a9:	89 e5                	mov    %esp,%ebp
   153ab:	83 ec 08             	sub    $0x8,%esp
    return dev_read(file->dev_id,file->pos,buf,size);    
   153ae:	8b 45 10             	mov    0x10(%ebp),%eax
   153b1:	8b 50 30             	mov    0x30(%eax),%edx
   153b4:	8b 45 10             	mov    0x10(%ebp),%eax
   153b7:	8b 40 2c             	mov    0x2c(%eax),%eax
   153ba:	ff 75 0c             	pushl  0xc(%ebp)
   153bd:	ff 75 08             	pushl  0x8(%ebp)
   153c0:	52                   	push   %edx
   153c1:	50                   	push   %eax
   153c2:	e8 a5 e8 ff ff       	call   13c6c <dev_read>
   153c7:	83 c4 10             	add    $0x10,%esp
}
   153ca:	c9                   	leave  
   153cb:	c3                   	ret    

000153cc <devfs_write>:

int devfs_write(char*buf,int size,file_t* file){
   153cc:	55                   	push   %ebp
   153cd:	89 e5                	mov    %esp,%ebp
   153cf:	83 ec 08             	sub    $0x8,%esp
    return dev_write(file->dev_id,file->pos,buf,size);
   153d2:	8b 45 10             	mov    0x10(%ebp),%eax
   153d5:	8b 50 30             	mov    0x30(%eax),%edx
   153d8:	8b 45 10             	mov    0x10(%ebp),%eax
   153db:	8b 40 2c             	mov    0x2c(%eax),%eax
   153de:	ff 75 0c             	pushl  0xc(%ebp)
   153e1:	ff 75 08             	pushl  0x8(%ebp)
   153e4:	52                   	push   %edx
   153e5:	50                   	push   %eax
   153e6:	e8 cd e8 ff ff       	call   13cb8 <dev_write>
   153eb:	83 c4 10             	add    $0x10,%esp
}
   153ee:	c9                   	leave  
   153ef:	c3                   	ret    

000153f0 <devfs_close>:

void devfs_close(file_t* file){
   153f0:	55                   	push   %ebp
   153f1:	89 e5                	mov    %esp,%ebp
   153f3:	83 ec 08             	sub    $0x8,%esp
    dev_close(file->dev_id);
   153f6:	8b 45 08             	mov    0x8(%ebp),%eax
   153f9:	8b 40 2c             	mov    0x2c(%eax),%eax
   153fc:	83 ec 0c             	sub    $0xc,%esp
   153ff:	50                   	push   %eax
   15400:	e8 4b e9 ff ff       	call   13d50 <dev_close>
   15405:	83 c4 10             	add    $0x10,%esp
}
   15408:	90                   	nop
   15409:	c9                   	leave  
   1540a:	c3                   	ret    

0001540b <devfs_seek>:

int devfs_seek(file_t* file,uint32_t offset,int dir){
   1540b:	55                   	push   %ebp
   1540c:	89 e5                	mov    %esp,%ebp
    return -1;
   1540e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   15413:	5d                   	pop    %ebp
   15414:	c3                   	ret    

00015415 <devfs_stat>:

int devfs_stat(file_t*file,struct stat* st){
   15415:	55                   	push   %ebp
   15416:	89 e5                	mov    %esp,%ebp
    return -1;
   15418:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   1541d:	5d                   	pop    %ebp
   1541e:	c3                   	ret    

0001541f <devfs_ioctl>:

int devfs_ioctl(file_t *file,int cmd,int arg0,int arg1){
   1541f:	55                   	push   %ebp
   15420:	89 e5                	mov    %esp,%ebp
   15422:	83 ec 08             	sub    $0x8,%esp
    return dev_control(file->dev_id,cmd,arg0,arg1);
   15425:	8b 45 08             	mov    0x8(%ebp),%eax
   15428:	8b 40 2c             	mov    0x2c(%eax),%eax
   1542b:	ff 75 14             	pushl  0x14(%ebp)
   1542e:	ff 75 10             	pushl  0x10(%ebp)
   15431:	ff 75 0c             	pushl  0xc(%ebp)
   15434:	50                   	push   %eax
   15435:	e8 ca e8 ff ff       	call   13d04 <dev_control>
   1543a:	83 c4 10             	add    $0x10,%esp
}
   1543d:	c9                   	leave  
   1543e:	c3                   	ret    

0001543f <up2>:
static inline uint32_t up2(uint32_t size,uint32_t bound){
   1543f:	55                   	push   %ebp
   15440:	89 e5                	mov    %esp,%ebp
    return (size+bound-1) & ~(bound-1);
   15442:	8b 55 08             	mov    0x8(%ebp),%edx
   15445:	8b 45 0c             	mov    0xc(%ebp),%eax
   15448:	01 d0                	add    %edx,%eax
   1544a:	8d 50 ff             	lea    -0x1(%eax),%edx
   1544d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15450:	f7 d8                	neg    %eax
   15452:	21 d0                	and    %edx,%eax
}
   15454:	5d                   	pop    %ebp
   15455:	c3                   	ret    

00015456 <bwrite_sector>:
#include "dev/dev.h"
#include "tools/klib.h"

#include <sys/fcntl.h>

static int bwrite_sector(fat_t *fat,int sector){
   15456:	55                   	push   %ebp
   15457:	89 e5                	mov    %esp,%ebp
   15459:	83 ec 18             	sub    $0x18,%esp
    int cnt=dev_write(fat->fs->dev_id,sector,fat->fat_buff,1);
   1545c:	8b 45 08             	mov    0x8(%ebp),%eax
   1545f:	8b 50 28             	mov    0x28(%eax),%edx
   15462:	8b 45 08             	mov    0x8(%ebp),%eax
   15465:	8b 40 24             	mov    0x24(%eax),%eax
   15468:	8b 80 0c 02 00 00    	mov    0x20c(%eax),%eax
   1546e:	6a 01                	push   $0x1
   15470:	52                   	push   %edx
   15471:	ff 75 0c             	pushl  0xc(%ebp)
   15474:	50                   	push   %eax
   15475:	e8 3e e8 ff ff       	call   13cb8 <dev_write>
   1547a:	83 c4 10             	add    $0x10,%esp
   1547d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return (cnt == 1) ? 0 : -1;
   15480:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
   15484:	75 07                	jne    1548d <bwrite_sector+0x37>
   15486:	b8 00 00 00 00       	mov    $0x0,%eax
   1548b:	eb 05                	jmp    15492 <bwrite_sector+0x3c>
   1548d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}  
   15492:	c9                   	leave  
   15493:	c3                   	ret    

00015494 <cluster_is_valid>:

/**
 * @brief 检查簇号是否有效
 * @param cluster 要检查的簇号
 */
int cluster_is_valid(cluster_t cluster){
   15494:	55                   	push   %ebp
   15495:	89 e5                	mov    %esp,%ebp
   15497:	83 ec 04             	sub    $0x4,%esp
   1549a:	8b 45 08             	mov    0x8(%ebp),%eax
   1549d:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    return (cluster < FAT_CLUSTER_INVALID)  && (cluster >= 2);
   154a1:	66 83 7d fc f7       	cmpw   $0xfff7,-0x4(%ebp)
   154a6:	77 0e                	ja     154b6 <cluster_is_valid+0x22>
   154a8:	66 83 7d fc 01       	cmpw   $0x1,-0x4(%ebp)
   154ad:	76 07                	jbe    154b6 <cluster_is_valid+0x22>
   154af:	b8 01 00 00 00       	mov    $0x1,%eax
   154b4:	eb 05                	jmp    154bb <cluster_is_valid+0x27>
   154b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   154bb:	c9                   	leave  
   154bc:	c3                   	ret    

000154bd <bread_sector>:
/**
 * @brief 读取指定扇区到缓冲区
 * @param fat 文件系统数据结构
 * @param sector 要读取的扇区号
 */
static int bread_sector(fat_t *fat,int sector){
   154bd:	55                   	push   %ebp
   154be:	89 e5                	mov    %esp,%ebp
   154c0:	83 ec 18             	sub    $0x18,%esp
    if(sector == fat->curr_sector){
   154c3:	8b 45 08             	mov    0x8(%ebp),%eax
   154c6:	8b 40 2c             	mov    0x2c(%eax),%eax
   154c9:	39 45 0c             	cmp    %eax,0xc(%ebp)
   154cc:	75 07                	jne    154d5 <bread_sector+0x18>
        return 0;
   154ce:	b8 00 00 00 00       	mov    $0x0,%eax
   154d3:	eb 3f                	jmp    15514 <bread_sector+0x57>
    }

    int cnt=dev_read(fat->fs->dev_id,sector,fat->fat_buff,1);
   154d5:	8b 45 08             	mov    0x8(%ebp),%eax
   154d8:	8b 50 28             	mov    0x28(%eax),%edx
   154db:	8b 45 08             	mov    0x8(%ebp),%eax
   154de:	8b 40 24             	mov    0x24(%eax),%eax
   154e1:	8b 80 0c 02 00 00    	mov    0x20c(%eax),%eax
   154e7:	6a 01                	push   $0x1
   154e9:	52                   	push   %edx
   154ea:	ff 75 0c             	pushl  0xc(%ebp)
   154ed:	50                   	push   %eax
   154ee:	e8 79 e7 ff ff       	call   13c6c <dev_read>
   154f3:	83 c4 10             	add    $0x10,%esp
   154f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(cnt == 1){
   154f9:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
   154fd:	75 10                	jne    1550f <bread_sector+0x52>
        fat->curr_sector=sector;
   154ff:	8b 45 08             	mov    0x8(%ebp),%eax
   15502:	8b 55 0c             	mov    0xc(%ebp),%edx
   15505:	89 50 2c             	mov    %edx,0x2c(%eax)
        return 0;
   15508:	b8 00 00 00 00       	mov    $0x0,%eax
   1550d:	eb 05                	jmp    15514 <bread_sector+0x57>
    }

    return -1;
   1550f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   15514:	c9                   	leave  
   15515:	c3                   	ret    

00015516 <cluster_get_next>:
 * @brief 获取下一个簇号
 * @param fat 文件系统数据结构
 * @param curr 当前簇号
 * @return 下一个簇号，如果无效则返回FAT_CLUSTER_INVALID
 */
int cluster_get_next(fat_t *fat,cluster_t curr){
   15516:	55                   	push   %ebp
   15517:	89 e5                	mov    %esp,%ebp
   15519:	83 ec 28             	sub    $0x28,%esp
   1551c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1551f:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    if (!cluster_is_valid(curr)) {
   15523:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
   15527:	50                   	push   %eax
   15528:	e8 67 ff ff ff       	call   15494 <cluster_is_valid>
   1552d:	83 c4 04             	add    $0x4,%esp
   15530:	85 c0                	test   %eax,%eax
   15532:	75 0a                	jne    1553e <cluster_get_next+0x28>
        return FAT_CLUSTER_INVALID;
   15534:	b8 f8 ff 00 00       	mov    $0xfff8,%eax
   15539:	e9 94 00 00 00       	jmp    155d2 <cluster_get_next+0xbc>
    }

    // 取fat表中的扇区号和在扇区中的偏移
    int offset = curr * sizeof(cluster_t);
   1553e:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
   15542:	01 c0                	add    %eax,%eax
   15544:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int sector = offset / fat->bytes_per_sec;
   15547:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1554a:	8b 55 08             	mov    0x8(%ebp),%edx
   1554d:	8b 4a 0c             	mov    0xc(%edx),%ecx
   15550:	ba 00 00 00 00       	mov    $0x0,%edx
   15555:	f7 f1                	div    %ecx
   15557:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int off_sector = offset % fat->bytes_per_sec;
   1555a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1555d:	8b 55 08             	mov    0x8(%ebp),%edx
   15560:	8b 4a 0c             	mov    0xc(%edx),%ecx
   15563:	ba 00 00 00 00       	mov    $0x0,%edx
   15568:	f7 f1                	div    %ecx
   1556a:	89 d0                	mov    %edx,%eax
   1556c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (sector >= fat->tbl_sectors) {
   1556f:	8b 45 08             	mov    0x8(%ebp),%eax
   15572:	8b 50 08             	mov    0x8(%eax),%edx
   15575:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15578:	39 c2                	cmp    %eax,%edx
   1557a:	77 1c                	ja     15598 <cluster_get_next+0x82>
        log_printf("cluster too big. %d", curr);
   1557c:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
   15580:	83 ec 08             	sub    $0x8,%esp
   15583:	50                   	push   %eax
   15584:	68 c4 92 01 00       	push   $0x192c4
   15589:	e8 3d 2f 00 00       	call   184cb <log_printf>
   1558e:	83 c4 10             	add    $0x10,%esp
        return FAT_CLUSTER_INVALID;
   15591:	b8 f8 ff 00 00       	mov    $0xfff8,%eax
   15596:	eb 3a                	jmp    155d2 <cluster_get_next+0xbc>
    }

    // 读扇区，然后取其中簇数据
    int err = bread_sector(fat, fat->tbl_start + sector);
   15598:	8b 45 08             	mov    0x8(%ebp),%eax
   1559b:	8b 10                	mov    (%eax),%edx
   1559d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   155a0:	01 d0                	add    %edx,%eax
   155a2:	83 ec 08             	sub    $0x8,%esp
   155a5:	50                   	push   %eax
   155a6:	ff 75 08             	pushl  0x8(%ebp)
   155a9:	e8 0f ff ff ff       	call   154bd <bread_sector>
   155ae:	83 c4 10             	add    $0x10,%esp
   155b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (err < 0) {
   155b4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   155b8:	79 07                	jns    155c1 <cluster_get_next+0xab>
        return FAT_CLUSTER_INVALID;
   155ba:	b8 f8 ff 00 00       	mov    $0xfff8,%eax
   155bf:	eb 11                	jmp    155d2 <cluster_get_next+0xbc>
    }

    return *(cluster_t*)(fat->fat_buff + off_sector);
   155c1:	8b 45 08             	mov    0x8(%ebp),%eax
   155c4:	8b 50 28             	mov    0x28(%eax),%edx
   155c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   155ca:	01 d0                	add    %edx,%eax
   155cc:	0f b7 00             	movzwl (%eax),%eax
   155cf:	0f b7 c0             	movzwl %ax,%eax
}
   155d2:	c9                   	leave  
   155d3:	c3                   	ret    

000155d4 <diritem_get_type>:

file_type_t diritem_get_type(diritem_t *item){
   155d4:	55                   	push   %ebp
   155d5:	89 e5                	mov    %esp,%ebp
   155d7:	83 ec 10             	sub    $0x10,%esp
    file_type_t type=FILE_UNKNOWN;
   155da:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    if(item->DIR_Attr & (DIRITEM_ATTR_VOLUME_ID | DIRITEM_ATTR_HIDDEN | DIRITEM_ATTR_SYSTEM)){
   155e1:	8b 45 08             	mov    0x8(%ebp),%eax
   155e4:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   155e8:	0f b6 c0             	movzbl %al,%eax
   155eb:	83 e0 0e             	and    $0xe,%eax
   155ee:	85 c0                	test   %eax,%eax
   155f0:	74 05                	je     155f7 <diritem_get_type+0x23>
        return type;   
   155f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   155f5:	eb 34                	jmp    1562b <diritem_get_type+0x57>
    }

    if((item->DIR_Attr & DIRITEM_ATTR_LONG_NAME) == DIRITEM_ATTR_LONG_NAME){
   155f7:	8b 45 08             	mov    0x8(%ebp),%eax
   155fa:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   155fe:	0f b6 c0             	movzbl %al,%eax
   15601:	83 e0 0f             	and    $0xf,%eax
   15604:	83 f8 0f             	cmp    $0xf,%eax
   15607:	75 05                	jne    1560e <diritem_get_type+0x3a>
        return type;
   15609:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1560c:	eb 1d                	jmp    1562b <diritem_get_type+0x57>
    }

    return item->DIR_Attr & DIRITEM_ATTR_DIRECTORY ? FILE_DIR : FILE_NORMAL;
   1560e:	8b 45 08             	mov    0x8(%ebp),%eax
   15611:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   15615:	0f b6 c0             	movzbl %al,%eax
   15618:	83 e0 10             	and    $0x10,%eax
   1561b:	85 c0                	test   %eax,%eax
   1561d:	74 07                	je     15626 <diritem_get_type+0x52>
   1561f:	b8 02 00 00 00       	mov    $0x2,%eax
   15624:	eb 05                	jmp    1562b <diritem_get_type+0x57>
   15626:	b8 03 00 00 00       	mov    $0x3,%eax
} 
   1562b:	c9                   	leave  
   1562c:	c3                   	ret    

0001562d <read_dir_entry>:
/**
 * @brief 读取指定扇区的目录项
 * @param fat 文件系统数据结构
 * @param index 目录项的索引
 */
static diritem_t* read_dir_entry(fat_t *fat,int index){
   1562d:	55                   	push   %ebp
   1562e:	89 e5                	mov    %esp,%ebp
   15630:	53                   	push   %ebx
   15631:	83 ec 14             	sub    $0x14,%esp
    if((index < 0) || (index >= fat->root_ent_cnt)){
   15634:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   15638:	78 0d                	js     15647 <read_dir_entry+0x1a>
   1563a:	8b 45 08             	mov    0x8(%ebp),%eax
   1563d:	8b 50 18             	mov    0x18(%eax),%edx
   15640:	8b 45 0c             	mov    0xc(%ebp),%eax
   15643:	39 c2                	cmp    %eax,%edx
   15645:	77 07                	ja     1564e <read_dir_entry+0x21>
        return (diritem_t*)0;
   15647:	b8 00 00 00 00       	mov    $0x0,%eax
   1564c:	eb 5f                	jmp    156ad <read_dir_entry+0x80>
    }

    int offset = index * sizeof(diritem_t);
   1564e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15651:	c1 e0 05             	shl    $0x5,%eax
   15654:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int sector=fat->root_start + offset / fat->bytes_per_sec;
   15657:	8b 45 08             	mov    0x8(%ebp),%eax
   1565a:	8b 48 14             	mov    0x14(%eax),%ecx
   1565d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15660:	8b 55 08             	mov    0x8(%ebp),%edx
   15663:	8b 5a 0c             	mov    0xc(%edx),%ebx
   15666:	ba 00 00 00 00       	mov    $0x0,%edx
   1566b:	f7 f3                	div    %ebx
   1566d:	01 c8                	add    %ecx,%eax
   1566f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    int err=bread_sector(fat,sector);
   15672:	83 ec 08             	sub    $0x8,%esp
   15675:	ff 75 f0             	pushl  -0x10(%ebp)
   15678:	ff 75 08             	pushl  0x8(%ebp)
   1567b:	e8 3d fe ff ff       	call   154bd <bread_sector>
   15680:	83 c4 10             	add    $0x10,%esp
   15683:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(err < 0){
   15686:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1568a:	79 07                	jns    15693 <read_dir_entry+0x66>
        return (diritem_t*)0;
   1568c:	b8 00 00 00 00       	mov    $0x0,%eax
   15691:	eb 1a                	jmp    156ad <read_dir_entry+0x80>
    }

    return (diritem_t*)(fat->fat_buff + offset % fat->bytes_per_sec);
   15693:	8b 45 08             	mov    0x8(%ebp),%eax
   15696:	8b 48 28             	mov    0x28(%eax),%ecx
   15699:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1569c:	8b 55 08             	mov    0x8(%ebp),%edx
   1569f:	8b 5a 0c             	mov    0xc(%edx),%ebx
   156a2:	ba 00 00 00 00       	mov    $0x0,%edx
   156a7:	f7 f3                	div    %ebx
   156a9:	89 d0                	mov    %edx,%eax
   156ab:	01 c8                	add    %ecx,%eax
}
   156ad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   156b0:	c9                   	leave  
   156b1:	c3                   	ret    

000156b2 <diritem_get_name>:
/**
 * @brief 获取目录项的名称
 * @param item 目录项
 * @param dest 存储名称的目标缓冲区
 */
void diritem_get_name(diritem_t *item,char *dest){
   156b2:	55                   	push   %ebp
   156b3:	89 e5                	mov    %esp,%ebp
   156b5:	83 ec 18             	sub    $0x18,%esp
    char* c=dest;
   156b8:	8b 45 0c             	mov    0xc(%ebp),%eax
   156bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char* ext=(char*)0;
   156be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    kernel_memset(dest,0,12);
   156c5:	83 ec 04             	sub    $0x4,%esp
   156c8:	6a 0c                	push   $0xc
   156ca:	6a 00                	push   $0x0
   156cc:	ff 75 0c             	pushl  0xc(%ebp)
   156cf:	e8 d4 27 00 00       	call   17ea8 <kernel_memset>
   156d4:	83 c4 10             	add    $0x10,%esp

    for(int i=0;i<11;i++){
   156d7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   156de:	eb 43                	jmp    15723 <diritem_get_name+0x71>
        if(item->DIR_Name[i]!=' '){
   156e0:	8b 55 08             	mov    0x8(%ebp),%edx
   156e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   156e6:	01 d0                	add    %edx,%eax
   156e8:	0f b6 00             	movzbl (%eax),%eax
   156eb:	3c 20                	cmp    $0x20,%al
   156ed:	74 18                	je     15707 <diritem_get_name+0x55>
            *c++=item->DIR_Name[i];
   156ef:	8b 55 08             	mov    0x8(%ebp),%edx
   156f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   156f5:	01 d0                	add    %edx,%eax
   156f7:	0f b6 08             	movzbl (%eax),%ecx
   156fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156fd:	8d 50 01             	lea    0x1(%eax),%edx
   15700:	89 55 f4             	mov    %edx,-0xc(%ebp)
   15703:	89 ca                	mov    %ecx,%edx
   15705:	88 10                	mov    %dl,(%eax)
        }

        if(i == 7){
   15707:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
   1570b:	75 12                	jne    1571f <diritem_get_name+0x6d>
            ext=c;
   1570d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15710:	89 45 f0             	mov    %eax,-0x10(%ebp)
            *c++='.';
   15713:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15716:	8d 50 01             	lea    0x1(%eax),%edx
   15719:	89 55 f4             	mov    %edx,-0xc(%ebp)
   1571c:	c6 00 2e             	movb   $0x2e,(%eax)
    for(int i=0;i<11;i++){
   1571f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15723:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
   15727:	7e b7                	jle    156e0 <diritem_get_name+0x2e>
        }
    }

    if(ext && (ext[1] == '\0')){
   15729:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1572d:	74 13                	je     15742 <diritem_get_name+0x90>
   1572f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15732:	83 c0 01             	add    $0x1,%eax
   15735:	0f b6 00             	movzbl (%eax),%eax
   15738:	84 c0                	test   %al,%al
   1573a:	75 06                	jne    15742 <diritem_get_name+0x90>
        ext[0]='\0';
   1573c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1573f:	c6 00 00             	movb   $0x0,(%eax)
    }
}
   15742:	90                   	nop
   15743:	c9                   	leave  
   15744:	c3                   	ret    

00015745 <cluster_set_next>:
 * @param fat 文件系统数据结构
 * @param curr 当前簇号
 * @param next 要设置的下一个簇号
 * @return 返回下一个簇号，如果出错则返回FAT_CLUSTER_INVALID
 */
int cluster_set_next(fat_t *fat,cluster_t curr,cluster_t next){
   15745:	55                   	push   %ebp
   15746:	89 e5                	mov    %esp,%ebp
   15748:	83 ec 38             	sub    $0x38,%esp
   1574b:	8b 55 0c             	mov    0xc(%ebp),%edx
   1574e:	8b 45 10             	mov    0x10(%ebp),%eax
   15751:	66 89 55 d4          	mov    %dx,-0x2c(%ebp)
   15755:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
     if (!cluster_is_valid(curr)) {
   15759:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
   1575d:	50                   	push   %eax
   1575e:	e8 31 fd ff ff       	call   15494 <cluster_is_valid>
   15763:	83 c4 04             	add    $0x4,%esp
   15766:	85 c0                	test   %eax,%eax
   15768:	75 0a                	jne    15774 <cluster_set_next+0x2f>
        return -1;
   1576a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1576f:	e9 fe 00 00 00       	jmp    15872 <cluster_set_next+0x12d>
    }

    int offset = curr * sizeof(cluster_t);
   15774:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
   15778:	01 c0                	add    %eax,%eax
   1577a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    int sector = offset / fat->bytes_per_sec;
   1577d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15780:	8b 55 08             	mov    0x8(%ebp),%edx
   15783:	8b 4a 0c             	mov    0xc(%edx),%ecx
   15786:	ba 00 00 00 00       	mov    $0x0,%edx
   1578b:	f7 f1                	div    %ecx
   1578d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int off_sector = offset % fat->bytes_per_sec;
   15790:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15793:	8b 55 08             	mov    0x8(%ebp),%edx
   15796:	8b 4a 0c             	mov    0xc(%edx),%ecx
   15799:	ba 00 00 00 00       	mov    $0x0,%edx
   1579e:	f7 f1                	div    %ecx
   157a0:	89 d0                	mov    %edx,%eax
   157a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (sector >= fat->tbl_sectors) {
   157a5:	8b 45 08             	mov    0x8(%ebp),%eax
   157a8:	8b 50 08             	mov    0x8(%eax),%edx
   157ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157ae:	39 c2                	cmp    %eax,%edx
   157b0:	77 1f                	ja     157d1 <cluster_set_next+0x8c>
        log_printf("cluster too big. %d", curr);
   157b2:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
   157b6:	83 ec 08             	sub    $0x8,%esp
   157b9:	50                   	push   %eax
   157ba:	68 c4 92 01 00       	push   $0x192c4
   157bf:	e8 07 2d 00 00       	call   184cb <log_printf>
   157c4:	83 c4 10             	add    $0x10,%esp
        return -1;
   157c7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   157cc:	e9 a1 00 00 00       	jmp    15872 <cluster_set_next+0x12d>
    }

    // 读缓存
    int err = bread_sector(fat, fat->tbl_start + sector);
   157d1:	8b 45 08             	mov    0x8(%ebp),%eax
   157d4:	8b 10                	mov    (%eax),%edx
   157d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157d9:	01 d0                	add    %edx,%eax
   157db:	83 ec 08             	sub    $0x8,%esp
   157de:	50                   	push   %eax
   157df:	ff 75 08             	pushl  0x8(%ebp)
   157e2:	e8 d6 fc ff ff       	call   154bd <bread_sector>
   157e7:	83 c4 10             	add    $0x10,%esp
   157ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (err < 0) {
   157ed:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   157f1:	79 07                	jns    157fa <cluster_set_next+0xb5>
        return -1;
   157f3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   157f8:	eb 78                	jmp    15872 <cluster_set_next+0x12d>
    }

    // 改next
    *(cluster_t*)(fat->fat_buff + off_sector) = next;
   157fa:	8b 45 08             	mov    0x8(%ebp),%eax
   157fd:	8b 50 28             	mov    0x28(%eax),%edx
   15800:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15803:	01 c2                	add    %eax,%edx
   15805:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
   15809:	66 89 02             	mov    %ax,(%edx)

    // 回写到多个表中
    for (int i = 0; i < fat->tbl_cnt; i++) {
   1580c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   15813:	eb 4b                	jmp    15860 <cluster_set_next+0x11b>
        err = bwrite_sector(fat, fat->tbl_start + sector);
   15815:	8b 45 08             	mov    0x8(%ebp),%eax
   15818:	8b 10                	mov    (%eax),%edx
   1581a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1581d:	01 d0                	add    %edx,%eax
   1581f:	83 ec 08             	sub    $0x8,%esp
   15822:	50                   	push   %eax
   15823:	ff 75 08             	pushl  0x8(%ebp)
   15826:	e8 2b fc ff ff       	call   15456 <bwrite_sector>
   1582b:	83 c4 10             	add    $0x10,%esp
   1582e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (err < 0) {
   15831:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   15835:	79 17                	jns    1584e <cluster_set_next+0x109>
            log_printf("write cluster failed.");
   15837:	83 ec 0c             	sub    $0xc,%esp
   1583a:	68 d8 92 01 00       	push   $0x192d8
   1583f:	e8 87 2c 00 00       	call   184cb <log_printf>
   15844:	83 c4 10             	add    $0x10,%esp
            return -1;
   15847:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1584c:	eb 24                	jmp    15872 <cluster_set_next+0x12d>
        }
        sector += fat->tbl_sectors;
   1584e:	8b 45 08             	mov    0x8(%ebp),%eax
   15851:	8b 50 08             	mov    0x8(%eax),%edx
   15854:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15857:	01 d0                	add    %edx,%eax
   15859:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for (int i = 0; i < fat->tbl_cnt; i++) {
   1585c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   15860:	8b 45 08             	mov    0x8(%ebp),%eax
   15863:	8b 50 04             	mov    0x4(%eax),%edx
   15866:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15869:	39 c2                	cmp    %eax,%edx
   1586b:	77 a8                	ja     15815 <cluster_set_next+0xd0>
    }
    return 0;
   1586d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15872:	c9                   	leave  
   15873:	c3                   	ret    

00015874 <cluster_free_chain>:
/**
 * @brief 将簇链表释放
 * @param fat 文件系统数据结构
 * @param start 起始簇号
 */
void cluster_free_chain(fat_t *fat,cluster_t start){
   15874:	55                   	push   %ebp
   15875:	89 e5                	mov    %esp,%ebp
   15877:	83 ec 28             	sub    $0x28,%esp
   1587a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1587d:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    while(cluster_is_valid(start)){
   15881:	eb 34                	jmp    158b7 <cluster_free_chain+0x43>
        cluster_t next=cluster_get_next(fat,start);
   15883:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
   15887:	83 ec 08             	sub    $0x8,%esp
   1588a:	50                   	push   %eax
   1588b:	ff 75 08             	pushl  0x8(%ebp)
   1588e:	e8 83 fc ff ff       	call   15516 <cluster_get_next>
   15893:	83 c4 10             	add    $0x10,%esp
   15896:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
        cluster_set_next(fat,start,FAT_CLUSTER_FREE);
   1589a:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
   1589e:	83 ec 04             	sub    $0x4,%esp
   158a1:	6a 00                	push   $0x0
   158a3:	50                   	push   %eax
   158a4:	ff 75 08             	pushl  0x8(%ebp)
   158a7:	e8 99 fe ff ff       	call   15745 <cluster_set_next>
   158ac:	83 c4 10             	add    $0x10,%esp
        start=next;
   158af:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   158b3:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    while(cluster_is_valid(start)){
   158b7:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
   158bb:	83 ec 0c             	sub    $0xc,%esp
   158be:	50                   	push   %eax
   158bf:	e8 d0 fb ff ff       	call   15494 <cluster_is_valid>
   158c4:	83 c4 10             	add    $0x10,%esp
   158c7:	85 c0                	test   %eax,%eax
   158c9:	75 b8                	jne    15883 <cluster_free_chain+0xf>
    }
}
   158cb:	90                   	nop
   158cc:	c9                   	leave  
   158cd:	c3                   	ret    

000158ce <cluster_alloc_free>:
/**
 * @brief 分配指定数量的簇
 * @param fat 文件系统数据结构
 * @param cluster_cnt 要分配的簇数量
 */
cluster_t cluster_alloc_free(fat_t *fat,int cnt){
   158ce:	55                   	push   %ebp
   158cf:	89 e5                	mov    %esp,%ebp
   158d1:	83 ec 28             	sub    $0x28,%esp
    cluster_t pre, curr, start;
    int c_total = fat->tbl_sectors * fat->bytes_per_sec / sizeof(cluster_t);
   158d4:	8b 45 08             	mov    0x8(%ebp),%eax
   158d7:	8b 50 08             	mov    0x8(%eax),%edx
   158da:	8b 45 08             	mov    0x8(%ebp),%eax
   158dd:	8b 40 0c             	mov    0xc(%eax),%eax
   158e0:	0f af c2             	imul   %edx,%eax
   158e3:	d1 e8                	shr    %eax
   158e5:	89 45 ec             	mov    %eax,-0x14(%ebp)

    pre = start = FAT_CLUSTER_INVALID;
   158e8:	66 c7 45 f2 f8 ff    	movw   $0xfff8,-0xe(%ebp)
   158ee:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   158f2:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
    for (curr = 2; (curr< c_total) && cnt; curr++) {
   158f6:	66 c7 45 f4 02 00    	movw   $0x2,-0xc(%ebp)
   158fc:	e9 a0 00 00 00       	jmp    159a1 <cluster_alloc_free+0xd3>
        cluster_t free = cluster_get_next(fat, curr);
   15901:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
   15905:	83 ec 08             	sub    $0x8,%esp
   15908:	50                   	push   %eax
   15909:	ff 75 08             	pushl  0x8(%ebp)
   1590c:	e8 05 fc ff ff       	call   15516 <cluster_get_next>
   15911:	83 c4 10             	add    $0x10,%esp
   15914:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
        if (free == FAT_CLUSTER_FREE) {
   15918:	66 83 7d ea 00       	cmpw   $0x0,-0x16(%ebp)
   1591d:	75 77                	jne    15996 <cluster_alloc_free+0xc8>
            // 记录首个簇
            if (!cluster_is_valid(start)) {
   1591f:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   15923:	83 ec 0c             	sub    $0xc,%esp
   15926:	50                   	push   %eax
   15927:	e8 68 fb ff ff       	call   15494 <cluster_is_valid>
   1592c:	83 c4 10             	add    $0x10,%esp
   1592f:	85 c0                	test   %eax,%eax
   15931:	75 08                	jne    1593b <cluster_alloc_free+0x6d>
                start = curr;
   15933:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
   15937:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
            } 
        
            // 前一簇如果有效，则设置。否则忽略掉
            if (cluster_is_valid(pre)) {
   1593b:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   1593f:	83 ec 0c             	sub    $0xc,%esp
   15942:	50                   	push   %eax
   15943:	e8 4c fb ff ff       	call   15494 <cluster_is_valid>
   15948:	83 c4 10             	add    $0x10,%esp
   1594b:	85 c0                	test   %eax,%eax
   1594d:	74 3b                	je     1598a <cluster_alloc_free+0xbc>
                // 找到空表项，设置前一表项的链接
                int err = cluster_set_next(fat, pre, curr);
   1594f:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
   15953:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   15957:	83 ec 04             	sub    $0x4,%esp
   1595a:	52                   	push   %edx
   1595b:	50                   	push   %eax
   1595c:	ff 75 08             	pushl  0x8(%ebp)
   1595f:	e8 e1 fd ff ff       	call   15745 <cluster_set_next>
   15964:	83 c4 10             	add    $0x10,%esp
   15967:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (err < 0) {
   1596a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1596e:	79 1a                	jns    1598a <cluster_alloc_free+0xbc>
                    cluster_free_chain(fat, start);
   15970:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   15974:	83 ec 08             	sub    $0x8,%esp
   15977:	50                   	push   %eax
   15978:	ff 75 08             	pushl  0x8(%ebp)
   1597b:	e8 f4 fe ff ff       	call   15874 <cluster_free_chain>
   15980:	83 c4 10             	add    $0x10,%esp
                    return FAT_CLUSTER_INVALID;
   15983:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   15988:	eb 6f                	jmp    159f9 <cluster_alloc_free+0x12b>
                }
            }

            pre = curr;
   1598a:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
   1598e:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
            cnt--;
   15992:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    for (curr = 2; (curr< c_total) && cnt; curr++) {
   15996:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
   1599a:	83 c0 01             	add    $0x1,%eax
   1599d:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
   159a1:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
   159a5:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   159a8:	7e 0a                	jle    159b4 <cluster_alloc_free+0xe6>
   159aa:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   159ae:	0f 85 4d ff ff ff    	jne    15901 <cluster_alloc_free+0x33>
        }
    }

    // 最后的结点
    if (cnt == 0) {
   159b4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   159b8:	75 27                	jne    159e1 <cluster_alloc_free+0x113>
        int err = cluster_set_next(fat, pre, FAT_CLUSTER_INVALID);
   159ba:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   159be:	83 ec 04             	sub    $0x4,%esp
   159c1:	68 f8 ff 00 00       	push   $0xfff8
   159c6:	50                   	push   %eax
   159c7:	ff 75 08             	pushl  0x8(%ebp)
   159ca:	e8 76 fd ff ff       	call   15745 <cluster_set_next>
   159cf:	83 c4 10             	add    $0x10,%esp
   159d2:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if (err == 0) {
   159d5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   159d9:	75 06                	jne    159e1 <cluster_alloc_free+0x113>
            return start;
   159db:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   159df:	eb 18                	jmp    159f9 <cluster_alloc_free+0x12b>
        }
    }

    // 失败，空间不够等问题
    cluster_free_chain(fat, start);
   159e1:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   159e5:	83 ec 08             	sub    $0x8,%esp
   159e8:	50                   	push   %eax
   159e9:	ff 75 08             	pushl  0x8(%ebp)
   159ec:	e8 83 fe ff ff       	call   15874 <cluster_free_chain>
   159f1:	83 c4 10             	add    $0x10,%esp
    return FAT_CLUSTER_INVALID;
   159f4:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
}
   159f9:	c9                   	leave  
   159fa:	c3                   	ret    

000159fb <expand_file>:
/**
 * @brief 扩展文件大小
 * @param file 文件指针
 * @param incr_bytes 要增加的字节数
 */
static int expand_file(file_t *file,int inc_bytes){
   159fb:	55                   	push   %ebp
   159fc:	89 e5                	mov    %esp,%ebp
   159fe:	53                   	push   %ebx
   159ff:	83 ec 24             	sub    $0x24,%esp
     fat_t * fat = (fat_t *)file->fs->data;
   15a02:	8b 45 08             	mov    0x8(%ebp),%eax
   15a05:	8b 40 38             	mov    0x38(%eax),%eax
   15a08:	8b 80 08 02 00 00    	mov    0x208(%eax),%eax
   15a0e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    int cluster_cnt;
    if ((file->size == 0) || (file->size % fat->cluster_byte_size == 0)) {
   15a11:	8b 45 08             	mov    0x8(%ebp),%eax
   15a14:	8b 40 24             	mov    0x24(%eax),%eax
   15a17:	85 c0                	test   %eax,%eax
   15a19:	74 19                	je     15a34 <expand_file+0x39>
   15a1b:	8b 45 08             	mov    0x8(%ebp),%eax
   15a1e:	8b 40 24             	mov    0x24(%eax),%eax
   15a21:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15a24:	8b 4a 20             	mov    0x20(%edx),%ecx
   15a27:	ba 00 00 00 00       	mov    $0x0,%edx
   15a2c:	f7 f1                	div    %ecx
   15a2e:	89 d0                	mov    %edx,%eax
   15a30:	85 c0                	test   %eax,%eax
   15a32:	75 29                	jne    15a5d <expand_file+0x62>
        // 文件为空，或者刚好达到的簇的末尾
        cluster_cnt = up2(inc_bytes, fat->cluster_byte_size) / fat->cluster_byte_size; 
   15a34:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a37:	8b 50 20             	mov    0x20(%eax),%edx
   15a3a:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a3d:	52                   	push   %edx
   15a3e:	50                   	push   %eax
   15a3f:	e8 fb f9 ff ff       	call   1543f <up2>
   15a44:	83 c4 08             	add    $0x8,%esp
   15a47:	89 c1                	mov    %eax,%ecx
   15a49:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a4c:	8b 58 20             	mov    0x20(%eax),%ebx
   15a4f:	89 c8                	mov    %ecx,%eax
   15a51:	ba 00 00 00 00       	mov    $0x0,%edx
   15a56:	f7 f3                	div    %ebx
   15a58:	89 45 f4             	mov    %eax,-0xc(%ebp)
   15a5b:	eb 6b                	jmp    15ac8 <expand_file+0xcd>
    } else {
        // 文件非空，当前簇的空闲量，如果空间够增长，则直接退出了
        // 例如：大小为2048，再扩充1024,簇大小为1024
        int cfree = fat->cluster_byte_size - (file->size % fat->cluster_byte_size);
   15a5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a60:	8b 48 20             	mov    0x20(%eax),%ecx
   15a63:	8b 45 08             	mov    0x8(%ebp),%eax
   15a66:	8b 40 24             	mov    0x24(%eax),%eax
   15a69:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15a6c:	8b 5a 20             	mov    0x20(%edx),%ebx
   15a6f:	ba 00 00 00 00       	mov    $0x0,%edx
   15a74:	f7 f3                	div    %ebx
   15a76:	89 d0                	mov    %edx,%eax
   15a78:	29 c1                	sub    %eax,%ecx
   15a7a:	89 c8                	mov    %ecx,%eax
   15a7c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (cfree > inc_bytes) {
   15a7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15a82:	3b 45 0c             	cmp    0xc(%ebp),%eax
   15a85:	7e 0a                	jle    15a91 <expand_file+0x96>
            return 0;
   15a87:	b8 00 00 00 00       	mov    $0x0,%eax
   15a8c:	e9 da 00 00 00       	jmp    15b6b <expand_file+0x170>
        }

        cluster_cnt = up2(inc_bytes - cfree, fat->cluster_byte_size) / fat->cluster_byte_size;
   15a91:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a94:	8b 40 20             	mov    0x20(%eax),%eax
   15a97:	8b 55 0c             	mov    0xc(%ebp),%edx
   15a9a:	2b 55 ec             	sub    -0x14(%ebp),%edx
   15a9d:	50                   	push   %eax
   15a9e:	52                   	push   %edx
   15a9f:	e8 9b f9 ff ff       	call   1543f <up2>
   15aa4:	83 c4 08             	add    $0x8,%esp
   15aa7:	89 c1                	mov    %eax,%ecx
   15aa9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15aac:	8b 58 20             	mov    0x20(%eax),%ebx
   15aaf:	89 c8                	mov    %ecx,%eax
   15ab1:	ba 00 00 00 00       	mov    $0x0,%edx
   15ab6:	f7 f3                	div    %ebx
   15ab8:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (cluster_cnt == 0) {
   15abb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15abf:	75 07                	jne    15ac8 <expand_file+0xcd>
            cluster_cnt = 1;
   15ac1:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
        }
    }

    cluster_t start = cluster_alloc_free(fat, cluster_cnt);
   15ac8:	83 ec 08             	sub    $0x8,%esp
   15acb:	ff 75 f4             	pushl  -0xc(%ebp)
   15ace:	ff 75 f0             	pushl  -0x10(%ebp)
   15ad1:	e8 f8 fd ff ff       	call   158ce <cluster_alloc_free>
   15ad6:	83 c4 10             	add    $0x10,%esp
   15ad9:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
    if (!cluster_is_valid(start)) {
   15add:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
   15ae1:	83 ec 0c             	sub    $0xc,%esp
   15ae4:	50                   	push   %eax
   15ae5:	e8 aa f9 ff ff       	call   15494 <cluster_is_valid>
   15aea:	83 c4 10             	add    $0x10,%esp
   15aed:	85 c0                	test   %eax,%eax
   15aef:	75 17                	jne    15b08 <expand_file+0x10d>
        log_printf("no cluster for file write");
   15af1:	83 ec 0c             	sub    $0xc,%esp
   15af4:	68 ee 92 01 00       	push   $0x192ee
   15af9:	e8 cd 29 00 00       	call   184cb <log_printf>
   15afe:	83 c4 10             	add    $0x10,%esp
        return -1;
   15b01:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15b06:	eb 63                	jmp    15b6b <expand_file+0x170>
    }

    // 在文件关闭时，回写
    if (!cluster_is_valid(file->sblk)) {
   15b08:	8b 45 08             	mov    0x8(%ebp),%eax
   15b0b:	8b 40 40             	mov    0x40(%eax),%eax
   15b0e:	0f b7 c0             	movzwl %ax,%eax
   15b11:	83 ec 0c             	sub    $0xc,%esp
   15b14:	50                   	push   %eax
   15b15:	e8 7a f9 ff ff       	call   15494 <cluster_is_valid>
   15b1a:	83 c4 10             	add    $0x10,%esp
   15b1d:	85 c0                	test   %eax,%eax
   15b1f:	75 18                	jne    15b39 <expand_file+0x13e>
        file->cblk = file->sblk = start;
   15b21:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
   15b25:	8b 45 08             	mov    0x8(%ebp),%eax
   15b28:	89 50 40             	mov    %edx,0x40(%eax)
   15b2b:	8b 45 08             	mov    0x8(%ebp),%eax
   15b2e:	8b 50 40             	mov    0x40(%eax),%edx
   15b31:	8b 45 08             	mov    0x8(%ebp),%eax
   15b34:	89 50 44             	mov    %edx,0x44(%eax)
   15b37:	eb 2d                	jmp    15b66 <expand_file+0x16b>
    } else {
        // 建立链接关系
        int err = cluster_set_next(fat, file->cblk, start);
   15b39:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
   15b3d:	8b 45 08             	mov    0x8(%ebp),%eax
   15b40:	8b 40 44             	mov    0x44(%eax),%eax
   15b43:	0f b7 c0             	movzwl %ax,%eax
   15b46:	83 ec 04             	sub    $0x4,%esp
   15b49:	52                   	push   %edx
   15b4a:	50                   	push   %eax
   15b4b:	ff 75 f0             	pushl  -0x10(%ebp)
   15b4e:	e8 f2 fb ff ff       	call   15745 <cluster_set_next>
   15b53:	83 c4 10             	add    $0x10,%esp
   15b56:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (err < 0) {
   15b59:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   15b5d:	79 07                	jns    15b66 <expand_file+0x16b>
            return -1;
   15b5f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15b64:	eb 05                	jmp    15b6b <expand_file+0x170>
        }
    }

    return 0;
   15b66:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15b6b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15b6e:	c9                   	leave  
   15b6f:	c3                   	ret    

00015b70 <fatfs_mount>:

int fatfs_mount(struct _fs_t *fs,int major,int minor){
   15b70:	55                   	push   %ebp
   15b71:	89 e5                	mov    %esp,%ebp
   15b73:	83 ec 18             	sub    $0x18,%esp
    int dev_id=dev_open(major,minor,(void*)0);
   15b76:	83 ec 04             	sub    $0x4,%esp
   15b79:	6a 00                	push   $0x0
   15b7b:	ff 75 10             	pushl  0x10(%ebp)
   15b7e:	ff 75 0c             	pushl  0xc(%ebp)
   15b81:	e8 94 df ff ff       	call   13b1a <dev_open>
   15b86:	83 c4 10             	add    $0x10,%esp
   15b89:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(dev_id<0){
   15b8c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15b90:	79 20                	jns    15bb2 <fatfs_mount+0x42>
        log_printf("open disk failed. major: %x, minor: %x",major,minor);
   15b92:	83 ec 04             	sub    $0x4,%esp
   15b95:	ff 75 10             	pushl  0x10(%ebp)
   15b98:	ff 75 0c             	pushl  0xc(%ebp)
   15b9b:	68 08 93 01 00       	push   $0x19308
   15ba0:	e8 26 29 00 00       	call   184cb <log_printf>
   15ba5:	83 c4 10             	add    $0x10,%esp
        return -1;
   15ba8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15bad:	e9 8c 01 00 00       	jmp    15d3e <fatfs_mount+0x1ce>
    }

    dbr_t* dbr=(dbr_t*)memory_alloc_page();
   15bb2:	e8 8e ad ff ff       	call   10945 <memory_alloc_page>
   15bb7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!dbr){
   15bba:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   15bbe:	75 20                	jne    15be0 <fatfs_mount+0x70>
        log_printf("mount failed.: can't alloc buf");
   15bc0:	83 ec 0c             	sub    $0xc,%esp
   15bc3:	68 30 93 01 00       	push   $0x19330
   15bc8:	e8 fe 28 00 00       	call   184cb <log_printf>
   15bcd:	83 c4 10             	add    $0x10,%esp
        goto mount_failed;
   15bd0:	90                   	nop
    fs->dev_id=dev_id;

    return 0;

mount_failed:
    if(dbr){
   15bd1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   15bd5:	0f 84 50 01 00 00    	je     15d2b <fatfs_mount+0x1bb>
   15bdb:	e9 3c 01 00 00       	jmp    15d1c <fatfs_mount+0x1ac>
    int cnt=dev_read(dev_id,0,(char*)dbr,1);
   15be0:	6a 01                	push   $0x1
   15be2:	ff 75 f0             	pushl  -0x10(%ebp)
   15be5:	6a 00                	push   $0x0
   15be7:	ff 75 f4             	pushl  -0xc(%ebp)
   15bea:	e8 7d e0 ff ff       	call   13c6c <dev_read>
   15bef:	83 c4 10             	add    $0x10,%esp
   15bf2:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(cnt<1){
   15bf5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   15bf9:	7f 1a                	jg     15c15 <fatfs_mount+0xa5>
        log_printf("read dbr failed.");
   15bfb:	83 ec 0c             	sub    $0xc,%esp
   15bfe:	68 4f 93 01 00       	push   $0x1934f
   15c03:	e8 c3 28 00 00       	call   184cb <log_printf>
   15c08:	83 c4 10             	add    $0x10,%esp
        return -1;
   15c0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15c10:	e9 29 01 00 00       	jmp    15d3e <fatfs_mount+0x1ce>
    fat_t* fat=&fs->fat_data;
   15c15:	8b 45 08             	mov    0x8(%ebp),%eax
   15c18:	05 1c 02 00 00       	add    $0x21c,%eax
   15c1d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    fat->fat_buff=(uint8_t*)dbr;
   15c20:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15c23:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15c26:	89 50 28             	mov    %edx,0x28(%eax)
    fat->bytes_per_sec=dbr->BPB_BytsPerSec;
   15c29:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c2c:	0f b7 40 0b          	movzwl 0xb(%eax),%eax
   15c30:	0f b7 d0             	movzwl %ax,%edx
   15c33:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15c36:	89 50 0c             	mov    %edx,0xc(%eax)
    fat->tbl_start=dbr->BPB_RsvdSecCnt;
   15c39:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c3c:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   15c40:	0f b7 d0             	movzwl %ax,%edx
   15c43:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15c46:	89 10                	mov    %edx,(%eax)
    fat->tbl_sectors=dbr->BPB_FATSz16;
   15c48:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c4b:	0f b7 40 16          	movzwl 0x16(%eax),%eax
   15c4f:	0f b7 d0             	movzwl %ax,%edx
   15c52:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15c55:	89 50 08             	mov    %edx,0x8(%eax)
    fat->tbl_cnt=dbr->BPB_NumFATs;
   15c58:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c5b:	0f b6 40 10          	movzbl 0x10(%eax),%eax
   15c5f:	0f b6 d0             	movzbl %al,%edx
   15c62:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15c65:	89 50 04             	mov    %edx,0x4(%eax)
    fat->root_ent_cnt=dbr->BPB_RootEntCnt;
   15c68:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c6b:	0f b7 40 11          	movzwl 0x11(%eax),%eax
   15c6f:	0f b7 d0             	movzwl %ax,%edx
   15c72:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15c75:	89 50 18             	mov    %edx,0x18(%eax)
    fat->sec_per_cluster=dbr->BPB_SecPerClus;
   15c78:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c7b:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   15c7f:	0f b6 d0             	movzbl %al,%edx
   15c82:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15c85:	89 50 10             	mov    %edx,0x10(%eax)
    fat->root_start=fat->tbl_start+fat->tbl_sectors*fat->tbl_cnt;
   15c88:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15c8b:	8b 10                	mov    (%eax),%edx
   15c8d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15c90:	8b 48 08             	mov    0x8(%eax),%ecx
   15c93:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15c96:	8b 40 04             	mov    0x4(%eax),%eax
   15c99:	0f af c1             	imul   %ecx,%eax
   15c9c:	01 c2                	add    %eax,%edx
   15c9e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15ca1:	89 50 14             	mov    %edx,0x14(%eax)
    fat->data_start=fat->root_start+fat->root_ent_cnt*32/512;
   15ca4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15ca7:	8b 50 14             	mov    0x14(%eax),%edx
   15caa:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15cad:	8b 40 18             	mov    0x18(%eax),%eax
   15cb0:	c1 e0 05             	shl    $0x5,%eax
   15cb3:	c1 e8 09             	shr    $0x9,%eax
   15cb6:	01 c2                	add    %eax,%edx
   15cb8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15cbb:	89 50 1c             	mov    %edx,0x1c(%eax)
    fat->cluster_byte_size=fat->sec_per_cluster*dbr->BPB_BytsPerSec;
   15cbe:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15cc1:	8b 50 10             	mov    0x10(%eax),%edx
   15cc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15cc7:	0f b7 40 0b          	movzwl 0xb(%eax),%eax
   15ccb:	0f b7 c0             	movzwl %ax,%eax
   15cce:	0f af d0             	imul   %eax,%edx
   15cd1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15cd4:	89 50 20             	mov    %edx,0x20(%eax)
    fat->fs=fs;
   15cd7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15cda:	8b 55 08             	mov    0x8(%ebp),%edx
   15cdd:	89 50 24             	mov    %edx,0x24(%eax)
    fat->curr_sector=-1; // 初始化当前扇区为-1
   15ce0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15ce3:	c7 40 2c ff ff ff ff 	movl   $0xffffffff,0x2c(%eax)
    fs->type=FS_FAT16;
   15cea:	8b 45 08             	mov    0x8(%ebp),%eax
   15ced:	c7 80 00 02 00 00 01 	movl   $0x1,0x200(%eax)
   15cf4:	00 00 00 
    fs->data=&fs->fat_data;
   15cf7:	8b 45 08             	mov    0x8(%ebp),%eax
   15cfa:	8d 90 1c 02 00 00    	lea    0x21c(%eax),%edx
   15d00:	8b 45 08             	mov    0x8(%ebp),%eax
   15d03:	89 90 08 02 00 00    	mov    %edx,0x208(%eax)
    fs->dev_id=dev_id;
   15d09:	8b 45 08             	mov    0x8(%ebp),%eax
   15d0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15d0f:	89 90 0c 02 00 00    	mov    %edx,0x20c(%eax)
    return 0;
   15d15:	b8 00 00 00 00       	mov    $0x0,%eax
   15d1a:	eb 22                	jmp    15d3e <fatfs_mount+0x1ce>
        memory_free_page((uint32_t)dbr);
   15d1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d1f:	83 ec 0c             	sub    $0xc,%esp
   15d22:	50                   	push   %eax
   15d23:	e8 50 ac ff ff       	call   10978 <memory_free_page>
   15d28:	83 c4 10             	add    $0x10,%esp
    }

    dev_close(dev_id);
   15d2b:	83 ec 0c             	sub    $0xc,%esp
   15d2e:	ff 75 f4             	pushl  -0xc(%ebp)
   15d31:	e8 1a e0 ff ff       	call   13d50 <dev_close>
   15d36:	83 c4 10             	add    $0x10,%esp
    return -1;
   15d39:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   15d3e:	c9                   	leave  
   15d3f:	c3                   	ret    

00015d40 <fatfs_unmount>:

void fatfs_unmount(struct _fs_t *fs){
   15d40:	55                   	push   %ebp
   15d41:	89 e5                	mov    %esp,%ebp
   15d43:	83 ec 18             	sub    $0x18,%esp
    fat_t* fat=(fat_t*)fs->data;
   15d46:	8b 45 08             	mov    0x8(%ebp),%eax
   15d49:	8b 80 08 02 00 00    	mov    0x208(%eax),%eax
   15d4f:	89 45 f4             	mov    %eax,-0xc(%ebp)

    dev_close(fs->dev_id);
   15d52:	8b 45 08             	mov    0x8(%ebp),%eax
   15d55:	8b 80 0c 02 00 00    	mov    0x20c(%eax),%eax
   15d5b:	83 ec 0c             	sub    $0xc,%esp
   15d5e:	50                   	push   %eax
   15d5f:	e8 ec df ff ff       	call   13d50 <dev_close>
   15d64:	83 c4 10             	add    $0x10,%esp

    memory_free_page((uint32_t)fat->fat_buff);
   15d67:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d6a:	8b 40 28             	mov    0x28(%eax),%eax
   15d6d:	83 ec 0c             	sub    $0xc,%esp
   15d70:	50                   	push   %eax
   15d71:	e8 02 ac ff ff       	call   10978 <memory_free_page>
   15d76:	83 c4 10             	add    $0x10,%esp
}
   15d79:	90                   	nop
   15d7a:	c9                   	leave  
   15d7b:	c3                   	ret    

00015d7c <to_sfn>:
/**
 * @brief 将文件名转换为短文件名格式就是目录项中的DIR_Name格式
 * @param dest 存储转换后的短文件名
 * @param src 原始文件名
 */
static void to_sfn(char *dest,const char *src){
   15d7c:	55                   	push   %ebp
   15d7d:	89 e5                	mov    %esp,%ebp
   15d7f:	83 ec 18             	sub    $0x18,%esp
    kernel_memset(dest,' ',11);
   15d82:	83 ec 04             	sub    $0x4,%esp
   15d85:	6a 0b                	push   $0xb
   15d87:	6a 20                	push   $0x20
   15d89:	ff 75 08             	pushl  0x8(%ebp)
   15d8c:	e8 17 21 00 00       	call   17ea8 <kernel_memset>
   15d91:	83 c4 10             	add    $0x10,%esp

    char *curr=dest;
   15d94:	8b 45 08             	mov    0x8(%ebp),%eax
   15d97:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char *end=dest+11;
   15d9a:	8b 45 08             	mov    0x8(%ebp),%eax
   15d9d:	83 c0 0b             	add    $0xb,%eax
   15da0:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while(*src && (curr < end)){
   15da3:	eb 49                	jmp    15dee <to_sfn+0x72>
        char c=*src++;
   15da5:	8b 45 0c             	mov    0xc(%ebp),%eax
   15da8:	8d 50 01             	lea    0x1(%eax),%edx
   15dab:	89 55 0c             	mov    %edx,0xc(%ebp)
   15dae:	0f b6 00             	movzbl (%eax),%eax
   15db1:	88 45 f3             	mov    %al,-0xd(%ebp)
        switch(c){
   15db4:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
   15db8:	83 f8 2e             	cmp    $0x2e,%eax
   15dbb:	75 0b                	jne    15dc8 <to_sfn+0x4c>
            case '.':
                curr=dest+8;
   15dbd:	8b 45 08             	mov    0x8(%ebp),%eax
   15dc0:	83 c0 08             	add    $0x8,%eax
   15dc3:	89 45 f4             	mov    %eax,-0xc(%ebp)
                break;
   15dc6:	eb 26                	jmp    15dee <to_sfn+0x72>
            default:
                if((c>='a')&&(c<='z')){
   15dc8:	80 7d f3 60          	cmpb   $0x60,-0xd(%ebp)
   15dcc:	7e 10                	jle    15dde <to_sfn+0x62>
   15dce:	80 7d f3 7a          	cmpb   $0x7a,-0xd(%ebp)
   15dd2:	7f 0a                	jg     15dde <to_sfn+0x62>
                    c=c-'a'+'A';
   15dd4:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   15dd8:	83 e8 20             	sub    $0x20,%eax
   15ddb:	88 45 f3             	mov    %al,-0xd(%ebp)
                }
                *curr++=c;
   15dde:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15de1:	8d 50 01             	lea    0x1(%eax),%edx
   15de4:	89 55 f4             	mov    %edx,-0xc(%ebp)
   15de7:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
   15deb:	88 10                	mov    %dl,(%eax)
                break;
   15ded:	90                   	nop
    while(*src && (curr < end)){
   15dee:	8b 45 0c             	mov    0xc(%ebp),%eax
   15df1:	0f b6 00             	movzbl (%eax),%eax
   15df4:	84 c0                	test   %al,%al
   15df6:	74 08                	je     15e00 <to_sfn+0x84>
   15df8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15dfb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   15dfe:	72 a5                	jb     15da5 <to_sfn+0x29>

        }
    }

}
   15e00:	90                   	nop
   15e01:	c9                   	leave  
   15e02:	c3                   	ret    

00015e03 <diritem_name_match>:

static int diritem_name_match(diritem_t *item,const char *path){
   15e03:	55                   	push   %ebp
   15e04:	89 e5                	mov    %esp,%ebp
   15e06:	83 ec 18             	sub    $0x18,%esp
    char buf[11];
    to_sfn(buf,path);
   15e09:	83 ec 08             	sub    $0x8,%esp
   15e0c:	ff 75 0c             	pushl  0xc(%ebp)
   15e0f:	8d 45 ed             	lea    -0x13(%ebp),%eax
   15e12:	50                   	push   %eax
   15e13:	e8 64 ff ff ff       	call   15d7c <to_sfn>
   15e18:	83 c4 10             	add    $0x10,%esp
    return kernel_memcmp(item->DIR_Name,buf,11) == 0;
   15e1b:	8b 45 08             	mov    0x8(%ebp),%eax
   15e1e:	83 ec 04             	sub    $0x4,%esp
   15e21:	6a 0b                	push   $0xb
   15e23:	8d 55 ed             	lea    -0x13(%ebp),%edx
   15e26:	52                   	push   %edx
   15e27:	50                   	push   %eax
   15e28:	e8 bc 20 00 00       	call   17ee9 <kernel_memcmp>
   15e2d:	83 c4 10             	add    $0x10,%esp
   15e30:	85 c0                	test   %eax,%eax
   15e32:	0f 94 c0             	sete   %al
   15e35:	0f b6 c0             	movzbl %al,%eax
}
   15e38:	c9                   	leave  
   15e39:	c3                   	ret    

00015e3a <read_from_diritem>:

static void read_from_diritem(fat_t *fat,file_t *file,diritem_t *item,int index){
   15e3a:	55                   	push   %ebp
   15e3b:	89 e5                	mov    %esp,%ebp
    file->type=diritem_get_type(item);
   15e3d:	ff 75 10             	pushl  0x10(%ebp)
   15e40:	e8 8f f7 ff ff       	call   155d4 <diritem_get_type>
   15e45:	83 c4 04             	add    $0x4,%esp
   15e48:	89 c2                	mov    %eax,%edx
   15e4a:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e4d:	89 50 20             	mov    %edx,0x20(%eax)
    file->size=item->DIR_FileSize;
   15e50:	8b 45 10             	mov    0x10(%ebp),%eax
   15e53:	8b 50 1c             	mov    0x1c(%eax),%edx
   15e56:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e59:	89 50 24             	mov    %edx,0x24(%eax)
    file->pos=0;
   15e5c:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e5f:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)

    file->sblk=(item->DIR_FstClusHI << 16) | item->DIR_FstClusLO;
   15e66:	8b 45 10             	mov    0x10(%ebp),%eax
   15e69:	0f b7 40 14          	movzwl 0x14(%eax),%eax
   15e6d:	0f b7 c0             	movzwl %ax,%eax
   15e70:	c1 e0 10             	shl    $0x10,%eax
   15e73:	89 c2                	mov    %eax,%edx
   15e75:	8b 45 10             	mov    0x10(%ebp),%eax
   15e78:	0f b7 40 1a          	movzwl 0x1a(%eax),%eax
   15e7c:	0f b7 c0             	movzwl %ax,%eax
   15e7f:	09 c2                	or     %eax,%edx
   15e81:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e84:	89 50 40             	mov    %edx,0x40(%eax)
    file->cblk=file->sblk;
   15e87:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e8a:	8b 50 40             	mov    0x40(%eax),%edx
   15e8d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e90:	89 50 44             	mov    %edx,0x44(%eax)
    file->p_index=index;
   15e93:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e96:	8b 55 14             	mov    0x14(%ebp),%edx
   15e99:	89 50 3c             	mov    %edx,0x3c(%eax)

}
   15e9c:	90                   	nop
   15e9d:	c9                   	leave  
   15e9e:	c3                   	ret    

00015e9f <diritem_init>:
 * @brief 初始化目录项
 * @param item 目录项
 * @param attr 目录项属性
 * @param name 目录项名称
 */
int diritem_init(diritem_t *item,uint8_t attr,const char *name){
   15e9f:	55                   	push   %ebp
   15ea0:	89 e5                	mov    %esp,%ebp
   15ea2:	83 ec 18             	sub    $0x18,%esp
   15ea5:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ea8:	88 45 f4             	mov    %al,-0xc(%ebp)
    to_sfn((char*)item->DIR_Name,name);
   15eab:	8b 45 08             	mov    0x8(%ebp),%eax
   15eae:	83 ec 08             	sub    $0x8,%esp
   15eb1:	ff 75 10             	pushl  0x10(%ebp)
   15eb4:	50                   	push   %eax
   15eb5:	e8 c2 fe ff ff       	call   15d7c <to_sfn>
   15eba:	83 c4 10             	add    $0x10,%esp
    item->DIR_FstClusHI=(uint16_t)(FAT_CLUSTER_INVALID >> 16);
   15ebd:	8b 45 08             	mov    0x8(%ebp),%eax
   15ec0:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
    item->DIR_FstClusLO=(uint16_t)(FAT_CLUSTER_INVALID & 0xFFFF);
   15ec6:	8b 45 08             	mov    0x8(%ebp),%eax
   15ec9:	66 c7 40 1a f8 ff    	movw   $0xfff8,0x1a(%eax)
    item->DIR_Attr=attr;
   15ecf:	8b 45 08             	mov    0x8(%ebp),%eax
   15ed2:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
   15ed6:	88 50 0b             	mov    %dl,0xb(%eax)
    item->DIR_FileSize=0;
   15ed9:	8b 45 08             	mov    0x8(%ebp),%eax
   15edc:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    item->DIR_NTRes=0;
   15ee3:	8b 45 08             	mov    0x8(%ebp),%eax
   15ee6:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
    item->DIR_CrtTime=0;
   15eea:	8b 45 08             	mov    0x8(%ebp),%eax
   15eed:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%eax)
    item->DIR_CrtDate=0;
   15ef3:	8b 45 08             	mov    0x8(%ebp),%eax
   15ef6:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
    item->DIR_WrtDate=0;
   15efc:	8b 45 08             	mov    0x8(%ebp),%eax
   15eff:	66 c7 40 18 00 00    	movw   $0x0,0x18(%eax)
    item->DIR_WrtTime=0;
   15f05:	8b 45 08             	mov    0x8(%ebp),%eax
   15f08:	66 c7 40 16 00 00    	movw   $0x0,0x16(%eax)
    item->DIR_LstAccDate=0;
   15f0e:	8b 45 08             	mov    0x8(%ebp),%eax
   15f11:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    return 0;
   15f17:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15f1c:	c9                   	leave  
   15f1d:	c3                   	ret    

00015f1e <write_dir_entry>:
 * @param fat 文件系统数据结构
 * @param item 要写入的目录项
 * @param index 目录项的索引
 * @return 0 成功，-1 失败
 */
static int write_dir_entry(fat_t *fat,diritem_t *item,int index){
   15f1e:	55                   	push   %ebp
   15f1f:	89 e5                	mov    %esp,%ebp
   15f21:	53                   	push   %ebx
   15f22:	83 ec 14             	sub    $0x14,%esp
    if ((index < 0) || (index >= fat->root_ent_cnt)) {
   15f25:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   15f29:	78 0d                	js     15f38 <write_dir_entry+0x1a>
   15f2b:	8b 45 08             	mov    0x8(%ebp),%eax
   15f2e:	8b 50 18             	mov    0x18(%eax),%edx
   15f31:	8b 45 10             	mov    0x10(%ebp),%eax
   15f34:	39 c2                	cmp    %eax,%edx
   15f36:	77 0a                	ja     15f42 <write_dir_entry+0x24>
        return -1;
   15f38:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15f3d:	e9 81 00 00 00       	jmp    15fc3 <write_dir_entry+0xa5>
    }

    int offset = index * sizeof(diritem_t);
   15f42:	8b 45 10             	mov    0x10(%ebp),%eax
   15f45:	c1 e0 05             	shl    $0x5,%eax
   15f48:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int sector = fat->root_start + offset / fat->bytes_per_sec;
   15f4b:	8b 45 08             	mov    0x8(%ebp),%eax
   15f4e:	8b 48 14             	mov    0x14(%eax),%ecx
   15f51:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f54:	8b 55 08             	mov    0x8(%ebp),%edx
   15f57:	8b 5a 0c             	mov    0xc(%edx),%ebx
   15f5a:	ba 00 00 00 00       	mov    $0x0,%edx
   15f5f:	f7 f3                	div    %ebx
   15f61:	01 c8                	add    %ecx,%eax
   15f63:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int err = bread_sector(fat, sector);
   15f66:	83 ec 08             	sub    $0x8,%esp
   15f69:	ff 75 f0             	pushl  -0x10(%ebp)
   15f6c:	ff 75 08             	pushl  0x8(%ebp)
   15f6f:	e8 49 f5 ff ff       	call   154bd <bread_sector>
   15f74:	83 c4 10             	add    $0x10,%esp
   15f77:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (err < 0) {
   15f7a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   15f7e:	79 07                	jns    15f87 <write_dir_entry+0x69>
        return -1;
   15f80:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15f85:	eb 3c                	jmp    15fc3 <write_dir_entry+0xa5>
    }
    kernel_memcpy(fat->fat_buff + offset % fat->bytes_per_sec, item, sizeof(diritem_t));
   15f87:	8b 45 08             	mov    0x8(%ebp),%eax
   15f8a:	8b 48 28             	mov    0x28(%eax),%ecx
   15f8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f90:	8b 55 08             	mov    0x8(%ebp),%edx
   15f93:	8b 5a 0c             	mov    0xc(%edx),%ebx
   15f96:	ba 00 00 00 00       	mov    $0x0,%edx
   15f9b:	f7 f3                	div    %ebx
   15f9d:	89 d0                	mov    %edx,%eax
   15f9f:	01 c8                	add    %ecx,%eax
   15fa1:	83 ec 04             	sub    $0x4,%esp
   15fa4:	6a 20                	push   $0x20
   15fa6:	ff 75 0c             	pushl  0xc(%ebp)
   15fa9:	50                   	push   %eax
   15faa:	e8 aa 1e 00 00       	call   17e59 <kernel_memcpy>
   15faf:	83 c4 10             	add    $0x10,%esp
    return bwrite_sector(fat, sector);
   15fb2:	83 ec 08             	sub    $0x8,%esp
   15fb5:	ff 75 f0             	pushl  -0x10(%ebp)
   15fb8:	ff 75 08             	pushl  0x8(%ebp)
   15fbb:	e8 96 f4 ff ff       	call   15456 <bwrite_sector>
   15fc0:	83 c4 10             	add    $0x10,%esp
}
   15fc3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15fc6:	c9                   	leave  
   15fc7:	c3                   	ret    

00015fc8 <fatfs_open>:

int fatfs_open(struct _fs_t *fs,const char *path,file_t *file){
   15fc8:	55                   	push   %ebp
   15fc9:	89 e5                	mov    %esp,%ebp
   15fcb:	83 ec 48             	sub    $0x48,%esp
 fat_t * fat = (fat_t *)fs->data;
   15fce:	8b 45 08             	mov    0x8(%ebp),%eax
   15fd1:	8b 80 08 02 00 00    	mov    0x208(%eax),%eax
   15fd7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    diritem_t * file_item = (diritem_t *)0;
   15fda:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int p_index = -1;
   15fe1:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)

    // 遍历根目录的数据区，找到已经存在的匹配项
    for (int i = 0; i < fat->root_ent_cnt; i++) {
   15fe8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15fef:	eb 6f                	jmp    16060 <fatfs_open+0x98>
        diritem_t * item = read_dir_entry(fat, i);
   15ff1:	83 ec 08             	sub    $0x8,%esp
   15ff4:	ff 75 ec             	pushl  -0x14(%ebp)
   15ff7:	ff 75 e8             	pushl  -0x18(%ebp)
   15ffa:	e8 2e f6 ff ff       	call   1562d <read_dir_entry>
   15fff:	83 c4 10             	add    $0x10,%esp
   16002:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (item == (diritem_t *)0) {
   16005:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   16009:	75 0a                	jne    16015 <fatfs_open+0x4d>
            return -1;
   1600b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16010:	e9 3f 01 00 00       	jmp    16154 <fatfs_open+0x18c>
        }

         // 结束项，不需要再扫描了，同时index也不能往前走
        if (item->DIR_Name[0] == DIRITEM_NAME_END) {
   16015:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16018:	0f b6 00             	movzbl (%eax),%eax
   1601b:	84 c0                	test   %al,%al
   1601d:	75 08                	jne    16027 <fatfs_open+0x5f>
            p_index = i;
   1601f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16022:	89 45 f0             	mov    %eax,-0x10(%ebp)
            break;
   16025:	eb 46                	jmp    1606d <fatfs_open+0xa5>
        }

        // 只显示普通文件和目录，其它的不显示
        if (item->DIR_Name[0] == DIRITEM_NAME_FREE) {
   16027:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1602a:	0f b6 00             	movzbl (%eax),%eax
   1602d:	3c e5                	cmp    $0xe5,%al
   1602f:	75 08                	jne    16039 <fatfs_open+0x71>
            p_index = i;
   16031:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16034:	89 45 f0             	mov    %eax,-0x10(%ebp)
            continue;
   16037:	eb 23                	jmp    1605c <fatfs_open+0x94>
        }

        // 找到要打开的目录
        if (diritem_name_match(item, path)) {
   16039:	83 ec 08             	sub    $0x8,%esp
   1603c:	ff 75 0c             	pushl  0xc(%ebp)
   1603f:	ff 75 e4             	pushl  -0x1c(%ebp)
   16042:	e8 bc fd ff ff       	call   15e03 <diritem_name_match>
   16047:	83 c4 10             	add    $0x10,%esp
   1604a:	85 c0                	test   %eax,%eax
   1604c:	74 0e                	je     1605c <fatfs_open+0x94>
            file_item = item;
   1604e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16051:	89 45 f4             	mov    %eax,-0xc(%ebp)
            p_index = i;
   16054:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16057:	89 45 f0             	mov    %eax,-0x10(%ebp)
            break;
   1605a:	eb 11                	jmp    1606d <fatfs_open+0xa5>
    for (int i = 0; i < fat->root_ent_cnt; i++) {
   1605c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   16060:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16063:	8b 50 18             	mov    0x18(%eax),%edx
   16066:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16069:	39 c2                	cmp    %eax,%edx
   1606b:	77 84                	ja     15ff1 <fatfs_open+0x29>
        }
    }

    if (file_item) {
   1606d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   16071:	74 62                	je     160d5 <fatfs_open+0x10d>
        read_from_diritem(fat, file, file_item, p_index);
   16073:	ff 75 f0             	pushl  -0x10(%ebp)
   16076:	ff 75 f4             	pushl  -0xc(%ebp)
   16079:	ff 75 10             	pushl  0x10(%ebp)
   1607c:	ff 75 e8             	pushl  -0x18(%ebp)
   1607f:	e8 b6 fd ff ff       	call   15e3a <read_from_diritem>
   16084:	83 c4 10             	add    $0x10,%esp

        // 如果要截断，则清空
        if (file->mode & O_TRUNC) {
   16087:	8b 45 10             	mov    0x10(%ebp),%eax
   1608a:	8b 40 34             	mov    0x34(%eax),%eax
   1608d:	25 00 04 00 00       	and    $0x400,%eax
   16092:	85 c0                	test   %eax,%eax
   16094:	74 38                	je     160ce <fatfs_open+0x106>
            cluster_free_chain(fat, file->sblk);
   16096:	8b 45 10             	mov    0x10(%ebp),%eax
   16099:	8b 40 40             	mov    0x40(%eax),%eax
   1609c:	0f b7 c0             	movzwl %ax,%eax
   1609f:	83 ec 08             	sub    $0x8,%esp
   160a2:	50                   	push   %eax
   160a3:	ff 75 e8             	pushl  -0x18(%ebp)
   160a6:	e8 c9 f7 ff ff       	call   15874 <cluster_free_chain>
   160ab:	83 c4 10             	add    $0x10,%esp
            file->cblk = file->sblk = FAT_CLUSTER_INVALID;
   160ae:	8b 45 10             	mov    0x10(%ebp),%eax
   160b1:	c7 40 40 f8 ff 00 00 	movl   $0xfff8,0x40(%eax)
   160b8:	8b 45 10             	mov    0x10(%ebp),%eax
   160bb:	8b 50 40             	mov    0x40(%eax),%edx
   160be:	8b 45 10             	mov    0x10(%ebp),%eax
   160c1:	89 50 44             	mov    %edx,0x44(%eax)
            file->size = 0;
   160c4:	8b 45 10             	mov    0x10(%ebp),%eax
   160c7:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
        }
        return 0;
   160ce:	b8 00 00 00 00       	mov    $0x0,%eax
   160d3:	eb 7f                	jmp    16154 <fatfs_open+0x18c>
    } else if ((file->mode & O_CREAT) && (p_index >= 0)) {
   160d5:	8b 45 10             	mov    0x10(%ebp),%eax
   160d8:	8b 40 34             	mov    0x34(%eax),%eax
   160db:	25 00 02 00 00       	and    $0x200,%eax
   160e0:	85 c0                	test   %eax,%eax
   160e2:	74 6b                	je     1614f <fatfs_open+0x187>
   160e4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   160e8:	78 65                	js     1614f <fatfs_open+0x187>
        // 创建一个空闲的diritem项
        diritem_t item;
        diritem_init(&item, 0, path);
   160ea:	83 ec 04             	sub    $0x4,%esp
   160ed:	ff 75 0c             	pushl  0xc(%ebp)
   160f0:	6a 00                	push   $0x0
   160f2:	8d 45 c0             	lea    -0x40(%ebp),%eax
   160f5:	50                   	push   %eax
   160f6:	e8 a4 fd ff ff       	call   15e9f <diritem_init>
   160fb:	83 c4 10             	add    $0x10,%esp
        int err = write_dir_entry(fat, &item, p_index);
   160fe:	83 ec 04             	sub    $0x4,%esp
   16101:	ff 75 f0             	pushl  -0x10(%ebp)
   16104:	8d 45 c0             	lea    -0x40(%ebp),%eax
   16107:	50                   	push   %eax
   16108:	ff 75 e8             	pushl  -0x18(%ebp)
   1610b:	e8 0e fe ff ff       	call   15f1e <write_dir_entry>
   16110:	83 c4 10             	add    $0x10,%esp
   16113:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if (err < 0) {
   16116:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1611a:	79 17                	jns    16133 <fatfs_open+0x16b>
            log_printf("create file failed.");
   1611c:	83 ec 0c             	sub    $0xc,%esp
   1611f:	68 60 93 01 00       	push   $0x19360
   16124:	e8 a2 23 00 00       	call   184cb <log_printf>
   16129:	83 c4 10             	add    $0x10,%esp
            return -1;
   1612c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16131:	eb 21                	jmp    16154 <fatfs_open+0x18c>
        }

        read_from_diritem(fat, file, &item, p_index);
   16133:	ff 75 f0             	pushl  -0x10(%ebp)
   16136:	8d 45 c0             	lea    -0x40(%ebp),%eax
   16139:	50                   	push   %eax
   1613a:	ff 75 10             	pushl  0x10(%ebp)
   1613d:	ff 75 e8             	pushl  -0x18(%ebp)
   16140:	e8 f5 fc ff ff       	call   15e3a <read_from_diritem>
   16145:	83 c4 10             	add    $0x10,%esp
        return 0;
   16148:	b8 00 00 00 00       	mov    $0x0,%eax
   1614d:	eb 05                	jmp    16154 <fatfs_open+0x18c>
    }

    return -1;
   1614f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   16154:	c9                   	leave  
   16155:	c3                   	ret    

00016156 <move_file_pos>:
 * @param fat 文件系统数据结构
 * @param move_bytes 要移动的字节数
 * @param expand 是否扩展文件大小
 * @return 0 成功，-1 失败
 */
static int move_file_pos(file_t *file,fat_t *fat,uint32_t move_bytes,int expand){
   16156:	55                   	push   %ebp
   16157:	89 e5                	mov    %esp,%ebp
   16159:	83 ec 18             	sub    $0x18,%esp
   uint32_t c_offset = file->pos % fat->cluster_byte_size;
   1615c:	8b 45 08             	mov    0x8(%ebp),%eax
   1615f:	8b 40 30             	mov    0x30(%eax),%eax
   16162:	89 c2                	mov    %eax,%edx
   16164:	8b 45 0c             	mov    0xc(%ebp),%eax
   16167:	8b 48 20             	mov    0x20(%eax),%ecx
   1616a:	89 d0                	mov    %edx,%eax
   1616c:	ba 00 00 00 00       	mov    $0x0,%edx
   16171:	f7 f1                	div    %ecx
   16173:	89 55 f0             	mov    %edx,-0x10(%ebp)

    // 跨簇，则调整curr_cluster。注意，如果已经是最后一个簇了，则curr_cluster不会调整
	if (c_offset + move_bytes >= fat->cluster_byte_size) {
   16176:	8b 55 f0             	mov    -0x10(%ebp),%edx
   16179:	8b 45 10             	mov    0x10(%ebp),%eax
   1617c:	01 c2                	add    %eax,%edx
   1617e:	8b 45 0c             	mov    0xc(%ebp),%eax
   16181:	8b 40 20             	mov    0x20(%eax),%eax
   16184:	39 c2                	cmp    %eax,%edx
   16186:	72 74                	jb     161fc <move_file_pos+0xa6>
        cluster_t next = cluster_get_next(fat, file->cblk);
   16188:	8b 45 08             	mov    0x8(%ebp),%eax
   1618b:	8b 40 44             	mov    0x44(%eax),%eax
   1618e:	0f b7 c0             	movzwl %ax,%eax
   16191:	83 ec 08             	sub    $0x8,%esp
   16194:	50                   	push   %eax
   16195:	ff 75 0c             	pushl  0xc(%ebp)
   16198:	e8 79 f3 ff ff       	call   15516 <cluster_get_next>
   1619d:	83 c4 10             	add    $0x10,%esp
   161a0:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
		if ((next == FAT_CLUSTER_INVALID) && expand) {
   161a4:	66 83 7d f6 f8       	cmpw   $0xfff8,-0xa(%ebp)
   161a9:	75 47                	jne    161f2 <move_file_pos+0x9c>
   161ab:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   161af:	74 41                	je     161f2 <move_file_pos+0x9c>
            int err = expand_file(file, fat->cluster_byte_size);
   161b1:	8b 45 0c             	mov    0xc(%ebp),%eax
   161b4:	8b 40 20             	mov    0x20(%eax),%eax
   161b7:	83 ec 08             	sub    $0x8,%esp
   161ba:	50                   	push   %eax
   161bb:	ff 75 08             	pushl  0x8(%ebp)
   161be:	e8 38 f8 ff ff       	call   159fb <expand_file>
   161c3:	83 c4 10             	add    $0x10,%esp
   161c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (err < 0) {
   161c9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   161cd:	79 07                	jns    161d6 <move_file_pos+0x80>
                return -1;
   161cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   161d4:	eb 40                	jmp    16216 <move_file_pos+0xc0>
            }

            next = cluster_get_next(fat, file->cblk);
   161d6:	8b 45 08             	mov    0x8(%ebp),%eax
   161d9:	8b 40 44             	mov    0x44(%eax),%eax
   161dc:	0f b7 c0             	movzwl %ax,%eax
   161df:	83 ec 08             	sub    $0x8,%esp
   161e2:	50                   	push   %eax
   161e3:	ff 75 0c             	pushl  0xc(%ebp)
   161e6:	e8 2b f3 ff ff       	call   15516 <cluster_get_next>
   161eb:	83 c4 10             	add    $0x10,%esp
   161ee:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
        }

        file->cblk = next;
   161f2:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
   161f6:	8b 45 08             	mov    0x8(%ebp),%eax
   161f9:	89 50 44             	mov    %edx,0x44(%eax)
	}

	file->pos += move_bytes;
   161fc:	8b 45 08             	mov    0x8(%ebp),%eax
   161ff:	8b 40 30             	mov    0x30(%eax),%eax
   16202:	89 c2                	mov    %eax,%edx
   16204:	8b 45 10             	mov    0x10(%ebp),%eax
   16207:	01 d0                	add    %edx,%eax
   16209:	89 c2                	mov    %eax,%edx
   1620b:	8b 45 08             	mov    0x8(%ebp),%eax
   1620e:	89 50 30             	mov    %edx,0x30(%eax)
	return 0;
   16211:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16216:	c9                   	leave  
   16217:	c3                   	ret    

00016218 <fatfs_read>:

int fatfs_read(char *buf,int size,file_t *file){
   16218:	55                   	push   %ebp
   16219:	89 e5                	mov    %esp,%ebp
   1621b:	53                   	push   %ebx
   1621c:	83 ec 34             	sub    $0x34,%esp

    fat_t *fat=(fat_t*)file->fs->data;
   1621f:	8b 45 10             	mov    0x10(%ebp),%eax
   16222:	8b 40 38             	mov    0x38(%eax),%eax
   16225:	8b 80 08 02 00 00    	mov    0x208(%eax),%eax
   1622b:	89 45 e8             	mov    %eax,-0x18(%ebp)

    uint32_t nbytes=size;
   1622e:	8b 45 0c             	mov    0xc(%ebp),%eax
   16231:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(file->pos + nbytes > file->size){
   16234:	8b 45 10             	mov    0x10(%ebp),%eax
   16237:	8b 40 30             	mov    0x30(%eax),%eax
   1623a:	89 c2                	mov    %eax,%edx
   1623c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1623f:	01 c2                	add    %eax,%edx
   16241:	8b 45 10             	mov    0x10(%ebp),%eax
   16244:	8b 40 24             	mov    0x24(%eax),%eax
   16247:	39 c2                	cmp    %eax,%edx
   16249:	76 13                	jbe    1625e <fatfs_read+0x46>
        nbytes=file->size - file->pos;
   1624b:	8b 45 10             	mov    0x10(%ebp),%eax
   1624e:	8b 50 24             	mov    0x24(%eax),%edx
   16251:	8b 45 10             	mov    0x10(%ebp),%eax
   16254:	8b 40 30             	mov    0x30(%eax),%eax
   16257:	29 c2                	sub    %eax,%edx
   16259:	89 d0                	mov    %edx,%eax
   1625b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    uint32_t total_read=0;
   1625e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while(nbytes > 0){
   16265:	e9 35 01 00 00       	jmp    1639f <fatfs_read+0x187>
        uint32_t curr_read=nbytes;
   1626a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1626d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t cluster_offset=file->pos % fat->cluster_byte_size;
   16270:	8b 45 10             	mov    0x10(%ebp),%eax
   16273:	8b 40 30             	mov    0x30(%eax),%eax
   16276:	89 c2                	mov    %eax,%edx
   16278:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1627b:	8b 48 20             	mov    0x20(%eax),%ecx
   1627e:	89 d0                	mov    %edx,%eax
   16280:	ba 00 00 00 00       	mov    $0x0,%edx
   16285:	f7 f1                	div    %ecx
   16287:	89 55 e4             	mov    %edx,-0x1c(%ebp)

        // 簇号从2开始，同时注意disk的调用的dev_read的size是以扇区为的单位的
        uint32_t start_sector=fat->data_start+ (file->cblk - 2) * fat->sec_per_cluster;
   1628a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1628d:	8b 50 1c             	mov    0x1c(%eax),%edx
   16290:	8b 45 10             	mov    0x10(%ebp),%eax
   16293:	8b 40 44             	mov    0x44(%eax),%eax
   16296:	83 e8 02             	sub    $0x2,%eax
   16299:	89 c1                	mov    %eax,%ecx
   1629b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1629e:	8b 40 10             	mov    0x10(%eax),%eax
   162a1:	0f af c1             	imul   %ecx,%eax
   162a4:	01 d0                	add    %edx,%eax
   162a6:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if((cluster_offset ==0 ) && (nbytes == fat->cluster_byte_size)){
   162a9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   162ad:	75 4c                	jne    162fb <fatfs_read+0xe3>
   162af:	8b 45 e8             	mov    -0x18(%ebp),%eax
   162b2:	8b 40 20             	mov    0x20(%eax),%eax
   162b5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   162b8:	75 41                	jne    162fb <fatfs_read+0xe3>
            int err=dev_read(fat->fs->dev_id,start_sector,buf,fat->sec_per_cluster);
   162ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
   162bd:	8b 40 10             	mov    0x10(%eax),%eax
   162c0:	89 c1                	mov    %eax,%ecx
   162c2:	8b 55 e0             	mov    -0x20(%ebp),%edx
   162c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   162c8:	8b 40 24             	mov    0x24(%eax),%eax
   162cb:	8b 80 0c 02 00 00    	mov    0x20c(%eax),%eax
   162d1:	51                   	push   %ecx
   162d2:	ff 75 08             	pushl  0x8(%ebp)
   162d5:	52                   	push   %edx
   162d6:	50                   	push   %eax
   162d7:	e8 90 d9 ff ff       	call   13c6c <dev_read>
   162dc:	83 c4 10             	add    $0x10,%esp
   162df:	89 45 dc             	mov    %eax,-0x24(%ebp)

            if(err < 0){
   162e2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   162e6:	79 08                	jns    162f0 <fatfs_read+0xd8>
                return total_read;
   162e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   162eb:	e9 bc 00 00 00       	jmp    163ac <fatfs_read+0x194>
            }

            curr_read=fat->cluster_byte_size;
   162f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   162f3:	8b 40 20             	mov    0x20(%eax),%eax
   162f6:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if((cluster_offset ==0 ) && (nbytes == fat->cluster_byte_size)){
   162f9:	eb 71                	jmp    1636c <fatfs_read+0x154>
        }

        else{
            if(cluster_offset + curr_read > fat->cluster_byte_size){
   162fb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   162fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16301:	01 c2                	add    %eax,%edx
   16303:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16306:	8b 40 20             	mov    0x20(%eax),%eax
   16309:	39 c2                	cmp    %eax,%edx
   1630b:	76 0c                	jbe    16319 <fatfs_read+0x101>
                curr_read=fat->cluster_byte_size - cluster_offset;
   1630d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16310:	8b 40 20             	mov    0x20(%eax),%eax
   16313:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   16316:	89 45 ec             	mov    %eax,-0x14(%ebp)
            }

            fat->curr_sector=-1; // 重置当前扇区
   16319:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1631c:	c7 40 2c ff ff ff ff 	movl   $0xffffffff,0x2c(%eax)
            int err=dev_read(fat->fs->dev_id,start_sector,fat->fat_buff,fat->sec_per_cluster);
   16323:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16326:	8b 40 10             	mov    0x10(%eax),%eax
   16329:	89 c3                	mov    %eax,%ebx
   1632b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1632e:	8b 48 28             	mov    0x28(%eax),%ecx
   16331:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16334:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16337:	8b 40 24             	mov    0x24(%eax),%eax
   1633a:	8b 80 0c 02 00 00    	mov    0x20c(%eax),%eax
   16340:	53                   	push   %ebx
   16341:	51                   	push   %ecx
   16342:	52                   	push   %edx
   16343:	50                   	push   %eax
   16344:	e8 23 d9 ff ff       	call   13c6c <dev_read>
   16349:	83 c4 10             	add    $0x10,%esp
   1634c:	89 45 d8             	mov    %eax,-0x28(%ebp)

            kernel_memcpy(buf,fat->fat_buff+cluster_offset,curr_read);
   1634f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16352:	8b 50 28             	mov    0x28(%eax),%edx
   16355:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16358:	01 d0                	add    %edx,%eax
   1635a:	83 ec 04             	sub    $0x4,%esp
   1635d:	ff 75 ec             	pushl  -0x14(%ebp)
   16360:	50                   	push   %eax
   16361:	ff 75 08             	pushl  0x8(%ebp)
   16364:	e8 f0 1a 00 00       	call   17e59 <kernel_memcpy>
   16369:	83 c4 10             	add    $0x10,%esp
        }

        buf+=curr_read;
   1636c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1636f:	01 45 08             	add    %eax,0x8(%ebp)
        nbytes-=curr_read;
   16372:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16375:	29 45 f4             	sub    %eax,-0xc(%ebp)
        total_read+=curr_read;
   16378:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1637b:	01 45 f0             	add    %eax,-0x10(%ebp)

        int err=move_file_pos(file,fat,curr_read,0);
   1637e:	6a 00                	push   $0x0
   16380:	ff 75 ec             	pushl  -0x14(%ebp)
   16383:	ff 75 e8             	pushl  -0x18(%ebp)
   16386:	ff 75 10             	pushl  0x10(%ebp)
   16389:	e8 c8 fd ff ff       	call   16156 <move_file_pos>
   1638e:	83 c4 10             	add    $0x10,%esp
   16391:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        if(err < 0){
   16394:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   16398:	79 05                	jns    1639f <fatfs_read+0x187>
            return total_read;
   1639a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1639d:	eb 0d                	jmp    163ac <fatfs_read+0x194>
    while(nbytes > 0){
   1639f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   163a3:	0f 85 c1 fe ff ff    	jne    1626a <fatfs_read+0x52>
        }
    }

    return total_read;
   163a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   163ac:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   163af:	c9                   	leave  
   163b0:	c3                   	ret    

000163b1 <fatfs_write>:
 * @param buf 要写入的数据缓冲区
 * @param size 要写入的字节数
 * @param file 文件指针
 * @return 返回实际写入的字节数，如果出错则返回0
 */
int fatfs_write(char *buf,int size,file_t *file){
   163b1:	55                   	push   %ebp
   163b2:	89 e5                	mov    %esp,%ebp
   163b4:	53                   	push   %ebx
   163b5:	83 ec 34             	sub    $0x34,%esp
    fat_t * fat = (fat_t *)file->fs->data;
   163b8:	8b 45 10             	mov    0x10(%ebp),%eax
   163bb:	8b 40 38             	mov    0x38(%eax),%eax
   163be:	8b 80 08 02 00 00    	mov    0x208(%eax),%eax
   163c4:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // 如果文件大小不够，则先扩展文件大小
    if (file->pos + size > file->size) {
   163c7:	8b 45 10             	mov    0x10(%ebp),%eax
   163ca:	8b 50 30             	mov    0x30(%eax),%edx
   163cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   163d0:	01 d0                	add    %edx,%eax
   163d2:	89 c2                	mov    %eax,%edx
   163d4:	8b 45 10             	mov    0x10(%ebp),%eax
   163d7:	8b 40 24             	mov    0x24(%eax),%eax
   163da:	39 c2                	cmp    %eax,%edx
   163dc:	76 3e                	jbe    1641c <fatfs_write+0x6b>
        int inc_size = file->pos + size - file->size;
   163de:	8b 45 10             	mov    0x10(%ebp),%eax
   163e1:	8b 50 30             	mov    0x30(%eax),%edx
   163e4:	8b 45 0c             	mov    0xc(%ebp),%eax
   163e7:	01 d0                	add    %edx,%eax
   163e9:	89 c2                	mov    %eax,%edx
   163eb:	8b 45 10             	mov    0x10(%ebp),%eax
   163ee:	8b 40 24             	mov    0x24(%eax),%eax
   163f1:	29 c2                	sub    %eax,%edx
   163f3:	89 d0                	mov    %edx,%eax
   163f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int err = expand_file(file, inc_size);
   163f8:	83 ec 08             	sub    $0x8,%esp
   163fb:	ff 75 e4             	pushl  -0x1c(%ebp)
   163fe:	ff 75 10             	pushl  0x10(%ebp)
   16401:	e8 f5 f5 ff ff       	call   159fb <expand_file>
   16406:	83 c4 10             	add    $0x10,%esp
   16409:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if (err < 0) {
   1640c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   16410:	79 0a                	jns    1641c <fatfs_write+0x6b>
            return 0;
   16412:	b8 00 00 00 00       	mov    $0x0,%eax
   16417:	e9 ad 01 00 00       	jmp    165c9 <fatfs_write+0x218>
        }
    }

    uint32_t nbytes = size;
   1641c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1641f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t total_write = 0;
   16422:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	while (nbytes) {
   16429:	e9 8e 01 00 00       	jmp    165bc <fatfs_write+0x20b>
        // 每次写的数据量取决于当前簇中剩余的空间，以及size的量综合
        uint32_t curr_write = nbytes;
   1642e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16431:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32_t cluster_offset = file->pos % fat->cluster_byte_size;
   16434:	8b 45 10             	mov    0x10(%ebp),%eax
   16437:	8b 40 30             	mov    0x30(%eax),%eax
   1643a:	89 c2                	mov    %eax,%edx
   1643c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1643f:	8b 48 20             	mov    0x20(%eax),%ecx
   16442:	89 d0                	mov    %edx,%eax
   16444:	ba 00 00 00 00       	mov    $0x0,%edx
   16449:	f7 f1                	div    %ecx
   1644b:	89 55 dc             	mov    %edx,-0x24(%ebp)
        uint32_t start_sector = fat->data_start + (file->cblk - 2)* fat->sec_per_cluster;  // 从2开始
   1644e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16451:	8b 50 1c             	mov    0x1c(%eax),%edx
   16454:	8b 45 10             	mov    0x10(%ebp),%eax
   16457:	8b 40 44             	mov    0x44(%eax),%eax
   1645a:	83 e8 02             	sub    $0x2,%eax
   1645d:	89 c1                	mov    %eax,%ecx
   1645f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16462:	8b 40 10             	mov    0x10(%eax),%eax
   16465:	0f af c1             	imul   %ecx,%eax
   16468:	01 d0                	add    %edx,%eax
   1646a:	89 45 d8             	mov    %eax,-0x28(%ebp)

        // 如果是整簇, 写整簇
        if ((cluster_offset == 0) && (nbytes == fat->cluster_byte_size)) {
   1646d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   16471:	75 4f                	jne    164c2 <fatfs_write+0x111>
   16473:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16476:	8b 40 20             	mov    0x20(%eax),%eax
   16479:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   1647c:	75 44                	jne    164c2 <fatfs_write+0x111>
            int err = dev_write(fat->fs->dev_id, start_sector, buf, fat->sec_per_cluster);
   1647e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16481:	8b 40 10             	mov    0x10(%eax),%eax
   16484:	89 c1                	mov    %eax,%ecx
   16486:	8b 55 d8             	mov    -0x28(%ebp),%edx
   16489:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1648c:	8b 40 24             	mov    0x24(%eax),%eax
   1648f:	8b 80 0c 02 00 00    	mov    0x20c(%eax),%eax
   16495:	51                   	push   %ecx
   16496:	ff 75 08             	pushl  0x8(%ebp)
   16499:	52                   	push   %edx
   1649a:	50                   	push   %eax
   1649b:	e8 18 d8 ff ff       	call   13cb8 <dev_write>
   164a0:	83 c4 10             	add    $0x10,%esp
   164a3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            if (err < 0) {
   164a6:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   164aa:	79 08                	jns    164b4 <fatfs_write+0x103>
                return total_write;
   164ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
   164af:	e9 15 01 00 00       	jmp    165c9 <fatfs_write+0x218>
            }

            curr_write = fat->cluster_byte_size;
   164b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   164b7:	8b 40 20             	mov    0x20(%eax),%eax
   164ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if ((cluster_offset == 0) && (nbytes == fat->cluster_byte_size)) {
   164bd:	e9 b6 00 00 00       	jmp    16578 <fatfs_write+0x1c7>
        } else {
            // 如果跨簇，只写第一个簇内的一部分
            if (cluster_offset + curr_write > fat->cluster_byte_size) {
   164c2:	8b 55 dc             	mov    -0x24(%ebp),%edx
   164c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   164c8:	01 c2                	add    %eax,%edx
   164ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
   164cd:	8b 40 20             	mov    0x20(%eax),%eax
   164d0:	39 c2                	cmp    %eax,%edx
   164d2:	76 0c                	jbe    164e0 <fatfs_write+0x12f>
                curr_write = fat->cluster_byte_size - cluster_offset;
   164d4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   164d7:	8b 40 20             	mov    0x20(%eax),%eax
   164da:	2b 45 dc             	sub    -0x24(%ebp),%eax
   164dd:	89 45 ec             	mov    %eax,-0x14(%ebp)
            }

            fat->curr_sector = -1;
   164e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   164e3:	c7 40 2c ff ff ff ff 	movl   $0xffffffff,0x2c(%eax)
            int err = dev_read(fat->fs->dev_id, start_sector, fat->fat_buff, fat->sec_per_cluster);
   164ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
   164ed:	8b 40 10             	mov    0x10(%eax),%eax
   164f0:	89 c3                	mov    %eax,%ebx
   164f2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   164f5:	8b 48 28             	mov    0x28(%eax),%ecx
   164f8:	8b 55 d8             	mov    -0x28(%ebp),%edx
   164fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   164fe:	8b 40 24             	mov    0x24(%eax),%eax
   16501:	8b 80 0c 02 00 00    	mov    0x20c(%eax),%eax
   16507:	53                   	push   %ebx
   16508:	51                   	push   %ecx
   16509:	52                   	push   %edx
   1650a:	50                   	push   %eax
   1650b:	e8 5c d7 ff ff       	call   13c6c <dev_read>
   16510:	83 c4 10             	add    $0x10,%esp
   16513:	89 45 d0             	mov    %eax,-0x30(%ebp)
            if (err < 0) {
   16516:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   1651a:	79 08                	jns    16524 <fatfs_write+0x173>
                return total_write;
   1651c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1651f:	e9 a5 00 00 00       	jmp    165c9 <fatfs_write+0x218>
            }
            kernel_memcpy(fat->fat_buff + cluster_offset, buf, curr_write);        
   16524:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16527:	8b 50 28             	mov    0x28(%eax),%edx
   1652a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1652d:	01 d0                	add    %edx,%eax
   1652f:	83 ec 04             	sub    $0x4,%esp
   16532:	ff 75 ec             	pushl  -0x14(%ebp)
   16535:	ff 75 08             	pushl  0x8(%ebp)
   16538:	50                   	push   %eax
   16539:	e8 1b 19 00 00       	call   17e59 <kernel_memcpy>
   1653e:	83 c4 10             	add    $0x10,%esp
            
            // 写整个簇，然后从中拷贝
            err = dev_write(fat->fs->dev_id, start_sector, fat->fat_buff, fat->sec_per_cluster);
   16541:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16544:	8b 40 10             	mov    0x10(%eax),%eax
   16547:	89 c3                	mov    %eax,%ebx
   16549:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1654c:	8b 48 28             	mov    0x28(%eax),%ecx
   1654f:	8b 55 d8             	mov    -0x28(%ebp),%edx
   16552:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16555:	8b 40 24             	mov    0x24(%eax),%eax
   16558:	8b 80 0c 02 00 00    	mov    0x20c(%eax),%eax
   1655e:	53                   	push   %ebx
   1655f:	51                   	push   %ecx
   16560:	52                   	push   %edx
   16561:	50                   	push   %eax
   16562:	e8 51 d7 ff ff       	call   13cb8 <dev_write>
   16567:	83 c4 10             	add    $0x10,%esp
   1656a:	89 45 d0             	mov    %eax,-0x30(%ebp)
            if (err < 0) {
   1656d:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   16571:	79 05                	jns    16578 <fatfs_write+0x1c7>
                return total_write;
   16573:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16576:	eb 51                	jmp    165c9 <fatfs_write+0x218>
            }
        }

        buf += curr_write;
   16578:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1657b:	01 45 08             	add    %eax,0x8(%ebp)
        nbytes -= curr_write;
   1657e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16581:	29 45 f4             	sub    %eax,-0xc(%ebp)
        total_write += curr_write;
   16584:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16587:	01 45 f0             	add    %eax,-0x10(%ebp)
        file->size += curr_write;
   1658a:	8b 45 10             	mov    0x10(%ebp),%eax
   1658d:	8b 50 24             	mov    0x24(%eax),%edx
   16590:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16593:	01 c2                	add    %eax,%edx
   16595:	8b 45 10             	mov    0x10(%ebp),%eax
   16598:	89 50 24             	mov    %edx,0x24(%eax)

        // 前移文件指针
		int err = move_file_pos(file, fat, curr_write, 1);
   1659b:	6a 01                	push   $0x1
   1659d:	ff 75 ec             	pushl  -0x14(%ebp)
   165a0:	ff 75 e8             	pushl  -0x18(%ebp)
   165a3:	ff 75 10             	pushl  0x10(%ebp)
   165a6:	e8 ab fb ff ff       	call   16156 <move_file_pos>
   165ab:	83 c4 10             	add    $0x10,%esp
   165ae:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (err < 0) {
   165b1:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   165b5:	79 05                	jns    165bc <fatfs_write+0x20b>
            return total_write;
   165b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   165ba:	eb 0d                	jmp    165c9 <fatfs_write+0x218>
	while (nbytes) {
   165bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   165c0:	0f 85 68 fe ff ff    	jne    1642e <fatfs_write+0x7d>
        }
    }

    return total_write;
   165c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   165c9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   165cc:	c9                   	leave  
   165cd:	c3                   	ret    

000165ce <fatfs_close>:

void fatfs_close(file_t *file){
   165ce:	55                   	push   %ebp
   165cf:	89 e5                	mov    %esp,%ebp
   165d1:	83 ec 18             	sub    $0x18,%esp
    if(file->mode == O_RDONLY){
   165d4:	8b 45 08             	mov    0x8(%ebp),%eax
   165d7:	8b 40 34             	mov    0x34(%eax),%eax
   165da:	85 c0                	test   %eax,%eax
   165dc:	74 74                	je     16652 <fatfs_close+0x84>
        return;
    }

    fat_t *fat=(fat_t*)file->fs->data;
   165de:	8b 45 08             	mov    0x8(%ebp),%eax
   165e1:	8b 40 38             	mov    0x38(%eax),%eax
   165e4:	8b 80 08 02 00 00    	mov    0x208(%eax),%eax
   165ea:	89 45 f4             	mov    %eax,-0xc(%ebp)

    diritem_t *item=read_dir_entry(fat,file->p_index);
   165ed:	8b 45 08             	mov    0x8(%ebp),%eax
   165f0:	8b 40 3c             	mov    0x3c(%eax),%eax
   165f3:	83 ec 08             	sub    $0x8,%esp
   165f6:	50                   	push   %eax
   165f7:	ff 75 f4             	pushl  -0xc(%ebp)
   165fa:	e8 2e f0 ff ff       	call   1562d <read_dir_entry>
   165ff:	83 c4 10             	add    $0x10,%esp
   16602:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(item == (diritem_t*)0){
   16605:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   16609:	74 4a                	je     16655 <fatfs_close+0x87>
        return;
    }

    item->DIR_FileSize=file->size;
   1660b:	8b 45 08             	mov    0x8(%ebp),%eax
   1660e:	8b 50 24             	mov    0x24(%eax),%edx
   16611:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16614:	89 50 1c             	mov    %edx,0x1c(%eax)
    item->DIR_FstClusHI=(uint16_t)(file->sblk >> 16);
   16617:	8b 45 08             	mov    0x8(%ebp),%eax
   1661a:	8b 40 40             	mov    0x40(%eax),%eax
   1661d:	c1 f8 10             	sar    $0x10,%eax
   16620:	89 c2                	mov    %eax,%edx
   16622:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16625:	66 89 50 14          	mov    %dx,0x14(%eax)
    item->DIR_FstClusLO=(uint16_t)(file->sblk & 0xFFFF);
   16629:	8b 45 08             	mov    0x8(%ebp),%eax
   1662c:	8b 40 40             	mov    0x40(%eax),%eax
   1662f:	89 c2                	mov    %eax,%edx
   16631:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16634:	66 89 50 1a          	mov    %dx,0x1a(%eax)
    write_dir_entry(fat,item,file->p_index);
   16638:	8b 45 08             	mov    0x8(%ebp),%eax
   1663b:	8b 40 3c             	mov    0x3c(%eax),%eax
   1663e:	83 ec 04             	sub    $0x4,%esp
   16641:	50                   	push   %eax
   16642:	ff 75 f0             	pushl  -0x10(%ebp)
   16645:	ff 75 f4             	pushl  -0xc(%ebp)
   16648:	e8 d1 f8 ff ff       	call   15f1e <write_dir_entry>
   1664d:	83 c4 10             	add    $0x10,%esp
   16650:	eb 04                	jmp    16656 <fatfs_close+0x88>
        return;
   16652:	90                   	nop
   16653:	eb 01                	jmp    16656 <fatfs_close+0x88>
        return;
   16655:	90                   	nop

}
   16656:	c9                   	leave  
   16657:	c3                   	ret    

00016658 <fatfs_seek>:

int fatfs_seek(file_t *file,uint32_t offset,int dir){
   16658:	55                   	push   %ebp
   16659:	89 e5                	mov    %esp,%ebp
   1665b:	83 ec 28             	sub    $0x28,%esp
    if(dir!=0){
   1665e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   16662:	74 0a                	je     1666e <fatfs_seek+0x16>
        return -1;
   16664:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16669:	e9 c7 00 00 00       	jmp    16735 <fatfs_seek+0xdd>
    }
    
    fat_t *fat=(fat_t*)file->fs->data;
   1666e:	8b 45 08             	mov    0x8(%ebp),%eax
   16671:	8b 40 38             	mov    0x38(%eax),%eax
   16674:	8b 80 08 02 00 00    	mov    0x208(%eax),%eax
   1667a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    cluster_t current_cluster=file->cblk;
   1667d:	8b 45 08             	mov    0x8(%ebp),%eax
   16680:	8b 40 44             	mov    0x44(%eax),%eax
   16683:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

    uint32_t curr_pos=0;
   16687:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    uint32_t offset_to_move=offset;
   1668e:	8b 45 0c             	mov    0xc(%ebp),%eax
   16691:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while(offset_to_move){
   16694:	eb 7d                	jmp    16713 <fatfs_seek+0xbb>
        uint32_t c_offset=curr_pos % fat->cluster_byte_size;
   16696:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16699:	8b 48 20             	mov    0x20(%eax),%ecx
   1669c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1669f:	ba 00 00 00 00       	mov    $0x0,%edx
   166a4:	f7 f1                	div    %ecx
   166a6:	89 55 e4             	mov    %edx,-0x1c(%ebp)
        uint32_t curr_move=offset_to_move;
   166a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   166ac:	89 45 e0             	mov    %eax,-0x20(%ebp)

        if(c_offset + curr_move < fat->cluster_byte_size){
   166af:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   166b2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   166b5:	01 c2                	add    %eax,%edx
   166b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   166ba:	8b 40 20             	mov    0x20(%eax),%eax
   166bd:	39 c2                	cmp    %eax,%edx
   166bf:	73 08                	jae    166c9 <fatfs_seek+0x71>
            curr_pos+=curr_move;
   166c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   166c4:	01 45 f0             	add    %eax,-0x10(%ebp)
            break;
   166c7:	eb 54                	jmp    1671d <fatfs_seek+0xc5>
        }

        curr_move=fat->cluster_byte_size-c_offset;
   166c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   166cc:	8b 40 20             	mov    0x20(%eax),%eax
   166cf:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   166d2:	89 45 e0             	mov    %eax,-0x20(%ebp)
        curr_pos+=curr_move;
   166d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   166d8:	01 45 f0             	add    %eax,-0x10(%ebp)
        offset_to_move-=curr_move;
   166db:	8b 45 e0             	mov    -0x20(%ebp),%eax
   166de:	29 45 ec             	sub    %eax,-0x14(%ebp)

        current_cluster=cluster_get_next(fat,current_cluster);
   166e1:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   166e5:	83 ec 08             	sub    $0x8,%esp
   166e8:	50                   	push   %eax
   166e9:	ff 75 e8             	pushl  -0x18(%ebp)
   166ec:	e8 25 ee ff ff       	call   15516 <cluster_get_next>
   166f1:	83 c4 10             	add    $0x10,%esp
   166f4:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
        if(!cluster_is_valid(current_cluster)){
   166f8:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   166fc:	83 ec 0c             	sub    $0xc,%esp
   166ff:	50                   	push   %eax
   16700:	e8 8f ed ff ff       	call   15494 <cluster_is_valid>
   16705:	83 c4 10             	add    $0x10,%esp
   16708:	85 c0                	test   %eax,%eax
   1670a:	75 07                	jne    16713 <fatfs_seek+0xbb>
            return -1;
   1670c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16711:	eb 22                	jmp    16735 <fatfs_seek+0xdd>
    while(offset_to_move){
   16713:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   16717:	0f 85 79 ff ff ff    	jne    16696 <fatfs_seek+0x3e>
        }
    }

    file->pos=curr_pos;
   1671d:	8b 55 f0             	mov    -0x10(%ebp),%edx
   16720:	8b 45 08             	mov    0x8(%ebp),%eax
   16723:	89 50 30             	mov    %edx,0x30(%eax)
    file->cblk=current_cluster;
   16726:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
   1672a:	8b 45 08             	mov    0x8(%ebp),%eax
   1672d:	89 50 44             	mov    %edx,0x44(%eax)
    return 0;
   16730:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16735:	c9                   	leave  
   16736:	c3                   	ret    

00016737 <fatfs_stat>:

int fatfs_stat(file_t *file,struct stat *st){
   16737:	55                   	push   %ebp
   16738:	89 e5                	mov    %esp,%ebp
    return -1;
   1673a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   1673f:	5d                   	pop    %ebp
   16740:	c3                   	ret    

00016741 <fatfs_opendir>:

int fatfs_opendir(struct _fs_t *fs,const char *name,DIR *dir){
   16741:	55                   	push   %ebp
   16742:	89 e5                	mov    %esp,%ebp
    dir->index=0;
   16744:	8b 45 10             	mov    0x10(%ebp),%eax
   16747:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    return 0;
   1674d:	b8 00 00 00 00       	mov    $0x0,%eax

}
   16752:	5d                   	pop    %ebp
   16753:	c3                   	ret    

00016754 <fatfs_readdir>:

int fatfs_readdir(struct _fs_t *fs,DIR *dir,struct dirent *dirent){
   16754:	55                   	push   %ebp
   16755:	89 e5                	mov    %esp,%ebp
   16757:	83 ec 18             	sub    $0x18,%esp
    fat_t *fat=(fat_t*)fs->data;
   1675a:	8b 45 08             	mov    0x8(%ebp),%eax
   1675d:	8b 80 08 02 00 00    	mov    0x208(%eax),%eax
   16763:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while(dir->index < fat->root_ent_cnt){
   16766:	e9 b1 00 00 00       	jmp    1681c <fatfs_readdir+0xc8>
        diritem_t *item=read_dir_entry(fat,dir->index);
   1676b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1676e:	8b 00                	mov    (%eax),%eax
   16770:	83 ec 08             	sub    $0x8,%esp
   16773:	50                   	push   %eax
   16774:	ff 75 f4             	pushl  -0xc(%ebp)
   16777:	e8 b1 ee ff ff       	call   1562d <read_dir_entry>
   1677c:	83 c4 10             	add    $0x10,%esp
   1677f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(item == (diritem_t*)0){
   16782:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   16786:	75 0a                	jne    16792 <fatfs_readdir+0x3e>
            return -1;
   16788:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1678d:	e9 a7 00 00 00       	jmp    16839 <fatfs_readdir+0xe5>
        }

        if(item->DIR_Name[0] == DIRITEM_NAME_END){
   16792:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16795:	0f b6 00             	movzbl (%eax),%eax
   16798:	84 c0                	test   %al,%al
   1679a:	0f 84 93 00 00 00    	je     16833 <fatfs_readdir+0xdf>
            break;
        }

        if(item->DIR_Name[0] != DIRITEM_NAME_FREE){
   167a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   167a3:	0f b6 00             	movzbl (%eax),%eax
   167a6:	3c e5                	cmp    $0xe5,%al
   167a8:	74 65                	je     1680f <fatfs_readdir+0xbb>
            file_type_t type=diritem_get_type(item);
   167aa:	83 ec 0c             	sub    $0xc,%esp
   167ad:	ff 75 f0             	pushl  -0x10(%ebp)
   167b0:	e8 1f ee ff ff       	call   155d4 <diritem_get_type>
   167b5:	83 c4 10             	add    $0x10,%esp
   167b8:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if(type == FILE_NORMAL || type == FILE_DIR){
   167bb:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
   167bf:	74 06                	je     167c7 <fatfs_readdir+0x73>
   167c1:	83 7d ec 02          	cmpl   $0x2,-0x14(%ebp)
   167c5:	75 48                	jne    1680f <fatfs_readdir+0xbb>
                dirent->size=item->DIR_FileSize;
   167c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   167ca:	8b 40 1c             	mov    0x1c(%eax),%eax
   167cd:	89 c2                	mov    %eax,%edx
   167cf:	8b 45 10             	mov    0x10(%ebp),%eax
   167d2:	89 90 08 01 00 00    	mov    %edx,0x108(%eax)
                dirent->type=type;
   167d8:	8b 55 ec             	mov    -0x14(%ebp),%edx
   167db:	8b 45 10             	mov    0x10(%ebp),%eax
   167de:	89 50 04             	mov    %edx,0x4(%eax)
                diritem_get_name(item,dirent->name);
   167e1:	8b 45 10             	mov    0x10(%ebp),%eax
   167e4:	83 c0 08             	add    $0x8,%eax
   167e7:	83 ec 08             	sub    $0x8,%esp
   167ea:	50                   	push   %eax
   167eb:	ff 75 f0             	pushl  -0x10(%ebp)
   167ee:	e8 bf ee ff ff       	call   156b2 <diritem_get_name>
   167f3:	83 c4 10             	add    $0x10,%esp
                dirent->index=dir->index++;
   167f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   167f9:	8b 00                	mov    (%eax),%eax
   167fb:	8d 48 01             	lea    0x1(%eax),%ecx
   167fe:	8b 55 0c             	mov    0xc(%ebp),%edx
   16801:	89 0a                	mov    %ecx,(%edx)
   16803:	8b 55 10             	mov    0x10(%ebp),%edx
   16806:	89 02                	mov    %eax,(%edx)
                return 0;
   16808:	b8 00 00 00 00       	mov    $0x0,%eax
   1680d:	eb 2a                	jmp    16839 <fatfs_readdir+0xe5>
            }
        }

        dir->index++;
   1680f:	8b 45 0c             	mov    0xc(%ebp),%eax
   16812:	8b 00                	mov    (%eax),%eax
   16814:	8d 50 01             	lea    0x1(%eax),%edx
   16817:	8b 45 0c             	mov    0xc(%ebp),%eax
   1681a:	89 10                	mov    %edx,(%eax)
    while(dir->index < fat->root_ent_cnt){
   1681c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1681f:	8b 00                	mov    (%eax),%eax
   16821:	89 c2                	mov    %eax,%edx
   16823:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16826:	8b 40 18             	mov    0x18(%eax),%eax
   16829:	39 c2                	cmp    %eax,%edx
   1682b:	0f 82 3a ff ff ff    	jb     1676b <fatfs_readdir+0x17>
   16831:	eb 01                	jmp    16834 <fatfs_readdir+0xe0>
            break;
   16833:	90                   	nop
    }

    return -1;
   16834:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   16839:	c9                   	leave  
   1683a:	c3                   	ret    

0001683b <fatfs_closedir>:

int fatfs_closedir(struct _fs_t *fs,DIR *dir){
   1683b:	55                   	push   %ebp
   1683c:	89 e5                	mov    %esp,%ebp
    return 0;
   1683e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16843:	5d                   	pop    %ebp
   16844:	c3                   	ret    

00016845 <fatfs_unlink>:
/**
 * @brief 删除指定路径的文件或目录
 * @param fs 文件系统数据结构
 * @param path 要删除的文件或目录的路径
 */
int fatfs_unlink(struct _fs_t *fs,const char *path){
   16845:	55                   	push   %ebp
   16846:	89 e5                	mov    %esp,%ebp
   16848:	83 ec 18             	sub    $0x18,%esp
    fat_t *fat=(fat_t*)fs->data;
   1684b:	8b 45 08             	mov    0x8(%ebp),%eax
   1684e:	8b 80 08 02 00 00    	mov    0x208(%eax),%eax
   16854:	89 45 f0             	mov    %eax,-0x10(%ebp)

    for(int i=0;i<fat->root_ent_cnt;i++){
   16857:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1685e:	e9 b1 00 00 00       	jmp    16914 <fatfs_unlink+0xcf>
        diritem_t *item=read_dir_entry(fat,i);
   16863:	83 ec 08             	sub    $0x8,%esp
   16866:	ff 75 f4             	pushl  -0xc(%ebp)
   16869:	ff 75 f0             	pushl  -0x10(%ebp)
   1686c:	e8 bc ed ff ff       	call   1562d <read_dir_entry>
   16871:	83 c4 10             	add    $0x10,%esp
   16874:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(item == (diritem_t*)0){
   16877:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1687b:	75 0a                	jne    16887 <fatfs_unlink+0x42>
            return -1;
   1687d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16882:	e9 a6 00 00 00       	jmp    1692d <fatfs_unlink+0xe8>
        }

        if(item->DIR_Name[0] == DIRITEM_NAME_END){
   16887:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1688a:	0f b6 00             	movzbl (%eax),%eax
   1688d:	84 c0                	test   %al,%al
   1688f:	0f 84 92 00 00 00    	je     16927 <fatfs_unlink+0xe2>
            break;
        }

        if(item->DIR_Name[0] == DIRITEM_NAME_FREE){
   16895:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16898:	0f b6 00             	movzbl (%eax),%eax
   1689b:	3c e5                	cmp    $0xe5,%al
   1689d:	74 70                	je     1690f <fatfs_unlink+0xca>
            continue;
        }

        if(diritem_name_match(item,path)){
   1689f:	83 ec 08             	sub    $0x8,%esp
   168a2:	ff 75 0c             	pushl  0xc(%ebp)
   168a5:	ff 75 ec             	pushl  -0x14(%ebp)
   168a8:	e8 56 f5 ff ff       	call   15e03 <diritem_name_match>
   168ad:	83 c4 10             	add    $0x10,%esp
   168b0:	85 c0                	test   %eax,%eax
   168b2:	74 5c                	je     16910 <fatfs_unlink+0xcb>
            int cluster=(item ->DIR_FstClusHI << 16) | item->DIR_FstClusLO;
   168b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   168b7:	0f b7 40 14          	movzwl 0x14(%eax),%eax
   168bb:	0f b7 c0             	movzwl %ax,%eax
   168be:	c1 e0 10             	shl    $0x10,%eax
   168c1:	89 c2                	mov    %eax,%edx
   168c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   168c6:	0f b7 40 1a          	movzwl 0x1a(%eax),%eax
   168ca:	0f b7 c0             	movzwl %ax,%eax
   168cd:	09 d0                	or     %edx,%eax
   168cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
            cluster_free_chain(fat,cluster);
   168d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   168d5:	0f b7 c0             	movzwl %ax,%eax
   168d8:	83 ec 08             	sub    $0x8,%esp
   168db:	50                   	push   %eax
   168dc:	ff 75 f0             	pushl  -0x10(%ebp)
   168df:	e8 90 ef ff ff       	call   15874 <cluster_free_chain>
   168e4:	83 c4 10             	add    $0x10,%esp

            kernel_memset(item,0,sizeof(diritem_t));
   168e7:	83 ec 04             	sub    $0x4,%esp
   168ea:	6a 20                	push   $0x20
   168ec:	6a 00                	push   $0x0
   168ee:	ff 75 ec             	pushl  -0x14(%ebp)
   168f1:	e8 b2 15 00 00       	call   17ea8 <kernel_memset>
   168f6:	83 c4 10             	add    $0x10,%esp
            return write_dir_entry(fat,item,i);
   168f9:	83 ec 04             	sub    $0x4,%esp
   168fc:	ff 75 f4             	pushl  -0xc(%ebp)
   168ff:	ff 75 ec             	pushl  -0x14(%ebp)
   16902:	ff 75 f0             	pushl  -0x10(%ebp)
   16905:	e8 14 f6 ff ff       	call   15f1e <write_dir_entry>
   1690a:	83 c4 10             	add    $0x10,%esp
   1690d:	eb 1e                	jmp    1692d <fatfs_unlink+0xe8>
            continue;
   1690f:	90                   	nop
    for(int i=0;i<fat->root_ent_cnt;i++){
   16910:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   16914:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16917:	8b 50 18             	mov    0x18(%eax),%edx
   1691a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1691d:	39 c2                	cmp    %eax,%edx
   1691f:	0f 87 3e ff ff ff    	ja     16863 <fatfs_unlink+0x1e>
   16925:	eb 01                	jmp    16928 <fatfs_unlink+0xe3>
            break;
   16927:	90                   	nop
        }
    }

    return -1;
   16928:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   1692d:	c9                   	leave  
   1692e:	c3                   	ret    

0001692f <file_alloc>:
static file_t file_table[FILE_TABLE_SIZE]; 

/// @brief 文件互斥锁
static mutex_t file_alloc_mutex; 

file_t* file_alloc(void){
   1692f:	55                   	push   %ebp
   16930:	89 e5                	mov    %esp,%ebp
   16932:	83 ec 18             	sub    $0x18,%esp
    file_t* file=(file_t*)0;
   16935:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    mutex_lock(&file_alloc_mutex);
   1693c:	83 ec 0c             	sub    $0xc,%esp
   1693f:	68 c0 c8 05 00       	push   $0x5c8c0
   16944:	e8 95 0e 00 00       	call   177de <mutex_lock>
   16949:	83 c4 10             	add    $0x10,%esp

    for(int i=0;i<FILE_TABLE_SIZE;i++){
   1694c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   16953:	eb 47                	jmp    1699c <file_alloc+0x6d>
       file_t* p_file=file_table+i;
   16955:	8b 55 f0             	mov    -0x10(%ebp),%edx
   16958:	89 d0                	mov    %edx,%eax
   1695a:	c1 e0 03             	shl    $0x3,%eax
   1695d:	01 d0                	add    %edx,%eax
   1695f:	c1 e0 03             	shl    $0x3,%eax
   16962:	05 c0 88 03 00       	add    $0x388c0,%eax
   16967:	89 45 ec             	mov    %eax,-0x14(%ebp)
       if(p_file->ref==0){
   1696a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1696d:	8b 40 28             	mov    0x28(%eax),%eax
   16970:	85 c0                	test   %eax,%eax
   16972:	75 24                	jne    16998 <file_alloc+0x69>
           kernel_memset(p_file,0,sizeof(file_t));
   16974:	83 ec 04             	sub    $0x4,%esp
   16977:	6a 48                	push   $0x48
   16979:	6a 00                	push   $0x0
   1697b:	ff 75 ec             	pushl  -0x14(%ebp)
   1697e:	e8 25 15 00 00       	call   17ea8 <kernel_memset>
   16983:	83 c4 10             	add    $0x10,%esp
           p_file->ref=1;
   16986:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16989:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
           file=p_file;
   16990:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16993:	89 45 f4             	mov    %eax,-0xc(%ebp)
           break;
   16996:	eb 0d                	jmp    169a5 <file_alloc+0x76>
    for(int i=0;i<FILE_TABLE_SIZE;i++){
   16998:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1699c:	81 7d f0 ff 07 00 00 	cmpl   $0x7ff,-0x10(%ebp)
   169a3:	7e b0                	jle    16955 <file_alloc+0x26>
       }
    }

    mutex_unlock(&file_alloc_mutex);
   169a5:	83 ec 0c             	sub    $0xc,%esp
   169a8:	68 c0 c8 05 00       	push   $0x5c8c0
   169ad:	e8 bb 0e 00 00       	call   1786d <mutex_unlock>
   169b2:	83 c4 10             	add    $0x10,%esp
    return file;
   169b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   169b8:	c9                   	leave  
   169b9:	c3                   	ret    

000169ba <file_free>:

void file_free(file_t* file){
   169ba:	55                   	push   %ebp
   169bb:	89 e5                	mov    %esp,%ebp
   169bd:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&file_alloc_mutex);
   169c0:	83 ec 0c             	sub    $0xc,%esp
   169c3:	68 c0 c8 05 00       	push   $0x5c8c0
   169c8:	e8 11 0e 00 00       	call   177de <mutex_lock>
   169cd:	83 c4 10             	add    $0x10,%esp

    if(file->ref){
   169d0:	8b 45 08             	mov    0x8(%ebp),%eax
   169d3:	8b 40 28             	mov    0x28(%eax),%eax
   169d6:	85 c0                	test   %eax,%eax
   169d8:	74 0f                	je     169e9 <file_free+0x2f>
        file->ref--;
   169da:	8b 45 08             	mov    0x8(%ebp),%eax
   169dd:	8b 40 28             	mov    0x28(%eax),%eax
   169e0:	8d 50 ff             	lea    -0x1(%eax),%edx
   169e3:	8b 45 08             	mov    0x8(%ebp),%eax
   169e6:	89 50 28             	mov    %edx,0x28(%eax)
    }
    
    mutex_unlock(&file_alloc_mutex);
   169e9:	83 ec 0c             	sub    $0xc,%esp
   169ec:	68 c0 c8 05 00       	push   $0x5c8c0
   169f1:	e8 77 0e 00 00       	call   1786d <mutex_unlock>
   169f6:	83 c4 10             	add    $0x10,%esp
}
   169f9:	90                   	nop
   169fa:	c9                   	leave  
   169fb:	c3                   	ret    

000169fc <file_table_init>:

void file_table_init(void){
   169fc:	55                   	push   %ebp
   169fd:	89 e5                	mov    %esp,%ebp
   169ff:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&file_alloc_mutex);
   16a02:	83 ec 0c             	sub    $0xc,%esp
   16a05:	68 c0 c8 05 00       	push   $0x5c8c0
   16a0a:	e8 a1 0d 00 00       	call   177b0 <mutex_init>
   16a0f:	83 c4 10             	add    $0x10,%esp
    kernel_memset(file_table,0,sizeof(file_table));
   16a12:	83 ec 04             	sub    $0x4,%esp
   16a15:	68 00 40 02 00       	push   $0x24000
   16a1a:	6a 00                	push   $0x0
   16a1c:	68 c0 88 03 00       	push   $0x388c0
   16a21:	e8 82 14 00 00       	call   17ea8 <kernel_memset>
   16a26:	83 c4 10             	add    $0x10,%esp
}
   16a29:	90                   	nop
   16a2a:	c9                   	leave  
   16a2b:	c3                   	ret    

00016a2c <file_inc_ref>:

void file_inc_ref(file_t* file){
   16a2c:	55                   	push   %ebp
   16a2d:	89 e5                	mov    %esp,%ebp
   16a2f:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&file_alloc_mutex);
   16a32:	83 ec 0c             	sub    $0xc,%esp
   16a35:	68 c0 c8 05 00       	push   $0x5c8c0
   16a3a:	e8 9f 0d 00 00       	call   177de <mutex_lock>
   16a3f:	83 c4 10             	add    $0x10,%esp
    file->ref++;
   16a42:	8b 45 08             	mov    0x8(%ebp),%eax
   16a45:	8b 40 28             	mov    0x28(%eax),%eax
   16a48:	8d 50 01             	lea    0x1(%eax),%edx
   16a4b:	8b 45 08             	mov    0x8(%ebp),%eax
   16a4e:	89 50 28             	mov    %edx,0x28(%eax)
    mutex_unlock(&file_alloc_mutex);
   16a51:	83 ec 0c             	sub    $0xc,%esp
   16a54:	68 c0 c8 05 00       	push   $0x5c8c0
   16a59:	e8 0f 0e 00 00       	call   1786d <mutex_unlock>
   16a5e:	83 c4 10             	add    $0x10,%esp
   16a61:	90                   	nop
   16a62:	c9                   	leave  
   16a63:	c3                   	ret    

00016a64 <list_node_next>:
static inline list_node_t* list_node_next(list_node_t* node){
   16a64:	55                   	push   %ebp
   16a65:	89 e5                	mov    %esp,%ebp
    return node->next;
   16a67:	8b 45 08             	mov    0x8(%ebp),%eax
   16a6a:	8b 40 04             	mov    0x4(%eax),%eax
}
   16a6d:	5d                   	pop    %ebp
   16a6e:	c3                   	ret    

00016a6f <list_first>:
static inline list_node_t* list_first(list_t* list){
   16a6f:	55                   	push   %ebp
   16a70:	89 e5                	mov    %esp,%ebp
    return list->first;
   16a72:	8b 45 08             	mov    0x8(%ebp),%eax
   16a75:	8b 00                	mov    (%eax),%eax
}
   16a77:	5d                   	pop    %ebp
   16a78:	c3                   	ret    

00016a79 <is_fd_bad>:
/**
 * @brief 判断fd是否有效
 * @param fd 文件描述符
 * @return 1表示无效，0表示有效
 */
static int is_fd_bad(int fd){
   16a79:	55                   	push   %ebp
   16a7a:	89 e5                	mov    %esp,%ebp
    if((fd<0) || (fd>=TASK_OFILE_NR)){
   16a7c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   16a80:	78 06                	js     16a88 <is_fd_bad+0xf>
   16a82:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   16a86:	7e 07                	jle    16a8f <is_fd_bad+0x16>
        return 1;
   16a88:	b8 01 00 00 00       	mov    $0x1,%eax
   16a8d:	eb 05                	jmp    16a94 <is_fd_bad+0x1b>
    }

    return 0;
   16a8f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16a94:	5d                   	pop    %ebp
   16a95:	c3                   	ret    

00016a96 <path_to_num>:
 * @brief 将路径中字符数字转换为数字
 * @param path 路径
 * @param num 转换后的数字
 * @return 0表示成功，-1表示失败
 */
int path_to_num(const char* path, int* num){
   16a96:	55                   	push   %ebp
   16a97:	89 e5                	mov    %esp,%ebp
   16a99:	83 ec 10             	sub    $0x10,%esp
    int n=0;
   16a9c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    
    const char* c=path;
   16aa3:	8b 45 08             	mov    0x8(%ebp),%eax
   16aa6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(*c){
   16aa9:	eb 23                	jmp    16ace <path_to_num+0x38>
        n=n*10+*c-'0';
   16aab:	8b 55 fc             	mov    -0x4(%ebp),%edx
   16aae:	89 d0                	mov    %edx,%eax
   16ab0:	c1 e0 02             	shl    $0x2,%eax
   16ab3:	01 d0                	add    %edx,%eax
   16ab5:	01 c0                	add    %eax,%eax
   16ab7:	89 c2                	mov    %eax,%edx
   16ab9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16abc:	0f b6 00             	movzbl (%eax),%eax
   16abf:	0f be c0             	movsbl %al,%eax
   16ac2:	01 d0                	add    %edx,%eax
   16ac4:	83 e8 30             	sub    $0x30,%eax
   16ac7:	89 45 fc             	mov    %eax,-0x4(%ebp)
        c++;
   16aca:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while(*c){
   16ace:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16ad1:	0f b6 00             	movzbl (%eax),%eax
   16ad4:	84 c0                	test   %al,%al
   16ad6:	75 d3                	jne    16aab <path_to_num+0x15>
    }

    *num=n;
   16ad8:	8b 45 0c             	mov    0xc(%ebp),%eax
   16adb:	8b 55 fc             	mov    -0x4(%ebp),%edx
   16ade:	89 10                	mov    %edx,(%eax)
    return 0;
   16ae0:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16ae5:	c9                   	leave  
   16ae6:	c3                   	ret    

00016ae7 <path_next_child>:
/**
 * @brief 获取路径的下一个子路径
 * @param path 路径
 * @return 返回下一个子路径的指针
 */
const char* path_next_child(const char* path){
   16ae7:	55                   	push   %ebp
   16ae8:	89 e5                	mov    %esp,%ebp
   16aea:	83 ec 10             	sub    $0x10,%esp
    const char* c=path;
   16aed:	8b 45 08             	mov    0x8(%ebp),%eax
   16af0:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // /dev/tty
    while(*c && (*c++=='/')){}
   16af3:	90                   	nop
   16af4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16af7:	0f b6 00             	movzbl (%eax),%eax
   16afa:	84 c0                	test   %al,%al
   16afc:	74 10                	je     16b0e <path_next_child+0x27>
   16afe:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16b01:	8d 50 01             	lea    0x1(%eax),%edx
   16b04:	89 55 fc             	mov    %edx,-0x4(%ebp)
   16b07:	0f b6 00             	movzbl (%eax),%eax
   16b0a:	3c 2f                	cmp    $0x2f,%al
   16b0c:	74 e6                	je     16af4 <path_next_child+0xd>
    while(*c && (*c++!='/')){}
   16b0e:	90                   	nop
   16b0f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16b12:	0f b6 00             	movzbl (%eax),%eax
   16b15:	84 c0                	test   %al,%al
   16b17:	74 10                	je     16b29 <path_next_child+0x42>
   16b19:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16b1c:	8d 50 01             	lea    0x1(%eax),%edx
   16b1f:	89 55 fc             	mov    %edx,-0x4(%ebp)
   16b22:	0f b6 00             	movzbl (%eax),%eax
   16b25:	3c 2f                	cmp    $0x2f,%al
   16b27:	75 e6                	jne    16b0f <path_next_child+0x28>
    return *c ? c : (const char*)0;
   16b29:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16b2c:	0f b6 00             	movzbl (%eax),%eax
   16b2f:	84 c0                	test   %al,%al
   16b31:	74 05                	je     16b38 <path_next_child+0x51>
   16b33:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16b36:	eb 05                	jmp    16b3d <path_next_child+0x56>
   16b38:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16b3d:	c9                   	leave  
   16b3e:	c3                   	ret    

00016b3f <is_path_valid>:

static int is_path_valid(const char* path){
   16b3f:	55                   	push   %ebp
   16b40:	89 e5                	mov    %esp,%ebp
    if((path==(const char*)0) || (path[0]=='\0')){
   16b42:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   16b46:	74 0a                	je     16b52 <is_path_valid+0x13>
   16b48:	8b 45 08             	mov    0x8(%ebp),%eax
   16b4b:	0f b6 00             	movzbl (%eax),%eax
   16b4e:	84 c0                	test   %al,%al
   16b50:	75 07                	jne    16b59 <is_path_valid+0x1a>
        return 0;
   16b52:	b8 00 00 00 00       	mov    $0x0,%eax
   16b57:	eb 05                	jmp    16b5e <is_path_valid+0x1f>
    }

    return 1;
   16b59:	b8 01 00 00 00       	mov    $0x1,%eax
}
   16b5e:	5d                   	pop    %ebp
   16b5f:	c3                   	ret    

00016b60 <path_begin_with>:
 * @brief 判断路径是否以指定字符串开头
 * @param path 路径
 * @param str 指定字符串
 * @return 1表示是，0表示不是
 */
int path_begin_with(const char* path,const char* str){
   16b60:	55                   	push   %ebp
   16b61:	89 e5                	mov    %esp,%ebp
   16b63:	83 ec 10             	sub    $0x10,%esp
    const char* s1=path,*s2=str;
   16b66:	8b 45 08             	mov    0x8(%ebp),%eax
   16b69:	89 45 fc             	mov    %eax,-0x4(%ebp)
   16b6c:	8b 45 0c             	mov    0xc(%ebp),%eax
   16b6f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(*s1 && *s2 && (*s1==*s2)){
   16b72:	eb 08                	jmp    16b7c <path_begin_with+0x1c>
        s1++;
   16b74:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        s2++;
   16b78:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while(*s1 && *s2 && (*s1==*s2)){
   16b7c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16b7f:	0f b6 00             	movzbl (%eax),%eax
   16b82:	84 c0                	test   %al,%al
   16b84:	74 1a                	je     16ba0 <path_begin_with+0x40>
   16b86:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16b89:	0f b6 00             	movzbl (%eax),%eax
   16b8c:	84 c0                	test   %al,%al
   16b8e:	74 10                	je     16ba0 <path_begin_with+0x40>
   16b90:	8b 45 fc             	mov    -0x4(%ebp),%eax
   16b93:	0f b6 10             	movzbl (%eax),%edx
   16b96:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16b99:	0f b6 00             	movzbl (%eax),%eax
   16b9c:	38 c2                	cmp    %al,%dl
   16b9e:	74 d4                	je     16b74 <path_begin_with+0x14>
    }

    return *s2=='\0';
   16ba0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16ba3:	0f b6 00             	movzbl (%eax),%eax
   16ba6:	84 c0                	test   %al,%al
   16ba8:	0f 94 c0             	sete   %al
   16bab:	0f b6 c0             	movzbl %al,%eax
}
   16bae:	c9                   	leave  
   16baf:	c3                   	ret    

00016bb0 <fs_protect>:


static void fs_protect(fs_t* fs){
   16bb0:	55                   	push   %ebp
   16bb1:	89 e5                	mov    %esp,%ebp
   16bb3:	83 ec 08             	sub    $0x8,%esp
    if(fs->mutex){
   16bb6:	8b 45 08             	mov    0x8(%ebp),%eax
   16bb9:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
   16bbf:	85 c0                	test   %eax,%eax
   16bc1:	74 15                	je     16bd8 <fs_protect+0x28>
        mutex_lock(fs->mutex);
   16bc3:	8b 45 08             	mov    0x8(%ebp),%eax
   16bc6:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
   16bcc:	83 ec 0c             	sub    $0xc,%esp
   16bcf:	50                   	push   %eax
   16bd0:	e8 09 0c 00 00       	call   177de <mutex_lock>
   16bd5:	83 c4 10             	add    $0x10,%esp
    }
}
   16bd8:	90                   	nop
   16bd9:	c9                   	leave  
   16bda:	c3                   	ret    

00016bdb <fs_unprotect>:

static void fs_unprotect(fs_t* fs){
   16bdb:	55                   	push   %ebp
   16bdc:	89 e5                	mov    %esp,%ebp
   16bde:	83 ec 08             	sub    $0x8,%esp
    if(fs->mutex){
   16be1:	8b 45 08             	mov    0x8(%ebp),%eax
   16be4:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
   16bea:	85 c0                	test   %eax,%eax
   16bec:	74 15                	je     16c03 <fs_unprotect+0x28>
        mutex_unlock(fs->mutex);
   16bee:	8b 45 08             	mov    0x8(%ebp),%eax
   16bf1:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
   16bf7:	83 ec 0c             	sub    $0xc,%esp
   16bfa:	50                   	push   %eax
   16bfb:	e8 6d 0c 00 00       	call   1786d <mutex_unlock>
   16c00:	83 c4 10             	add    $0x10,%esp
    }
}
   16c03:	90                   	nop
   16c04:	c9                   	leave  
   16c05:	c3                   	ret    

00016c06 <sys_open>:

int sys_open(const char* name,int flags,...){
   16c06:	55                   	push   %ebp
   16c07:	89 e5                	mov    %esp,%ebp
   16c09:	83 ec 28             	sub    $0x28,%esp

    file_t* file=file_alloc();
   16c0c:	e8 1e fd ff ff       	call   1692f <file_alloc>
   16c11:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!file){
   16c14:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   16c18:	75 0a                	jne    16c24 <sys_open+0x1e>
        return -1;
   16c1a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16c1f:	e9 5d 01 00 00       	jmp    16d81 <sys_open+0x17b>
    }
    
    int fd=task_alloc_fd(file);
   16c24:	83 ec 0c             	sub    $0xc,%esp
   16c27:	ff 75 ec             	pushl  -0x14(%ebp)
   16c2a:	e8 55 b4 ff ff       	call   12084 <task_alloc_fd>
   16c2f:	83 c4 10             	add    $0x10,%esp
   16c32:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(fd<0){
   16c35:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   16c39:	0f 88 1a 01 00 00    	js     16d59 <sys_open+0x153>
        goto sys_open_failed;
    }

    fs_t* fs=(fs_t*)0;
   16c3f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    list_node_t* node=list_first(&mounted_list);
   16c46:	83 ec 0c             	sub    $0xc,%esp
   16c49:	68 e4 c8 05 00       	push   $0x5c8e4
   16c4e:	e8 1c fe ff ff       	call   16a6f <list_first>
   16c53:	83 c4 10             	add    $0x10,%esp
   16c56:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(node){
   16c59:	eb 47                	jmp    16ca2 <sys_open+0x9c>
        fs_t* curr=list_node_parent(node,fs_t,node);
   16c5b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   16c5f:	74 0a                	je     16c6b <sys_open+0x65>
   16c61:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16c64:	2d 10 02 00 00       	sub    $0x210,%eax
   16c69:	eb 05                	jmp    16c70 <sys_open+0x6a>
   16c6b:	b8 00 00 00 00       	mov    $0x0,%eax
   16c70:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(path_begin_with(name,curr->mount_point)){
   16c73:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16c76:	83 ec 08             	sub    $0x8,%esp
   16c79:	50                   	push   %eax
   16c7a:	ff 75 08             	pushl  0x8(%ebp)
   16c7d:	e8 de fe ff ff       	call   16b60 <path_begin_with>
   16c82:	83 c4 10             	add    $0x10,%esp
   16c85:	85 c0                	test   %eax,%eax
   16c87:	74 08                	je     16c91 <sys_open+0x8b>
            fs=curr;
   16c89:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16c8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
   16c8f:	eb 17                	jmp    16ca8 <sys_open+0xa2>
        }

        node=list_node_next(node);
   16c91:	83 ec 0c             	sub    $0xc,%esp
   16c94:	ff 75 f0             	pushl  -0x10(%ebp)
   16c97:	e8 c8 fd ff ff       	call   16a64 <list_node_next>
   16c9c:	83 c4 10             	add    $0x10,%esp
   16c9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(node){
   16ca2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   16ca6:	75 b3                	jne    16c5b <sys_open+0x55>
    }

    if(fs){
   16ca8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   16cac:	74 13                	je     16cc1 <sys_open+0xbb>
        name=path_next_child(name);
   16cae:	83 ec 0c             	sub    $0xc,%esp
   16cb1:	ff 75 08             	pushl  0x8(%ebp)
   16cb4:	e8 2e fe ff ff       	call   16ae7 <path_next_child>
   16cb9:	83 c4 10             	add    $0x10,%esp
   16cbc:	89 45 08             	mov    %eax,0x8(%ebp)
   16cbf:	eb 08                	jmp    16cc9 <sys_open+0xc3>
    }
    else{
        // 如果均不匹配使用根文件系统
        fs=root_fs;
   16cc1:	a1 e0 c8 05 00       	mov    0x5c8e0,%eax
   16cc6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    file->mode=flags;
   16cc9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16ccc:	8b 55 0c             	mov    0xc(%ebp),%edx
   16ccf:	89 50 34             	mov    %edx,0x34(%eax)
    file->fs=fs;
   16cd2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16cd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   16cd8:	89 50 38             	mov    %edx,0x38(%eax)

    kernel_strncpy(file->file_name,name,FILE_NAME_SIZE);
   16cdb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16cde:	83 ec 04             	sub    $0x4,%esp
   16ce1:	6a 20                	push   $0x20
   16ce3:	ff 75 08             	pushl  0x8(%ebp)
   16ce6:	50                   	push   %eax
   16ce7:	e8 48 10 00 00       	call   17d34 <kernel_strncpy>
   16cec:	83 c4 10             	add    $0x10,%esp

    fs_protect(fs);
   16cef:	83 ec 0c             	sub    $0xc,%esp
   16cf2:	ff 75 f4             	pushl  -0xc(%ebp)
   16cf5:	e8 b6 fe ff ff       	call   16bb0 <fs_protect>
   16cfa:	83 c4 10             	add    $0x10,%esp
    int err=fs->op->open(fs,name,file);
   16cfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16d00:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   16d06:	8b 40 08             	mov    0x8(%eax),%eax
   16d09:	83 ec 04             	sub    $0x4,%esp
   16d0c:	ff 75 ec             	pushl  -0x14(%ebp)
   16d0f:	ff 75 08             	pushl  0x8(%ebp)
   16d12:	ff 75 f4             	pushl  -0xc(%ebp)
   16d15:	ff d0                	call   *%eax
   16d17:	83 c4 10             	add    $0x10,%esp
   16d1a:	89 45 e0             	mov    %eax,-0x20(%ebp)


    if(err<0){
   16d1d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   16d21:	79 23                	jns    16d46 <sys_open+0x140>
        fs_unprotect(fs);
   16d23:	83 ec 0c             	sub    $0xc,%esp
   16d26:	ff 75 f4             	pushl  -0xc(%ebp)
   16d29:	e8 ad fe ff ff       	call   16bdb <fs_unprotect>
   16d2e:	83 c4 10             	add    $0x10,%esp
        log_printf("open %s failed",name);
   16d31:	83 ec 08             	sub    $0x8,%esp
   16d34:	ff 75 08             	pushl  0x8(%ebp)
   16d37:	68 74 93 01 00       	push   $0x19374
   16d3c:	e8 8a 17 00 00       	call   184cb <log_printf>
   16d41:	83 c4 10             	add    $0x10,%esp
        goto sys_open_failed;
   16d44:	eb 14                	jmp    16d5a <sys_open+0x154>
    }
    fs_unprotect(fs);
   16d46:	83 ec 0c             	sub    $0xc,%esp
   16d49:	ff 75 f4             	pushl  -0xc(%ebp)
   16d4c:	e8 8a fe ff ff       	call   16bdb <fs_unprotect>
   16d51:	83 c4 10             	add    $0x10,%esp

    return fd;
   16d54:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16d57:	eb 28                	jmp    16d81 <sys_open+0x17b>
        goto sys_open_failed;
   16d59:	90                   	nop
   
sys_open_failed: 
    file_free(file);
   16d5a:	83 ec 0c             	sub    $0xc,%esp
   16d5d:	ff 75 ec             	pushl  -0x14(%ebp)
   16d60:	e8 55 fc ff ff       	call   169ba <file_free>
   16d65:	83 c4 10             	add    $0x10,%esp
    if(fd>=0){
   16d68:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   16d6c:	78 0e                	js     16d7c <sys_open+0x176>
        task_remove_fd(fd);
   16d6e:	83 ec 0c             	sub    $0xc,%esp
   16d71:	ff 75 e8             	pushl  -0x18(%ebp)
   16d74:	e8 5c b3 ff ff       	call   120d5 <task_remove_fd>
   16d79:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   16d7c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   16d81:	c9                   	leave  
   16d82:	c3                   	ret    

00016d83 <sys_read>:
 * @param file 文件描述符
 * @param ptr 读取到的内容存放的地址,这里的ptr会在调用例如get函数时传入，表示读取到的内容存放的地址
 * @param len 读取的长度
 * @return 读取的长度，失败返回-1
*/
int sys_read(int file,char* ptr,int len){
   16d83:	55                   	push   %ebp
   16d84:	89 e5                	mov    %esp,%ebp
   16d86:	83 ec 18             	sub    $0x18,%esp
    if(is_fd_bad(file) || !ptr || len <= 0){
   16d89:	ff 75 08             	pushl  0x8(%ebp)
   16d8c:	e8 e8 fc ff ff       	call   16a79 <is_fd_bad>
   16d91:	83 c4 04             	add    $0x4,%esp
   16d94:	85 c0                	test   %eax,%eax
   16d96:	75 0c                	jne    16da4 <sys_read+0x21>
   16d98:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   16d9c:	74 06                	je     16da4 <sys_read+0x21>
   16d9e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   16da2:	7f 0a                	jg     16dae <sys_read+0x2b>
        return 0;
   16da4:	b8 00 00 00 00       	mov    $0x0,%eax
   16da9:	e9 98 00 00 00       	jmp    16e46 <sys_read+0xc3>
    }

        
    file_t* p_file=task_file(file);
   16dae:	83 ec 0c             	sub    $0xc,%esp
   16db1:	ff 75 08             	pushl  0x8(%ebp)
   16db4:	e8 9a b2 ff ff       	call   12053 <task_file>
   16db9:	83 c4 10             	add    $0x10,%esp
   16dbc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!p_file){
   16dbf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   16dc3:	75 17                	jne    16ddc <sys_read+0x59>
        log_printf("file not opened");
   16dc5:	83 ec 0c             	sub    $0xc,%esp
   16dc8:	68 83 93 01 00       	push   $0x19383
   16dcd:	e8 f9 16 00 00       	call   184cb <log_printf>
   16dd2:	83 c4 10             	add    $0x10,%esp
        return -1;
   16dd5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16dda:	eb 6a                	jmp    16e46 <sys_read+0xc3>
    }

    if(p_file->mode == O_WRONLY){
   16ddc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16ddf:	8b 40 34             	mov    0x34(%eax),%eax
   16de2:	83 f8 01             	cmp    $0x1,%eax
   16de5:	75 17                	jne    16dfe <sys_read+0x7b>
        log_printf("file is write only");
   16de7:	83 ec 0c             	sub    $0xc,%esp
   16dea:	68 93 93 01 00       	push   $0x19393
   16def:	e8 d7 16 00 00       	call   184cb <log_printf>
   16df4:	83 c4 10             	add    $0x10,%esp
        return -1;
   16df7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16dfc:	eb 48                	jmp    16e46 <sys_read+0xc3>
    }


    fs_t* fs=p_file->fs;
   16dfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16e01:	8b 40 38             	mov    0x38(%eax),%eax
   16e04:	89 45 f0             	mov    %eax,-0x10(%ebp)

    fs_protect(fs);
   16e07:	83 ec 0c             	sub    $0xc,%esp
   16e0a:	ff 75 f0             	pushl  -0x10(%ebp)
   16e0d:	e8 9e fd ff ff       	call   16bb0 <fs_protect>
   16e12:	83 c4 10             	add    $0x10,%esp
    int err=fs->op->read(ptr,len,p_file);
   16e15:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16e18:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   16e1e:	8b 40 0c             	mov    0xc(%eax),%eax
   16e21:	83 ec 04             	sub    $0x4,%esp
   16e24:	ff 75 f4             	pushl  -0xc(%ebp)
   16e27:	ff 75 10             	pushl  0x10(%ebp)
   16e2a:	ff 75 0c             	pushl  0xc(%ebp)
   16e2d:	ff d0                	call   *%eax
   16e2f:	83 c4 10             	add    $0x10,%esp
   16e32:	89 45 ec             	mov    %eax,-0x14(%ebp)
    fs_unprotect(fs);
   16e35:	83 ec 0c             	sub    $0xc,%esp
   16e38:	ff 75 f0             	pushl  -0x10(%ebp)
   16e3b:	e8 9b fd ff ff       	call   16bdb <fs_unprotect>
   16e40:	83 c4 10             	add    $0x10,%esp

    return err;
   16e43:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
   16e46:	c9                   	leave  
   16e47:	c3                   	ret    

00016e48 <sys_write>:


int sys_write(int fd,char* ptr,int len){
   16e48:	55                   	push   %ebp
   16e49:	89 e5                	mov    %esp,%ebp
   16e4b:	83 ec 18             	sub    $0x18,%esp
    if(is_fd_bad(fd) || !ptr || len <= 0){
   16e4e:	ff 75 08             	pushl  0x8(%ebp)
   16e51:	e8 23 fc ff ff       	call   16a79 <is_fd_bad>
   16e56:	83 c4 04             	add    $0x4,%esp
   16e59:	85 c0                	test   %eax,%eax
   16e5b:	75 0c                	jne    16e69 <sys_write+0x21>
   16e5d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   16e61:	74 06                	je     16e69 <sys_write+0x21>
   16e63:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   16e67:	7f 0a                	jg     16e73 <sys_write+0x2b>
        return 0;
   16e69:	b8 00 00 00 00       	mov    $0x0,%eax
   16e6e:	e9 97 00 00 00       	jmp    16f0a <sys_write+0xc2>
    }

    file_t* p_file=task_file(fd);
   16e73:	83 ec 0c             	sub    $0xc,%esp
   16e76:	ff 75 08             	pushl  0x8(%ebp)
   16e79:	e8 d5 b1 ff ff       	call   12053 <task_file>
   16e7e:	83 c4 10             	add    $0x10,%esp
   16e81:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!p_file){
   16e84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   16e88:	75 17                	jne    16ea1 <sys_write+0x59>
        log_printf("file not opened");
   16e8a:	83 ec 0c             	sub    $0xc,%esp
   16e8d:	68 83 93 01 00       	push   $0x19383
   16e92:	e8 34 16 00 00       	call   184cb <log_printf>
   16e97:	83 c4 10             	add    $0x10,%esp
        return -1;
   16e9a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16e9f:	eb 69                	jmp    16f0a <sys_write+0xc2>
    }

    if(p_file->mode == O_RDONLY){
   16ea1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16ea4:	8b 40 34             	mov    0x34(%eax),%eax
   16ea7:	85 c0                	test   %eax,%eax
   16ea9:	75 17                	jne    16ec2 <sys_write+0x7a>
        log_printf("file is read only");
   16eab:	83 ec 0c             	sub    $0xc,%esp
   16eae:	68 a6 93 01 00       	push   $0x193a6
   16eb3:	e8 13 16 00 00       	call   184cb <log_printf>
   16eb8:	83 c4 10             	add    $0x10,%esp
        return -1;
   16ebb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16ec0:	eb 48                	jmp    16f0a <sys_write+0xc2>
    }

    fs_t* fs=p_file->fs;
   16ec2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16ec5:	8b 40 38             	mov    0x38(%eax),%eax
   16ec8:	89 45 f0             	mov    %eax,-0x10(%ebp)

    fs_protect(fs);
   16ecb:	83 ec 0c             	sub    $0xc,%esp
   16ece:	ff 75 f0             	pushl  -0x10(%ebp)
   16ed1:	e8 da fc ff ff       	call   16bb0 <fs_protect>
   16ed6:	83 c4 10             	add    $0x10,%esp
    int err=fs->op->write(ptr,len,p_file);
   16ed9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16edc:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   16ee2:	8b 40 10             	mov    0x10(%eax),%eax
   16ee5:	83 ec 04             	sub    $0x4,%esp
   16ee8:	ff 75 f4             	pushl  -0xc(%ebp)
   16eeb:	ff 75 10             	pushl  0x10(%ebp)
   16eee:	ff 75 0c             	pushl  0xc(%ebp)
   16ef1:	ff d0                	call   *%eax
   16ef3:	83 c4 10             	add    $0x10,%esp
   16ef6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    fs_unprotect(fs);
   16ef9:	83 ec 0c             	sub    $0xc,%esp
   16efc:	ff 75 f0             	pushl  -0x10(%ebp)
   16eff:	e8 d7 fc ff ff       	call   16bdb <fs_unprotect>
   16f04:	83 c4 10             	add    $0x10,%esp

    return err;
   16f07:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
   16f0a:	c9                   	leave  
   16f0b:	c3                   	ret    

00016f0c <sys_lseek>:

int sys_lseek(int file,int ptr,int dir){
   16f0c:	55                   	push   %ebp
   16f0d:	89 e5                	mov    %esp,%ebp
   16f0f:	83 ec 18             	sub    $0x18,%esp
    if(is_fd_bad(file)){
   16f12:	ff 75 08             	pushl  0x8(%ebp)
   16f15:	e8 5f fb ff ff       	call   16a79 <is_fd_bad>
   16f1a:	83 c4 04             	add    $0x4,%esp
   16f1d:	85 c0                	test   %eax,%eax
   16f1f:	74 07                	je     16f28 <sys_lseek+0x1c>
        return 0;
   16f21:	b8 00 00 00 00       	mov    $0x0,%eax
   16f26:	eb 77                	jmp    16f9f <sys_lseek+0x93>
    }

    file_t* p_file=task_file(file);
   16f28:	83 ec 0c             	sub    $0xc,%esp
   16f2b:	ff 75 08             	pushl  0x8(%ebp)
   16f2e:	e8 20 b1 ff ff       	call   12053 <task_file>
   16f33:	83 c4 10             	add    $0x10,%esp
   16f36:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!p_file){
   16f39:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   16f3d:	75 17                	jne    16f56 <sys_lseek+0x4a>
        log_printf("file not opened");
   16f3f:	83 ec 0c             	sub    $0xc,%esp
   16f42:	68 83 93 01 00       	push   $0x19383
   16f47:	e8 7f 15 00 00       	call   184cb <log_printf>
   16f4c:	83 c4 10             	add    $0x10,%esp
        return -1;
   16f4f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16f54:	eb 49                	jmp    16f9f <sys_lseek+0x93>
    }

    fs_t* fs=p_file->fs;
   16f56:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16f59:	8b 40 38             	mov    0x38(%eax),%eax
   16f5c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fs_protect(fs);
   16f5f:	83 ec 0c             	sub    $0xc,%esp
   16f62:	ff 75 f0             	pushl  -0x10(%ebp)
   16f65:	e8 46 fc ff ff       	call   16bb0 <fs_protect>
   16f6a:	83 c4 10             	add    $0x10,%esp
    int err=fs->op->seek(p_file,ptr,dir);
   16f6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16f70:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   16f76:	8b 40 18             	mov    0x18(%eax),%eax
   16f79:	8b 55 0c             	mov    0xc(%ebp),%edx
   16f7c:	83 ec 04             	sub    $0x4,%esp
   16f7f:	ff 75 10             	pushl  0x10(%ebp)
   16f82:	52                   	push   %edx
   16f83:	ff 75 f4             	pushl  -0xc(%ebp)
   16f86:	ff d0                	call   *%eax
   16f88:	83 c4 10             	add    $0x10,%esp
   16f8b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    fs_unprotect(fs);
   16f8e:	83 ec 0c             	sub    $0xc,%esp
   16f91:	ff 75 f0             	pushl  -0x10(%ebp)
   16f94:	e8 42 fc ff ff       	call   16bdb <fs_unprotect>
   16f99:	83 c4 10             	add    $0x10,%esp

    return err;
   16f9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
}   
   16f9f:	c9                   	leave  
   16fa0:	c3                   	ret    

00016fa1 <sys_close>:

int sys_close(int file){
   16fa1:	55                   	push   %ebp
   16fa2:	89 e5                	mov    %esp,%ebp
   16fa4:	83 ec 18             	sub    $0x18,%esp
    if(is_fd_bad(file)){
   16fa7:	ff 75 08             	pushl  0x8(%ebp)
   16faa:	e8 ca fa ff ff       	call   16a79 <is_fd_bad>
   16faf:	83 c4 04             	add    $0x4,%esp
   16fb2:	85 c0                	test   %eax,%eax
   16fb4:	74 1a                	je     16fd0 <sys_close+0x2f>
        log_printf("file error");
   16fb6:	83 ec 0c             	sub    $0xc,%esp
   16fb9:	68 b8 93 01 00       	push   $0x193b8
   16fbe:	e8 08 15 00 00       	call   184cb <log_printf>
   16fc3:	83 c4 10             	add    $0x10,%esp
        return -1;
   16fc6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16fcb:	e9 c8 00 00 00       	jmp    17098 <sys_close+0xf7>
    }

    file_t* p_file=task_file(file);
   16fd0:	83 ec 0c             	sub    $0xc,%esp
   16fd3:	ff 75 08             	pushl  0x8(%ebp)
   16fd6:	e8 78 b0 ff ff       	call   12053 <task_file>
   16fdb:	83 c4 10             	add    $0x10,%esp
   16fde:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!p_file){
   16fe1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   16fe5:	75 1a                	jne    17001 <sys_close+0x60>
        log_printf("file not opened");
   16fe7:	83 ec 0c             	sub    $0xc,%esp
   16fea:	68 83 93 01 00       	push   $0x19383
   16fef:	e8 d7 14 00 00       	call   184cb <log_printf>
   16ff4:	83 c4 10             	add    $0x10,%esp
        return -1;
   16ff7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16ffc:	e9 97 00 00 00       	jmp    17098 <sys_close+0xf7>
    }
    ASSERT(p_file->ref>0);
   17001:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17004:	8b 40 28             	mov    0x28(%eax),%eax
   17007:	85 c0                	test   %eax,%eax
   17009:	7f 1c                	jg     17027 <sys_close+0x86>
   1700b:	68 c3 93 01 00       	push   $0x193c3
   17010:	68 ec 94 01 00       	push   $0x194ec
   17015:	68 08 01 00 00       	push   $0x108
   1701a:	68 d4 93 01 00       	push   $0x193d4
   1701f:	e8 d7 11 00 00       	call   181fb <panic>
   17024:	83 c4 10             	add    $0x10,%esp

    fs_t* fs=p_file->fs;
   17027:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1702a:	8b 40 38             	mov    0x38(%eax),%eax
   1702d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(p_file->ref--==1){
   17030:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17033:	8b 40 28             	mov    0x28(%eax),%eax
   17036:	8d 48 ff             	lea    -0x1(%eax),%ecx
   17039:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1703c:	89 4a 28             	mov    %ecx,0x28(%edx)
   1703f:	83 f8 01             	cmp    $0x1,%eax
   17042:	75 41                	jne    17085 <sys_close+0xe4>
        fs_protect(fs);
   17044:	83 ec 0c             	sub    $0xc,%esp
   17047:	ff 75 f0             	pushl  -0x10(%ebp)
   1704a:	e8 61 fb ff ff       	call   16bb0 <fs_protect>
   1704f:	83 c4 10             	add    $0x10,%esp
        fs->op->close(p_file);
   17052:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17055:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   1705b:	8b 40 14             	mov    0x14(%eax),%eax
   1705e:	83 ec 0c             	sub    $0xc,%esp
   17061:	ff 75 f4             	pushl  -0xc(%ebp)
   17064:	ff d0                	call   *%eax
   17066:	83 c4 10             	add    $0x10,%esp
        fs_unprotect(fs);
   17069:	83 ec 0c             	sub    $0xc,%esp
   1706c:	ff 75 f0             	pushl  -0x10(%ebp)
   1706f:	e8 67 fb ff ff       	call   16bdb <fs_unprotect>
   17074:	83 c4 10             	add    $0x10,%esp

        file_free(p_file);
   17077:	83 ec 0c             	sub    $0xc,%esp
   1707a:	ff 75 f4             	pushl  -0xc(%ebp)
   1707d:	e8 38 f9 ff ff       	call   169ba <file_free>
   17082:	83 c4 10             	add    $0x10,%esp
        
    }

    task_remove_fd(file);
   17085:	83 ec 0c             	sub    $0xc,%esp
   17088:	ff 75 08             	pushl  0x8(%ebp)
   1708b:	e8 45 b0 ff ff       	call   120d5 <task_remove_fd>
   17090:	83 c4 10             	add    $0x10,%esp


    return 0;
   17093:	b8 00 00 00 00       	mov    $0x0,%eax


}
   17098:	c9                   	leave  
   17099:	c3                   	ret    

0001709a <sys_isatty>:

int sys_isatty(int file){
   1709a:	55                   	push   %ebp
   1709b:	89 e5                	mov    %esp,%ebp
   1709d:	83 ec 18             	sub    $0x18,%esp
    if(is_fd_bad(file)){
   170a0:	ff 75 08             	pushl  0x8(%ebp)
   170a3:	e8 d1 f9 ff ff       	call   16a79 <is_fd_bad>
   170a8:	83 c4 04             	add    $0x4,%esp
   170ab:	85 c0                	test   %eax,%eax
   170ad:	74 07                	je     170b6 <sys_isatty+0x1c>
        return 0;
   170af:	b8 00 00 00 00       	mov    $0x0,%eax
   170b4:	eb 3d                	jmp    170f3 <sys_isatty+0x59>
    }

    file_t* p_file=task_file(file);
   170b6:	83 ec 0c             	sub    $0xc,%esp
   170b9:	ff 75 08             	pushl  0x8(%ebp)
   170bc:	e8 92 af ff ff       	call   12053 <task_file>
   170c1:	83 c4 10             	add    $0x10,%esp
   170c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!p_file){
   170c7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   170cb:	75 17                	jne    170e4 <sys_isatty+0x4a>
        log_printf("file not opened");
   170cd:	83 ec 0c             	sub    $0xc,%esp
   170d0:	68 83 93 01 00       	push   $0x19383
   170d5:	e8 f1 13 00 00       	call   184cb <log_printf>
   170da:	83 c4 10             	add    $0x10,%esp
        return -1;
   170dd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   170e2:	eb 0f                	jmp    170f3 <sys_isatty+0x59>
    }

    return p_file->type==FILE_TYPE_TTY;
   170e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   170e7:	8b 40 20             	mov    0x20(%eax),%eax
   170ea:	83 f8 01             	cmp    $0x1,%eax
   170ed:	0f 94 c0             	sete   %al
   170f0:	0f b6 c0             	movzbl %al,%eax
    
}
   170f3:	c9                   	leave  
   170f4:	c3                   	ret    

000170f5 <sys_fstat>:

int sys_fstat(int file,struct stat* st){
   170f5:	55                   	push   %ebp
   170f6:	89 e5                	mov    %esp,%ebp
   170f8:	83 ec 18             	sub    $0x18,%esp
    if(is_fd_bad(file)){
   170fb:	ff 75 08             	pushl  0x8(%ebp)
   170fe:	e8 76 f9 ff ff       	call   16a79 <is_fd_bad>
   17103:	83 c4 04             	add    $0x4,%esp
   17106:	85 c0                	test   %eax,%eax
   17108:	74 0a                	je     17114 <sys_fstat+0x1f>
        return 0;
   1710a:	b8 00 00 00 00       	mov    $0x0,%eax
   1710f:	e9 85 00 00 00       	jmp    17199 <sys_fstat+0xa4>
    }

    file_t* p_file=task_file(file);
   17114:	83 ec 0c             	sub    $0xc,%esp
   17117:	ff 75 08             	pushl  0x8(%ebp)
   1711a:	e8 34 af ff ff       	call   12053 <task_file>
   1711f:	83 c4 10             	add    $0x10,%esp
   17122:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!p_file){
   17125:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   17129:	75 17                	jne    17142 <sys_fstat+0x4d>
        log_printf("file not opened");
   1712b:	83 ec 0c             	sub    $0xc,%esp
   1712e:	68 83 93 01 00       	push   $0x19383
   17133:	e8 93 13 00 00       	call   184cb <log_printf>
   17138:	83 c4 10             	add    $0x10,%esp
        return -1;
   1713b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17140:	eb 57                	jmp    17199 <sys_fstat+0xa4>
    }

    kernel_memset(st,0,sizeof(struct stat));
   17142:	83 ec 04             	sub    $0x4,%esp
   17145:	6a 48                	push   $0x48
   17147:	6a 00                	push   $0x0
   17149:	ff 75 0c             	pushl  0xc(%ebp)
   1714c:	e8 57 0d 00 00       	call   17ea8 <kernel_memset>
   17151:	83 c4 10             	add    $0x10,%esp

    fs_t* fs=p_file->fs;
   17154:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17157:	8b 40 38             	mov    0x38(%eax),%eax
   1715a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fs_protect(fs);
   1715d:	83 ec 0c             	sub    $0xc,%esp
   17160:	ff 75 f0             	pushl  -0x10(%ebp)
   17163:	e8 48 fa ff ff       	call   16bb0 <fs_protect>
   17168:	83 c4 10             	add    $0x10,%esp
    int err=fs->op->stat(p_file,st);
   1716b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1716e:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   17174:	8b 40 1c             	mov    0x1c(%eax),%eax
   17177:	83 ec 08             	sub    $0x8,%esp
   1717a:	ff 75 0c             	pushl  0xc(%ebp)
   1717d:	ff 75 f4             	pushl  -0xc(%ebp)
   17180:	ff d0                	call   *%eax
   17182:	83 c4 10             	add    $0x10,%esp
   17185:	89 45 ec             	mov    %eax,-0x14(%ebp)
    fs_unprotect(fs);
   17188:	83 ec 0c             	sub    $0xc,%esp
   1718b:	ff 75 f0             	pushl  -0x10(%ebp)
   1718e:	e8 48 fa ff ff       	call   16bdb <fs_unprotect>
   17193:	83 c4 10             	add    $0x10,%esp

    return err;
   17196:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
   17199:	c9                   	leave  
   1719a:	c3                   	ret    

0001719b <mount_list_init>:

static void mount_list_init(void){
   1719b:	55                   	push   %ebp
   1719c:	89 e5                	mov    %esp,%ebp
   1719e:	83 ec 18             	sub    $0x18,%esp
    list_init(&free_list);
   171a1:	83 ec 0c             	sub    $0xc,%esp
   171a4:	68 f8 df 05 00       	push   $0x5dff8
   171a9:	e8 09 11 00 00       	call   182b7 <list_init>
   171ae:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<FS_TABLE_SIZE;i++){
   171b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   171b8:	eb 28                	jmp    171e2 <mount_list_init+0x47>
        list_insert_first(&free_list,&fs_table[i].node);
   171ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
   171bd:	69 c0 4c 02 00 00    	imul   $0x24c,%eax,%eax
   171c3:	05 10 02 00 00       	add    $0x210,%eax
   171c8:	05 00 c9 05 00       	add    $0x5c900,%eax
   171cd:	83 ec 08             	sub    $0x8,%esp
   171d0:	50                   	push   %eax
   171d1:	68 f8 df 05 00       	push   $0x5dff8
   171d6:	e8 01 11 00 00       	call   182dc <list_insert_first>
   171db:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<FS_TABLE_SIZE;i++){
   171de:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   171e2:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
   171e6:	7e d2                	jle    171ba <mount_list_init+0x1f>
    }

    list_init(&mounted_list);
   171e8:	83 ec 0c             	sub    $0xc,%esp
   171eb:	68 e4 c8 05 00       	push   $0x5c8e4
   171f0:	e8 c2 10 00 00       	call   182b7 <list_init>
   171f5:	83 c4 10             	add    $0x10,%esp
}
   171f8:	90                   	nop
   171f9:	c9                   	leave  
   171fa:	c3                   	ret    

000171fb <get_fs_op>:
 * @brief 获取文件系统操作函数表
 * @param type 文件系统类型
 * @param major 设备号
 * @return 返回文件系统操作函数表的指针
 */
static fs_op_t* get_fs_op(fs_type_t type,int major){
   171fb:	55                   	push   %ebp
   171fc:	89 e5                	mov    %esp,%ebp
    switch(type){
   171fe:	8b 45 08             	mov    0x8(%ebp),%eax
   17201:	85 c0                	test   %eax,%eax
   17203:	74 07                	je     1720c <get_fs_op+0x11>
   17205:	83 f8 01             	cmp    $0x1,%eax
   17208:	74 09                	je     17213 <get_fs_op+0x18>
   1720a:	eb 0e                	jmp    1721a <get_fs_op+0x1f>
        case FS_DEVFS:
            return &(devfs_op);
   1720c:	b8 00 a1 01 00       	mov    $0x1a100,%eax
   17211:	eb 0c                	jmp    1721f <get_fs_op+0x24>
        case FS_FAT16:
            return &(fatfs_op);
   17213:	b8 40 a1 01 00       	mov    $0x1a140,%eax
   17218:	eb 05                	jmp    1721f <get_fs_op+0x24>
        default:
            return (fs_op_t*)0;
   1721a:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
   1721f:	5d                   	pop    %ebp
   17220:	c3                   	ret    

00017221 <mount>:

static fs_t* mount(fs_type_t type,char* mount_point,int dev_major,int minor){
   17221:	55                   	push   %ebp
   17222:	89 e5                	mov    %esp,%ebp
   17224:	83 ec 28             	sub    $0x28,%esp
    fs_t* fs=(fs_t*)0;
   17227:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    log_printf("mount file system, name: %s, dev: %x",mount_point,dev_major);
   1722e:	83 ec 04             	sub    $0x4,%esp
   17231:	ff 75 10             	pushl  0x10(%ebp)
   17234:	ff 75 0c             	pushl  0xc(%ebp)
   17237:	68 04 94 01 00       	push   $0x19404
   1723c:	e8 8a 12 00 00       	call   184cb <log_printf>
   17241:	83 c4 10             	add    $0x10,%esp
    
    list_node_t* curr=list_first(&mounted_list);
   17244:	83 ec 0c             	sub    $0xc,%esp
   17247:	68 e4 c8 05 00       	push   $0x5c8e4
   1724c:	e8 1e f8 ff ff       	call   16a6f <list_first>
   17251:	83 c4 10             	add    $0x10,%esp
   17254:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(curr){
   17257:	eb 59                	jmp    172b2 <mount+0x91>
        fs_t* p_fs=list_node_parent(curr,fs_t,node);
   17259:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1725d:	74 0a                	je     17269 <mount+0x48>
   1725f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17262:	2d 10 02 00 00       	sub    $0x210,%eax
   17267:	eb 05                	jmp    1726e <mount+0x4d>
   17269:	b8 00 00 00 00       	mov    $0x0,%eax
   1726e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(kernel_strncmp(p_fs->mount_point,mount_point,FS_MOUNT_SIZE)==0){
   17271:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   17274:	83 ec 04             	sub    $0x4,%esp
   17277:	68 00 02 00 00       	push   $0x200
   1727c:	ff 75 0c             	pushl  0xc(%ebp)
   1727f:	50                   	push   %eax
   17280:	e8 1f 0b 00 00       	call   17da4 <kernel_strncmp>
   17285:	83 c4 10             	add    $0x10,%esp
   17288:	85 c0                	test   %eax,%eax
   1728a:	75 15                	jne    172a1 <mount+0x80>
            log_printf("file system already mounted");
   1728c:	83 ec 0c             	sub    $0xc,%esp
   1728f:	68 29 94 01 00       	push   $0x19429
   17294:	e8 32 12 00 00       	call   184cb <log_printf>
   17299:	83 c4 10             	add    $0x10,%esp
            goto mount_failed;
   1729c:	e9 11 01 00 00       	jmp    173b2 <mount+0x191>
        }

        curr=list_node_next(curr);
   172a1:	83 ec 0c             	sub    $0xc,%esp
   172a4:	ff 75 f0             	pushl  -0x10(%ebp)
   172a7:	e8 b8 f7 ff ff       	call   16a64 <list_node_next>
   172ac:	83 c4 10             	add    $0x10,%esp
   172af:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(curr){
   172b2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   172b6:	75 a1                	jne    17259 <mount+0x38>
    }

    list_node_t* free_node=list_remove_first(&free_list);
   172b8:	83 ec 0c             	sub    $0xc,%esp
   172bb:	68 f8 df 05 00       	push   $0x5dff8
   172c0:	e8 da 10 00 00       	call   1839f <list_remove_first>
   172c5:	83 c4 10             	add    $0x10,%esp
   172c8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!free_node){
   172cb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   172cf:	75 15                	jne    172e6 <mount+0xc5>
        log_printf("no free fs_t, mount failed");
   172d1:	83 ec 0c             	sub    $0xc,%esp
   172d4:	68 45 94 01 00       	push   $0x19445
   172d9:	e8 ed 11 00 00       	call   184cb <log_printf>
   172de:	83 c4 10             	add    $0x10,%esp
        goto mount_failed;
   172e1:	e9 cc 00 00 00       	jmp    173b2 <mount+0x191>
    }

    fs=list_node_parent(free_node,fs_t,node);
   172e6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   172ea:	74 0a                	je     172f6 <mount+0xd5>
   172ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
   172ef:	2d 10 02 00 00       	sub    $0x210,%eax
   172f4:	eb 05                	jmp    172fb <mount+0xda>
   172f6:	b8 00 00 00 00       	mov    $0x0,%eax
   172fb:	89 45 f4             	mov    %eax,-0xc(%ebp)

    fs_op_t* op=get_fs_op(type,dev_major);
   172fe:	83 ec 08             	sub    $0x8,%esp
   17301:	ff 75 10             	pushl  0x10(%ebp)
   17304:	ff 75 08             	pushl  0x8(%ebp)
   17307:	e8 ef fe ff ff       	call   171fb <get_fs_op>
   1730c:	83 c4 10             	add    $0x10,%esp
   1730f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!op){
   17312:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   17316:	75 15                	jne    1732d <mount+0x10c>
        log_printf("unsupported file system type");
   17318:	83 ec 0c             	sub    $0xc,%esp
   1731b:	68 60 94 01 00       	push   $0x19460
   17320:	e8 a6 11 00 00       	call   184cb <log_printf>
   17325:	83 c4 10             	add    $0x10,%esp
        goto mount_failed;
   17328:	e9 85 00 00 00       	jmp    173b2 <mount+0x191>
    }

    kernel_memset(fs,0,sizeof(fs_t));
   1732d:	83 ec 04             	sub    $0x4,%esp
   17330:	68 4c 02 00 00       	push   $0x24c
   17335:	6a 00                	push   $0x0
   17337:	ff 75 f4             	pushl  -0xc(%ebp)
   1733a:	e8 69 0b 00 00       	call   17ea8 <kernel_memset>
   1733f:	83 c4 10             	add    $0x10,%esp
    kernel_strncpy(fs->mount_point,mount_point,FS_MOUNT_SIZE);
   17342:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17345:	83 ec 04             	sub    $0x4,%esp
   17348:	68 00 02 00 00       	push   $0x200
   1734d:	ff 75 0c             	pushl  0xc(%ebp)
   17350:	50                   	push   %eax
   17351:	e8 de 09 00 00       	call   17d34 <kernel_strncpy>
   17356:	83 c4 10             	add    $0x10,%esp

    fs->op=op;
   17359:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1735c:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1735f:	89 90 04 02 00 00    	mov    %edx,0x204(%eax)
    
    if(op->mount(fs,dev_major,minor)<0){
   17365:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17368:	8b 00                	mov    (%eax),%eax
   1736a:	83 ec 04             	sub    $0x4,%esp
   1736d:	ff 75 14             	pushl  0x14(%ebp)
   17370:	ff 75 10             	pushl  0x10(%ebp)
   17373:	ff 75 f4             	pushl  -0xc(%ebp)
   17376:	ff d0                	call   *%eax
   17378:	83 c4 10             	add    $0x10,%esp
   1737b:	85 c0                	test   %eax,%eax
   1737d:	79 15                	jns    17394 <mount+0x173>
        log_printf("mount file system %s failed",mount_point);
   1737f:	83 ec 08             	sub    $0x8,%esp
   17382:	ff 75 0c             	pushl  0xc(%ebp)
   17385:	68 7d 94 01 00       	push   $0x1947d
   1738a:	e8 3c 11 00 00       	call   184cb <log_printf>
   1738f:	83 c4 10             	add    $0x10,%esp
        goto mount_failed;
   17392:	eb 1e                	jmp    173b2 <mount+0x191>
    }

    list_insert_last(&mounted_list,&fs->node);
   17394:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17397:	05 10 02 00 00       	add    $0x210,%eax
   1739c:	83 ec 08             	sub    $0x8,%esp
   1739f:	50                   	push   %eax
   173a0:	68 e4 c8 05 00       	push   $0x5c8e4
   173a5:	e8 91 0f 00 00       	call   1833b <list_insert_last>
   173aa:	83 c4 10             	add    $0x10,%esp
    return fs;
   173ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   173b0:	eb 24                	jmp    173d6 <mount+0x1b5>

mount_failed:
    if(fs){
   173b2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   173b6:	74 19                	je     173d1 <mount+0x1b0>
        list_insert_last(&free_list,&fs->node);
   173b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   173bb:	05 10 02 00 00       	add    $0x210,%eax
   173c0:	83 ec 08             	sub    $0x8,%esp
   173c3:	50                   	push   %eax
   173c4:	68 f8 df 05 00       	push   $0x5dff8
   173c9:	e8 6d 0f 00 00       	call   1833b <list_insert_last>
   173ce:	83 c4 10             	add    $0x10,%esp
    }
    return (fs_t*)0;
   173d1:	b8 00 00 00 00       	mov    $0x0,%eax
}
   173d6:	c9                   	leave  
   173d7:	c3                   	ret    

000173d8 <fs_init>:

void fs_init(void){
   173d8:	55                   	push   %ebp
   173d9:	89 e5                	mov    %esp,%ebp
   173db:	83 ec 18             	sub    $0x18,%esp
    mount_list_init();
   173de:	e8 b8 fd ff ff       	call   1719b <mount_list_init>
    file_table_init();
   173e3:	e8 14 f6 ff ff       	call   169fc <file_table_init>

    disk_init();
   173e8:	e8 85 cf ff ff       	call   14372 <disk_init>

    // 挂载设备文件系统
    fs_t* fs=mount(FS_DEVFS,"/dev",0,0);
   173ed:	6a 00                	push   $0x0
   173ef:	6a 00                	push   $0x0
   173f1:	68 99 94 01 00       	push   $0x19499
   173f6:	6a 00                	push   $0x0
   173f8:	e8 24 fe ff ff       	call   17221 <mount>
   173fd:	83 c4 10             	add    $0x10,%esp
   17400:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ASSERT(fs!=(fs_t*)0);
   17403:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   17407:	75 1c                	jne    17425 <fs_init+0x4d>
   17409:	68 9e 94 01 00       	push   $0x1949e
   1740e:	68 f8 94 01 00       	push   $0x194f8
   17413:	68 95 01 00 00       	push   $0x195
   17418:	68 d4 93 01 00       	push   $0x193d4
   1741d:	e8 d9 0d 00 00       	call   181fb <panic>
   17422:	83 c4 10             	add    $0x10,%esp

    root_fs=mount(FS_FAT16,"/home",ROOT_DEV);
   17425:	68 b1 00 00 00       	push   $0xb1
   1742a:	6a 02                	push   $0x2
   1742c:	68 ab 94 01 00       	push   $0x194ab
   17431:	6a 01                	push   $0x1
   17433:	e8 e9 fd ff ff       	call   17221 <mount>
   17438:	83 c4 10             	add    $0x10,%esp
   1743b:	a3 e0 c8 05 00       	mov    %eax,0x5c8e0
    ASSERT(root_fs!=(fs_t*)0);
   17440:	a1 e0 c8 05 00       	mov    0x5c8e0,%eax
   17445:	85 c0                	test   %eax,%eax
   17447:	75 1c                	jne    17465 <fs_init+0x8d>
   17449:	68 b1 94 01 00       	push   $0x194b1
   1744e:	68 f8 94 01 00       	push   $0x194f8
   17453:	68 98 01 00 00       	push   $0x198
   17458:	68 d4 93 01 00       	push   $0x193d4
   1745d:	e8 99 0d 00 00       	call   181fb <panic>
   17462:	83 c4 10             	add    $0x10,%esp
}
   17465:	90                   	nop
   17466:	c9                   	leave  
   17467:	c3                   	ret    

00017468 <sys_dup>:
/**
* @brief 复制文件描述符，返回新的文件描述符
* @return 新的文件描述符，失败返回-1
* @param file 旧的文件描述符
*/
int sys_dup(int file){
   17468:	55                   	push   %ebp
   17469:	89 e5                	mov    %esp,%ebp
   1746b:	83 ec 18             	sub    $0x18,%esp
    if(is_fd_bad(file)){
   1746e:	ff 75 08             	pushl  0x8(%ebp)
   17471:	e8 03 f6 ff ff       	call   16a79 <is_fd_bad>
   17476:	83 c4 04             	add    $0x4,%esp
   17479:	85 c0                	test   %eax,%eax
   1747b:	74 07                	je     17484 <sys_dup+0x1c>
        return -1;
   1747d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17482:	eb 6d                	jmp    174f1 <sys_dup+0x89>
    }

    file_t* p_file=task_file(file);
   17484:	83 ec 0c             	sub    $0xc,%esp
   17487:	ff 75 08             	pushl  0x8(%ebp)
   1748a:	e8 c4 ab ff ff       	call   12053 <task_file>
   1748f:	83 c4 10             	add    $0x10,%esp
   17492:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!p_file){
   17495:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   17499:	75 17                	jne    174b2 <sys_dup+0x4a>
        log_printf("file not opened");
   1749b:	83 ec 0c             	sub    $0xc,%esp
   1749e:	68 83 93 01 00       	push   $0x19383
   174a3:	e8 23 10 00 00       	call   184cb <log_printf>
   174a8:	83 c4 10             	add    $0x10,%esp
        return -1;
   174ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   174b0:	eb 3f                	jmp    174f1 <sys_dup+0x89>
    }

    int fd=task_alloc_fd(p_file);
   174b2:	83 ec 0c             	sub    $0xc,%esp
   174b5:	ff 75 f4             	pushl  -0xc(%ebp)
   174b8:	e8 c7 ab ff ff       	call   12084 <task_alloc_fd>
   174bd:	83 c4 10             	add    $0x10,%esp
   174c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(fd >= 0){
   174c3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   174c7:	78 13                	js     174dc <sys_dup+0x74>
        file_inc_ref(p_file);
   174c9:	83 ec 0c             	sub    $0xc,%esp
   174cc:	ff 75 f4             	pushl  -0xc(%ebp)
   174cf:	e8 58 f5 ff ff       	call   16a2c <file_inc_ref>
   174d4:	83 c4 10             	add    $0x10,%esp
        return fd;
   174d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   174da:	eb 15                	jmp    174f1 <sys_dup+0x89>
    }

    log_printf("alloc fd failed\n");
   174dc:	83 ec 0c             	sub    $0xc,%esp
   174df:	68 c3 94 01 00       	push   $0x194c3
   174e4:	e8 e2 0f 00 00       	call   184cb <log_printf>
   174e9:	83 c4 10             	add    $0x10,%esp
    return -1;
   174ec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   174f1:	c9                   	leave  
   174f2:	c3                   	ret    

000174f3 <sys_opendir>:

int sys_opendir(const char* path, DIR* dir){
   174f3:	55                   	push   %ebp
   174f4:	89 e5                	mov    %esp,%ebp
   174f6:	83 ec 18             	sub    $0x18,%esp
    fs_protect(root_fs);
   174f9:	a1 e0 c8 05 00       	mov    0x5c8e0,%eax
   174fe:	83 ec 0c             	sub    $0xc,%esp
   17501:	50                   	push   %eax
   17502:	e8 a9 f6 ff ff       	call   16bb0 <fs_protect>
   17507:	83 c4 10             	add    $0x10,%esp
    int err=root_fs->op->opendir(root_fs, path, dir);
   1750a:	a1 e0 c8 05 00       	mov    0x5c8e0,%eax
   1750f:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   17515:	8b 40 20             	mov    0x20(%eax),%eax
   17518:	8b 15 e0 c8 05 00    	mov    0x5c8e0,%edx
   1751e:	83 ec 04             	sub    $0x4,%esp
   17521:	ff 75 0c             	pushl  0xc(%ebp)
   17524:	ff 75 08             	pushl  0x8(%ebp)
   17527:	52                   	push   %edx
   17528:	ff d0                	call   *%eax
   1752a:	83 c4 10             	add    $0x10,%esp
   1752d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fs_unprotect(root_fs);
   17530:	a1 e0 c8 05 00       	mov    0x5c8e0,%eax
   17535:	83 ec 0c             	sub    $0xc,%esp
   17538:	50                   	push   %eax
   17539:	e8 9d f6 ff ff       	call   16bdb <fs_unprotect>
   1753e:	83 c4 10             	add    $0x10,%esp

    return err;
   17541:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   17544:	c9                   	leave  
   17545:	c3                   	ret    

00017546 <sys_readdir>:

int sys_readdir(DIR* dir, struct dirent* dirent){
   17546:	55                   	push   %ebp
   17547:	89 e5                	mov    %esp,%ebp
   17549:	83 ec 18             	sub    $0x18,%esp
    fs_protect(root_fs);
   1754c:	a1 e0 c8 05 00       	mov    0x5c8e0,%eax
   17551:	83 ec 0c             	sub    $0xc,%esp
   17554:	50                   	push   %eax
   17555:	e8 56 f6 ff ff       	call   16bb0 <fs_protect>
   1755a:	83 c4 10             	add    $0x10,%esp
    int err=root_fs->op->readdir(root_fs,dir,dirent);
   1755d:	a1 e0 c8 05 00       	mov    0x5c8e0,%eax
   17562:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   17568:	8b 40 24             	mov    0x24(%eax),%eax
   1756b:	8b 15 e0 c8 05 00    	mov    0x5c8e0,%edx
   17571:	83 ec 04             	sub    $0x4,%esp
   17574:	ff 75 0c             	pushl  0xc(%ebp)
   17577:	ff 75 08             	pushl  0x8(%ebp)
   1757a:	52                   	push   %edx
   1757b:	ff d0                	call   *%eax
   1757d:	83 c4 10             	add    $0x10,%esp
   17580:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fs_unprotect(root_fs);
   17583:	a1 e0 c8 05 00       	mov    0x5c8e0,%eax
   17588:	83 ec 0c             	sub    $0xc,%esp
   1758b:	50                   	push   %eax
   1758c:	e8 4a f6 ff ff       	call   16bdb <fs_unprotect>
   17591:	83 c4 10             	add    $0x10,%esp

    return err;
   17594:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   17597:	c9                   	leave  
   17598:	c3                   	ret    

00017599 <sys_closedir>:

int sys_closedir(DIR* dir){
   17599:	55                   	push   %ebp
   1759a:	89 e5                	mov    %esp,%ebp
   1759c:	83 ec 18             	sub    $0x18,%esp
    fs_protect(root_fs);
   1759f:	a1 e0 c8 05 00       	mov    0x5c8e0,%eax
   175a4:	83 ec 0c             	sub    $0xc,%esp
   175a7:	50                   	push   %eax
   175a8:	e8 03 f6 ff ff       	call   16bb0 <fs_protect>
   175ad:	83 c4 10             	add    $0x10,%esp
    int err=root_fs->op->closedir(root_fs,dir);
   175b0:	a1 e0 c8 05 00       	mov    0x5c8e0,%eax
   175b5:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   175bb:	8b 40 28             	mov    0x28(%eax),%eax
   175be:	8b 15 e0 c8 05 00    	mov    0x5c8e0,%edx
   175c4:	83 ec 08             	sub    $0x8,%esp
   175c7:	ff 75 08             	pushl  0x8(%ebp)
   175ca:	52                   	push   %edx
   175cb:	ff d0                	call   *%eax
   175cd:	83 c4 10             	add    $0x10,%esp
   175d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fs_unprotect(root_fs);
   175d3:	a1 e0 c8 05 00       	mov    0x5c8e0,%eax
   175d8:	83 ec 0c             	sub    $0xc,%esp
   175db:	50                   	push   %eax
   175dc:	e8 fa f5 ff ff       	call   16bdb <fs_unprotect>
   175e1:	83 c4 10             	add    $0x10,%esp
    
    return err;
   175e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   175e7:	c9                   	leave  
   175e8:	c3                   	ret    

000175e9 <sys_ioctl>:

int sys_ioctl(int fd,int cmd,int arg0,int arg1){
   175e9:	55                   	push   %ebp
   175ea:	89 e5                	mov    %esp,%ebp
   175ec:	83 ec 18             	sub    $0x18,%esp
    if(is_fd_bad(fd)){
   175ef:	ff 75 08             	pushl  0x8(%ebp)
   175f2:	e8 82 f4 ff ff       	call   16a79 <is_fd_bad>
   175f7:	83 c4 04             	add    $0x4,%esp
   175fa:	85 c0                	test   %eax,%eax
   175fc:	74 1a                	je     17618 <sys_ioctl+0x2f>
        log_printf("file %d is not valid",fd);
   175fe:	83 ec 08             	sub    $0x8,%esp
   17601:	ff 75 08             	pushl  0x8(%ebp)
   17604:	68 d4 94 01 00       	push   $0x194d4
   17609:	e8 bd 0e 00 00       	call   184cb <log_printf>
   1760e:	83 c4 10             	add    $0x10,%esp
        return -1;
   17611:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17616:	eb 76                	jmp    1768e <sys_ioctl+0xa5>
    }

    file_t *p_file=task_file(fd);
   17618:	83 ec 0c             	sub    $0xc,%esp
   1761b:	ff 75 08             	pushl  0x8(%ebp)
   1761e:	e8 30 aa ff ff       	call   12053 <task_file>
   17623:	83 c4 10             	add    $0x10,%esp
   17626:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(!p_file){
   17629:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1762d:	75 17                	jne    17646 <sys_ioctl+0x5d>
        log_printf("file not opened");
   1762f:	83 ec 0c             	sub    $0xc,%esp
   17632:	68 83 93 01 00       	push   $0x19383
   17637:	e8 8f 0e 00 00       	call   184cb <log_printf>
   1763c:	83 c4 10             	add    $0x10,%esp
        return -1;
   1763f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17644:	eb 48                	jmp    1768e <sys_ioctl+0xa5>
    }

    fs_t *fs=p_file->fs;
   17646:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17649:	8b 40 38             	mov    0x38(%eax),%eax
   1764c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fs_protect(fs);
   1764f:	83 ec 0c             	sub    $0xc,%esp
   17652:	ff 75 f0             	pushl  -0x10(%ebp)
   17655:	e8 56 f5 ff ff       	call   16bb0 <fs_protect>
   1765a:	83 c4 10             	add    $0x10,%esp
    int err=fs->op->ioctl(p_file,cmd,arg0,arg1);
   1765d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17660:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   17666:	8b 40 2c             	mov    0x2c(%eax),%eax
   17669:	ff 75 14             	pushl  0x14(%ebp)
   1766c:	ff 75 10             	pushl  0x10(%ebp)
   1766f:	ff 75 0c             	pushl  0xc(%ebp)
   17672:	ff 75 f4             	pushl  -0xc(%ebp)
   17675:	ff d0                	call   *%eax
   17677:	83 c4 10             	add    $0x10,%esp
   1767a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    fs_unprotect(fs);
   1767d:	83 ec 0c             	sub    $0xc,%esp
   17680:	ff 75 f0             	pushl  -0x10(%ebp)
   17683:	e8 53 f5 ff ff       	call   16bdb <fs_unprotect>
   17688:	83 c4 10             	add    $0x10,%esp

    return err;
   1768b:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
   1768e:	c9                   	leave  
   1768f:	c3                   	ret    

00017690 <sys_unlink>:

int sys_unlink(const char *path){
   17690:	55                   	push   %ebp
   17691:	89 e5                	mov    %esp,%ebp
   17693:	83 ec 18             	sub    $0x18,%esp
    fs_protect(root_fs);
   17696:	a1 e0 c8 05 00       	mov    0x5c8e0,%eax
   1769b:	83 ec 0c             	sub    $0xc,%esp
   1769e:	50                   	push   %eax
   1769f:	e8 0c f5 ff ff       	call   16bb0 <fs_protect>
   176a4:	83 c4 10             	add    $0x10,%esp
    int err=root_fs->op->unlink(root_fs, path);
   176a7:	a1 e0 c8 05 00       	mov    0x5c8e0,%eax
   176ac:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
   176b2:	8b 40 30             	mov    0x30(%eax),%eax
   176b5:	8b 15 e0 c8 05 00    	mov    0x5c8e0,%edx
   176bb:	83 ec 08             	sub    $0x8,%esp
   176be:	ff 75 08             	pushl  0x8(%ebp)
   176c1:	52                   	push   %edx
   176c2:	ff d0                	call   *%eax
   176c4:	83 c4 10             	add    $0x10,%esp
   176c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fs_unprotect(root_fs);
   176ca:	a1 e0 c8 05 00       	mov    0x5c8e0,%eax
   176cf:	83 ec 0c             	sub    $0xc,%esp
   176d2:	50                   	push   %eax
   176d3:	e8 03 f5 ff ff       	call   16bdb <fs_unprotect>
   176d8:	83 c4 10             	add    $0x10,%esp

    return err;
   176db:	8b 45 f4             	mov    -0xc(%ebp),%eax
   176de:	c9                   	leave  
   176df:	c3                   	ret    

000176e0 <kernel_init>:
#include "ipc/sem.h"
#include "cpu/cpu.h"
#include "dev/kbd.h"
#include "fs/fs.h"

void kernel_init(boot_info_t* boot_info){
   176e0:	55                   	push   %ebp
   176e1:	89 e5                	mov    %esp,%ebp
   176e3:	83 ec 08             	sub    $0x8,%esp
    irq_init();
   176e6:	e8 2b b1 ff ff       	call   12816 <irq_init>

    cpu_init();
   176eb:	e8 e9 ad ff ff       	call   124d9 <cpu_init>
    log_init();
   176f0:	e8 a7 0d 00 00       	call   1849c <log_init>

    memory_init(boot_info);
   176f5:	83 ec 0c             	sub    $0xc,%esp
   176f8:	ff 75 08             	pushl  0x8(%ebp)
   176fb:	e8 42 90 ff ff       	call   10742 <memory_init>
   17700:	83 c4 10             	add    $0x10,%esp
    fs_init();
   17703:	e8 d0 fc ff ff       	call   173d8 <fs_init>
    
    time_init();
   17708:	e8 8f d5 ff ff       	call   14c9c <time_init>

    task_manager_init();
   1770d:	e8 64 9c ff ff       	call   11376 <task_manager_init>

}
   17712:	90                   	nop
   17713:	c9                   	leave  
   17714:	c3                   	ret    

00017715 <move_to_first_task>:

void move_to_first_task(void){
   17715:	55                   	push   %ebp
   17716:	89 e5                	mov    %esp,%ebp
   17718:	56                   	push   %esi
   17719:	53                   	push   %ebx
   1771a:	83 ec 10             	sub    $0x10,%esp
    task_t* curr=task_current();
   1771d:	e8 d9 9e ff ff       	call   115fb <task_current>
   17722:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ASSERT(curr!=0);
   17725:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   17729:	75 19                	jne    17744 <move_to_first_task+0x2f>
   1772b:	68 00 95 01 00       	push   $0x19500
   17730:	68 54 95 01 00       	push   $0x19554
   17735:	6a 23                	push   $0x23
   17737:	68 08 95 01 00       	push   $0x19508
   1773c:	e8 ba 0a 00 00       	call   181fb <panic>
   17741:	83 c4 10             	add    $0x10,%esp
    tss_t* tss=&(curr->tss);
   17744:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17747:	05 58 02 00 00       	add    $0x258,%eax
   1774c:	89 45 f0             	mov    %eax,-0x10(%ebp)
        "push %[eflags]\n\t"
        "push %[cs]\n\t"
        "push %[eip]\n\t"
        "iret"
        :
        :[ss]"r"(tss->ss),[esp]"r"(tss->esp),[eflags]"r"(tss->eflags),[cs]"r"(tss->cs),
   1774f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17752:	8b 40 50             	mov    0x50(%eax),%eax
   17755:	8b 55 f0             	mov    -0x10(%ebp),%edx
   17758:	8b 52 38             	mov    0x38(%edx),%edx
   1775b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   1775e:	8b 49 24             	mov    0x24(%ecx),%ecx
   17761:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   17764:	8b 5b 4c             	mov    0x4c(%ebx),%ebx
         [eip]"r"(tss->eip)
   17767:	8b 75 f0             	mov    -0x10(%ebp),%esi
   1776a:	8b 76 20             	mov    0x20(%esi),%esi
    __asm__ __volatile__(
   1776d:	50                   	push   %eax
   1776e:	52                   	push   %edx
   1776f:	51                   	push   %ecx
   17770:	53                   	push   %ebx
   17771:	56                   	push   %esi
   17772:	cf                   	iret   
    );
}
   17773:	90                   	nop
   17774:	8d 65 f8             	lea    -0x8(%ebp),%esp
   17777:	5b                   	pop    %ebx
   17778:	5e                   	pop    %esi
   17779:	5d                   	pop    %ebp
   1777a:	c3                   	ret    

0001777b <init_main>:

void init_main(){
   1777b:	55                   	push   %ebp
   1777c:	89 e5                	mov    %esp,%ebp
   1777e:	83 ec 18             	sub    $0x18,%esp
    int count=0;
   17781:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    log_printf("Kernel is running....");
   17788:	83 ec 0c             	sub    $0xc,%esp
   1778b:	68 3b 95 01 00       	push   $0x1953b
   17790:	e8 36 0d 00 00       	call   184cb <log_printf>
   17795:	83 c4 10             	add    $0x10,%esp
    task_first_init();
   17798:	e8 c0 9c ff ff       	call   1145d <task_first_init>
    move_to_first_task();
   1779d:	e8 73 ff ff ff       	call   17715 <move_to_first_task>
}
   177a2:	90                   	nop
   177a3:	c9                   	leave  
   177a4:	c3                   	ret    

000177a5 <list_count>:
static inline int list_count(list_t* list){
   177a5:	55                   	push   %ebp
   177a6:	89 e5                	mov    %esp,%ebp
    return list->count;
   177a8:	8b 45 08             	mov    0x8(%ebp),%eax
   177ab:	8b 40 08             	mov    0x8(%eax),%eax
}
   177ae:	5d                   	pop    %ebp
   177af:	c3                   	ret    

000177b0 <mutex_init>:
#include "ipc/mutex.h"

void mutex_init(mutex_t* mutex){
   177b0:	55                   	push   %ebp
   177b1:	89 e5                	mov    %esp,%ebp
   177b3:	83 ec 08             	sub    $0x8,%esp
    mutex->locked_count=0;
   177b6:	8b 45 08             	mov    0x8(%ebp),%eax
   177b9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    mutex->owner=(task_t*)0;
   177c0:	8b 45 08             	mov    0x8(%ebp),%eax
   177c3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    list_init(&mutex->wait_list); 
   177c9:	8b 45 08             	mov    0x8(%ebp),%eax
   177cc:	83 c0 08             	add    $0x8,%eax
   177cf:	83 ec 0c             	sub    $0xc,%esp
   177d2:	50                   	push   %eax
   177d3:	e8 df 0a 00 00       	call   182b7 <list_init>
   177d8:	83 c4 10             	add    $0x10,%esp
}
   177db:	90                   	nop
   177dc:	c9                   	leave  
   177dd:	c3                   	ret    

000177de <mutex_lock>:

void mutex_lock(mutex_t* mutex){
   177de:	55                   	push   %ebp
   177df:	89 e5                	mov    %esp,%ebp
   177e1:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   177e4:	e8 1b b7 ff ff       	call   12f04 <irq_enter_protection>
   177e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* curr=task_current();
   177ec:	e8 0a 9e ff ff       	call   115fb <task_current>
   177f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(mutex->locked_count==0){
   177f4:	8b 45 08             	mov    0x8(%ebp),%eax
   177f7:	8b 40 04             	mov    0x4(%eax),%eax
   177fa:	85 c0                	test   %eax,%eax
   177fc:	75 14                	jne    17812 <mutex_lock+0x34>
        mutex->locked_count=1;
   177fe:	8b 45 08             	mov    0x8(%ebp),%eax
   17801:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
        mutex->owner=curr;
   17808:	8b 45 08             	mov    0x8(%ebp),%eax
   1780b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1780e:	89 10                	mov    %edx,(%eax)
   17810:	eb 4a                	jmp    1785c <mutex_lock+0x7e>
    }
    else if(mutex->owner==curr){
   17812:	8b 45 08             	mov    0x8(%ebp),%eax
   17815:	8b 00                	mov    (%eax),%eax
   17817:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1781a:	75 11                	jne    1782d <mutex_lock+0x4f>
        mutex->locked_count++;
   1781c:	8b 45 08             	mov    0x8(%ebp),%eax
   1781f:	8b 40 04             	mov    0x4(%eax),%eax
   17822:	8d 50 01             	lea    0x1(%eax),%edx
   17825:	8b 45 08             	mov    0x8(%ebp),%eax
   17828:	89 50 04             	mov    %edx,0x4(%eax)
   1782b:	eb 2f                	jmp    1785c <mutex_lock+0x7e>
    }
    else{
        task_set_block(curr);
   1782d:	83 ec 0c             	sub    $0xc,%esp
   17830:	ff 75 f0             	pushl  -0x10(%ebp)
   17833:	e8 51 9d ff ff       	call   11589 <task_set_block>
   17838:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&mutex->wait_list,&curr->wait_node);
   1783b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1783e:	8d 90 50 02 00 00    	lea    0x250(%eax),%edx
   17844:	8b 45 08             	mov    0x8(%ebp),%eax
   17847:	83 c0 08             	add    $0x8,%eax
   1784a:	83 ec 08             	sub    $0x8,%esp
   1784d:	52                   	push   %edx
   1784e:	50                   	push   %eax
   1784f:	e8 e7 0a 00 00       	call   1833b <list_insert_last>
   17854:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   17857:	e8 0a 9e ff ff       	call   11666 <task_dispatch>
    }
    irq_leave_protection(state);
   1785c:	83 ec 0c             	sub    $0xc,%esp
   1785f:	ff 75 f4             	pushl  -0xc(%ebp)
   17862:	e8 b5 b6 ff ff       	call   12f1c <irq_leave_protection>
   17867:	83 c4 10             	add    $0x10,%esp
}
   1786a:	90                   	nop
   1786b:	c9                   	leave  
   1786c:	c3                   	ret    

0001786d <mutex_unlock>:

void mutex_unlock(mutex_t* mutex){
   1786d:	55                   	push   %ebp
   1786e:	89 e5                	mov    %esp,%ebp
   17870:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   17873:	e8 8c b6 ff ff       	call   12f04 <irq_enter_protection>
   17878:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* curr=task_current();
   1787b:	e8 7b 9d ff ff       	call   115fb <task_current>
   17880:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(mutex->owner==curr){
   17883:	8b 45 08             	mov    0x8(%ebp),%eax
   17886:	8b 00                	mov    (%eax),%eax
   17888:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1788b:	0f 85 8a 00 00 00    	jne    1791b <mutex_unlock+0xae>
        if(--mutex->locked_count==0){
   17891:	8b 45 08             	mov    0x8(%ebp),%eax
   17894:	8b 40 04             	mov    0x4(%eax),%eax
   17897:	8d 50 ff             	lea    -0x1(%eax),%edx
   1789a:	8b 45 08             	mov    0x8(%ebp),%eax
   1789d:	89 50 04             	mov    %edx,0x4(%eax)
   178a0:	8b 45 08             	mov    0x8(%ebp),%eax
   178a3:	8b 40 04             	mov    0x4(%eax),%eax
   178a6:	85 c0                	test   %eax,%eax
   178a8:	75 71                	jne    1791b <mutex_unlock+0xae>
            mutex->owner=(task_t*)0;
   178aa:	8b 45 08             	mov    0x8(%ebp),%eax
   178ad:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
            if(list_count(&mutex->wait_list)){
   178b3:	8b 45 08             	mov    0x8(%ebp),%eax
   178b6:	83 c0 08             	add    $0x8,%eax
   178b9:	83 ec 0c             	sub    $0xc,%esp
   178bc:	50                   	push   %eax
   178bd:	e8 e3 fe ff ff       	call   177a5 <list_count>
   178c2:	83 c4 10             	add    $0x10,%esp
   178c5:	85 c0                	test   %eax,%eax
   178c7:	74 52                	je     1791b <mutex_unlock+0xae>
                list_node_t* node=list_remove_first(&mutex->wait_list);
   178c9:	8b 45 08             	mov    0x8(%ebp),%eax
   178cc:	83 c0 08             	add    $0x8,%eax
   178cf:	83 ec 0c             	sub    $0xc,%esp
   178d2:	50                   	push   %eax
   178d3:	e8 c7 0a 00 00       	call   1839f <list_remove_first>
   178d8:	83 c4 10             	add    $0x10,%esp
   178db:	89 45 ec             	mov    %eax,-0x14(%ebp)
                task_t* task=list_node_parent(node,task_t,wait_node);
   178de:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   178e2:	74 0a                	je     178ee <mutex_unlock+0x81>
   178e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   178e7:	2d 50 02 00 00       	sub    $0x250,%eax
   178ec:	eb 05                	jmp    178f3 <mutex_unlock+0x86>
   178ee:	b8 00 00 00 00       	mov    $0x0,%eax
   178f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
                task_set_ready(task);
   178f6:	83 ec 0c             	sub    $0xc,%esp
   178f9:	ff 75 e8             	pushl  -0x18(%ebp)
   178fc:	e8 52 9c ff ff       	call   11553 <task_set_ready>
   17901:	83 c4 10             	add    $0x10,%esp
                mutex->locked_count=1;
   17904:	8b 45 08             	mov    0x8(%ebp),%eax
   17907:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
                mutex->owner=task;
   1790e:	8b 45 08             	mov    0x8(%ebp),%eax
   17911:	8b 55 e8             	mov    -0x18(%ebp),%edx
   17914:	89 10                	mov    %edx,(%eax)
                task_dispatch();
   17916:	e8 4b 9d ff ff       	call   11666 <task_dispatch>
            }
        }
    }
    irq_leave_protection(state);
   1791b:	83 ec 0c             	sub    $0xc,%esp
   1791e:	ff 75 f4             	pushl  -0xc(%ebp)
   17921:	e8 f6 b5 ff ff       	call   12f1c <irq_leave_protection>
   17926:	83 c4 10             	add    $0x10,%esp
   17929:	90                   	nop
   1792a:	c9                   	leave  
   1792b:	c3                   	ret    

0001792c <list_count>:
static inline int list_count(list_t* list){
   1792c:	55                   	push   %ebp
   1792d:	89 e5                	mov    %esp,%ebp
    return list->count;
   1792f:	8b 45 08             	mov    0x8(%ebp),%eax
   17932:	8b 40 08             	mov    0x8(%eax),%eax
}
   17935:	5d                   	pop    %ebp
   17936:	c3                   	ret    

00017937 <sem_init>:
#include "ipc/sem.h"

void sem_init(sem_t* sem,int init_count){
   17937:	55                   	push   %ebp
   17938:	89 e5                	mov    %esp,%ebp
   1793a:	83 ec 08             	sub    $0x8,%esp
    sem->count=init_count;
   1793d:	8b 45 08             	mov    0x8(%ebp),%eax
   17940:	8b 55 0c             	mov    0xc(%ebp),%edx
   17943:	89 10                	mov    %edx,(%eax)
    list_init(&sem->wait_list);
   17945:	8b 45 08             	mov    0x8(%ebp),%eax
   17948:	83 c0 04             	add    $0x4,%eax
   1794b:	83 ec 0c             	sub    $0xc,%esp
   1794e:	50                   	push   %eax
   1794f:	e8 63 09 00 00       	call   182b7 <list_init>
   17954:	83 c4 10             	add    $0x10,%esp
}
   17957:	90                   	nop
   17958:	c9                   	leave  
   17959:	c3                   	ret    

0001795a <sem_wait>:

void sem_wait(sem_t* sem){
   1795a:	55                   	push   %ebp
   1795b:	89 e5                	mov    %esp,%ebp
   1795d:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   17960:	e8 9f b5 ff ff       	call   12f04 <irq_enter_protection>
   17965:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(sem->count>0){
   17968:	8b 45 08             	mov    0x8(%ebp),%eax
   1796b:	8b 00                	mov    (%eax),%eax
   1796d:	85 c0                	test   %eax,%eax
   1796f:	7e 0f                	jle    17980 <sem_wait+0x26>
        sem->count--;
   17971:	8b 45 08             	mov    0x8(%ebp),%eax
   17974:	8b 00                	mov    (%eax),%eax
   17976:	8d 50 ff             	lea    -0x1(%eax),%edx
   17979:	8b 45 08             	mov    0x8(%ebp),%eax
   1797c:	89 10                	mov    %edx,(%eax)
   1797e:	eb 37                	jmp    179b7 <sem_wait+0x5d>
    }
    else{
        task_t* curr=task_current();
   17980:	e8 76 9c ff ff       	call   115fb <task_current>
   17985:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_set_block(curr);
   17988:	83 ec 0c             	sub    $0xc,%esp
   1798b:	ff 75 f0             	pushl  -0x10(%ebp)
   1798e:	e8 f6 9b ff ff       	call   11589 <task_set_block>
   17993:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&sem->wait_list,&curr->wait_node);
   17996:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17999:	8d 90 50 02 00 00    	lea    0x250(%eax),%edx
   1799f:	8b 45 08             	mov    0x8(%ebp),%eax
   179a2:	83 c0 04             	add    $0x4,%eax
   179a5:	83 ec 08             	sub    $0x8,%esp
   179a8:	52                   	push   %edx
   179a9:	50                   	push   %eax
   179aa:	e8 8c 09 00 00       	call   1833b <list_insert_last>
   179af:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   179b2:	e8 af 9c ff ff       	call   11666 <task_dispatch>
    }
    irq_leave_protection(state);
   179b7:	83 ec 0c             	sub    $0xc,%esp
   179ba:	ff 75 f4             	pushl  -0xc(%ebp)
   179bd:	e8 5a b5 ff ff       	call   12f1c <irq_leave_protection>
   179c2:	83 c4 10             	add    $0x10,%esp
}
   179c5:	90                   	nop
   179c6:	c9                   	leave  
   179c7:	c3                   	ret    

000179c8 <sem_notify>:

void sem_notify(sem_t* sem){
   179c8:	55                   	push   %ebp
   179c9:	89 e5                	mov    %esp,%ebp
   179cb:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   179ce:	e8 31 b5 ff ff       	call   12f04 <irq_enter_protection>
   179d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(list_count(&sem->wait_list)){
   179d6:	8b 45 08             	mov    0x8(%ebp),%eax
   179d9:	83 c0 04             	add    $0x4,%eax
   179dc:	83 ec 0c             	sub    $0xc,%esp
   179df:	50                   	push   %eax
   179e0:	e8 47 ff ff ff       	call   1792c <list_count>
   179e5:	83 c4 10             	add    $0x10,%esp
   179e8:	85 c0                	test   %eax,%eax
   179ea:	74 42                	je     17a2e <sem_notify+0x66>
        list_node_t* node=list_remove_first(&sem->wait_list);
   179ec:	8b 45 08             	mov    0x8(%ebp),%eax
   179ef:	83 c0 04             	add    $0x4,%eax
   179f2:	83 ec 0c             	sub    $0xc,%esp
   179f5:	50                   	push   %eax
   179f6:	e8 a4 09 00 00       	call   1839f <list_remove_first>
   179fb:	83 c4 10             	add    $0x10,%esp
   179fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_t* task=list_node_parent(node,task_t,wait_node);
   17a01:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   17a05:	74 0a                	je     17a11 <sem_notify+0x49>
   17a07:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17a0a:	2d 50 02 00 00       	sub    $0x250,%eax
   17a0f:	eb 05                	jmp    17a16 <sem_notify+0x4e>
   17a11:	b8 00 00 00 00       	mov    $0x0,%eax
   17a16:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_ready(task);
   17a19:	83 ec 0c             	sub    $0xc,%esp
   17a1c:	ff 75 ec             	pushl  -0x14(%ebp)
   17a1f:	e8 2f 9b ff ff       	call   11553 <task_set_ready>
   17a24:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   17a27:	e8 3a 9c ff ff       	call   11666 <task_dispatch>
   17a2c:	eb 0d                	jmp    17a3b <sem_notify+0x73>
    }
    else{
        sem->count++;
   17a2e:	8b 45 08             	mov    0x8(%ebp),%eax
   17a31:	8b 00                	mov    (%eax),%eax
   17a33:	8d 50 01             	lea    0x1(%eax),%edx
   17a36:	8b 45 08             	mov    0x8(%ebp),%eax
   17a39:	89 10                	mov    %edx,(%eax)
    }
    irq_leave_protection(state);
   17a3b:	83 ec 0c             	sub    $0xc,%esp
   17a3e:	ff 75 f4             	pushl  -0xc(%ebp)
   17a41:	e8 d6 b4 ff ff       	call   12f1c <irq_leave_protection>
   17a46:	83 c4 10             	add    $0x10,%esp
}
   17a49:	90                   	nop
   17a4a:	c9                   	leave  
   17a4b:	c3                   	ret    

00017a4c <sem_count>:

int sem_count(sem_t* sem){
   17a4c:	55                   	push   %ebp
   17a4d:	89 e5                	mov    %esp,%ebp
   17a4f:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   17a52:	e8 ad b4 ff ff       	call   12f04 <irq_enter_protection>
   17a57:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int count=sem->count;
   17a5a:	8b 45 08             	mov    0x8(%ebp),%eax
   17a5d:	8b 00                	mov    (%eax),%eax
   17a5f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    irq_leave_protection(state);
   17a62:	83 ec 0c             	sub    $0xc,%esp
   17a65:	ff 75 f4             	pushl  -0xc(%ebp)
   17a68:	e8 af b4 ff ff       	call   12f1c <irq_leave_protection>
   17a6d:	83 c4 10             	add    $0x10,%esp
    return count;
   17a70:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17a73:	c9                   	leave  
   17a74:	c3                   	ret    

00017a75 <bitmap_byte_count>:
#include "tools/bitmap.h"
#include "tools/klib.h"

int bitmap_byte_count(int bit_count){
   17a75:	55                   	push   %ebp
   17a76:	89 e5                	mov    %esp,%ebp
    return (bit_count+8-1)/8;
   17a78:	8b 45 08             	mov    0x8(%ebp),%eax
   17a7b:	83 c0 07             	add    $0x7,%eax
   17a7e:	8d 50 07             	lea    0x7(%eax),%edx
   17a81:	85 c0                	test   %eax,%eax
   17a83:	0f 48 c2             	cmovs  %edx,%eax
   17a86:	c1 f8 03             	sar    $0x3,%eax
}
   17a89:	5d                   	pop    %ebp
   17a8a:	c3                   	ret    

00017a8b <bitmap_init>:

void bitmap_init(bitmap_t* bitmap,uint8_t* bits,int count,int init_bit){
   17a8b:	55                   	push   %ebp
   17a8c:	89 e5                	mov    %esp,%ebp
   17a8e:	83 ec 18             	sub    $0x18,%esp
    bitmap->bit_count=count;
   17a91:	8b 45 08             	mov    0x8(%ebp),%eax
   17a94:	8b 55 10             	mov    0x10(%ebp),%edx
   17a97:	89 10                	mov    %edx,(%eax)
    bitmap->bits=bits;
   17a99:	8b 45 08             	mov    0x8(%ebp),%eax
   17a9c:	8b 55 0c             	mov    0xc(%ebp),%edx
   17a9f:	89 50 04             	mov    %edx,0x4(%eax)
    int bytes=bitmap_byte_count(bitmap->bit_count);
   17aa2:	8b 45 08             	mov    0x8(%ebp),%eax
   17aa5:	8b 00                	mov    (%eax),%eax
   17aa7:	50                   	push   %eax
   17aa8:	e8 c8 ff ff ff       	call   17a75 <bitmap_byte_count>
   17aad:	83 c4 04             	add    $0x4,%esp
   17ab0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_memset(bitmap->bits,init_bit? 0xFF : 0,bytes);
   17ab3:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   17ab7:	74 07                	je     17ac0 <bitmap_init+0x35>
   17ab9:	ba ff 00 00 00       	mov    $0xff,%edx
   17abe:	eb 05                	jmp    17ac5 <bitmap_init+0x3a>
   17ac0:	ba 00 00 00 00       	mov    $0x0,%edx
   17ac5:	8b 45 08             	mov    0x8(%ebp),%eax
   17ac8:	8b 40 04             	mov    0x4(%eax),%eax
   17acb:	83 ec 04             	sub    $0x4,%esp
   17ace:	ff 75 f4             	pushl  -0xc(%ebp)
   17ad1:	52                   	push   %edx
   17ad2:	50                   	push   %eax
   17ad3:	e8 d0 03 00 00       	call   17ea8 <kernel_memset>
   17ad8:	83 c4 10             	add    $0x10,%esp
}
   17adb:	90                   	nop
   17adc:	c9                   	leave  
   17add:	c3                   	ret    

00017ade <bitmap_get_bit>:

int bitmap_get_bit(bitmap_t* bitmap,int index){
   17ade:	55                   	push   %ebp
   17adf:	89 e5                	mov    %esp,%ebp
   17ae1:	53                   	push   %ebx
    if(index>bitmap->bit_count) return -1;
   17ae2:	8b 45 08             	mov    0x8(%ebp),%eax
   17ae5:	8b 00                	mov    (%eax),%eax
   17ae7:	39 45 0c             	cmp    %eax,0xc(%ebp)
   17aea:	7e 07                	jle    17af3 <bitmap_get_bit+0x15>
   17aec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17af1:	eb 37                	jmp    17b2a <bitmap_get_bit+0x4c>
    return bitmap->bits[index/8] & (1<<(index % 8));
   17af3:	8b 45 08             	mov    0x8(%ebp),%eax
   17af6:	8b 50 04             	mov    0x4(%eax),%edx
   17af9:	8b 45 0c             	mov    0xc(%ebp),%eax
   17afc:	8d 48 07             	lea    0x7(%eax),%ecx
   17aff:	85 c0                	test   %eax,%eax
   17b01:	0f 48 c1             	cmovs  %ecx,%eax
   17b04:	c1 f8 03             	sar    $0x3,%eax
   17b07:	01 d0                	add    %edx,%eax
   17b09:	0f b6 00             	movzbl (%eax),%eax
   17b0c:	0f b6 d8             	movzbl %al,%ebx
   17b0f:	8b 45 0c             	mov    0xc(%ebp),%eax
   17b12:	99                   	cltd   
   17b13:	c1 ea 1d             	shr    $0x1d,%edx
   17b16:	01 d0                	add    %edx,%eax
   17b18:	83 e0 07             	and    $0x7,%eax
   17b1b:	29 d0                	sub    %edx,%eax
   17b1d:	ba 01 00 00 00       	mov    $0x1,%edx
   17b22:	89 c1                	mov    %eax,%ecx
   17b24:	d3 e2                	shl    %cl,%edx
   17b26:	89 d0                	mov    %edx,%eax
   17b28:	21 d8                	and    %ebx,%eax
}
   17b2a:	5b                   	pop    %ebx
   17b2b:	5d                   	pop    %ebp
   17b2c:	c3                   	ret    

00017b2d <bitmap_set_bit>:

void bitmap_set_bit(bitmap_t* bitmap,int index,int count,int bit){
   17b2d:	55                   	push   %ebp
   17b2e:	89 e5                	mov    %esp,%ebp
   17b30:	56                   	push   %esi
   17b31:	53                   	push   %ebx
   17b32:	83 ec 10             	sub    $0x10,%esp
    if(index+count>bitmap->bit_count) return;
   17b35:	8b 55 0c             	mov    0xc(%ebp),%edx
   17b38:	8b 45 10             	mov    0x10(%ebp),%eax
   17b3b:	01 c2                	add    %eax,%edx
   17b3d:	8b 45 08             	mov    0x8(%ebp),%eax
   17b40:	8b 00                	mov    (%eax),%eax
   17b42:	39 c2                	cmp    %eax,%edx
   17b44:	0f 8f c6 00 00 00    	jg     17c10 <bitmap_set_bit+0xe3>
    for(int i=0;(i<count) && (index<bitmap->bit_count);i++,index++){
   17b4a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   17b51:	e9 a2 00 00 00       	jmp    17bf8 <bitmap_set_bit+0xcb>
        if(bit){
   17b56:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   17b5a:	74 4a                	je     17ba6 <bitmap_set_bit+0x79>
            bitmap->bits[index/8] |=(1<<(index%8));
   17b5c:	8b 45 08             	mov    0x8(%ebp),%eax
   17b5f:	8b 50 04             	mov    0x4(%eax),%edx
   17b62:	8b 45 0c             	mov    0xc(%ebp),%eax
   17b65:	8d 48 07             	lea    0x7(%eax),%ecx
   17b68:	85 c0                	test   %eax,%eax
   17b6a:	0f 48 c1             	cmovs  %ecx,%eax
   17b6d:	c1 f8 03             	sar    $0x3,%eax
   17b70:	89 c3                	mov    %eax,%ebx
   17b72:	89 d8                	mov    %ebx,%eax
   17b74:	01 d0                	add    %edx,%eax
   17b76:	0f b6 00             	movzbl (%eax),%eax
   17b79:	89 c6                	mov    %eax,%esi
   17b7b:	8b 45 0c             	mov    0xc(%ebp),%eax
   17b7e:	99                   	cltd   
   17b7f:	c1 ea 1d             	shr    $0x1d,%edx
   17b82:	01 d0                	add    %edx,%eax
   17b84:	83 e0 07             	and    $0x7,%eax
   17b87:	29 d0                	sub    %edx,%eax
   17b89:	ba 01 00 00 00       	mov    $0x1,%edx
   17b8e:	89 c1                	mov    %eax,%ecx
   17b90:	d3 e2                	shl    %cl,%edx
   17b92:	89 d0                	mov    %edx,%eax
   17b94:	89 f2                	mov    %esi,%edx
   17b96:	09 c2                	or     %eax,%edx
   17b98:	8b 45 08             	mov    0x8(%ebp),%eax
   17b9b:	8b 40 04             	mov    0x4(%eax),%eax
   17b9e:	89 d9                	mov    %ebx,%ecx
   17ba0:	01 c8                	add    %ecx,%eax
   17ba2:	88 10                	mov    %dl,(%eax)
   17ba4:	eb 4a                	jmp    17bf0 <bitmap_set_bit+0xc3>
        }
        else{
            bitmap->bits[index/8]&=~(1<<(index%8));
   17ba6:	8b 45 08             	mov    0x8(%ebp),%eax
   17ba9:	8b 50 04             	mov    0x4(%eax),%edx
   17bac:	8b 45 0c             	mov    0xc(%ebp),%eax
   17baf:	8d 48 07             	lea    0x7(%eax),%ecx
   17bb2:	85 c0                	test   %eax,%eax
   17bb4:	0f 48 c1             	cmovs  %ecx,%eax
   17bb7:	c1 f8 03             	sar    $0x3,%eax
   17bba:	89 c3                	mov    %eax,%ebx
   17bbc:	89 d8                	mov    %ebx,%eax
   17bbe:	01 d0                	add    %edx,%eax
   17bc0:	0f b6 00             	movzbl (%eax),%eax
   17bc3:	89 c6                	mov    %eax,%esi
   17bc5:	8b 45 0c             	mov    0xc(%ebp),%eax
   17bc8:	99                   	cltd   
   17bc9:	c1 ea 1d             	shr    $0x1d,%edx
   17bcc:	01 d0                	add    %edx,%eax
   17bce:	83 e0 07             	and    $0x7,%eax
   17bd1:	29 d0                	sub    %edx,%eax
   17bd3:	ba 01 00 00 00       	mov    $0x1,%edx
   17bd8:	89 c1                	mov    %eax,%ecx
   17bda:	d3 e2                	shl    %cl,%edx
   17bdc:	89 d0                	mov    %edx,%eax
   17bde:	f7 d0                	not    %eax
   17be0:	89 f2                	mov    %esi,%edx
   17be2:	21 c2                	and    %eax,%edx
   17be4:	8b 45 08             	mov    0x8(%ebp),%eax
   17be7:	8b 40 04             	mov    0x4(%eax),%eax
   17bea:	89 d9                	mov    %ebx,%ecx
   17bec:	01 c8                	add    %ecx,%eax
   17bee:	88 10                	mov    %dl,(%eax)
    for(int i=0;(i<count) && (index<bitmap->bit_count);i++,index++){
   17bf0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   17bf4:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
   17bf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17bfb:	3b 45 10             	cmp    0x10(%ebp),%eax
   17bfe:	7d 11                	jge    17c11 <bitmap_set_bit+0xe4>
   17c00:	8b 45 08             	mov    0x8(%ebp),%eax
   17c03:	8b 00                	mov    (%eax),%eax
   17c05:	39 45 0c             	cmp    %eax,0xc(%ebp)
   17c08:	0f 8c 48 ff ff ff    	jl     17b56 <bitmap_set_bit+0x29>
   17c0e:	eb 01                	jmp    17c11 <bitmap_set_bit+0xe4>
    if(index+count>bitmap->bit_count) return;
   17c10:	90                   	nop
        }
    }
}
   17c11:	83 c4 10             	add    $0x10,%esp
   17c14:	5b                   	pop    %ebx
   17c15:	5e                   	pop    %esi
   17c16:	5d                   	pop    %ebp
   17c17:	c3                   	ret    

00017c18 <bitmap_is_set>:

int bitmap_is_set(bitmap_t* bitmap,int index){
   17c18:	55                   	push   %ebp
   17c19:	89 e5                	mov    %esp,%ebp
    return bitmap_get_bit(bitmap,index) ? 1 : 0;
   17c1b:	ff 75 0c             	pushl  0xc(%ebp)
   17c1e:	ff 75 08             	pushl  0x8(%ebp)
   17c21:	e8 b8 fe ff ff       	call   17ade <bitmap_get_bit>
   17c26:	83 c4 08             	add    $0x8,%esp
   17c29:	85 c0                	test   %eax,%eax
   17c2b:	0f 95 c0             	setne  %al
   17c2e:	0f b6 c0             	movzbl %al,%eax
}
   17c31:	c9                   	leave  
   17c32:	c3                   	ret    

00017c33 <bitmap_alloc_nbits>:

int bitmap_alloc_nbits(bitmap_t* bitmap,int bit,int count){
   17c33:	55                   	push   %ebp
   17c34:	89 e5                	mov    %esp,%ebp
   17c36:	83 ec 10             	sub    $0x10,%esp
    int search_idx = 0;
   17c39:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int ok_idx = -1;
   17c40:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)

    while (search_idx < bitmap->bit_count) {
   17c47:	e9 85 00 00 00       	jmp    17cd1 <bitmap_alloc_nbits+0x9e>
        if (bitmap_get_bit(bitmap, search_idx) != bit) {
   17c4c:	ff 75 fc             	pushl  -0x4(%ebp)
   17c4f:	ff 75 08             	pushl  0x8(%ebp)
   17c52:	e8 87 fe ff ff       	call   17ade <bitmap_get_bit>
   17c57:	83 c4 08             	add    $0x8,%esp
   17c5a:	39 45 0c             	cmp    %eax,0xc(%ebp)
   17c5d:	74 06                	je     17c65 <bitmap_alloc_nbits+0x32>
            search_idx++;
   17c5f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
            continue;
   17c63:	eb 6c                	jmp    17cd1 <bitmap_alloc_nbits+0x9e>
        }

        ok_idx = search_idx;
   17c65:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17c68:	89 45 f8             	mov    %eax,-0x8(%ebp)

        int i;
        for (i = 1; (i < count) && (search_idx < bitmap->bit_count); i++) {
   17c6b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   17c72:	eb 27                	jmp    17c9b <bitmap_alloc_nbits+0x68>
            if (bitmap_get_bit(bitmap, search_idx++) != bit) {
   17c74:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17c77:	8d 50 01             	lea    0x1(%eax),%edx
   17c7a:	89 55 fc             	mov    %edx,-0x4(%ebp)
   17c7d:	50                   	push   %eax
   17c7e:	ff 75 08             	pushl  0x8(%ebp)
   17c81:	e8 58 fe ff ff       	call   17ade <bitmap_get_bit>
   17c86:	83 c4 08             	add    $0x8,%esp
   17c89:	39 45 0c             	cmp    %eax,0xc(%ebp)
   17c8c:	74 09                	je     17c97 <bitmap_alloc_nbits+0x64>
                ok_idx = -1;
   17c8e:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
                break;
   17c95:	eb 16                	jmp    17cad <bitmap_alloc_nbits+0x7a>
        for (i = 1; (i < count) && (search_idx < bitmap->bit_count); i++) {
   17c97:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   17c9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17c9e:	3b 45 10             	cmp    0x10(%ebp),%eax
   17ca1:	7d 0a                	jge    17cad <bitmap_alloc_nbits+0x7a>
   17ca3:	8b 45 08             	mov    0x8(%ebp),%eax
   17ca6:	8b 00                	mov    (%eax),%eax
   17ca8:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   17cab:	7c c7                	jl     17c74 <bitmap_alloc_nbits+0x41>
            }
        }
        
        if (i >= count) {
   17cad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17cb0:	3b 45 10             	cmp    0x10(%ebp),%eax
   17cb3:	7c 1c                	jl     17cd1 <bitmap_alloc_nbits+0x9e>
            bitmap_set_bit(bitmap, ok_idx, count, ~bit);
   17cb5:	8b 45 0c             	mov    0xc(%ebp),%eax
   17cb8:	f7 d0                	not    %eax
   17cba:	50                   	push   %eax
   17cbb:	ff 75 10             	pushl  0x10(%ebp)
   17cbe:	ff 75 f8             	pushl  -0x8(%ebp)
   17cc1:	ff 75 08             	pushl  0x8(%ebp)
   17cc4:	e8 64 fe ff ff       	call   17b2d <bitmap_set_bit>
   17cc9:	83 c4 10             	add    $0x10,%esp
            return ok_idx;
   17ccc:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17ccf:	eb 13                	jmp    17ce4 <bitmap_alloc_nbits+0xb1>
    while (search_idx < bitmap->bit_count) {
   17cd1:	8b 45 08             	mov    0x8(%ebp),%eax
   17cd4:	8b 00                	mov    (%eax),%eax
   17cd6:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   17cd9:	0f 8c 6d ff ff ff    	jl     17c4c <bitmap_alloc_nbits+0x19>
        }
    }

    return -1;
   17cdf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17ce4:	c9                   	leave  
   17ce5:	c3                   	ret    

00017ce6 <hlt>:
static inline void hlt(void){
   17ce6:	55                   	push   %ebp
   17ce7:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("hlt");
   17ce9:	f4                   	hlt    
}
   17cea:	90                   	nop
   17ceb:	5d                   	pop    %ebp
   17cec:	c3                   	ret    

00017ced <kernel_strcpy>:
#include "tools/klib.h"

// 复制字符串
void kernel_strcpy(char* dest,const char* src){
   17ced:	55                   	push   %ebp
   17cee:	89 e5                	mov    %esp,%ebp
    if(!dest || !src){
   17cf0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   17cf4:	74 3b                	je     17d31 <kernel_strcpy+0x44>
   17cf6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   17cfa:	74 35                	je     17d31 <kernel_strcpy+0x44>
        return;
    }
    while(*dest&&*src){
   17cfc:	eb 17                	jmp    17d15 <kernel_strcpy+0x28>
        *dest++=*src++;
   17cfe:	8b 55 0c             	mov    0xc(%ebp),%edx
   17d01:	8d 42 01             	lea    0x1(%edx),%eax
   17d04:	89 45 0c             	mov    %eax,0xc(%ebp)
   17d07:	8b 45 08             	mov    0x8(%ebp),%eax
   17d0a:	8d 48 01             	lea    0x1(%eax),%ecx
   17d0d:	89 4d 08             	mov    %ecx,0x8(%ebp)
   17d10:	0f b6 12             	movzbl (%edx),%edx
   17d13:	88 10                	mov    %dl,(%eax)
    while(*dest&&*src){
   17d15:	8b 45 08             	mov    0x8(%ebp),%eax
   17d18:	0f b6 00             	movzbl (%eax),%eax
   17d1b:	84 c0                	test   %al,%al
   17d1d:	74 0a                	je     17d29 <kernel_strcpy+0x3c>
   17d1f:	8b 45 0c             	mov    0xc(%ebp),%eax
   17d22:	0f b6 00             	movzbl (%eax),%eax
   17d25:	84 c0                	test   %al,%al
   17d27:	75 d5                	jne    17cfe <kernel_strcpy+0x11>
    }
    *dest='\0';
   17d29:	8b 45 08             	mov    0x8(%ebp),%eax
   17d2c:	c6 00 00             	movb   $0x0,(%eax)
   17d2f:	eb 01                	jmp    17d32 <kernel_strcpy+0x45>
        return;
   17d31:	90                   	nop
}
   17d32:	5d                   	pop    %ebp
   17d33:	c3                   	ret    

00017d34 <kernel_strncpy>:

// 复制字符串指明复制多个字符
void kernel_strncpy(char* dest,const char* src,unsigned int size){
   17d34:	55                   	push   %ebp
   17d35:	89 e5                	mov    %esp,%ebp
   17d37:	83 ec 10             	sub    $0x10,%esp
    if(!dest||!src||!size){
   17d3a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   17d3e:	74 61                	je     17da1 <kernel_strncpy+0x6d>
   17d40:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   17d44:	74 5b                	je     17da1 <kernel_strncpy+0x6d>
   17d46:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   17d4a:	74 55                	je     17da1 <kernel_strncpy+0x6d>
        return;
    }
    char*d=dest;
   17d4c:	8b 45 08             	mov    0x8(%ebp),%eax
   17d4f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    const char* s=src;
   17d52:	8b 45 0c             	mov    0xc(%ebp),%eax
   17d55:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while((size-->0)&&(*s)){
   17d58:	eb 17                	jmp    17d71 <kernel_strncpy+0x3d>
        *d++=*s++;
   17d5a:	8b 55 f8             	mov    -0x8(%ebp),%edx
   17d5d:	8d 42 01             	lea    0x1(%edx),%eax
   17d60:	89 45 f8             	mov    %eax,-0x8(%ebp)
   17d63:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17d66:	8d 48 01             	lea    0x1(%eax),%ecx
   17d69:	89 4d fc             	mov    %ecx,-0x4(%ebp)
   17d6c:	0f b6 12             	movzbl (%edx),%edx
   17d6f:	88 10                	mov    %dl,(%eax)
    while((size-->0)&&(*s)){
   17d71:	8b 45 10             	mov    0x10(%ebp),%eax
   17d74:	8d 50 ff             	lea    -0x1(%eax),%edx
   17d77:	89 55 10             	mov    %edx,0x10(%ebp)
   17d7a:	85 c0                	test   %eax,%eax
   17d7c:	74 0a                	je     17d88 <kernel_strncpy+0x54>
   17d7e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17d81:	0f b6 00             	movzbl (%eax),%eax
   17d84:	84 c0                	test   %al,%al
   17d86:	75 d2                	jne    17d5a <kernel_strncpy+0x26>
    }
    if(size==0){
   17d88:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   17d8c:	75 0b                	jne    17d99 <kernel_strncpy+0x65>
        *(d-1)='\0';
   17d8e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17d91:	83 e8 01             	sub    $0x1,%eax
   17d94:	c6 00 00             	movb   $0x0,(%eax)
   17d97:	eb 09                	jmp    17da2 <kernel_strncpy+0x6e>
    }
    else{
        *d='\0';
   17d99:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17d9c:	c6 00 00             	movb   $0x0,(%eax)
   17d9f:	eb 01                	jmp    17da2 <kernel_strncpy+0x6e>
        return;
   17da1:	90                   	nop
    }
}
   17da2:	c9                   	leave  
   17da3:	c3                   	ret    

00017da4 <kernel_strncmp>:
 * @brief 字符串比较函数
 * @param s1 字符串1
 * @param s2 字符串2
 * @param size 比较的长度
 */
int kernel_strncmp(const char* s1,const char* s2,unsigned int size){
   17da4:	55                   	push   %ebp
   17da5:	89 e5                	mov    %esp,%ebp
    if(!s1 || !s2){
   17da7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   17dab:	74 06                	je     17db3 <kernel_strncmp+0xf>
   17dad:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   17db1:	75 0f                	jne    17dc2 <kernel_strncmp+0x1e>
        return -1;
   17db3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17db8:	eb 62                	jmp    17e1c <kernel_strncmp+0x78>
    }
    while(*s1 && *s2 && (*s1==*s2) && size){
        s1++;
   17dba:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        s2++;
   17dbe:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    while(*s1 && *s2 && (*s1==*s2) && size){
   17dc2:	8b 45 08             	mov    0x8(%ebp),%eax
   17dc5:	0f b6 00             	movzbl (%eax),%eax
   17dc8:	84 c0                	test   %al,%al
   17dca:	74 20                	je     17dec <kernel_strncmp+0x48>
   17dcc:	8b 45 0c             	mov    0xc(%ebp),%eax
   17dcf:	0f b6 00             	movzbl (%eax),%eax
   17dd2:	84 c0                	test   %al,%al
   17dd4:	74 16                	je     17dec <kernel_strncmp+0x48>
   17dd6:	8b 45 08             	mov    0x8(%ebp),%eax
   17dd9:	0f b6 10             	movzbl (%eax),%edx
   17ddc:	8b 45 0c             	mov    0xc(%ebp),%eax
   17ddf:	0f b6 00             	movzbl (%eax),%eax
   17de2:	38 c2                	cmp    %al,%dl
   17de4:	75 06                	jne    17dec <kernel_strncmp+0x48>
   17de6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   17dea:	75 ce                	jne    17dba <kernel_strncmp+0x16>
    }
    // 相等返回1
    return !((*s1=='\0') || (*s2=='\0') || (*s1==*s2));
   17dec:	8b 45 08             	mov    0x8(%ebp),%eax
   17def:	0f b6 00             	movzbl (%eax),%eax
   17df2:	84 c0                	test   %al,%al
   17df4:	74 21                	je     17e17 <kernel_strncmp+0x73>
   17df6:	8b 45 0c             	mov    0xc(%ebp),%eax
   17df9:	0f b6 00             	movzbl (%eax),%eax
   17dfc:	84 c0                	test   %al,%al
   17dfe:	74 17                	je     17e17 <kernel_strncmp+0x73>
   17e00:	8b 45 08             	mov    0x8(%ebp),%eax
   17e03:	0f b6 10             	movzbl (%eax),%edx
   17e06:	8b 45 0c             	mov    0xc(%ebp),%eax
   17e09:	0f b6 00             	movzbl (%eax),%eax
   17e0c:	38 c2                	cmp    %al,%dl
   17e0e:	74 07                	je     17e17 <kernel_strncmp+0x73>
   17e10:	b8 01 00 00 00       	mov    $0x1,%eax
   17e15:	eb 05                	jmp    17e1c <kernel_strncmp+0x78>
   17e17:	b8 00 00 00 00       	mov    $0x0,%eax
}
   17e1c:	5d                   	pop    %ebp
   17e1d:	c3                   	ret    

00017e1e <kernel_strlen>:
 * @brief 获取字符串的长度
 * @param str 要获取长度的字符串
 * @return 字符串的长度
 * @note 如果字符串为空，返回0
 */
int kernel_strlen(const char* str){
   17e1e:	55                   	push   %ebp
   17e1f:	89 e5                	mov    %esp,%ebp
   17e21:	83 ec 10             	sub    $0x10,%esp
    if(!str){
   17e24:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   17e28:	75 07                	jne    17e31 <kernel_strlen+0x13>
        return 0;
   17e2a:	b8 00 00 00 00       	mov    $0x0,%eax
   17e2f:	eb 26                	jmp    17e57 <kernel_strlen+0x39>
    }
    const char*c=str;
   17e31:	8b 45 08             	mov    0x8(%ebp),%eax
   17e34:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int len=0;
   17e37:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    while(*c++){
   17e3e:	eb 04                	jmp    17e44 <kernel_strlen+0x26>
        len++;
   17e40:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while(*c++){
   17e44:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17e47:	8d 50 01             	lea    0x1(%eax),%edx
   17e4a:	89 55 fc             	mov    %edx,-0x4(%ebp)
   17e4d:	0f b6 00             	movzbl (%eax),%eax
   17e50:	84 c0                	test   %al,%al
   17e52:	75 ec                	jne    17e40 <kernel_strlen+0x22>
    }
    return len;
   17e54:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
   17e57:	c9                   	leave  
   17e58:	c3                   	ret    

00017e59 <kernel_memcpy>:

// 复制内存的值
void kernel_memcpy(void* dest,void* src,unsigned int size){
   17e59:	55                   	push   %ebp
   17e5a:	89 e5                	mov    %esp,%ebp
   17e5c:	83 ec 10             	sub    $0x10,%esp
    if(!dest || !src || !size){
   17e5f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   17e63:	74 40                	je     17ea5 <kernel_memcpy+0x4c>
   17e65:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   17e69:	74 3a                	je     17ea5 <kernel_memcpy+0x4c>
   17e6b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   17e6f:	74 34                	je     17ea5 <kernel_memcpy+0x4c>
        return;
    }
    uint8_t* s=(uint8_t*) src;
   17e71:	8b 45 0c             	mov    0xc(%ebp),%eax
   17e74:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t* d=(uint8_t*) dest;
   17e77:	8b 45 08             	mov    0x8(%ebp),%eax
   17e7a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(size--){
   17e7d:	eb 17                	jmp    17e96 <kernel_memcpy+0x3d>
        *d++=*s++;
   17e7f:	8b 55 fc             	mov    -0x4(%ebp),%edx
   17e82:	8d 42 01             	lea    0x1(%edx),%eax
   17e85:	89 45 fc             	mov    %eax,-0x4(%ebp)
   17e88:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17e8b:	8d 48 01             	lea    0x1(%eax),%ecx
   17e8e:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   17e91:	0f b6 12             	movzbl (%edx),%edx
   17e94:	88 10                	mov    %dl,(%eax)
    while(size--){
   17e96:	8b 45 10             	mov    0x10(%ebp),%eax
   17e99:	8d 50 ff             	lea    -0x1(%eax),%edx
   17e9c:	89 55 10             	mov    %edx,0x10(%ebp)
   17e9f:	85 c0                	test   %eax,%eax
   17ea1:	75 dc                	jne    17e7f <kernel_memcpy+0x26>
   17ea3:	eb 01                	jmp    17ea6 <kernel_memcpy+0x4d>
        return;
   17ea5:	90                   	nop
    }
    
}
   17ea6:	c9                   	leave  
   17ea7:	c3                   	ret    

00017ea8 <kernel_memset>:

// 设置内存的值
void kernel_memset(void* dest,uint8_t v,int size){
   17ea8:	55                   	push   %ebp
   17ea9:	89 e5                	mov    %esp,%ebp
   17eab:	83 ec 14             	sub    $0x14,%esp
   17eae:	8b 45 0c             	mov    0xc(%ebp),%eax
   17eb1:	88 45 ec             	mov    %al,-0x14(%ebp)
    if(!dest || !size){
   17eb4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   17eb8:	74 2c                	je     17ee6 <kernel_memset+0x3e>
   17eba:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   17ebe:	74 26                	je     17ee6 <kernel_memset+0x3e>
        return;
    }
    uint8_t* d=(uint8_t*) dest;
   17ec0:	8b 45 08             	mov    0x8(%ebp),%eax
   17ec3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(size--){
   17ec6:	eb 0f                	jmp    17ed7 <kernel_memset+0x2f>
        *d++=v;
   17ec8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17ecb:	8d 50 01             	lea    0x1(%eax),%edx
   17ece:	89 55 fc             	mov    %edx,-0x4(%ebp)
   17ed1:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
   17ed5:	88 10                	mov    %dl,(%eax)
    while(size--){
   17ed7:	8b 45 10             	mov    0x10(%ebp),%eax
   17eda:	8d 50 ff             	lea    -0x1(%eax),%edx
   17edd:	89 55 10             	mov    %edx,0x10(%ebp)
   17ee0:	85 c0                	test   %eax,%eax
   17ee2:	75 e4                	jne    17ec8 <kernel_memset+0x20>
   17ee4:	eb 01                	jmp    17ee7 <kernel_memset+0x3f>
        return;
   17ee6:	90                   	nop
    }
}
   17ee7:	c9                   	leave  
   17ee8:	c3                   	ret    

00017ee9 <kernel_memcmp>:

// 比较内存的值
int kernel_memcmp(void* d1,void* d2,unsigned int size){
   17ee9:	55                   	push   %ebp
   17eea:	89 e5                	mov    %esp,%ebp
   17eec:	83 ec 10             	sub    $0x10,%esp
     if(!d1 || !d2 || !size){
   17eef:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   17ef3:	74 0c                	je     17f01 <kernel_memcmp+0x18>
   17ef5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   17ef9:	74 06                	je     17f01 <kernel_memcmp+0x18>
   17efb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   17eff:	75 07                	jne    17f08 <kernel_memcmp+0x1f>
        return 1;
   17f01:	b8 01 00 00 00       	mov    $0x1,%eax
   17f06:	eb 43                	jmp    17f4b <kernel_memcmp+0x62>
    }
    uint8_t* p_d1=(uint8_t*) d1;
   17f08:	8b 45 08             	mov    0x8(%ebp),%eax
   17f0b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t* p_d2=(uint8_t*) d2;
   17f0e:	8b 45 0c             	mov    0xc(%ebp),%eax
   17f11:	89 45 f8             	mov    %eax,-0x8(%ebp)
    // 不同返回1，相同返回0
    while(size--){
   17f14:	eb 23                	jmp    17f39 <kernel_memcmp+0x50>
        if(*p_d1++!=*p_d2++){
   17f16:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17f19:	8d 50 01             	lea    0x1(%eax),%edx
   17f1c:	89 55 fc             	mov    %edx,-0x4(%ebp)
   17f1f:	0f b6 08             	movzbl (%eax),%ecx
   17f22:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17f25:	8d 50 01             	lea    0x1(%eax),%edx
   17f28:	89 55 f8             	mov    %edx,-0x8(%ebp)
   17f2b:	0f b6 00             	movzbl (%eax),%eax
   17f2e:	38 c1                	cmp    %al,%cl
   17f30:	74 07                	je     17f39 <kernel_memcmp+0x50>
            return 1;
   17f32:	b8 01 00 00 00       	mov    $0x1,%eax
   17f37:	eb 12                	jmp    17f4b <kernel_memcmp+0x62>
    while(size--){
   17f39:	8b 45 10             	mov    0x10(%ebp),%eax
   17f3c:	8d 50 ff             	lea    -0x1(%eax),%edx
   17f3f:	89 55 10             	mov    %edx,0x10(%ebp)
   17f42:	85 c0                	test   %eax,%eax
   17f44:	75 d0                	jne    17f16 <kernel_memcmp+0x2d>
        }
    }
    return 0;
   17f46:	b8 00 00 00 00       	mov    $0x0,%eax
}
   17f4b:	c9                   	leave  
   17f4c:	c3                   	ret    

00017f4d <kernel_sprintf>:

void kernel_sprintf(char* buf,const char* fmt,...){
   17f4d:	55                   	push   %ebp
   17f4e:	89 e5                	mov    %esp,%ebp
   17f50:	83 ec 18             	sub    $0x18,%esp
    va_list args;
    va_start(args,fmt);
   17f53:	8d 45 10             	lea    0x10(%ebp),%eax
   17f56:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_vsprintf(buf,fmt,args);
   17f59:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17f5c:	83 ec 04             	sub    $0x4,%esp
   17f5f:	50                   	push   %eax
   17f60:	ff 75 0c             	pushl  0xc(%ebp)
   17f63:	ff 75 08             	pushl  0x8(%ebp)
   17f66:	e8 45 01 00 00       	call   180b0 <kernel_vsprintf>
   17f6b:	83 c4 10             	add    $0x10,%esp
    va_end(args);
}
   17f6e:	90                   	nop
   17f6f:	c9                   	leave  
   17f70:	c3                   	ret    

00017f71 <kernel_itoa>:

void kernel_itoa(char * buf, int num, int base) {
   17f71:	55                   	push   %ebp
   17f72:	89 e5                	mov    %esp,%ebp
   17f74:	53                   	push   %ebx
   17f75:	83 ec 20             	sub    $0x20,%esp
    static const char * num2ch = {"FEDCBA9876543210123456789ABCDEF"};
    char * p = buf;
   17f78:	8b 45 08             	mov    0x8(%ebp),%eax
   17f7b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int old_num = num;
   17f7e:	8b 45 0c             	mov    0xc(%ebp),%eax
   17f81:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if ((base != 2) && (base != 8) && (base != 10) && (base != 16)) {
   17f84:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   17f88:	74 1d                	je     17fa7 <kernel_itoa+0x36>
   17f8a:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
   17f8e:	74 17                	je     17fa7 <kernel_itoa+0x36>
   17f90:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   17f94:	74 11                	je     17fa7 <kernel_itoa+0x36>
   17f96:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
   17f9a:	74 0b                	je     17fa7 <kernel_itoa+0x36>
        *p = '\0';
   17f9c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17f9f:	c6 00 00             	movb   $0x0,(%eax)
        return;
   17fa2:	e9 03 01 00 00       	jmp    180aa <kernel_itoa+0x139>
    }

    int signed_num = 0;
   17fa7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if ((num < 0) && (base == 10)) {
   17fae:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   17fb2:	79 19                	jns    17fcd <kernel_itoa+0x5c>
   17fb4:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   17fb8:	75 13                	jne    17fcd <kernel_itoa+0x5c>
        *p++ = '-';
   17fba:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17fbd:	8d 50 01             	lea    0x1(%eax),%edx
   17fc0:	89 55 f8             	mov    %edx,-0x8(%ebp)
   17fc3:	c6 00 2d             	movb   $0x2d,(%eax)
        signed_num = 1;
   17fc6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    }

    if (signed_num) {
   17fcd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   17fd1:	74 3b                	je     1800e <kernel_itoa+0x9d>
        do {
            char ch = num2ch[num % base + 15];
   17fd3:	8b 0d 74 a1 01 00    	mov    0x1a174,%ecx
   17fd9:	8b 45 0c             	mov    0xc(%ebp),%eax
   17fdc:	99                   	cltd   
   17fdd:	f7 7d 10             	idivl  0x10(%ebp)
   17fe0:	89 d0                	mov    %edx,%eax
   17fe2:	83 c0 0f             	add    $0xf,%eax
   17fe5:	01 c8                	add    %ecx,%eax
   17fe7:	0f b6 00             	movzbl (%eax),%eax
   17fea:	88 45 e6             	mov    %al,-0x1a(%ebp)
            *p++ = ch;
   17fed:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17ff0:	8d 50 01             	lea    0x1(%eax),%edx
   17ff3:	89 55 f8             	mov    %edx,-0x8(%ebp)
   17ff6:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
   17ffa:	88 10                	mov    %dl,(%eax)
            num /= base;
   17ffc:	8b 45 0c             	mov    0xc(%ebp),%eax
   17fff:	99                   	cltd   
   18000:	f7 7d 10             	idivl  0x10(%ebp)
   18003:	89 45 0c             	mov    %eax,0xc(%ebp)
        } while (num);
   18006:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1800a:	75 c7                	jne    17fd3 <kernel_itoa+0x62>
   1800c:	eb 4b                	jmp    18059 <kernel_itoa+0xe8>
    } else {
        uint32_t u_num = (uint32_t)num;
   1800e:	8b 45 0c             	mov    0xc(%ebp),%eax
   18011:	89 45 f0             	mov    %eax,-0x10(%ebp)
        do {
            char ch = num2ch[u_num % base + 15];
   18014:	8b 0d 74 a1 01 00    	mov    0x1a174,%ecx
   1801a:	8b 5d 10             	mov    0x10(%ebp),%ebx
   1801d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18020:	ba 00 00 00 00       	mov    $0x0,%edx
   18025:	f7 f3                	div    %ebx
   18027:	89 d0                	mov    %edx,%eax
   18029:	83 c0 0f             	add    $0xf,%eax
   1802c:	01 c8                	add    %ecx,%eax
   1802e:	0f b6 00             	movzbl (%eax),%eax
   18031:	88 45 e7             	mov    %al,-0x19(%ebp)
            *p++ = ch;
   18034:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18037:	8d 50 01             	lea    0x1(%eax),%edx
   1803a:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1803d:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
   18041:	88 10                	mov    %dl,(%eax)
            u_num /= base;
   18043:	8b 5d 10             	mov    0x10(%ebp),%ebx
   18046:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18049:	ba 00 00 00 00       	mov    $0x0,%edx
   1804e:	f7 f3                	div    %ebx
   18050:	89 45 f0             	mov    %eax,-0x10(%ebp)
        } while (u_num);
   18053:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   18057:	75 bb                	jne    18014 <kernel_itoa+0xa3>
    }
    *p-- = '\0';
   18059:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1805c:	8d 50 ff             	lea    -0x1(%eax),%edx
   1805f:	89 55 f8             	mov    %edx,-0x8(%ebp)
   18062:	c6 00 00             	movb   $0x0,(%eax)

    char * start = (!signed_num) ? buf : buf + 1;
   18065:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   18069:	74 08                	je     18073 <kernel_itoa+0x102>
   1806b:	8b 45 08             	mov    0x8(%ebp),%eax
   1806e:	83 c0 01             	add    $0x1,%eax
   18071:	eb 03                	jmp    18076 <kernel_itoa+0x105>
   18073:	8b 45 08             	mov    0x8(%ebp),%eax
   18076:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while (start < p) {
   18079:	eb 27                	jmp    180a2 <kernel_itoa+0x131>
        char ch = *start;
   1807b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1807e:	0f b6 00             	movzbl (%eax),%eax
   18081:	88 45 e5             	mov    %al,-0x1b(%ebp)
        *start = *p;
   18084:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18087:	0f b6 10             	movzbl (%eax),%edx
   1808a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1808d:	88 10                	mov    %dl,(%eax)
        *p-- = ch;
   1808f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18092:	8d 50 ff             	lea    -0x1(%eax),%edx
   18095:	89 55 f8             	mov    %edx,-0x8(%ebp)
   18098:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
   1809c:	88 10                	mov    %dl,(%eax)
        start++;
   1809e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    while (start < p) {
   180a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   180a5:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   180a8:	72 d1                	jb     1807b <kernel_itoa+0x10a>
    }
}
   180aa:	83 c4 20             	add    $0x20,%esp
   180ad:	5b                   	pop    %ebx
   180ae:	5d                   	pop    %ebp
   180af:	c3                   	ret    

000180b0 <kernel_vsprintf>:

void kernel_vsprintf(char* buf,const char*fmt,va_list args){
   180b0:	55                   	push   %ebp
   180b1:	89 e5                	mov    %esp,%ebp
   180b3:	83 ec 20             	sub    $0x20,%esp
    enum {NORMAL,READ_FMT} state=NORMAL;
   180b6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    char* curr=buf;
   180bd:	8b 45 08             	mov    0x8(%ebp),%eax
   180c0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    char ch;
    while((ch=*fmt++)){
   180c3:	e9 17 01 00 00       	jmp    181df <kernel_vsprintf+0x12f>
       switch (state)
   180c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   180cb:	85 c0                	test   %eax,%eax
   180cd:	74 0a                	je     180d9 <kernel_vsprintf+0x29>
   180cf:	83 f8 01             	cmp    $0x1,%eax
   180d2:	74 2b                	je     180ff <kernel_vsprintf+0x4f>
   180d4:	e9 06 01 00 00       	jmp    181df <kernel_vsprintf+0x12f>
       {
            case NORMAL:
                if(ch=='%'){
   180d9:	80 7d ef 25          	cmpb   $0x25,-0x11(%ebp)
   180dd:	75 0c                	jne    180eb <kernel_vsprintf+0x3b>
                    state=READ_FMT;
   180df:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
   180e6:	e9 f4 00 00 00       	jmp    181df <kernel_vsprintf+0x12f>
                }
                else{
                    *curr++=ch;
   180eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   180ee:	8d 50 01             	lea    0x1(%eax),%edx
   180f1:	89 55 f8             	mov    %edx,-0x8(%ebp)
   180f4:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
   180f8:	88 10                	mov    %dl,(%eax)
                }
                break;
   180fa:	e9 e0 00 00 00       	jmp    181df <kernel_vsprintf+0x12f>
            case READ_FMT:
                if(ch=='s'){
   180ff:	80 7d ef 73          	cmpb   $0x73,-0x11(%ebp)
   18103:	75 47                	jne    1814c <kernel_vsprintf+0x9c>
                    const char*str=va_arg(args,char*);
   18105:	8b 45 10             	mov    0x10(%ebp),%eax
   18108:	8d 50 04             	lea    0x4(%eax),%edx
   1810b:	89 55 10             	mov    %edx,0x10(%ebp)
   1810e:	8b 00                	mov    (%eax),%eax
   18110:	89 45 f4             	mov    %eax,-0xc(%ebp)
                    int len=kernel_strlen(str);
   18113:	ff 75 f4             	pushl  -0xc(%ebp)
   18116:	e8 03 fd ff ff       	call   17e1e <kernel_strlen>
   1811b:	83 c4 04             	add    $0x4,%esp
   1811e:	89 45 f0             	mov    %eax,-0x10(%ebp)
                    while(len--){
   18121:	eb 17                	jmp    1813a <kernel_vsprintf+0x8a>
                        *curr++=*str++;
   18123:	8b 55 f4             	mov    -0xc(%ebp),%edx
   18126:	8d 42 01             	lea    0x1(%edx),%eax
   18129:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1812c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1812f:	8d 48 01             	lea    0x1(%eax),%ecx
   18132:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   18135:	0f b6 12             	movzbl (%edx),%edx
   18138:	88 10                	mov    %dl,(%eax)
                    while(len--){
   1813a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1813d:	8d 50 ff             	lea    -0x1(%eax),%edx
   18140:	89 55 f0             	mov    %edx,-0x10(%ebp)
   18143:	85 c0                	test   %eax,%eax
   18145:	75 dc                	jne    18123 <kernel_vsprintf+0x73>
   18147:	e9 8b 00 00 00       	jmp    181d7 <kernel_vsprintf+0x127>
                    }
                }
                else if(ch=='d'){
   1814c:	80 7d ef 64          	cmpb   $0x64,-0x11(%ebp)
   18150:	75 2e                	jne    18180 <kernel_vsprintf+0xd0>
                    int num=va_arg(args,int);
   18152:	8b 45 10             	mov    0x10(%ebp),%eax
   18155:	8d 50 04             	lea    0x4(%eax),%edx
   18158:	89 55 10             	mov    %edx,0x10(%ebp)
   1815b:	8b 00                	mov    (%eax),%eax
   1815d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                    kernel_itoa(curr,num,10);
   18160:	6a 0a                	push   $0xa
   18162:	ff 75 e4             	pushl  -0x1c(%ebp)
   18165:	ff 75 f8             	pushl  -0x8(%ebp)
   18168:	e8 04 fe ff ff       	call   17f71 <kernel_itoa>
   1816d:	83 c4 0c             	add    $0xc,%esp
                    curr+=kernel_strlen(curr);
   18170:	ff 75 f8             	pushl  -0x8(%ebp)
   18173:	e8 a6 fc ff ff       	call   17e1e <kernel_strlen>
   18178:	83 c4 04             	add    $0x4,%esp
   1817b:	01 45 f8             	add    %eax,-0x8(%ebp)
   1817e:	eb 57                	jmp    181d7 <kernel_vsprintf+0x127>
                }
                else if(ch=='x'){
   18180:	80 7d ef 78          	cmpb   $0x78,-0x11(%ebp)
   18184:	75 2e                	jne    181b4 <kernel_vsprintf+0x104>
                    int num=va_arg(args,int);
   18186:	8b 45 10             	mov    0x10(%ebp),%eax
   18189:	8d 50 04             	lea    0x4(%eax),%edx
   1818c:	89 55 10             	mov    %edx,0x10(%ebp)
   1818f:	8b 00                	mov    (%eax),%eax
   18191:	89 45 e8             	mov    %eax,-0x18(%ebp)
                    kernel_itoa(curr,num,16);
   18194:	6a 10                	push   $0x10
   18196:	ff 75 e8             	pushl  -0x18(%ebp)
   18199:	ff 75 f8             	pushl  -0x8(%ebp)
   1819c:	e8 d0 fd ff ff       	call   17f71 <kernel_itoa>
   181a1:	83 c4 0c             	add    $0xc,%esp
                    curr+=kernel_strlen(curr);
   181a4:	ff 75 f8             	pushl  -0x8(%ebp)
   181a7:	e8 72 fc ff ff       	call   17e1e <kernel_strlen>
   181ac:	83 c4 04             	add    $0x4,%esp
   181af:	01 45 f8             	add    %eax,-0x8(%ebp)
   181b2:	eb 23                	jmp    181d7 <kernel_vsprintf+0x127>
                }
                else if(ch=='c'){
   181b4:	80 7d ef 63          	cmpb   $0x63,-0x11(%ebp)
   181b8:	75 1d                	jne    181d7 <kernel_vsprintf+0x127>
                    char c=va_arg(args,int);
   181ba:	8b 45 10             	mov    0x10(%ebp),%eax
   181bd:	8d 50 04             	lea    0x4(%eax),%edx
   181c0:	89 55 10             	mov    %edx,0x10(%ebp)
   181c3:	8b 00                	mov    (%eax),%eax
   181c5:	88 45 ee             	mov    %al,-0x12(%ebp)
                    *curr++=c;
   181c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   181cb:	8d 50 01             	lea    0x1(%eax),%edx
   181ce:	89 55 f8             	mov    %edx,-0x8(%ebp)
   181d1:	0f b6 55 ee          	movzbl -0x12(%ebp),%edx
   181d5:	88 10                	mov    %dl,(%eax)
                }
                state=NORMAL;
   181d7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
                break;
   181de:	90                   	nop
    while((ch=*fmt++)){
   181df:	8b 45 0c             	mov    0xc(%ebp),%eax
   181e2:	8d 50 01             	lea    0x1(%eax),%edx
   181e5:	89 55 0c             	mov    %edx,0xc(%ebp)
   181e8:	0f b6 00             	movzbl (%eax),%eax
   181eb:	88 45 ef             	mov    %al,-0x11(%ebp)
   181ee:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
   181f2:	0f 85 d0 fe ff ff    	jne    180c8 <kernel_vsprintf+0x18>
        
       }
    }

}
   181f8:	90                   	nop
   181f9:	c9                   	leave  
   181fa:	c3                   	ret    

000181fb <panic>:

void panic (const char * file, int line, const char * func, const char * cond){
   181fb:	55                   	push   %ebp
   181fc:	89 e5                	mov    %esp,%ebp
   181fe:	83 ec 08             	sub    $0x8,%esp
    log_printf("assert failed!, %s\n",cond);
   18201:	83 ec 08             	sub    $0x8,%esp
   18204:	ff 75 14             	pushl  0x14(%ebp)
   18207:	68 68 95 01 00       	push   $0x19568
   1820c:	e8 ba 02 00 00       	call   184cb <log_printf>
   18211:	83 c4 10             	add    $0x10,%esp
    log_printf("file: %s\nline: %d\nfunc: %s\n",file,line,func);
   18214:	ff 75 10             	pushl  0x10(%ebp)
   18217:	ff 75 0c             	pushl  0xc(%ebp)
   1821a:	ff 75 08             	pushl  0x8(%ebp)
   1821d:	68 7c 95 01 00       	push   $0x1957c
   18222:	e8 a4 02 00 00       	call   184cb <log_printf>
   18227:	83 c4 10             	add    $0x10,%esp
    for(;;){
        hlt();
   1822a:	e8 b7 fa ff ff       	call   17ce6 <hlt>
   1822f:	eb f9                	jmp    1822a <panic+0x2f>

00018231 <string_count>:
    }
}

int string_count(char**start){
   18231:	55                   	push   %ebp
   18232:	89 e5                	mov    %esp,%ebp
   18234:	83 ec 10             	sub    $0x10,%esp
    int count=0;
   18237:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    if(start){
   1823e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   18242:	74 15                	je     18259 <string_count+0x28>
        while(*start++){
   18244:	eb 04                	jmp    1824a <string_count+0x19>
            count++;
   18246:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        while(*start++){
   1824a:	8b 45 08             	mov    0x8(%ebp),%eax
   1824d:	8d 50 04             	lea    0x4(%eax),%edx
   18250:	89 55 08             	mov    %edx,0x8(%ebp)
   18253:	8b 00                	mov    (%eax),%eax
   18255:	85 c0                	test   %eax,%eax
   18257:	75 ed                	jne    18246 <string_count+0x15>
        }
    }

    return count;
   18259:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1825c:	c9                   	leave  
   1825d:	c3                   	ret    

0001825e <get_file_name>:

char* get_file_name(char*name){
   1825e:	55                   	push   %ebp
   1825f:	89 e5                	mov    %esp,%ebp
   18261:	83 ec 10             	sub    $0x10,%esp
    char*s=name;
   18264:	8b 45 08             	mov    0x8(%ebp),%eax
   18267:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while(*s!='\0'){
   1826a:	eb 04                	jmp    18270 <get_file_name+0x12>
        s++;
   1826c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while(*s!='\0'){
   18270:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18273:	0f b6 00             	movzbl (%eax),%eax
   18276:	84 c0                	test   %al,%al
   18278:	75 f2                	jne    1826c <get_file_name+0xe>
    }

    while((*s!='/') && (*s!='\\') && (s>=name)){
   1827a:	eb 04                	jmp    18280 <get_file_name+0x22>
        s--;
   1827c:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    while((*s!='/') && (*s!='\\') && (s>=name)){
   18280:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18283:	0f b6 00             	movzbl (%eax),%eax
   18286:	3c 2f                	cmp    $0x2f,%al
   18288:	74 12                	je     1829c <get_file_name+0x3e>
   1828a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1828d:	0f b6 00             	movzbl (%eax),%eax
   18290:	3c 5c                	cmp    $0x5c,%al
   18292:	74 08                	je     1829c <get_file_name+0x3e>
   18294:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18297:	3b 45 08             	cmp    0x8(%ebp),%eax
   1829a:	73 e0                	jae    1827c <get_file_name+0x1e>
    }

    return s+1;
   1829c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1829f:	83 c0 01             	add    $0x1,%eax
   182a2:	c9                   	leave  
   182a3:	c3                   	ret    

000182a4 <list_is_empty>:
static inline int list_is_empty(list_t* list){
   182a4:	55                   	push   %ebp
   182a5:	89 e5                	mov    %esp,%ebp
    return list->count==0;
   182a7:	8b 45 08             	mov    0x8(%ebp),%eax
   182aa:	8b 40 08             	mov    0x8(%eax),%eax
   182ad:	85 c0                	test   %eax,%eax
   182af:	0f 94 c0             	sete   %al
   182b2:	0f b6 c0             	movzbl %al,%eax
}
   182b5:	5d                   	pop    %ebp
   182b6:	c3                   	ret    

000182b7 <list_init>:
#include "tools/list.h"

void list_init(list_t* list){
   182b7:	55                   	push   %ebp
   182b8:	89 e5                	mov    %esp,%ebp
    list->first=list->last=(list_node_t*)0;
   182ba:	8b 45 08             	mov    0x8(%ebp),%eax
   182bd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   182c4:	8b 45 08             	mov    0x8(%ebp),%eax
   182c7:	8b 50 04             	mov    0x4(%eax),%edx
   182ca:	8b 45 08             	mov    0x8(%ebp),%eax
   182cd:	89 10                	mov    %edx,(%eax)
    list->count=0;
   182cf:	8b 45 08             	mov    0x8(%ebp),%eax
   182d2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
   182d9:	90                   	nop
   182da:	5d                   	pop    %ebp
   182db:	c3                   	ret    

000182dc <list_insert_first>:

void list_insert_first(list_t* list,list_node_t* node){
   182dc:	55                   	push   %ebp
   182dd:	89 e5                	mov    %esp,%ebp
    node->next=list->first;
   182df:	8b 45 08             	mov    0x8(%ebp),%eax
   182e2:	8b 10                	mov    (%eax),%edx
   182e4:	8b 45 0c             	mov    0xc(%ebp),%eax
   182e7:	89 50 04             	mov    %edx,0x4(%eax)
    node->pre=(list_node_t*)0;
   182ea:	8b 45 0c             	mov    0xc(%ebp),%eax
   182ed:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(list_is_empty(list)){
   182f3:	ff 75 08             	pushl  0x8(%ebp)
   182f6:	e8 a9 ff ff ff       	call   182a4 <list_is_empty>
   182fb:	83 c4 04             	add    $0x4,%esp
   182fe:	85 c0                	test   %eax,%eax
   18300:	74 15                	je     18317 <list_insert_first+0x3b>
        list->last=list->first=node;
   18302:	8b 45 08             	mov    0x8(%ebp),%eax
   18305:	8b 55 0c             	mov    0xc(%ebp),%edx
   18308:	89 10                	mov    %edx,(%eax)
   1830a:	8b 45 08             	mov    0x8(%ebp),%eax
   1830d:	8b 10                	mov    (%eax),%edx
   1830f:	8b 45 08             	mov    0x8(%ebp),%eax
   18312:	89 50 04             	mov    %edx,0x4(%eax)
   18315:	eb 12                	jmp    18329 <list_insert_first+0x4d>
    }
    else{
        list->first->pre=node;
   18317:	8b 45 08             	mov    0x8(%ebp),%eax
   1831a:	8b 00                	mov    (%eax),%eax
   1831c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1831f:	89 10                	mov    %edx,(%eax)
        list->first=node;
   18321:	8b 45 08             	mov    0x8(%ebp),%eax
   18324:	8b 55 0c             	mov    0xc(%ebp),%edx
   18327:	89 10                	mov    %edx,(%eax)
    }
    list->count++;
   18329:	8b 45 08             	mov    0x8(%ebp),%eax
   1832c:	8b 40 08             	mov    0x8(%eax),%eax
   1832f:	8d 50 01             	lea    0x1(%eax),%edx
   18332:	8b 45 08             	mov    0x8(%ebp),%eax
   18335:	89 50 08             	mov    %edx,0x8(%eax)
}
   18338:	90                   	nop
   18339:	c9                   	leave  
   1833a:	c3                   	ret    

0001833b <list_insert_last>:

void list_insert_last(list_t*list,list_node_t*node){
   1833b:	55                   	push   %ebp
   1833c:	89 e5                	mov    %esp,%ebp
    node->pre=list->last;
   1833e:	8b 45 08             	mov    0x8(%ebp),%eax
   18341:	8b 50 04             	mov    0x4(%eax),%edx
   18344:	8b 45 0c             	mov    0xc(%ebp),%eax
   18347:	89 10                	mov    %edx,(%eax)
    node->next=(list_node_t*)0;
   18349:	8b 45 0c             	mov    0xc(%ebp),%eax
   1834c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if(list_is_empty(list)){
   18353:	ff 75 08             	pushl  0x8(%ebp)
   18356:	e8 49 ff ff ff       	call   182a4 <list_is_empty>
   1835b:	83 c4 04             	add    $0x4,%esp
   1835e:	85 c0                	test   %eax,%eax
   18360:	74 16                	je     18378 <list_insert_last+0x3d>
        list->first=list->last=node;
   18362:	8b 45 08             	mov    0x8(%ebp),%eax
   18365:	8b 55 0c             	mov    0xc(%ebp),%edx
   18368:	89 50 04             	mov    %edx,0x4(%eax)
   1836b:	8b 45 08             	mov    0x8(%ebp),%eax
   1836e:	8b 50 04             	mov    0x4(%eax),%edx
   18371:	8b 45 08             	mov    0x8(%ebp),%eax
   18374:	89 10                	mov    %edx,(%eax)
   18376:	eb 15                	jmp    1838d <list_insert_last+0x52>
    }
    else{
        list->last->next=node;
   18378:	8b 45 08             	mov    0x8(%ebp),%eax
   1837b:	8b 40 04             	mov    0x4(%eax),%eax
   1837e:	8b 55 0c             	mov    0xc(%ebp),%edx
   18381:	89 50 04             	mov    %edx,0x4(%eax)
        list->last=node;
   18384:	8b 45 08             	mov    0x8(%ebp),%eax
   18387:	8b 55 0c             	mov    0xc(%ebp),%edx
   1838a:	89 50 04             	mov    %edx,0x4(%eax)
    }
    list->count++;
   1838d:	8b 45 08             	mov    0x8(%ebp),%eax
   18390:	8b 40 08             	mov    0x8(%eax),%eax
   18393:	8d 50 01             	lea    0x1(%eax),%edx
   18396:	8b 45 08             	mov    0x8(%ebp),%eax
   18399:	89 50 08             	mov    %edx,0x8(%eax)
}
   1839c:	90                   	nop
   1839d:	c9                   	leave  
   1839e:	c3                   	ret    

0001839f <list_remove_first>:

/**
 * @brief 删除链表的第一个节点
 * @param list 具体要操作的链表
 */
list_node_t* list_remove_first(list_t* list){
   1839f:	55                   	push   %ebp
   183a0:	89 e5                	mov    %esp,%ebp
   183a2:	83 ec 10             	sub    $0x10,%esp
    if(list_is_empty(list)){
   183a5:	ff 75 08             	pushl  0x8(%ebp)
   183a8:	e8 f7 fe ff ff       	call   182a4 <list_is_empty>
   183ad:	83 c4 04             	add    $0x4,%esp
   183b0:	85 c0                	test   %eax,%eax
   183b2:	74 07                	je     183bb <list_remove_first+0x1c>
        return (list_node_t*)0;
   183b4:	b8 00 00 00 00       	mov    $0x0,%eax
   183b9:	eb 5a                	jmp    18415 <list_remove_first+0x76>
    }
    list_node_t* remove_node=list->first;
   183bb:	8b 45 08             	mov    0x8(%ebp),%eax
   183be:	8b 00                	mov    (%eax),%eax
   183c0:	89 45 fc             	mov    %eax,-0x4(%ebp)
    list->first=remove_node->next;
   183c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   183c6:	8b 50 04             	mov    0x4(%eax),%edx
   183c9:	8b 45 08             	mov    0x8(%ebp),%eax
   183cc:	89 10                	mov    %edx,(%eax)
    if(list->first==(list_node_t*)0){
   183ce:	8b 45 08             	mov    0x8(%ebp),%eax
   183d1:	8b 00                	mov    (%eax),%eax
   183d3:	85 c0                	test   %eax,%eax
   183d5:	75 0c                	jne    183e3 <list_remove_first+0x44>
        list->last=(list_node_t*)0;
   183d7:	8b 45 08             	mov    0x8(%ebp),%eax
   183da:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   183e1:	eb 0b                	jmp    183ee <list_remove_first+0x4f>
    }
    else{
        list->first->pre=(list_node_t*)0;
   183e3:	8b 45 08             	mov    0x8(%ebp),%eax
   183e6:	8b 00                	mov    (%eax),%eax
   183e8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    remove_node->pre=remove_node->next=(list_node_t*)0;
   183ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
   183f1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   183f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   183fb:	8b 50 04             	mov    0x4(%eax),%edx
   183fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18401:	89 10                	mov    %edx,(%eax)
    list->count--;
   18403:	8b 45 08             	mov    0x8(%ebp),%eax
   18406:	8b 40 08             	mov    0x8(%eax),%eax
   18409:	8d 50 ff             	lea    -0x1(%eax),%edx
   1840c:	8b 45 08             	mov    0x8(%ebp),%eax
   1840f:	89 50 08             	mov    %edx,0x8(%eax)
    return remove_node;
   18412:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   18415:	c9                   	leave  
   18416:	c3                   	ret    

00018417 <list_remove>:

list_node_t* list_remove(list_t* list,list_node_t*node){
   18417:	55                   	push   %ebp
   18418:	89 e5                	mov    %esp,%ebp
    if(node==list->first){
   1841a:	8b 45 08             	mov    0x8(%ebp),%eax
   1841d:	8b 00                	mov    (%eax),%eax
   1841f:	39 45 0c             	cmp    %eax,0xc(%ebp)
   18422:	75 0b                	jne    1842f <list_remove+0x18>
        list->first=node->next;
   18424:	8b 45 0c             	mov    0xc(%ebp),%eax
   18427:	8b 50 04             	mov    0x4(%eax),%edx
   1842a:	8b 45 08             	mov    0x8(%ebp),%eax
   1842d:	89 10                	mov    %edx,(%eax)
    }
    if(node==list->last){
   1842f:	8b 45 08             	mov    0x8(%ebp),%eax
   18432:	8b 40 04             	mov    0x4(%eax),%eax
   18435:	39 45 0c             	cmp    %eax,0xc(%ebp)
   18438:	75 0b                	jne    18445 <list_remove+0x2e>
        list->last=node->pre;
   1843a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1843d:	8b 10                	mov    (%eax),%edx
   1843f:	8b 45 08             	mov    0x8(%ebp),%eax
   18442:	89 50 04             	mov    %edx,0x4(%eax)
    }
    if(node->pre){
   18445:	8b 45 0c             	mov    0xc(%ebp),%eax
   18448:	8b 00                	mov    (%eax),%eax
   1844a:	85 c0                	test   %eax,%eax
   1844c:	74 0e                	je     1845c <list_remove+0x45>
        node->pre->next=node->next;
   1844e:	8b 45 0c             	mov    0xc(%ebp),%eax
   18451:	8b 00                	mov    (%eax),%eax
   18453:	8b 55 0c             	mov    0xc(%ebp),%edx
   18456:	8b 52 04             	mov    0x4(%edx),%edx
   18459:	89 50 04             	mov    %edx,0x4(%eax)
    }
    if(node->next){
   1845c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1845f:	8b 40 04             	mov    0x4(%eax),%eax
   18462:	85 c0                	test   %eax,%eax
   18464:	74 0d                	je     18473 <list_remove+0x5c>
        node->next->pre=node->pre;
   18466:	8b 45 0c             	mov    0xc(%ebp),%eax
   18469:	8b 40 04             	mov    0x4(%eax),%eax
   1846c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1846f:	8b 12                	mov    (%edx),%edx
   18471:	89 10                	mov    %edx,(%eax)
    }
    node->pre=node->next=(list_node_t*)0;
   18473:	8b 45 0c             	mov    0xc(%ebp),%eax
   18476:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   1847d:	8b 45 0c             	mov    0xc(%ebp),%eax
   18480:	8b 50 04             	mov    0x4(%eax),%edx
   18483:	8b 45 0c             	mov    0xc(%ebp),%eax
   18486:	89 10                	mov    %edx,(%eax)
    list->count--;
   18488:	8b 45 08             	mov    0x8(%ebp),%eax
   1848b:	8b 40 08             	mov    0x8(%eax),%eax
   1848e:	8d 50 ff             	lea    -0x1(%eax),%edx
   18491:	8b 45 08             	mov    0x8(%ebp),%eax
   18494:	89 50 08             	mov    %edx,0x8(%eax)
    return node;
   18497:	8b 45 0c             	mov    0xc(%ebp),%eax
   1849a:	5d                   	pop    %ebp
   1849b:	c3                   	ret    

0001849c <log_init>:
static mutex_t mutex;

// 用来记录打印设备的id
static int log_dev_id;

void log_init(void){
   1849c:	55                   	push   %ebp
   1849d:	89 e5                	mov    %esp,%ebp
   1849f:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   184a2:	83 ec 0c             	sub    $0xc,%esp
   184a5:	68 04 e0 05 00       	push   $0x5e004
   184aa:	e8 01 f3 ff ff       	call   177b0 <mutex_init>
   184af:	83 c4 10             	add    $0x10,%esp

    log_dev_id=dev_open(DEV_TTY,0,0);
   184b2:	83 ec 04             	sub    $0x4,%esp
   184b5:	6a 00                	push   $0x0
   184b7:	6a 00                	push   $0x0
   184b9:	6a 01                	push   $0x1
   184bb:	e8 5a b6 ff ff       	call   13b1a <dev_open>
   184c0:	83 c4 10             	add    $0x10,%esp
   184c3:	a3 18 e0 05 00       	mov    %eax,0x5e018
    outb(COM1_PORT+1,0x00);
    outb(COM1_PORT+3,0x03);
    outb(COM1_PORT+2,0xc7);
    outb(COM1_PORT+4,0x0F);
#endif
}
   184c8:	90                   	nop
   184c9:	c9                   	leave  
   184ca:	c3                   	ret    

000184cb <log_printf>:

void log_printf(const char* fmt,...){
   184cb:	55                   	push   %ebp
   184cc:	89 e5                	mov    %esp,%ebp
   184ce:	81 ec 98 00 00 00    	sub    $0x98,%esp
    char str_buf[128];
    va_list args;
    kernel_memset(str_buf,'\0',128);
   184d4:	83 ec 04             	sub    $0x4,%esp
   184d7:	68 80 00 00 00       	push   $0x80
   184dc:	6a 00                	push   $0x0
   184de:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   184e4:	50                   	push   %eax
   184e5:	e8 be f9 ff ff       	call   17ea8 <kernel_memset>
   184ea:	83 c4 10             	add    $0x10,%esp
    va_start(args,fmt);
   184ed:	8d 45 0c             	lea    0xc(%ebp),%eax
   184f0:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
    kernel_vsprintf(str_buf,fmt,args);
   184f6:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
   184fc:	83 ec 04             	sub    $0x4,%esp
   184ff:	50                   	push   %eax
   18500:	ff 75 08             	pushl  0x8(%ebp)
   18503:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   18509:	50                   	push   %eax
   1850a:	e8 a1 fb ff ff       	call   180b0 <kernel_vsprintf>
   1850f:	83 c4 10             	add    $0x10,%esp
    va_end(args);
    
    mutex_lock(&mutex);
   18512:	83 ec 0c             	sub    $0xc,%esp
   18515:	68 04 e0 05 00       	push   $0x5e004
   1851a:	e8 bf f2 ff ff       	call   177de <mutex_lock>
   1851f:	83 c4 10             	add    $0x10,%esp
        outb(COM1_PORT,*p++);
    }
    outb(COM1_PORT,'\r');
    outb(COM1_PORT,'\n');
#else
    dev_write(log_dev_id,0,str_buf,kernel_strlen(str_buf));
   18522:	83 ec 0c             	sub    $0xc,%esp
   18525:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   1852b:	50                   	push   %eax
   1852c:	e8 ed f8 ff ff       	call   17e1e <kernel_strlen>
   18531:	83 c4 10             	add    $0x10,%esp
   18534:	89 c2                	mov    %eax,%edx
   18536:	a1 18 e0 05 00       	mov    0x5e018,%eax
   1853b:	52                   	push   %edx
   1853c:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
   18542:	52                   	push   %edx
   18543:	6a 00                	push   $0x0
   18545:	50                   	push   %eax
   18546:	e8 6d b7 ff ff       	call   13cb8 <dev_write>
   1854b:	83 c4 10             	add    $0x10,%esp
    char c='\n';
   1854e:	c6 85 73 ff ff ff 0a 	movb   $0xa,-0x8d(%ebp)
    dev_write(log_dev_id,0,&c,1);
   18555:	a1 18 e0 05 00       	mov    0x5e018,%eax
   1855a:	6a 01                	push   $0x1
   1855c:	8d 95 73 ff ff ff    	lea    -0x8d(%ebp),%edx
   18562:	52                   	push   %edx
   18563:	6a 00                	push   $0x0
   18565:	50                   	push   %eax
   18566:	e8 4d b7 ff ff       	call   13cb8 <dev_write>
   1856b:	83 c4 10             	add    $0x10,%esp
#endif
    mutex_unlock(&mutex);
   1856e:	83 ec 0c             	sub    $0xc,%esp
   18571:	68 04 e0 05 00       	push   $0x5e004
   18576:	e8 f2 f2 ff ff       	call   1786d <mutex_unlock>
   1857b:	83 c4 10             	add    $0x10,%esp
   1857e:	90                   	nop
   1857f:	c9                   	leave  
   18580:	c3                   	ret    

Disassembly of section .first_task:

80000000 <first_task_entry>:
    .text
	.global first_task_entry
	.extern first_task_main
first_task_entry:
	mov %ss,%ax
80000000:	66 8c d0             	mov    %ss,%ax
	mov %ax, %ds
80000003:	8e d8                	mov    %eax,%ds
	mov %ax, %ss
80000005:	8e d0                	mov    %eax,%ss
	mov %ax, %es
80000007:	8e c0                	mov    %eax,%es
	mov %ax, %fs
80000009:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
8000000b:	8e e8                	mov    %eax,%gs
8000000d:	e9 00 00 00 00       	jmp    80000012 <first_task_main>

80000012 <first_task_main>:
#include "tools/log.h"
#include "core/task.h"
#include "applib/lib_syscall.h"
#include "dev/tty.h" 

int first_task_main(void){
80000012:	55                   	push   %ebp
80000013:	89 e5                	mov    %esp,%ebp
80000015:	83 ec 28             	sub    $0x28,%esp
        print_msg("child task id=%d",pid);
        print_msg("parent: %d",count);
    }
#endif

    for(int i=0;i<1;i++){
80000018:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
8000001f:	eb 7e                	jmp    8000009f <first_task_main+0x8d>
        int pid=fork();
80000021:	e8 73 01 00 00       	call   80000199 <fork>
80000026:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(pid<0){
80000029:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
8000002d:	79 14                	jns    80000043 <first_task_main+0x31>
            print_msg("create shell failed.",0);
8000002f:	83 ec 08             	sub    $0x8,%esp
80000032:	6a 00                	push   $0x0
80000034:	68 c1 00 00 80       	push   $0x800000c1
80000039:	e8 33 01 00 00       	call   80000171 <print_msg>
8000003e:	83 c4 10             	add    $0x10,%esp
            break;
80000041:	eb 66                	jmp    800000a9 <first_task_main+0x97>
        }
        else if(pid==0){
80000043:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
80000047:	75 52                	jne    8000009b <first_task_main+0x89>
            char tty_num[]="/dev/tty?";
80000049:	c7 45 e6 2f 64 65 76 	movl   $0x7665642f,-0x1a(%ebp)
80000050:	c7 45 ea 2f 74 74 79 	movl   $0x7974742f,-0x16(%ebp)
80000057:	66 c7 45 ee 3f 00    	movw   $0x3f,-0x12(%ebp)
            tty_num[sizeof(tty_num)-2]=i+'0';
8000005d:	8b 45 f4             	mov    -0xc(%ebp),%eax
80000060:	83 c0 30             	add    $0x30,%eax
80000063:	88 45 ee             	mov    %al,-0x12(%ebp)
            char* argv[]={tty_num,(char*)0};
80000066:	8d 45 e6             	lea    -0x1a(%ebp),%eax
80000069:	89 45 dc             	mov    %eax,-0x24(%ebp)
8000006c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
            execve("shell.elf",argv,(char**)0);
80000073:	83 ec 04             	sub    $0x4,%esp
80000076:	6a 00                	push   $0x0
80000078:	8d 45 dc             	lea    -0x24(%ebp),%eax
8000007b:	50                   	push   %eax
8000007c:	68 d6 00 00 80       	push   $0x800000d6
80000081:	e8 2e 01 00 00       	call   800001b4 <execve>
80000086:	83 c4 10             	add    $0x10,%esp
            
            while(1){
                msleep(1000);
80000089:	83 ec 0c             	sub    $0xc,%esp
8000008c:	68 e8 03 00 00       	push   $0x3e8
80000091:	e8 96 00 00 00       	call   8000012c <msleep>
80000096:	83 c4 10             	add    $0x10,%esp
80000099:	eb ee                	jmp    80000089 <first_task_main+0x77>
    for(int i=0;i<1;i++){
8000009b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
8000009f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
800000a3:	0f 8e 78 ff ff ff    	jle    80000021 <first_task_main+0xf>
    }

    for(;;){

        // 回收所有的孤儿进程
        int status=0;
800000a9:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
        wait(&status);
800000b0:	83 ec 0c             	sub    $0xc,%esp
800000b3:	8d 45 d8             	lea    -0x28(%ebp),%eax
800000b6:	50                   	push   %eax
800000b7:	e8 bc 02 00 00       	call   80000378 <wait>
800000bc:	83 c4 10             	add    $0x10,%esp
    for(;;){
800000bf:	eb e8                	jmp    800000a9 <first_task_main+0x97>
800000c1:	63 72 65             	arpl   %si,0x65(%edx)
800000c4:	61                   	popa   
800000c5:	74 65                	je     8000012c <msleep>
800000c7:	20 73 68             	and    %dh,0x68(%ebx)
800000ca:	65 6c                	gs insb (%dx),%es:(%edi)
800000cc:	6c                   	insb   (%dx),%es:(%edi)
800000cd:	20 66 61             	and    %ah,0x61(%esi)
800000d0:	69 6c 65 64 2e 00 73 	imul   $0x6873002e,0x64(%ebp,%eiz,2),%ebp
800000d7:	68 
800000d8:	65 6c                	gs insb (%dx),%es:(%edi)
800000da:	6c                   	insb   (%dx),%es:(%edi)
800000db:	2e 65 6c             	cs gs insb (%dx),%es:(%edi)
800000de:	66                   	data16
	...

800000e0 <sys_call>:
#include "os_cfg.h"

#include <stdlib.h>
#include <string.h>

static inline int sys_call(syscall_args_t*args){
800000e0:	55                   	push   %ebp
800000e1:	89 e5                	mov    %esp,%ebp
800000e3:	57                   	push   %edi
800000e4:	56                   	push   %esi
800000e5:	53                   	push   %ebx
800000e6:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[]={0,SELECTOR_SYSCALL | 0};
800000e9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
800000f0:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%ebp)
        "push %[arg0]\n\t"
        "push %[id]\n\t"
        "lcall *(%[a])"
        :"=a"(ret)
        :[a]"r"(addr),
         [arg3]"r"(args->arg3),
800000f7:	8b 45 08             	mov    0x8(%ebp),%eax
800000fa:	8b 50 10             	mov    0x10(%eax),%edx
         [arg2]"r"(args->arg2),
800000fd:	8b 45 08             	mov    0x8(%ebp),%eax
80000100:	8b 48 0c             	mov    0xc(%eax),%ecx
         [arg1]"r"(args->arg1),
80000103:	8b 45 08             	mov    0x8(%ebp),%eax
80000106:	8b 58 08             	mov    0x8(%eax),%ebx
         [arg0]"r"(args->arg0),
80000109:	8b 45 08             	mov    0x8(%ebp),%eax
8000010c:	8b 70 04             	mov    0x4(%eax),%esi
         [id]"r"(args->id)
8000010f:	8b 45 08             	mov    0x8(%ebp),%eax
80000112:	8b 38                	mov    (%eax),%edi
    __asm__ __volatile__(
80000114:	8d 45 e8             	lea    -0x18(%ebp),%eax
80000117:	52                   	push   %edx
80000118:	51                   	push   %ecx
80000119:	53                   	push   %ebx
8000011a:	56                   	push   %esi
8000011b:	57                   	push   %edi
8000011c:	ff 18                	lcall  *(%eax)
8000011e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    );
    return ret;
80000121:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
80000124:	83 c4 10             	add    $0x10,%esp
80000127:	5b                   	pop    %ebx
80000128:	5e                   	pop    %esi
80000129:	5f                   	pop    %edi
8000012a:	5d                   	pop    %ebp
8000012b:	c3                   	ret    

8000012c <msleep>:

void msleep(int ms){
8000012c:	55                   	push   %ebp
8000012d:	89 e5                	mov    %esp,%ebp
8000012f:	83 ec 20             	sub    $0x20,%esp
    if(ms<=0){
80000132:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
80000136:	7e 1b                	jle    80000153 <msleep+0x27>
        return;
    }

    syscall_args_t args;
    args.id=SYS_SLEEP;
80000138:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    args.arg0=ms;
8000013f:	8b 45 08             	mov    0x8(%ebp),%eax
80000142:	89 45 f0             	mov    %eax,-0x10(%ebp)

    sys_call(&args);
80000145:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000148:	50                   	push   %eax
80000149:	e8 92 ff ff ff       	call   800000e0 <sys_call>
8000014e:	83 c4 04             	add    $0x4,%esp
80000151:	eb 01                	jmp    80000154 <msleep+0x28>
        return;
80000153:	90                   	nop
}
80000154:	c9                   	leave  
80000155:	c3                   	ret    

80000156 <getpid>:

int getpid(void){
80000156:	55                   	push   %ebp
80000157:	89 e5                	mov    %esp,%ebp
80000159:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_GETPID;
8000015c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
    return sys_call(&args);
80000163:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000166:	50                   	push   %eax
80000167:	e8 74 ff ff ff       	call   800000e0 <sys_call>
8000016c:	83 c4 04             	add    $0x4,%esp
}
8000016f:	c9                   	leave  
80000170:	c3                   	ret    

80000171 <print_msg>:

void print_msg(const char* fmt,int arg){
80000171:	55                   	push   %ebp
80000172:	89 e5                	mov    %esp,%ebp
80000174:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_PRINT_MSG;
80000177:	c7 45 ec 64 00 00 00 	movl   $0x64,-0x14(%ebp)
    args.arg0=(uint32_t)fmt;
8000017e:	8b 45 08             	mov    0x8(%ebp),%eax
80000181:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=arg;
80000184:	8b 45 0c             	mov    0xc(%ebp),%eax
80000187:	89 45 f4             	mov    %eax,-0xc(%ebp)
    sys_call(&args);
8000018a:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000018d:	50                   	push   %eax
8000018e:	e8 4d ff ff ff       	call   800000e0 <sys_call>
80000193:	83 c4 04             	add    $0x4,%esp
}
80000196:	90                   	nop
80000197:	c9                   	leave  
80000198:	c3                   	ret    

80000199 <fork>:

int fork(void){
80000199:	55                   	push   %ebp
8000019a:	89 e5                	mov    %esp,%ebp
8000019c:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_FORK;
8000019f:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
    return sys_call(&args);
800001a6:	8d 45 ec             	lea    -0x14(%ebp),%eax
800001a9:	50                   	push   %eax
800001aa:	e8 31 ff ff ff       	call   800000e0 <sys_call>
800001af:	83 c4 04             	add    $0x4,%esp
}
800001b2:	c9                   	leave  
800001b3:	c3                   	ret    

800001b4 <execve>:

int execve(const char* name,char* const* argv,char* const* env){
800001b4:	55                   	push   %ebp
800001b5:	89 e5                	mov    %esp,%ebp
800001b7:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_EXECVE;
800001ba:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
    args.arg0=(int)name;
800001c1:	8b 45 08             	mov    0x8(%ebp),%eax
800001c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)argv;
800001c7:	8b 45 0c             	mov    0xc(%ebp),%eax
800001ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)env;
800001cd:	8b 45 10             	mov    0x10(%ebp),%eax
800001d0:	89 45 f8             	mov    %eax,-0x8(%ebp)

    sys_call(&args);
800001d3:	8d 45 ec             	lea    -0x14(%ebp),%eax
800001d6:	50                   	push   %eax
800001d7:	e8 04 ff ff ff       	call   800000e0 <sys_call>
800001dc:	83 c4 04             	add    $0x4,%esp
}
800001df:	90                   	nop
800001e0:	c9                   	leave  
800001e1:	c3                   	ret    

800001e2 <yield>:

int yield(void){
800001e2:	55                   	push   %ebp
800001e3:	89 e5                	mov    %esp,%ebp
800001e5:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_YIELD;
800001e8:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%ebp)

    return sys_call(&args);
800001ef:	8d 45 ec             	lea    -0x14(%ebp),%eax
800001f2:	50                   	push   %eax
800001f3:	e8 e8 fe ff ff       	call   800000e0 <sys_call>
800001f8:	83 c4 04             	add    $0x4,%esp
}
800001fb:	c9                   	leave  
800001fc:	c3                   	ret    

800001fd <open>:

int open(const char*name,int flags, ...){
800001fd:	55                   	push   %ebp
800001fe:	89 e5                	mov    %esp,%ebp
80000200:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_OPEN;
80000203:	c7 45 ec 32 00 00 00 	movl   $0x32,-0x14(%ebp)
    args.arg0=(int)name;
8000020a:	8b 45 08             	mov    0x8(%ebp),%eax
8000020d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)flags;
80000210:	8b 45 0c             	mov    0xc(%ebp),%eax
80000213:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return sys_call(&args);
80000216:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000219:	50                   	push   %eax
8000021a:	e8 c1 fe ff ff       	call   800000e0 <sys_call>
8000021f:	83 c4 04             	add    $0x4,%esp
}
80000222:	c9                   	leave  
80000223:	c3                   	ret    

80000224 <read>:

int read(int file,char* ptr,int len){
80000224:	55                   	push   %ebp
80000225:	89 e5                	mov    %esp,%ebp
80000227:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_READ;
8000022a:	c7 45 ec 33 00 00 00 	movl   $0x33,-0x14(%ebp)
    args.arg0=(int)file;
80000231:	8b 45 08             	mov    0x8(%ebp),%eax
80000234:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)ptr;
80000237:	8b 45 0c             	mov    0xc(%ebp),%eax
8000023a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)len;
8000023d:	8b 45 10             	mov    0x10(%ebp),%eax
80000240:	89 45 f8             	mov    %eax,-0x8(%ebp)

    return sys_call(&args);
80000243:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000246:	50                   	push   %eax
80000247:	e8 94 fe ff ff       	call   800000e0 <sys_call>
8000024c:	83 c4 04             	add    $0x4,%esp
}
8000024f:	c9                   	leave  
80000250:	c3                   	ret    

80000251 <write>:

int write(int file,char*ptr,int len){
80000251:	55                   	push   %ebp
80000252:	89 e5                	mov    %esp,%ebp
80000254:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_WRITE;
80000257:	c7 45 ec 34 00 00 00 	movl   $0x34,-0x14(%ebp)
    args.arg0=(int)file;
8000025e:	8b 45 08             	mov    0x8(%ebp),%eax
80000261:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)ptr;
80000264:	8b 45 0c             	mov    0xc(%ebp),%eax
80000267:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)len;
8000026a:	8b 45 10             	mov    0x10(%ebp),%eax
8000026d:	89 45 f8             	mov    %eax,-0x8(%ebp)

    return sys_call(&args);
80000270:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000273:	50                   	push   %eax
80000274:	e8 67 fe ff ff       	call   800000e0 <sys_call>
80000279:	83 c4 04             	add    $0x4,%esp
}
8000027c:	c9                   	leave  
8000027d:	c3                   	ret    

8000027e <close>:

int close(int file){
8000027e:	55                   	push   %ebp
8000027f:	89 e5                	mov    %esp,%ebp
80000281:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_CLOSE;
80000284:	c7 45 ec 35 00 00 00 	movl   $0x35,-0x14(%ebp)
    args.arg0=(int)file;
8000028b:	8b 45 08             	mov    0x8(%ebp),%eax
8000028e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
80000291:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000294:	50                   	push   %eax
80000295:	e8 46 fe ff ff       	call   800000e0 <sys_call>
8000029a:	83 c4 04             	add    $0x4,%esp
}
8000029d:	c9                   	leave  
8000029e:	c3                   	ret    

8000029f <lseek>:

int lseek(int file,int ptr,int dir){
8000029f:	55                   	push   %ebp
800002a0:	89 e5                	mov    %esp,%ebp
800002a2:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_LSEEK;
800002a5:	c7 45 ec 36 00 00 00 	movl   $0x36,-0x14(%ebp)
    args.arg0=(int)file;
800002ac:	8b 45 08             	mov    0x8(%ebp),%eax
800002af:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)ptr;
800002b2:	8b 45 0c             	mov    0xc(%ebp),%eax
800002b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)dir;
800002b8:	8b 45 10             	mov    0x10(%ebp),%eax
800002bb:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return sys_call(&args);
800002be:	8d 45 ec             	lea    -0x14(%ebp),%eax
800002c1:	50                   	push   %eax
800002c2:	e8 19 fe ff ff       	call   800000e0 <sys_call>
800002c7:	83 c4 04             	add    $0x4,%esp
}
800002ca:	c9                   	leave  
800002cb:	c3                   	ret    

800002cc <isatty>:

int isatty(int file){
800002cc:	55                   	push   %ebp
800002cd:	89 e5                	mov    %esp,%ebp
800002cf:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_ISATTY;
800002d2:	c7 45 ec 37 00 00 00 	movl   $0x37,-0x14(%ebp)
    args.arg0=(int)file;
800002d9:	8b 45 08             	mov    0x8(%ebp),%eax
800002dc:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
800002df:	8d 45 ec             	lea    -0x14(%ebp),%eax
800002e2:	50                   	push   %eax
800002e3:	e8 f8 fd ff ff       	call   800000e0 <sys_call>
800002e8:	83 c4 04             	add    $0x4,%esp
}
800002eb:	c9                   	leave  
800002ec:	c3                   	ret    

800002ed <fstat>:

int fstat(int file,struct stat* st){
800002ed:	55                   	push   %ebp
800002ee:	89 e5                	mov    %esp,%ebp
800002f0:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_FSTAT;
800002f3:	c7 45 ec 39 00 00 00 	movl   $0x39,-0x14(%ebp)
    args.arg0=(int)file;
800002fa:	8b 45 08             	mov    0x8(%ebp),%eax
800002fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)st;
80000300:	8b 45 0c             	mov    0xc(%ebp),%eax
80000303:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return sys_call(&args);
80000306:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000309:	50                   	push   %eax
8000030a:	e8 d1 fd ff ff       	call   800000e0 <sys_call>
8000030f:	83 c4 04             	add    $0x4,%esp
}
80000312:	c9                   	leave  
80000313:	c3                   	ret    

80000314 <sbrk>:

void* sbrk(ptrdiff_t incr){
80000314:	55                   	push   %ebp
80000315:	89 e5                	mov    %esp,%ebp
80000317:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_SBRK;
8000031a:	c7 45 ec 38 00 00 00 	movl   $0x38,-0x14(%ebp)
    args.arg0=(int)incr;
80000321:	8b 45 08             	mov    0x8(%ebp),%eax
80000324:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return (void*)sys_call(&args);
80000327:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000032a:	50                   	push   %eax
8000032b:	e8 b0 fd ff ff       	call   800000e0 <sys_call>
80000330:	83 c4 04             	add    $0x4,%esp
}
80000333:	c9                   	leave  
80000334:	c3                   	ret    

80000335 <dup>:
/** 
* @brief 复制文件描述符
* @param file 需要复制的文件描述符
* @return 复制后的文件描述符，失败返回-1
*/
int dup(int file){
80000335:	55                   	push   %ebp
80000336:	89 e5                	mov    %esp,%ebp
80000338:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_DUP;
8000033b:	c7 45 ec 3a 00 00 00 	movl   $0x3a,-0x14(%ebp)
    args.arg0=(int)file;
80000342:	8b 45 08             	mov    0x8(%ebp),%eax
80000345:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
80000348:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000034b:	50                   	push   %eax
8000034c:	e8 8f fd ff ff       	call   800000e0 <sys_call>
80000351:	83 c4 04             	add    $0x4,%esp
}
80000354:	c9                   	leave  
80000355:	c3                   	ret    

80000356 <_exit>:

/**
 * @brief  当我们使用newlib库时，exit函数会调用_exit函数
 * @param status 退出的状态码
 */
void _exit(int status){
80000356:	55                   	push   %ebp
80000357:	89 e5                	mov    %esp,%ebp
80000359:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_EXIT;
8000035c:	c7 45 ec 05 00 00 00 	movl   $0x5,-0x14(%ebp)
    args.arg0=(int)status;
80000363:	8b 45 08             	mov    0x8(%ebp),%eax
80000366:	89 45 f0             	mov    %eax,-0x10(%ebp)

    sys_call(&args);
80000369:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000036c:	50                   	push   %eax
8000036d:	e8 6e fd ff ff       	call   800000e0 <sys_call>
80000372:	83 c4 04             	add    $0x4,%esp

    for(;;){
        asm volatile("hlt");
80000375:	f4                   	hlt    
80000376:	eb fd                	jmp    80000375 <_exit+0x1f>

80000378 <wait>:
    }
}

int wait(int* status){
80000378:	55                   	push   %ebp
80000379:	89 e5                	mov    %esp,%ebp
8000037b:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_WAIT;
8000037e:	c7 45 ec 06 00 00 00 	movl   $0x6,-0x14(%ebp)
    args.arg0=(int)status;
80000385:	8b 45 08             	mov    0x8(%ebp),%eax
80000388:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
8000038b:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000038e:	50                   	push   %eax
8000038f:	e8 4c fd ff ff       	call   800000e0 <sys_call>
80000394:	83 c4 04             	add    $0x4,%esp
}
80000397:	c9                   	leave  
80000398:	c3                   	ret    
