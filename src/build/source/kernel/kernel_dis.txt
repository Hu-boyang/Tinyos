
E:/CppProject/TinyOs/src/build/source/kernel/kernel.elf:     file format elf32-i386
E:/CppProject/TinyOs/src/build/source/kernel/kernel.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010000

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x000067c0 memsz 0x000067c0 flags r-x
    LOAD off    0x00008000 vaddr 0x00017000 paddr 0x00017000 align 2**12
         filesz 0x0000009c memsz 0x000555e0 flags rw-
    LOAD off    0x00009000 vaddr 0x80000000 paddr 0x0006c5e0 align 2**12
         filesz 0x0000038d memsz 0x0000038d flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005b33  00010000  00010000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000c80  00015b40  00015b40  00006b40  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         0000009c  00017000  00017000  00008000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          000545e0  00018000  00018000  0000809c  2**12
                  ALLOC
  4 .first_task   0000038d  80000000  0006c5e0  00009000  2**0
                  CONTENTS, ALLOC, LOAD, CODE
  5 .debug_line   000032af  00000000  00000000  0000938d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000be93  00000000  00000000  0000c63c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000277a  00000000  00000000  000184cf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 000002e0  00000000  00000000  0001ac50  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 000000a8  00000000  00000000  0001af30  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000021d1  00000000  00000000  0001afd8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      00000011  00000000  00000000  0001d1a9  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00002260  00000000  00000000  0001d1bc  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
00015b40 l    d  .rodata	00000000 .rodata
00017000 l    d  .data	00000000 .data
00018000 l    d  .bss	00000000 .bss
80000000 l    d  .first_task	00000000 .first_task
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 CMakeFiles/kernel.dir/init/start.S.obj
00010013 l       .text	00000000 gdt_reload
00000000 l    df *ABS*	00000000 memory.c
000102e5 l     F .text	00000011 read_cr0
000102f6 l     F .text	0000000c write_cr0
00010302 l     F .text	0000000c write_cr3
0001030e l     F .text	0000000c write_cr4
0001031a l     F .text	00000011 read_cr4
0001032b l     F .text	0000000d down2
00010338 l     F .text	00000017 up2
0001034f l     F .text	0000003e mmu_set_page_dir
0001038d l     F .text	0000000b pde_index
00010398 l     F .text	00000010 pte_index
000103a8 l     F .text	00000010 pde_paddr
000103b8 l     F .text	00000010 pte_paddr
000103c8 l     F .text	0000000f get_pte_perm
00018000 l     O .bss	00000028 paddr_alloc
00019000 l     O .bss	00001000 kernel_page_dir
000103d7 l     F .text	00000058 addr_alloc_init
0001042f l     F .text	00000067 addr_alloc_page
00010496 l     F .text	00000062 addr_free_page
000104f8 l     F .text	00000037 total_mem_size
00015c58 l     O .rodata	00000012 __func__.2528
00017000 l     O .data	00000050 kernel_map.2539
00015c6c l     O .rodata	0000000c __func__.2559
00010946 l     F .text	00000013 curr_page_dir
00015c78 l     O .rodata	00000011 __func__.2600
00015c8c l     O .rodata	00000009 __func__.2660
00000000 l    df *ABS*	00000000 syscall.c
00015ca0 l     O .rodata	00000194 sys_table
00000000 l    df *ABS*	00000000 task.c
00010eab l     F .text	00000011 read_cr0
00010ebc l     F .text	0000000c write_cr0
00010ec8 l     F .text	00000007 hlt
00010ecf l     F .text	00000017 write_tr
00010ee6 l     F .text	0000000c write_cr3
00010ef2 l     F .text	0000000c write_cr4
00010efe l     F .text	00000011 read_cr4
00010f0f l     F .text	0000001b list_node_init
00010f2a l     F .text	0000000b list_node_next
00010f35 l     F .text	0000000b list_count
00010f40 l     F .text	0000000a list_first
00010f4a l     F .text	0000003e mmu_set_page_dir
0001a000 l     O .bss	000005c0 task_manager
0001a5c0 l     O .bss	00001000 idle_task_stack
0001b5c0 l     O .bss	00016400 task_table
000319c0 l     O .bss	00000014 table_mutex
00010f88 l     F .text	0000019b tss_init
00015f78 l     O .rodata	0000000a __func__.2852
0001134d l     F .text	0000000a idle_task_entry
00015f84 l     O .rodata	00000010 __func__.2883
00011866 l     F .text	00000068 alloc_task
000118ce l     F .text	00000033 free_task
00011a72 l     F .text	000000fe load_phdr
00011b70 l     F .text	000001be load_elf_file
00011d2e l     F .text	000000f3 copy_args
00015f94 l     O .rodata	0000000a __func__.3005
00000000 l    df *ABS*	00000000 cpu.c
000122bc l     F .text	00000028 lgdt
000122e4 l     F .text	0000001a far_jump
000319e0 l     O .bss	00000800 gdt_table
000321e0 l     O .bss	00000014 mutex
00000000 l    df *ABS*	00000000 irq.c
00012533 l     F .text	00000007 cli
0001253a l     F .text	00000007 sti
00012541 l     F .text	0000001d inb
0001255e l     F .text	0000001f outb
0001257d l     F .text	00000028 lidt
000125a5 l     F .text	00000007 hlt
000125ac l     F .text	00000010 read_eflags
000125bc l     F .text	0000000b write_eflags
000125c7 l     F .text	00000011 read_cr2
000125d8 l     F .text	00000093 init_pic
00032200 l     O .bss	00000400 idt_table
0001297b l     F .text	000000f8 dump_core_regs
00012a73 l     F .text	0000003f do_default_handler
00000000 l    df *ABS*	00000000 console.c
00012e87 l     F .text	0000001d inb
00012ea4 l     F .text	0000001f outb
00032600 l     O .bss	000002a0 console_buf
000328a0 l     O .bss	00000004 curr_console_idx
00012ec3 l     F .text	00000074 read_cursor_pos
00012f37 l     F .text	000000ba update_cursor_pos
00012ff1 l     F .text	00000093 erase_rows
00013084 l     F .text	00000089 scroll_up
0001310d l     F .text	00000086 clear_display
00013193 l     F .text	00000010 move_to_col0
000131a3 l     F .text	00000038 move_next_line
000131db l     F .text	00000076 move_forward
00013251 l     F .text	00000078 move_backword
0001339a l     F .text	00000095 show_char
0001342f l     F .text	0000003a erase_backword
00013469 l     F .text	0000001e save_cursor
00013487 l     F .text	0000001e restore_cursor
000134a5 l     F .text	00000029 clear_esc_param
000134ce l     F .text	00000071 write_esc
0001353f l     F .text	00000099 set_font_style
00016560 l     O .rodata	00000020 color_table.2438
000135d8 l     F .text	00000051 erase_in_display
00013629 l     F .text	0000001e move_cursor
00013647 l     F .text	00000037 move_left
0001367e l     F .text	00000049 move_right
000136c7 l     F .text	000000f4 write_esc_square
000137bb l     F .text	000000a2 write_normal
00000000 l    df *ABS*	00000000 dev.c
00017050 l     O .data	00000004 dev_desc_tbl
000328c0 l     O .bss	00000a00 dev_tb
00013a02 l     F .text	0000003c is_devid_bad
00000000 l    df *ABS*	00000000 kbd.c
00013cf6 l     F .text	0000001d inb
000332c0 l     O .bss	00000004 kbd_stat
00016580 l     O .rodata	00000074 map_table
000332c4 l     O .bss	00000004 inited.2312
00013d62 l     F .text	0000001a is_make_code
00013d7c l     F .text	00000015 get_key
00013d91 l     F .text	0000003c do_fx_key
00013dcd l     F .text	000001d3 do_normal_key
000332c8 l     O .bss	00000004 recv_state.2359
00000000 l    df *ABS*	00000000 time.c
000140c4 l     F .text	0000001f outb
000332cc l     O .bss	00000004 sys_tick
0001410b l     F .text	00000060 init_pit
00000000 l    df *ABS*	00000000 tty.c
000332e0 l     O .bss	000022a0 tty_devs
00035580 l     O .bss	00000004 curr_tty
00014183 l     F .text	0000004f get_tty
00000000 l    df *ABS*	00000000 file.c
000355a0 l     O .bss	0001c000 file_table
000515a0 l     O .bss	00000014 file_alloc_mutex
00000000 l    df *ABS*	00000000 fs.c
000147da l     F .text	0000001d inb
000147f7 l     F .text	0000001f inw
00014816 l     F .text	0000001f outb
000515c0 l     O .bss	00019000 TEMP_ADDR
0006a5c0 l     O .bss	00000004 temp_pos
00014835 l     F .text	0000012f read_disk
00014964 l     F .text	00000021 is_path_valid
00000000 l    df *ABS*	00000000 init.c
0001675c l     O .rodata	00000013 __func__.2921
00000000 l    df *ABS*	00000000 mutex.c
00014d57 l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 sem.c
00014ede l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 bitmap.c
00000000 l    df *ABS*	00000000 kilb.c
00015298 l     F .text	00000007 hlt
00017098 l     O .data	00000004 num2ch.2085
00000000 l    df *ABS*	00000000 list.c
00015856 l     F .text	00000013 list_is_empty
00000000 l    df *ABS*	00000000 log.c
0006a5c4 l     O .bss	00000014 mutex
0006a5d8 l     O .bss	00000004 log_dev_id
00000000 l    df *ABS*	00000000 first_task.c
00000000 l    df *ABS*	00000000 lib_syscall.c
800000d4 l     F .first_task	0000004c sys_call
00015090 g     F .text	0000004f bitmap_get_bit
0001540b g     F .text	0000004f kernel_memcpy
00014bdd g     F .text	0000000a sys_close
000115dc g     F .text	0000000a task_current
800001d6 g     F .first_task	0000001b yield
00012676 g     F .text	0000000b irq_enable_global
000158ed g     F .text	00000064 list_insert_last
00011fd0 g     F .text	00000031 task_file
000102a8 g       .text	00000000 exception_handler_kbd
00010cf6 g     F .text	0000010c sys_sbrk
000117ec g     F .text	00000064 sys_msleep
00012be6 g     F .text	0000001c do_handler_segment_not_present
00011534 g     F .text	00000036 task_set_ready
000151ca g     F .text	0000001b bitmap_is_set
0001545a g     F .text	00000041 kernel_memset
00013bda g     F .text	0000004c dev_write
00014bb9 g     F .text	00000024 sys_lseek
00013d13 g     F .text	0000004f kbd_init
0001026a g       .text	00000000 exception_handler_virtual_exception
00010e1c g     F .text	0000008f do_handler_syscall
00012456 g     F .text	0000001e cpu_init
00015a4e g     F .text	0000002f log_init
00011901 g     F .text	00000171 sys_fork
00014d2d g     F .text	0000002a init_main
0001020f g       .text	00000000 exception_handler_alignment_check
000124fd g     F .text	00000036 gdt_free_sel
00010e02 g     F .text	0000001a sys_print_msg
0001529f g     F .text	00000047 kernel_strcpy
00013fa0 g     F .text	00000064 do_e0_key
00017000 g       .data	00000000 s_data
800001a8 g     F .first_task	0000002e execve
8000014a g     F .first_task	0000001b getpid
00012681 g     F .text	0000008b irq_enable
0001002b g       .text	00000000 exception_handler_unknown
000100a7 g       .text	00000000 exception_handler_breakpoint
00012b3e g     F .text	0000001c do_handler_overflow
00012dc3 g     F .text	0000001c do_handler_alignment_check
000105df g     F .text	0000009d memory_create_map
00014ae5 g     F .text	00000087 sys_read
0001394a g     F .text	000000b8 console_select
000101b6 g       .text	00000000 exception_handler_general_protection
00012c1e g     F .text	000000b5 do_handler_general_protection
00014ffe g     F .text	00000029 sem_count
80000012 g     F .first_task	000000a2 first_task_main
00012ace g     F .text	0000001c do_handler_divider
000150df g     F .text	000000eb bitmap_set_bit
00012bae g     F .text	0000001c do_handler_double_fault
00012cd3 g     F .text	000000d4 do_handler_page_fault
800002c0 g     F .first_task	00000021 isatty
00010142 g       .text	00000000 exception_handler_double_fault
00012e33 g     F .text	0000002b pic_send_eoi
0001152a g     F .text	0000000a task_first_task
00010000 g       .text	00000000 s_text
000107c8 g     F .text	00000085 memory_create_uvm
00014f0c g     F .text	0000006e sem_wait
00010901 g     F .text	00000025 memory_alloc_page_for
00010199 g       .text	00000000 exception_handler_stack_segment_fault
80000000 g       .first_task	00000000 first_task_entry
00014bf1 g     F .text	0000000a sys_fstat
00013b8e g     F .text	0000004c dev_read
00012e17 g     F .text	0000001c do_handler_virtual_exception
000100c6 g       .text	00000000 exception_handler_overflow
80000293 g     F .first_task	0000002d lseek
00010289 g       .text	00000000 exception_handler_time
0006a5e0 g     O .bss	00002000 stack
00014bfb g     F .text	0000000e fs_init
00010959 g     F .text	00000099 memory_free_page
0006c5e0 g       *ABS*	00000000 s_first_task
00012052 g     F .text	00000026 task_remove_fd
0001463e g     F .text	0000000a tty_control
000132c9 g     F .text	000000d1 console_init
00014420 g     F .text	00000121 tty_read
000112a9 g     F .text	00000086 task_uninit
0001084d g     F .text	000000b4 memory_alloc_for_page_dir
00014293 g     F .text	0000008d tty_fifo_get
000100e5 g       .text	00000000 exception_handler_bound_range
0001464e g     F .text	0000006d tty_in
00014f7a g     F .text	00000084 sem_notify
00010c74 g     F .text	00000082 memory_copy_uvm_data
00013c26 g     F .text	0000004c dev_control
00014004 g     F .text	000000c0 do_handler_kbd
00012b76 g     F .text	0000001c do_handler_invalid_opcode
0001015f g       .text	00000000 exception_handler_invalid_tss
00012da7 g     F .text	0000001c do_handler_fpu_error
0001143e g     F .text	000000ec task_first_init
00012ddf g     F .text	0000001c do_handler_machine_check
80000245 g     F .first_task	0000002d write
00014985 g     F .text	00000160 sys_open
00012aea g     F .text	0000001c do_handler_Debug
800002e1 g     F .first_task	00000027 fstat
00014be7 g     F .text	0000000a sys_isatty
0001588e g     F .text	0000005f list_insert_first
00013a3e g     F .text	00000150 dev_open
000117ca g     F .text	00000022 task_set_wakeup
00012b06 g     F .text	0000001c do_handler_NMI
0001004a g       .text	00000000 exception_handler_divider
000141d2 g     F .text	00000037 tty_fifo_init
000152e6 g     F .text	00000070 kernel_strncpy
0001266b g     F .text	0000000b irq_disable_global
000115e6 g     F .text	00000061 sys_sched_yield
00014b6c g     F .text	0000004d sys_write
8000036c g     F .first_task	00000021 wait
0006c96d g       *ABS*	00000000 mem_free_start
00014c92 g     F .text	00000035 kernel_init
00014ee9 g     F .text	00000023 sem_init
00010000 g       .text	00000000 _start
00015662 g     F .text	0000014b kernel_vsprintf
00015810 g     F .text	00000046 get_file_name
00010123 g       .text	00000000 exception_handler_device_unavailable
00010104 g       .text	00000000 exception_handler_invalid_opcode
00013c72 g     F .text	00000084 dev_close
0006c5e0 g       .bss	00000000 e_data
80000218 g     F .first_task	0000002d read
00014d90 g     F .text	0000008f mutex_lock
00012001 g     F .text	00000051 task_alloc_fd
000157e3 g     F .text	0000002d string_count
0001022c g       .text	00000000 exception_handler_machine_check
00014541 g     F .text	000000fd tty_write
00012bca g     F .text	0000001c do_handler_invalid_tss
00000000 g       .text	00000000 kernel_base
00014209 g     F .text	0000008a tty_fifo_put
0006c96d g       *ABS*	00000000 e_first_task
0001178e g     F .text	0000003c task_set_sleep
00014c09 g     F .text	00000089 sys_dup
000157ad g     F .text	00000036 panic
00012941 g     F .text	0000003a irq_install
00012384 g     F .text	0000008b init_gdt
00014320 g     F .text	00000100 tty_open
8000018d g     F .first_task	0000001b fork
00012e5e g     F .text	00000018 irq_enter_protection
00014d62 g     F .text	0000002e mutex_init
0001270c g     F .text	00000087 irq_disable
80000308 g     F .first_task	00000021 sbrk
0001024b g       .text	00000000 exception_handler_smd_exception
000109f2 g     F .text	000000e7 memory_destroy_uvm
00015027 g     F .text	00000016 bitmap_byte_count
00012b92 g     F .text	0000001c do_handler_device_unavailable
00011647 g     F .text	0000005b task_dispatch
00010ad9 g     F .text	00000155 memory_copy_uvm
00014648 g     F .text	00000006 tty_close
00014cc7 g     F .text	00000066 move_to_first_task
000124e9 g     F .text	00000014 switch_to_tss
0001385d g     F .text	000000e7 console_write
80000329 g     F .first_task	00000021 dup
00011597 g     F .text	00000045 task_next_run
0001549b g     F .text	00000064 kernel_memcmp
0001067c g     F .text	000000a7 create_kernel_table
00015869 g     F .text	00000025 list_init
00012dfb g     F .text	0000001c do_handler_smd_exception
000101d3 g       .text	00000000 exception_handler_page_fault
0001156a g     F .text	0000002d task_set_block
00012ab2 g     F .text	0000001c do_handler_unknown
00010926 g     F .text	00000020 memory_alloc_page
000101f0 g       .text	00000000 exception_handler_fpu_error
0001132f g     F .text	0000001e task_switch_from_to
00012793 g     F .text	000001ae irq_init
00014e1f g     F .text	000000bf mutex_unlock
000147aa g     F .text	00000030 file_table_init
00012e76 g     F .text	00000011 irq_leave_protection
00014768 g     F .text	00000042 file_free
80000165 g     F .first_task	00000028 print_msg
000153d0 g     F .text	0000003b kernel_strlen
000122fe g     F .text	00000086 segment_desc_set
00012b5a g     F .text	0000001c do_handler_bound_range
000102c7 g       .text	00000000 exception_handler_syscall
00015951 g     F .text	00000078 list_remove_first
000167c0 g       .rodata	00000000 e_text
00015356 g     F .text	0000007a kernel_strncmp
0001503d g     F .text	00000053 bitmap_init
0001017c g       .text	00000000 exception_handler_segment_not_present
00010088 g       .text	00000000 exception_handler_NMI
000151e5 g     F .text	000000b3 bitmap_alloc_nbits
000146e4 g     F .text	00000084 file_alloc
00011357 g     F .text	000000e7 task_manager_init
0001127c g     F .text	0000002d task_start
00010069 g       .text	00000000 exception_handler_Debug
000116a2 g     F .text	000000ec task_time_tick
00010723 g     F .text	000000a5 memory_init
00011e21 g     F .text	000001af sys_execve
000121cc g     F .text	000000f0 sys_wait
00012078 g     F .text	00000154 sys_exit
000146bb g     F .text	00000029 tty_select
00013944 g     F .text	00000006 console_close
00010c2e g     F .text	00000046 memory_get_paddr
00012c02 g     F .text	0000001c do_handler_stack_segment_fault
00012b22 g     F .text	0000001c do_handler_breakpoint
8000034a g     F .first_task	00000022 _exit
00015a7d g     F .text	000000b6 log_printf
00011123 g     F .text	00000159 task_init
800001f1 g     F .first_task	00000027 open
000154ff g     F .text	00000024 kernel_sprintf
00011850 g     F .text	00000016 sys_getpid
00012474 g     F .text	00000075 gdt_alloc_desc
00015523 g     F .text	0000013f kernel_itoa
000159c9 g     F .text	00000085 list_remove
0001240f g     F .text	00000047 gate_desc_set
80000120 g     F .first_task	0000002a msleep
80000272 g     F .first_task	00000021 close
0001052f g     F .text	000000b0 find_pte
000140e3 g     F .text	00000028 do_handler_time
0001416b g     F .text	00000018 time_init
00017060 g     O .data	00000038 dev_tty_desc



Disassembly of section .text:

00010000 <_start>:
_start:
    // 从栈中取出参数,参数保存在%eax中,最终传递给kernel_init函数
    // 参数位于load_32.c中
    // 以下三步可以简写为: mov 4(%esp),%eax
    // 传递的是boot_info
    push %ebp
   10000:	55                   	push   %ebp
    mov %esp,%ebp
   10001:	89 e5                	mov    %esp,%ebp
    mov 0x8(%ebp),%eax
   10003:	8b 45 08             	mov    0x8(%ebp),%eax
    
    push %eax
   10006:	50                   	push   %eax

    // kernel_init 位于init.c中
    call kernel_init
   10007:	e8 86 4c 00 00       	call   14c92 <kernel_init>

    // 加载到对应选择子以及偏移量
    jmp $KERNEL_SELECTOR_CS,$gdt_reload
   1000c:	ea 13 00 01 00 08 00 	ljmp   $0x8,$0x10013

00010013 <gdt_reload>:
gdt_reload:
    // 初始化寄存器
    mov $KERNEL_SELECTOR_DS,%ax
   10013:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
   10017:	8e d8                	mov    %eax,%ds
	mov %ax, %ss
   10019:	8e d0                	mov    %eax,%ss
	mov %ax, %es
   1001b:	8e c0                	mov    %eax,%es
	mov %ax, %fs
   1001d:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
   1001f:	8e e8                	mov    %eax,%gs
    mov $(stack+KERNEL_STACK_SIZE),%esp
   10021:	bc e0 c5 06 00       	mov    $0x6c5e0,%esp
    jmp init_main
   10026:	e9 02 4d 00 00       	jmp    14d2d <init_main>

0001002b <exception_handler_unknown>:
    iret

// 宏的结束
.endm

exception_handler unknown,-1,0
   1002b:	6a 00                	push   $0x0
   1002d:	6a ff                	push   $0xffffffff
   1002f:	60                   	pusha  
   10030:	1e                   	push   %ds
   10031:	06                   	push   %es
   10032:	0f a0                	push   %fs
   10034:	0f a8                	push   %gs
   10036:	54                   	push   %esp
   10037:	e8 76 2a 00 00       	call   12ab2 <do_handler_unknown>
   1003c:	83 c4 04             	add    $0x4,%esp
   1003f:	0f a9                	pop    %gs
   10041:	0f a1                	pop    %fs
   10043:	07                   	pop    %es
   10044:	1f                   	pop    %ds
   10045:	61                   	popa   
   10046:	83 c4 08             	add    $0x8,%esp
   10049:	cf                   	iret   

0001004a <exception_handler_divider>:
exception_handler divider,0,0
   1004a:	6a 00                	push   $0x0
   1004c:	6a 00                	push   $0x0
   1004e:	60                   	pusha  
   1004f:	1e                   	push   %ds
   10050:	06                   	push   %es
   10051:	0f a0                	push   %fs
   10053:	0f a8                	push   %gs
   10055:	54                   	push   %esp
   10056:	e8 73 2a 00 00       	call   12ace <do_handler_divider>
   1005b:	83 c4 04             	add    $0x4,%esp
   1005e:	0f a9                	pop    %gs
   10060:	0f a1                	pop    %fs
   10062:	07                   	pop    %es
   10063:	1f                   	pop    %ds
   10064:	61                   	popa   
   10065:	83 c4 08             	add    $0x8,%esp
   10068:	cf                   	iret   

00010069 <exception_handler_Debug>:
exception_handler Debug, 1, 0
   10069:	6a 00                	push   $0x0
   1006b:	6a 01                	push   $0x1
   1006d:	60                   	pusha  
   1006e:	1e                   	push   %ds
   1006f:	06                   	push   %es
   10070:	0f a0                	push   %fs
   10072:	0f a8                	push   %gs
   10074:	54                   	push   %esp
   10075:	e8 70 2a 00 00       	call   12aea <do_handler_Debug>
   1007a:	83 c4 04             	add    $0x4,%esp
   1007d:	0f a9                	pop    %gs
   1007f:	0f a1                	pop    %fs
   10081:	07                   	pop    %es
   10082:	1f                   	pop    %ds
   10083:	61                   	popa   
   10084:	83 c4 08             	add    $0x8,%esp
   10087:	cf                   	iret   

00010088 <exception_handler_NMI>:
exception_handler NMI, 2, 0
   10088:	6a 00                	push   $0x0
   1008a:	6a 02                	push   $0x2
   1008c:	60                   	pusha  
   1008d:	1e                   	push   %ds
   1008e:	06                   	push   %es
   1008f:	0f a0                	push   %fs
   10091:	0f a8                	push   %gs
   10093:	54                   	push   %esp
   10094:	e8 6d 2a 00 00       	call   12b06 <do_handler_NMI>
   10099:	83 c4 04             	add    $0x4,%esp
   1009c:	0f a9                	pop    %gs
   1009e:	0f a1                	pop    %fs
   100a0:	07                   	pop    %es
   100a1:	1f                   	pop    %ds
   100a2:	61                   	popa   
   100a3:	83 c4 08             	add    $0x8,%esp
   100a6:	cf                   	iret   

000100a7 <exception_handler_breakpoint>:
exception_handler breakpoint, 3, 0
   100a7:	6a 00                	push   $0x0
   100a9:	6a 03                	push   $0x3
   100ab:	60                   	pusha  
   100ac:	1e                   	push   %ds
   100ad:	06                   	push   %es
   100ae:	0f a0                	push   %fs
   100b0:	0f a8                	push   %gs
   100b2:	54                   	push   %esp
   100b3:	e8 6a 2a 00 00       	call   12b22 <do_handler_breakpoint>
   100b8:	83 c4 04             	add    $0x4,%esp
   100bb:	0f a9                	pop    %gs
   100bd:	0f a1                	pop    %fs
   100bf:	07                   	pop    %es
   100c0:	1f                   	pop    %ds
   100c1:	61                   	popa   
   100c2:	83 c4 08             	add    $0x8,%esp
   100c5:	cf                   	iret   

000100c6 <exception_handler_overflow>:
exception_handler overflow, 4, 0
   100c6:	6a 00                	push   $0x0
   100c8:	6a 04                	push   $0x4
   100ca:	60                   	pusha  
   100cb:	1e                   	push   %ds
   100cc:	06                   	push   %es
   100cd:	0f a0                	push   %fs
   100cf:	0f a8                	push   %gs
   100d1:	54                   	push   %esp
   100d2:	e8 67 2a 00 00       	call   12b3e <do_handler_overflow>
   100d7:	83 c4 04             	add    $0x4,%esp
   100da:	0f a9                	pop    %gs
   100dc:	0f a1                	pop    %fs
   100de:	07                   	pop    %es
   100df:	1f                   	pop    %ds
   100e0:	61                   	popa   
   100e1:	83 c4 08             	add    $0x8,%esp
   100e4:	cf                   	iret   

000100e5 <exception_handler_bound_range>:
exception_handler bound_range, 5, 0
   100e5:	6a 00                	push   $0x0
   100e7:	6a 05                	push   $0x5
   100e9:	60                   	pusha  
   100ea:	1e                   	push   %ds
   100eb:	06                   	push   %es
   100ec:	0f a0                	push   %fs
   100ee:	0f a8                	push   %gs
   100f0:	54                   	push   %esp
   100f1:	e8 64 2a 00 00       	call   12b5a <do_handler_bound_range>
   100f6:	83 c4 04             	add    $0x4,%esp
   100f9:	0f a9                	pop    %gs
   100fb:	0f a1                	pop    %fs
   100fd:	07                   	pop    %es
   100fe:	1f                   	pop    %ds
   100ff:	61                   	popa   
   10100:	83 c4 08             	add    $0x8,%esp
   10103:	cf                   	iret   

00010104 <exception_handler_invalid_opcode>:
exception_handler invalid_opcode, 6, 0
   10104:	6a 00                	push   $0x0
   10106:	6a 06                	push   $0x6
   10108:	60                   	pusha  
   10109:	1e                   	push   %ds
   1010a:	06                   	push   %es
   1010b:	0f a0                	push   %fs
   1010d:	0f a8                	push   %gs
   1010f:	54                   	push   %esp
   10110:	e8 61 2a 00 00       	call   12b76 <do_handler_invalid_opcode>
   10115:	83 c4 04             	add    $0x4,%esp
   10118:	0f a9                	pop    %gs
   1011a:	0f a1                	pop    %fs
   1011c:	07                   	pop    %es
   1011d:	1f                   	pop    %ds
   1011e:	61                   	popa   
   1011f:	83 c4 08             	add    $0x8,%esp
   10122:	cf                   	iret   

00010123 <exception_handler_device_unavailable>:
exception_handler device_unavailable, 7, 0
   10123:	6a 00                	push   $0x0
   10125:	6a 07                	push   $0x7
   10127:	60                   	pusha  
   10128:	1e                   	push   %ds
   10129:	06                   	push   %es
   1012a:	0f a0                	push   %fs
   1012c:	0f a8                	push   %gs
   1012e:	54                   	push   %esp
   1012f:	e8 5e 2a 00 00       	call   12b92 <do_handler_device_unavailable>
   10134:	83 c4 04             	add    $0x4,%esp
   10137:	0f a9                	pop    %gs
   10139:	0f a1                	pop    %fs
   1013b:	07                   	pop    %es
   1013c:	1f                   	pop    %ds
   1013d:	61                   	popa   
   1013e:	83 c4 08             	add    $0x8,%esp
   10141:	cf                   	iret   

00010142 <exception_handler_double_fault>:
exception_handler double_fault, 8, 1
   10142:	6a 08                	push   $0x8
   10144:	60                   	pusha  
   10145:	1e                   	push   %ds
   10146:	06                   	push   %es
   10147:	0f a0                	push   %fs
   10149:	0f a8                	push   %gs
   1014b:	54                   	push   %esp
   1014c:	e8 5d 2a 00 00       	call   12bae <do_handler_double_fault>
   10151:	83 c4 04             	add    $0x4,%esp
   10154:	0f a9                	pop    %gs
   10156:	0f a1                	pop    %fs
   10158:	07                   	pop    %es
   10159:	1f                   	pop    %ds
   1015a:	61                   	popa   
   1015b:	83 c4 08             	add    $0x8,%esp
   1015e:	cf                   	iret   

0001015f <exception_handler_invalid_tss>:
exception_handler invalid_tss, 10, 1
   1015f:	6a 0a                	push   $0xa
   10161:	60                   	pusha  
   10162:	1e                   	push   %ds
   10163:	06                   	push   %es
   10164:	0f a0                	push   %fs
   10166:	0f a8                	push   %gs
   10168:	54                   	push   %esp
   10169:	e8 5c 2a 00 00       	call   12bca <do_handler_invalid_tss>
   1016e:	83 c4 04             	add    $0x4,%esp
   10171:	0f a9                	pop    %gs
   10173:	0f a1                	pop    %fs
   10175:	07                   	pop    %es
   10176:	1f                   	pop    %ds
   10177:	61                   	popa   
   10178:	83 c4 08             	add    $0x8,%esp
   1017b:	cf                   	iret   

0001017c <exception_handler_segment_not_present>:
exception_handler segment_not_present, 11, 1
   1017c:	6a 0b                	push   $0xb
   1017e:	60                   	pusha  
   1017f:	1e                   	push   %ds
   10180:	06                   	push   %es
   10181:	0f a0                	push   %fs
   10183:	0f a8                	push   %gs
   10185:	54                   	push   %esp
   10186:	e8 5b 2a 00 00       	call   12be6 <do_handler_segment_not_present>
   1018b:	83 c4 04             	add    $0x4,%esp
   1018e:	0f a9                	pop    %gs
   10190:	0f a1                	pop    %fs
   10192:	07                   	pop    %es
   10193:	1f                   	pop    %ds
   10194:	61                   	popa   
   10195:	83 c4 08             	add    $0x8,%esp
   10198:	cf                   	iret   

00010199 <exception_handler_stack_segment_fault>:
exception_handler stack_segment_fault, 12, 1
   10199:	6a 0c                	push   $0xc
   1019b:	60                   	pusha  
   1019c:	1e                   	push   %ds
   1019d:	06                   	push   %es
   1019e:	0f a0                	push   %fs
   101a0:	0f a8                	push   %gs
   101a2:	54                   	push   %esp
   101a3:	e8 5a 2a 00 00       	call   12c02 <do_handler_stack_segment_fault>
   101a8:	83 c4 04             	add    $0x4,%esp
   101ab:	0f a9                	pop    %gs
   101ad:	0f a1                	pop    %fs
   101af:	07                   	pop    %es
   101b0:	1f                   	pop    %ds
   101b1:	61                   	popa   
   101b2:	83 c4 08             	add    $0x8,%esp
   101b5:	cf                   	iret   

000101b6 <exception_handler_general_protection>:
exception_handler general_protection, 13, 1
   101b6:	6a 0d                	push   $0xd
   101b8:	60                   	pusha  
   101b9:	1e                   	push   %ds
   101ba:	06                   	push   %es
   101bb:	0f a0                	push   %fs
   101bd:	0f a8                	push   %gs
   101bf:	54                   	push   %esp
   101c0:	e8 59 2a 00 00       	call   12c1e <do_handler_general_protection>
   101c5:	83 c4 04             	add    $0x4,%esp
   101c8:	0f a9                	pop    %gs
   101ca:	0f a1                	pop    %fs
   101cc:	07                   	pop    %es
   101cd:	1f                   	pop    %ds
   101ce:	61                   	popa   
   101cf:	83 c4 08             	add    $0x8,%esp
   101d2:	cf                   	iret   

000101d3 <exception_handler_page_fault>:
exception_handler page_fault, 14, 1
   101d3:	6a 0e                	push   $0xe
   101d5:	60                   	pusha  
   101d6:	1e                   	push   %ds
   101d7:	06                   	push   %es
   101d8:	0f a0                	push   %fs
   101da:	0f a8                	push   %gs
   101dc:	54                   	push   %esp
   101dd:	e8 f1 2a 00 00       	call   12cd3 <do_handler_page_fault>
   101e2:	83 c4 04             	add    $0x4,%esp
   101e5:	0f a9                	pop    %gs
   101e7:	0f a1                	pop    %fs
   101e9:	07                   	pop    %es
   101ea:	1f                   	pop    %ds
   101eb:	61                   	popa   
   101ec:	83 c4 08             	add    $0x8,%esp
   101ef:	cf                   	iret   

000101f0 <exception_handler_fpu_error>:
exception_handler fpu_error, 16, 0
   101f0:	6a 00                	push   $0x0
   101f2:	6a 10                	push   $0x10
   101f4:	60                   	pusha  
   101f5:	1e                   	push   %ds
   101f6:	06                   	push   %es
   101f7:	0f a0                	push   %fs
   101f9:	0f a8                	push   %gs
   101fb:	54                   	push   %esp
   101fc:	e8 a6 2b 00 00       	call   12da7 <do_handler_fpu_error>
   10201:	83 c4 04             	add    $0x4,%esp
   10204:	0f a9                	pop    %gs
   10206:	0f a1                	pop    %fs
   10208:	07                   	pop    %es
   10209:	1f                   	pop    %ds
   1020a:	61                   	popa   
   1020b:	83 c4 08             	add    $0x8,%esp
   1020e:	cf                   	iret   

0001020f <exception_handler_alignment_check>:
exception_handler alignment_check, 17, 1
   1020f:	6a 11                	push   $0x11
   10211:	60                   	pusha  
   10212:	1e                   	push   %ds
   10213:	06                   	push   %es
   10214:	0f a0                	push   %fs
   10216:	0f a8                	push   %gs
   10218:	54                   	push   %esp
   10219:	e8 a5 2b 00 00       	call   12dc3 <do_handler_alignment_check>
   1021e:	83 c4 04             	add    $0x4,%esp
   10221:	0f a9                	pop    %gs
   10223:	0f a1                	pop    %fs
   10225:	07                   	pop    %es
   10226:	1f                   	pop    %ds
   10227:	61                   	popa   
   10228:	83 c4 08             	add    $0x8,%esp
   1022b:	cf                   	iret   

0001022c <exception_handler_machine_check>:
exception_handler machine_check, 18, 0
   1022c:	6a 00                	push   $0x0
   1022e:	6a 12                	push   $0x12
   10230:	60                   	pusha  
   10231:	1e                   	push   %ds
   10232:	06                   	push   %es
   10233:	0f a0                	push   %fs
   10235:	0f a8                	push   %gs
   10237:	54                   	push   %esp
   10238:	e8 a2 2b 00 00       	call   12ddf <do_handler_machine_check>
   1023d:	83 c4 04             	add    $0x4,%esp
   10240:	0f a9                	pop    %gs
   10242:	0f a1                	pop    %fs
   10244:	07                   	pop    %es
   10245:	1f                   	pop    %ds
   10246:	61                   	popa   
   10247:	83 c4 08             	add    $0x8,%esp
   1024a:	cf                   	iret   

0001024b <exception_handler_smd_exception>:
exception_handler smd_exception, 19, 0
   1024b:	6a 00                	push   $0x0
   1024d:	6a 13                	push   $0x13
   1024f:	60                   	pusha  
   10250:	1e                   	push   %ds
   10251:	06                   	push   %es
   10252:	0f a0                	push   %fs
   10254:	0f a8                	push   %gs
   10256:	54                   	push   %esp
   10257:	e8 9f 2b 00 00       	call   12dfb <do_handler_smd_exception>
   1025c:	83 c4 04             	add    $0x4,%esp
   1025f:	0f a9                	pop    %gs
   10261:	0f a1                	pop    %fs
   10263:	07                   	pop    %es
   10264:	1f                   	pop    %ds
   10265:	61                   	popa   
   10266:	83 c4 08             	add    $0x8,%esp
   10269:	cf                   	iret   

0001026a <exception_handler_virtual_exception>:
exception_handler virtual_exception, 20, 0
   1026a:	6a 00                	push   $0x0
   1026c:	6a 14                	push   $0x14
   1026e:	60                   	pusha  
   1026f:	1e                   	push   %ds
   10270:	06                   	push   %es
   10271:	0f a0                	push   %fs
   10273:	0f a8                	push   %gs
   10275:	54                   	push   %esp
   10276:	e8 9c 2b 00 00       	call   12e17 <do_handler_virtual_exception>
   1027b:	83 c4 04             	add    $0x4,%esp
   1027e:	0f a9                	pop    %gs
   10280:	0f a1                	pop    %fs
   10282:	07                   	pop    %es
   10283:	1f                   	pop    %ds
   10284:	61                   	popa   
   10285:	83 c4 08             	add    $0x8,%esp
   10288:	cf                   	iret   

00010289 <exception_handler_time>:
exception_handler time,0x20,0
   10289:	6a 00                	push   $0x0
   1028b:	6a 20                	push   $0x20
   1028d:	60                   	pusha  
   1028e:	1e                   	push   %ds
   1028f:	06                   	push   %es
   10290:	0f a0                	push   %fs
   10292:	0f a8                	push   %gs
   10294:	54                   	push   %esp
   10295:	e8 49 3e 00 00       	call   140e3 <do_handler_time>
   1029a:	83 c4 04             	add    $0x4,%esp
   1029d:	0f a9                	pop    %gs
   1029f:	0f a1                	pop    %fs
   102a1:	07                   	pop    %es
   102a2:	1f                   	pop    %ds
   102a3:	61                   	popa   
   102a4:	83 c4 08             	add    $0x8,%esp
   102a7:	cf                   	iret   

000102a8 <exception_handler_kbd>:
exception_handler kbd,0x21,0
   102a8:	6a 00                	push   $0x0
   102aa:	6a 21                	push   $0x21
   102ac:	60                   	pusha  
   102ad:	1e                   	push   %ds
   102ae:	06                   	push   %es
   102af:	0f a0                	push   %fs
   102b1:	0f a8                	push   %gs
   102b3:	54                   	push   %esp
   102b4:	e8 4b 3d 00 00       	call   14004 <do_handler_kbd>
   102b9:	83 c4 04             	add    $0x4,%esp
   102bc:	0f a9                	pop    %gs
   102be:	0f a1                	pop    %fs
   102c0:	07                   	pop    %es
   102c1:	1f                   	pop    %ds
   102c2:	61                   	popa   
   102c3:	83 c4 08             	add    $0x8,%esp
   102c6:	cf                   	iret   

000102c7 <exception_handler_syscall>:

    .global exception_handler_syscall
    .extern do_handler_syscall
exception_handler_syscall:
    pusha
   102c7:	60                   	pusha  
    push %ds
   102c8:	1e                   	push   %ds
    push %es
   102c9:	06                   	push   %es
    push %fs
   102ca:	0f a0                	push   %fs
    push %gs
   102cc:	0f a8                	push   %gs
    pushf
   102ce:	9c                   	pushf  

    mov %esp,%eax
   102cf:	89 e0                	mov    %esp,%eax
    push %eax
   102d1:	50                   	push   %eax

    call do_handler_syscall
   102d2:	e8 45 0b 00 00       	call   10e1c <do_handler_syscall>
    add $4,%esp
   102d7:	83 c4 04             	add    $0x4,%esp
    
    popf
   102da:	9d                   	popf   
    pop %gs
   102db:	0f a9                	pop    %gs
    pop %fs
   102dd:	0f a1                	pop    %fs
    pop %es
   102df:	07                   	pop    %es
    pop %ds
   102e0:	1f                   	pop    %ds
    popa
   102e1:	61                   	popa   

   102e2:	ca 14 00             	lret   $0x14

000102e5 <read_cr0>:

/**
 * @brief 读取cr0寄存器
 * @return cr0寄存器的值 
 */
static inline uint32_t read_cr0(void){
   102e5:	55                   	push   %ebp
   102e6:	89 e5                	mov    %esp,%ebp
   102e8:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr0;
    __asm__ __volatile__(
   102eb:	0f 20 c0             	mov    %cr0,%eax
   102ee:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "mov %%cr0, %[v]"
        :[v]"=r"(cr0)
        :
    );
    return cr0;
   102f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   102f4:	c9                   	leave  
   102f5:	c3                   	ret    

000102f6 <write_cr0>:

/**
 * @brief 读取cr0寄存器
 * @return cr0寄存器的值 
 */
static inline void write_cr0(uint32_t v){
   102f6:	55                   	push   %ebp
   102f7:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   102f9:	8b 45 08             	mov    0x8(%ebp),%eax
   102fc:	0f 22 c0             	mov    %eax,%cr0
        "mov %[v],%%cr0"
        :
        :[v]"r"(v)
    );
}
   102ff:	90                   	nop
   10300:	5d                   	pop    %ebp
   10301:	c3                   	ret    

00010302 <write_cr3>:
        :
        :"a"(eflags)
    );
}

static inline void write_cr3(uint32_t v){
   10302:	55                   	push   %ebp
   10303:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10305:	8b 45 08             	mov    0x8(%ebp),%eax
   10308:	0f 22 d8             	mov    %eax,%cr3
        "mov %[v],%%cr3"
        :
        :[v]"r"(v)
    );
}
   1030b:	90                   	nop
   1030c:	5d                   	pop    %ebp
   1030d:	c3                   	ret    

0001030e <write_cr4>:

/**
 * @brief 写入cr4寄存器
 * @param v 要写入的值
 */
static inline void write_cr4(uint32_t v){
   1030e:	55                   	push   %ebp
   1030f:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10311:	8b 45 08             	mov    0x8(%ebp),%eax
   10314:	0f 22 e0             	mov    %eax,%cr4
        "mov %[v],%%cr4"
        :
        :[v]"r"(v)
    );
}
   10317:	90                   	nop
   10318:	5d                   	pop    %ebp
   10319:	c3                   	ret    

0001031a <read_cr4>:

/**
 * @brief 读取cr4寄存器
 * @return cr4寄存器的值 
*/
static inline uint32_t read_cr4(void){
   1031a:	55                   	push   %ebp
   1031b:	89 e5                	mov    %esp,%ebp
   1031d:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr4;
    __asm__ __volatile__(
   10320:	0f 20 e0             	mov    %cr4,%eax
   10323:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "mov %%cr4,%[v]"
        :[v]"=r"(cr4)
        :
    );
    return cr4;
   10326:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10329:	c9                   	leave  
   1032a:	c3                   	ret    

0001032b <down2>:
#include <stdarg.h>
#include "comm/types.h"
#include "tools/log.h"
#include "comm/cpu_instr.h"

static inline uint32_t down2(uint32_t size,uint32_t bound){
   1032b:	55                   	push   %ebp
   1032c:	89 e5                	mov    %esp,%ebp
    return size & ~(bound-1);
   1032e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10331:	f7 d8                	neg    %eax
   10333:	23 45 08             	and    0x8(%ebp),%eax
}
   10336:	5d                   	pop    %ebp
   10337:	c3                   	ret    

00010338 <up2>:

static inline uint32_t up2(uint32_t size,uint32_t bound){
   10338:	55                   	push   %ebp
   10339:	89 e5                	mov    %esp,%ebp
    return (size+bound-1) & ~(bound-1);
   1033b:	8b 55 08             	mov    0x8(%ebp),%edx
   1033e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10341:	01 d0                	add    %edx,%eax
   10343:	8d 50 ff             	lea    -0x1(%eax),%edx
   10346:	8b 45 0c             	mov    0xc(%ebp),%eax
   10349:	f7 d8                	neg    %eax
   1034b:	21 d0                	and    %edx,%eax
}
   1034d:	5d                   	pop    %ebp
   1034e:	c3                   	ret    

0001034f <mmu_set_page_dir>:

/**
 * @brief 将页目录的物理地址写入cr3寄存器
 * @param paddr 页目录表的物理地址 
*/
static inline void mmu_set_page_dir(uint32_t paddr){
   1034f:	55                   	push   %ebp
   10350:	89 e5                	mov    %esp,%ebp
   10352:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr4=read_cr4();
   10355:	e8 c0 ff ff ff       	call   1031a <read_cr4>
   1035a:	89 45 fc             	mov    %eax,-0x4(%ebp)
	write_cr4(cr4|CR4_PSE);
   1035d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10360:	83 c8 10             	or     $0x10,%eax
   10363:	50                   	push   %eax
   10364:	e8 a5 ff ff ff       	call   1030e <write_cr4>
   10369:	83 c4 04             	add    $0x4,%esp
	write_cr3(paddr);
   1036c:	ff 75 08             	pushl  0x8(%ebp)
   1036f:	e8 8e ff ff ff       	call   10302 <write_cr3>
   10374:	83 c4 04             	add    $0x4,%esp
	write_cr0(read_cr0()|CR0_PG);
   10377:	e8 69 ff ff ff       	call   102e5 <read_cr0>
   1037c:	0d 00 00 00 80       	or     $0x80000000,%eax
   10381:	50                   	push   %eax
   10382:	e8 6f ff ff ff       	call   102f6 <write_cr0>
   10387:	83 c4 04             	add    $0x4,%esp
}
   1038a:	90                   	nop
   1038b:	c9                   	leave  
   1038c:	c3                   	ret    

0001038d <pde_index>:

static inline uint32_t pde_index(uint32_t vaddr){
   1038d:	55                   	push   %ebp
   1038e:	89 e5                	mov    %esp,%ebp
    return vaddr >> 22;
   10390:	8b 45 08             	mov    0x8(%ebp),%eax
   10393:	c1 e8 16             	shr    $0x16,%eax
}
   10396:	5d                   	pop    %ebp
   10397:	c3                   	ret    

00010398 <pte_index>:

static inline uint32_t pte_index(uint32_t vaddr){
   10398:	55                   	push   %ebp
   10399:	89 e5                	mov    %esp,%ebp
    return (vaddr >> 12)  & 0x3FF;
   1039b:	8b 45 08             	mov    0x8(%ebp),%eax
   1039e:	c1 e8 0c             	shr    $0xc,%eax
   103a1:	25 ff 03 00 00       	and    $0x3ff,%eax
}
   103a6:	5d                   	pop    %ebp
   103a7:	c3                   	ret    

000103a8 <pde_paddr>:

static inline uint32_t pde_paddr(pde_t* pde){
   103a8:	55                   	push   %ebp
   103a9:	89 e5                	mov    %esp,%ebp
    return pde->phy_pt_addr << 12;
   103ab:	8b 45 08             	mov    0x8(%ebp),%eax
   103ae:	8b 00                	mov    (%eax),%eax
   103b0:	c1 e8 0c             	shr    $0xc,%eax
   103b3:	c1 e0 0c             	shl    $0xc,%eax
}
   103b6:	5d                   	pop    %ebp
   103b7:	c3                   	ret    

000103b8 <pte_paddr>:

static inline uint32_t pte_paddr(pte_t* pte){
   103b8:	55                   	push   %ebp
   103b9:	89 e5                	mov    %esp,%ebp
    return pte->phy_pt_addr << 12;
   103bb:	8b 45 08             	mov    0x8(%ebp),%eax
   103be:	8b 00                	mov    (%eax),%eax
   103c0:	c1 e8 0c             	shr    $0xc,%eax
   103c3:	c1 e0 0c             	shl    $0xc,%eax
}
   103c6:	5d                   	pop    %ebp
   103c7:	c3                   	ret    

000103c8 <get_pte_perm>:

static inline uint32_t get_pte_perm(pte_t* pte){
   103c8:	55                   	push   %ebp
   103c9:	89 e5                	mov    %esp,%ebp
    return (pte->v & 0x1FF);
   103cb:	8b 45 08             	mov    0x8(%ebp),%eax
   103ce:	8b 00                	mov    (%eax),%eax
   103d0:	25 ff 01 00 00       	and    $0x1ff,%eax
}
   103d5:	5d                   	pop    %ebp
   103d6:	c3                   	ret    

000103d7 <addr_alloc_init>:

/// @brief 内核页目录表
static pde_t kernel_page_dir[PDE_CNT] __attribute__((aligned(MEM_PAGE_SIZE)));

static void addr_alloc_init(addr_alloc_t* alloc,uint8_t* bits,
    uint32_t start,uint32_t size,uint32_t page_size){
   103d7:	55                   	push   %ebp
   103d8:	89 e5                	mov    %esp,%ebp
   103da:	83 ec 08             	sub    $0x8,%esp
        mutex_init(&alloc->mutex);
   103dd:	8b 45 08             	mov    0x8(%ebp),%eax
   103e0:	83 ec 0c             	sub    $0xc,%esp
   103e3:	50                   	push   %eax
   103e4:	e8 79 49 00 00       	call   14d62 <mutex_init>
   103e9:	83 c4 10             	add    $0x10,%esp
        alloc->start=start;
   103ec:	8b 45 08             	mov    0x8(%ebp),%eax
   103ef:	8b 55 10             	mov    0x10(%ebp),%edx
   103f2:	89 50 1c             	mov    %edx,0x1c(%eax)
        alloc->size=size;
   103f5:	8b 45 08             	mov    0x8(%ebp),%eax
   103f8:	8b 55 14             	mov    0x14(%ebp),%edx
   103fb:	89 50 20             	mov    %edx,0x20(%eax)
        alloc->page_size=page_size;
   103fe:	8b 45 08             	mov    0x8(%ebp),%eax
   10401:	8b 55 18             	mov    0x18(%ebp),%edx
   10404:	89 50 24             	mov    %edx,0x24(%eax)
        bitmap_init(&alloc->bitmap,bits,alloc->size/page_size,0);
   10407:	8b 45 08             	mov    0x8(%ebp),%eax
   1040a:	8b 40 20             	mov    0x20(%eax),%eax
   1040d:	ba 00 00 00 00       	mov    $0x0,%edx
   10412:	f7 75 18             	divl   0x18(%ebp)
   10415:	89 c2                	mov    %eax,%edx
   10417:	8b 45 08             	mov    0x8(%ebp),%eax
   1041a:	83 c0 14             	add    $0x14,%eax
   1041d:	6a 00                	push   $0x0
   1041f:	52                   	push   %edx
   10420:	ff 75 0c             	pushl  0xc(%ebp)
   10423:	50                   	push   %eax
   10424:	e8 14 4c 00 00       	call   1503d <bitmap_init>
   10429:	83 c4 10             	add    $0x10,%esp
}
   1042c:	90                   	nop
   1042d:	c9                   	leave  
   1042e:	c3                   	ret    

0001042f <addr_alloc_page>:

static uint32_t addr_alloc_page(addr_alloc_t* alloc,int page_count){
   1042f:	55                   	push   %ebp
   10430:	89 e5                	mov    %esp,%ebp
   10432:	83 ec 18             	sub    $0x18,%esp
    uint32_t addr=0;
   10435:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    mutex_lock(&alloc->mutex);
   1043c:	8b 45 08             	mov    0x8(%ebp),%eax
   1043f:	83 ec 0c             	sub    $0xc,%esp
   10442:	50                   	push   %eax
   10443:	e8 48 49 00 00       	call   14d90 <mutex_lock>
   10448:	83 c4 10             	add    $0x10,%esp
    int page_index=bitmap_alloc_nbits(&alloc->bitmap,0,page_count);
   1044b:	8b 45 08             	mov    0x8(%ebp),%eax
   1044e:	83 c0 14             	add    $0x14,%eax
   10451:	83 ec 04             	sub    $0x4,%esp
   10454:	ff 75 0c             	pushl  0xc(%ebp)
   10457:	6a 00                	push   $0x0
   10459:	50                   	push   %eax
   1045a:	e8 86 4d 00 00       	call   151e5 <bitmap_alloc_nbits>
   1045f:	83 c4 10             	add    $0x10,%esp
   10462:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(page_index>=0){
   10465:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10469:	78 17                	js     10482 <addr_alloc_page+0x53>
        addr=alloc->start+page_index*alloc->page_size;
   1046b:	8b 45 08             	mov    0x8(%ebp),%eax
   1046e:	8b 50 1c             	mov    0x1c(%eax),%edx
   10471:	8b 45 08             	mov    0x8(%ebp),%eax
   10474:	8b 48 24             	mov    0x24(%eax),%ecx
   10477:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1047a:	0f af c1             	imul   %ecx,%eax
   1047d:	01 d0                	add    %edx,%eax
   1047f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    mutex_unlock(&alloc->mutex);
   10482:	8b 45 08             	mov    0x8(%ebp),%eax
   10485:	83 ec 0c             	sub    $0xc,%esp
   10488:	50                   	push   %eax
   10489:	e8 91 49 00 00       	call   14e1f <mutex_unlock>
   1048e:	83 c4 10             	add    $0x10,%esp
    return addr;
   10491:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10494:	c9                   	leave  
   10495:	c3                   	ret    

00010496 <addr_free_page>:
 * @brief 释放页表项对应的物理页
 * @param alloc 内存页管理器的指针
 * @param addr 页表项对应的物理页的地址
 * @param page_count 页表项对应的物理页的数量
*/
static void addr_free_page(addr_alloc_t* alloc,uint32_t addr,int page_count){
   10496:	55                   	push   %ebp
   10497:	89 e5                	mov    %esp,%ebp
   10499:	53                   	push   %ebx
   1049a:	83 ec 14             	sub    $0x14,%esp
    mutex_lock(&alloc->mutex);
   1049d:	8b 45 08             	mov    0x8(%ebp),%eax
   104a0:	83 ec 0c             	sub    $0xc,%esp
   104a3:	50                   	push   %eax
   104a4:	e8 e7 48 00 00       	call   14d90 <mutex_lock>
   104a9:	83 c4 10             	add    $0x10,%esp
    uint32_t pg_index=(addr-alloc->start)/alloc->page_size;
   104ac:	8b 45 08             	mov    0x8(%ebp),%eax
   104af:	8b 40 1c             	mov    0x1c(%eax),%eax
   104b2:	8b 55 0c             	mov    0xc(%ebp),%edx
   104b5:	89 d1                	mov    %edx,%ecx
   104b7:	29 c1                	sub    %eax,%ecx
   104b9:	8b 45 08             	mov    0x8(%ebp),%eax
   104bc:	8b 58 24             	mov    0x24(%eax),%ebx
   104bf:	89 c8                	mov    %ecx,%eax
   104c1:	ba 00 00 00 00       	mov    $0x0,%edx
   104c6:	f7 f3                	div    %ebx
   104c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bitmap_set_bit(&alloc->bitmap,pg_index,page_count,0);
   104cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   104ce:	8b 55 08             	mov    0x8(%ebp),%edx
   104d1:	83 c2 14             	add    $0x14,%edx
   104d4:	6a 00                	push   $0x0
   104d6:	ff 75 10             	pushl  0x10(%ebp)
   104d9:	50                   	push   %eax
   104da:	52                   	push   %edx
   104db:	e8 ff 4b 00 00       	call   150df <bitmap_set_bit>
   104e0:	83 c4 10             	add    $0x10,%esp
    mutex_unlock(&alloc->mutex);
   104e3:	8b 45 08             	mov    0x8(%ebp),%eax
   104e6:	83 ec 0c             	sub    $0xc,%esp
   104e9:	50                   	push   %eax
   104ea:	e8 30 49 00 00       	call   14e1f <mutex_unlock>
   104ef:	83 c4 10             	add    $0x10,%esp
}
   104f2:	90                   	nop
   104f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   104f6:	c9                   	leave  
   104f7:	c3                   	ret    

000104f8 <total_mem_size>:

static uint32_t total_mem_size(boot_info_t* boot_info){
   104f8:	55                   	push   %ebp
   104f9:	89 e5                	mov    %esp,%ebp
   104fb:	83 ec 10             	sub    $0x10,%esp
    uint32_t mem_size=0;
   104fe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for(int i=0;i<boot_info->ram_region_count;i++){
   10505:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1050c:	eb 11                	jmp    1051f <total_mem_size+0x27>
        mem_size+=boot_info->ram_region_cfg[i].size;
   1050e:	8b 45 08             	mov    0x8(%ebp),%eax
   10511:	8b 55 f8             	mov    -0x8(%ebp),%edx
   10514:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
   10518:	01 45 fc             	add    %eax,-0x4(%ebp)
    for(int i=0;i<boot_info->ram_region_count;i++){
   1051b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1051f:	8b 45 08             	mov    0x8(%ebp),%eax
   10522:	8b 40 50             	mov    0x50(%eax),%eax
   10525:	39 45 f8             	cmp    %eax,-0x8(%ebp)
   10528:	7c e4                	jl     1050e <total_mem_size+0x16>
    }
    return mem_size;
   1052a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1052d:	c9                   	leave  
   1052e:	c3                   	ret    

0001052f <find_pte>:

pte_t* find_pte(pde_t*page_dir,uint32_t vaddr,int alloc){
   1052f:	55                   	push   %ebp
   10530:	89 e5                	mov    %esp,%ebp
   10532:	83 ec 18             	sub    $0x18,%esp
    pte_t* page_table;
    pde_t* pde=page_dir+pde_index(vaddr);
   10535:	ff 75 0c             	pushl  0xc(%ebp)
   10538:	e8 50 fe ff ff       	call   1038d <pde_index>
   1053d:	83 c4 04             	add    $0x4,%esp
   10540:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10547:	8b 45 08             	mov    0x8(%ebp),%eax
   1054a:	01 d0                	add    %edx,%eax
   1054c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(pde->present){
   1054f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10552:	0f b6 00             	movzbl (%eax),%eax
   10555:	83 e0 01             	and    $0x1,%eax
   10558:	84 c0                	test   %al,%al
   1055a:	74 10                	je     1056c <find_pte+0x3d>
        page_table=(pte_t*)pde_paddr(pde);
   1055c:	ff 75 f0             	pushl  -0x10(%ebp)
   1055f:	e8 44 fe ff ff       	call   103a8 <pde_paddr>
   10564:	83 c4 04             	add    $0x4,%esp
   10567:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1056a:	eb 57                	jmp    105c3 <find_pte+0x94>
    }
    else{
        if(alloc==0){
   1056c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   10570:	75 07                	jne    10579 <find_pte+0x4a>
            return (pte_t*)0;
   10572:	b8 00 00 00 00       	mov    $0x0,%eax
   10577:	eb 64                	jmp    105dd <find_pte+0xae>
        }
        uint32_t pg_paddr=addr_alloc_page(&paddr_alloc,1);
   10579:	83 ec 08             	sub    $0x8,%esp
   1057c:	6a 01                	push   $0x1
   1057e:	68 00 80 01 00       	push   $0x18000
   10583:	e8 a7 fe ff ff       	call   1042f <addr_alloc_page>
   10588:	83 c4 10             	add    $0x10,%esp
   1058b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(pg_paddr==0) return (pte_t*)0;
   1058e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10592:	75 07                	jne    1059b <find_pte+0x6c>
   10594:	b8 00 00 00 00       	mov    $0x0,%eax
   10599:	eb 42                	jmp    105dd <find_pte+0xae>
        pde->v=pg_paddr | PTE_P | PDE_W | PDE_U;
   1059b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1059e:	83 c8 07             	or     $0x7,%eax
   105a1:	89 c2                	mov    %eax,%edx
   105a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105a6:	89 10                	mov    %edx,(%eax)
        page_table=(pte_t*)pg_paddr;
   105a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   105ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
        kernel_memset(page_table,0,MEM_PAGE_SIZE);
   105ae:	83 ec 04             	sub    $0x4,%esp
   105b1:	68 00 10 00 00       	push   $0x1000
   105b6:	6a 00                	push   $0x0
   105b8:	ff 75 f4             	pushl  -0xc(%ebp)
   105bb:	e8 9a 4e 00 00       	call   1545a <kernel_memset>
   105c0:	83 c4 10             	add    $0x10,%esp
    }

    return page_table+pte_index(vaddr);
   105c3:	83 ec 0c             	sub    $0xc,%esp
   105c6:	ff 75 0c             	pushl  0xc(%ebp)
   105c9:	e8 ca fd ff ff       	call   10398 <pte_index>
   105ce:	83 c4 10             	add    $0x10,%esp
   105d1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   105d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   105db:	01 d0                	add    %edx,%eax
}
   105dd:	c9                   	leave  
   105de:	c3                   	ret    

000105df <memory_create_map>:

int memory_create_map(pde_t* page_dir,uint32_t vaddr,uint32_t paddr,int count,uint32_t perm){
   105df:	55                   	push   %ebp
   105e0:	89 e5                	mov    %esp,%ebp
   105e2:	83 ec 18             	sub    $0x18,%esp
    for(int i=0;i<count;i++){
   105e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   105ec:	eb 7b                	jmp    10669 <memory_create_map+0x8a>
        pte_t* pte=find_pte(page_dir,vaddr,1);
   105ee:	83 ec 04             	sub    $0x4,%esp
   105f1:	6a 01                	push   $0x1
   105f3:	ff 75 0c             	pushl  0xc(%ebp)
   105f6:	ff 75 08             	pushl  0x8(%ebp)
   105f9:	e8 31 ff ff ff       	call   1052f <find_pte>
   105fe:	83 c4 10             	add    $0x10,%esp
   10601:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(pte==(pte_t*)0){
   10604:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10608:	75 17                	jne    10621 <memory_create_map+0x42>
            log_printf("create pte failed.pte==0");
   1060a:	83 ec 0c             	sub    $0xc,%esp
   1060d:	68 40 5b 01 00       	push   $0x15b40
   10612:	e8 66 54 00 00       	call   15a7d <log_printf>
   10617:	83 c4 10             	add    $0x10,%esp
            return -1;
   1061a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1061f:	eb 59                	jmp    1067a <memory_create_map+0x9b>
        }
        ASSERT(pte->present==0);
   10621:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10624:	0f b6 00             	movzbl (%eax),%eax
   10627:	83 e0 01             	and    $0x1,%eax
   1062a:	84 c0                	test   %al,%al
   1062c:	74 19                	je     10647 <memory_create_map+0x68>
   1062e:	68 59 5b 01 00       	push   $0x15b59
   10633:	68 58 5c 01 00       	push   $0x15c58
   10638:	6a 50                	push   $0x50
   1063a:	68 6c 5b 01 00       	push   $0x15b6c
   1063f:	e8 69 51 00 00       	call   157ad <panic>
   10644:	83 c4 10             	add    $0x10,%esp
        pte->v=paddr | perm | PTE_P;
   10647:	8b 45 10             	mov    0x10(%ebp),%eax
   1064a:	0b 45 18             	or     0x18(%ebp),%eax
   1064d:	83 c8 01             	or     $0x1,%eax
   10650:	89 c2                	mov    %eax,%edx
   10652:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10655:	89 10                	mov    %edx,(%eax)
        vaddr+=MEM_PAGE_SIZE;
   10657:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
        paddr+=MEM_PAGE_SIZE;
   1065e:	81 45 10 00 10 00 00 	addl   $0x1000,0x10(%ebp)
    for(int i=0;i<count;i++){
   10665:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10669:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1066c:	3b 45 14             	cmp    0x14(%ebp),%eax
   1066f:	0f 8c 79 ff ff ff    	jl     105ee <memory_create_map+0xf>
    }
    return 0;
   10675:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1067a:	c9                   	leave  
   1067b:	c3                   	ret    

0001067c <create_kernel_table>:

void create_kernel_table(void){
   1067c:	55                   	push   %ebp
   1067d:	89 e5                	mov    %esp,%ebp
   1067f:	83 ec 28             	sub    $0x28,%esp
        {s_data,(void*)(MEM_EBDA_START-1),s_data,PTE_W},
        {(void*)CONSOLE_DISP_ADDR,(void*)CONSOLE_DISP_END,(void*)CONSOLE_DISP_ADDR, PTE_W},
        {(void*)MEM_EXT_START,(void*)MEM_EXT_END,(void*)MEM_EXT_START,PTE_W},
    };

    for(int i=0;i<sizeof(kernel_map)/sizeof(memory_map_t);i++){
   10682:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10689:	e9 86 00 00 00       	jmp    10714 <create_kernel_table+0x98>
        memory_map_t* map=kernel_map+i;
   1068e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10691:	c1 e0 04             	shl    $0x4,%eax
   10694:	05 00 70 01 00       	add    $0x17000,%eax
   10699:	89 45 f0             	mov    %eax,-0x10(%ebp)

        uint32_t vstart=down2((uint32_t)map->vstart,MEM_PAGE_SIZE);
   1069c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1069f:	8b 00                	mov    (%eax),%eax
   106a1:	68 00 10 00 00       	push   $0x1000
   106a6:	50                   	push   %eax
   106a7:	e8 7f fc ff ff       	call   1032b <down2>
   106ac:	83 c4 08             	add    $0x8,%esp
   106af:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t vend=up2((uint32_t)map->vend,MEM_PAGE_SIZE);
   106b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106b5:	8b 40 04             	mov    0x4(%eax),%eax
   106b8:	68 00 10 00 00       	push   $0x1000
   106bd:	50                   	push   %eax
   106be:	e8 75 fc ff ff       	call   10338 <up2>
   106c3:	83 c4 08             	add    $0x8,%esp
   106c6:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t paddr=down2((uint32_t)map->pstart,MEM_PAGE_SIZE);
   106c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106cc:	8b 40 08             	mov    0x8(%eax),%eax
   106cf:	68 00 10 00 00       	push   $0x1000
   106d4:	50                   	push   %eax
   106d5:	e8 51 fc ff ff       	call   1032b <down2>
   106da:	83 c4 08             	add    $0x8,%esp
   106dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int page_count=(vend-vstart) / MEM_PAGE_SIZE;
   106e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   106e3:	2b 45 ec             	sub    -0x14(%ebp),%eax
   106e6:	c1 e8 0c             	shr    $0xc,%eax
   106e9:	89 45 e0             	mov    %eax,-0x20(%ebp)
        
        
        memory_create_map(kernel_page_dir,vstart,(uint32_t)map->pstart,page_count,map->perm);
   106ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106ef:	8b 40 0c             	mov    0xc(%eax),%eax
   106f2:	8b 55 f0             	mov    -0x10(%ebp),%edx
   106f5:	8b 52 08             	mov    0x8(%edx),%edx
   106f8:	83 ec 0c             	sub    $0xc,%esp
   106fb:	50                   	push   %eax
   106fc:	ff 75 e0             	pushl  -0x20(%ebp)
   106ff:	52                   	push   %edx
   10700:	ff 75 ec             	pushl  -0x14(%ebp)
   10703:	68 00 90 01 00       	push   $0x19000
   10708:	e8 d2 fe ff ff       	call   105df <memory_create_map>
   1070d:	83 c4 20             	add    $0x20,%esp
    for(int i=0;i<sizeof(kernel_map)/sizeof(memory_map_t);i++){
   10710:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10714:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10717:	83 f8 04             	cmp    $0x4,%eax
   1071a:	0f 86 6e ff ff ff    	jbe    1068e <create_kernel_table+0x12>
    }
}
   10720:	90                   	nop
   10721:	c9                   	leave  
   10722:	c3                   	ret    

00010723 <memory_init>:

void memory_init(boot_info_t* boot_info){
   10723:	55                   	push   %ebp
   10724:	89 e5                	mov    %esp,%ebp
   10726:	83 ec 18             	sub    $0x18,%esp
   extern uint8_t* mem_free_start;
   uint8_t* mem_free=(uint8_t*)&mem_free_start;
   10729:	c7 45 f4 6d c9 06 00 	movl   $0x6c96d,-0xc(%ebp)
   uint32_t mem_up1MB_free=total_mem_size(boot_info)-MEM_EXT_START;
   10730:	ff 75 08             	pushl  0x8(%ebp)
   10733:	e8 c0 fd ff ff       	call   104f8 <total_mem_size>
   10738:	83 c4 04             	add    $0x4,%esp
   1073b:	2d 00 00 10 00       	sub    $0x100000,%eax
   10740:	89 45 f0             	mov    %eax,-0x10(%ebp)
   mem_up1MB_free=down2(mem_up1MB_free,MEM_PAGE_SIZE);
   10743:	68 00 10 00 00       	push   $0x1000
   10748:	ff 75 f0             	pushl  -0x10(%ebp)
   1074b:	e8 db fb ff ff       	call   1032b <down2>
   10750:	83 c4 08             	add    $0x8,%esp
   10753:	89 45 f0             	mov    %eax,-0x10(%ebp)
   addr_alloc_init(&paddr_alloc,mem_free,MEM_EXT_START,mem_up1MB_free,MEM_PAGE_SIZE);
   10756:	83 ec 0c             	sub    $0xc,%esp
   10759:	68 00 10 00 00       	push   $0x1000
   1075e:	ff 75 f0             	pushl  -0x10(%ebp)
   10761:	68 00 00 10 00       	push   $0x100000
   10766:	ff 75 f4             	pushl  -0xc(%ebp)
   10769:	68 00 80 01 00       	push   $0x18000
   1076e:	e8 64 fc ff ff       	call   103d7 <addr_alloc_init>
   10773:	83 c4 20             	add    $0x20,%esp
   mem_free+=bitmap_byte_count(paddr_alloc.size/MEM_PAGE_SIZE);
   10776:	a1 20 80 01 00       	mov    0x18020,%eax
   1077b:	c1 e8 0c             	shr    $0xc,%eax
   1077e:	83 ec 0c             	sub    $0xc,%esp
   10781:	50                   	push   %eax
   10782:	e8 a0 48 00 00       	call   15027 <bitmap_byte_count>
   10787:	83 c4 10             	add    $0x10,%esp
   1078a:	01 45 f4             	add    %eax,-0xc(%ebp)
   ASSERT(mem_free < (uint8_t *)MEM_EBDA_START);
   1078d:	81 7d f4 ff ff 07 00 	cmpl   $0x7ffff,-0xc(%ebp)
   10794:	76 19                	jbe    107af <memory_init+0x8c>
   10796:	68 a4 5b 01 00       	push   $0x15ba4
   1079b:	68 6c 5c 01 00       	push   $0x15c6c
   107a0:	6a 76                	push   $0x76
   107a2:	68 6c 5b 01 00       	push   $0x15b6c
   107a7:	e8 01 50 00 00       	call   157ad <panic>
   107ac:	83 c4 10             	add    $0x10,%esp
   create_kernel_table();
   107af:	e8 c8 fe ff ff       	call   1067c <create_kernel_table>
   mmu_set_page_dir((uint32_t)kernel_page_dir);
   107b4:	b8 00 90 01 00       	mov    $0x19000,%eax
   107b9:	83 ec 0c             	sub    $0xc,%esp
   107bc:	50                   	push   %eax
   107bd:	e8 8d fb ff ff       	call   1034f <mmu_set_page_dir>
   107c2:	83 c4 10             	add    $0x10,%esp
}
   107c5:	90                   	nop
   107c6:	c9                   	leave  
   107c7:	c3                   	ret    

000107c8 <memory_create_uvm>:

uint32_t memory_create_uvm(void){
   107c8:	55                   	push   %ebp
   107c9:	89 e5                	mov    %esp,%ebp
   107cb:	83 ec 18             	sub    $0x18,%esp
    pde_t* page_dir=(pde_t*)addr_alloc_page(&paddr_alloc,1);
   107ce:	83 ec 08             	sub    $0x8,%esp
   107d1:	6a 01                	push   $0x1
   107d3:	68 00 80 01 00       	push   $0x18000
   107d8:	e8 52 fc ff ff       	call   1042f <addr_alloc_page>
   107dd:	83 c4 10             	add    $0x10,%esp
   107e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(page_dir==0){
   107e3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   107e7:	75 07                	jne    107f0 <memory_create_uvm+0x28>
        return 0;
   107e9:	b8 00 00 00 00       	mov    $0x0,%eax
   107ee:	eb 5b                	jmp    1084b <memory_create_uvm+0x83>
    }
    kernel_memset((void*)page_dir,0,MEM_PAGE_SIZE);
   107f0:	83 ec 04             	sub    $0x4,%esp
   107f3:	68 00 10 00 00       	push   $0x1000
   107f8:	6a 00                	push   $0x0
   107fa:	ff 75 f0             	pushl  -0x10(%ebp)
   107fd:	e8 58 4c 00 00       	call   1545a <kernel_memset>
   10802:	83 c4 10             	add    $0x10,%esp
    uint32_t user_pde_start=pde_index(MEMORY_TASK_BASE);
   10805:	83 ec 0c             	sub    $0xc,%esp
   10808:	68 00 00 00 80       	push   $0x80000000
   1080d:	e8 7b fb ff ff       	call   1038d <pde_index>
   10812:	83 c4 10             	add    $0x10,%esp
   10815:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(int i=0;i<user_pde_start;i++){
   10818:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1081f:	eb 1f                	jmp    10840 <memory_create_uvm+0x78>
        page_dir[i].v=kernel_page_dir[i].v;
   10821:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10824:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1082b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1082e:	01 c2                	add    %eax,%edx
   10830:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10833:	8b 04 85 00 90 01 00 	mov    0x19000(,%eax,4),%eax
   1083a:	89 02                	mov    %eax,(%edx)
    for(int i=0;i<user_pde_start;i++){
   1083c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10840:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10843:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   10846:	77 d9                	ja     10821 <memory_create_uvm+0x59>
    }

    return (uint32_t)page_dir;
   10848:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   1084b:	c9                   	leave  
   1084c:	c3                   	ret    

0001084d <memory_alloc_for_page_dir>:

int memory_alloc_for_page_dir(uint32_t page_dir,uint32_t vaddr,uint32_t size,int perm){
   1084d:	55                   	push   %ebp
   1084e:	89 e5                	mov    %esp,%ebp
   10850:	83 ec 28             	sub    $0x28,%esp
    uint32_t curr_vaddr=vaddr;
   10853:	8b 45 0c             	mov    0xc(%ebp),%eax
   10856:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int page_count=up2(size,MEM_PAGE_SIZE) / MEM_PAGE_SIZE;
   10859:	68 00 10 00 00       	push   $0x1000
   1085e:	ff 75 10             	pushl  0x10(%ebp)
   10861:	e8 d2 fa ff ff       	call   10338 <up2>
   10866:	83 c4 08             	add    $0x8,%esp
   10869:	c1 e8 0c             	shr    $0xc,%eax
   1086c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(int i=0;i<page_count;i++){
   1086f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   10876:	eb 7b                	jmp    108f3 <memory_alloc_for_page_dir+0xa6>
        uint32_t paddr=addr_alloc_page(&paddr_alloc,1);
   10878:	83 ec 08             	sub    $0x8,%esp
   1087b:	6a 01                	push   $0x1
   1087d:	68 00 80 01 00       	push   $0x18000
   10882:	e8 a8 fb ff ff       	call   1042f <addr_alloc_page>
   10887:	83 c4 10             	add    $0x10,%esp
   1088a:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(paddr==0){
   1088d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   10891:	75 17                	jne    108aa <memory_alloc_for_page_dir+0x5d>
            log_printf("mem alloc failed. no memory");
   10893:	83 ec 0c             	sub    $0xc,%esp
   10896:	68 c9 5b 01 00       	push   $0x15bc9
   1089b:	e8 dd 51 00 00       	call   15a7d <log_printf>
   108a0:	83 c4 10             	add    $0x10,%esp
            return 0;
   108a3:	b8 00 00 00 00       	mov    $0x0,%eax
   108a8:	eb 55                	jmp    108ff <memory_alloc_for_page_dir+0xb2>
        }

        int err=memory_create_map((pde_t*)page_dir,curr_vaddr,paddr,1,perm);
   108aa:	8b 55 14             	mov    0x14(%ebp),%edx
   108ad:	8b 45 08             	mov    0x8(%ebp),%eax
   108b0:	83 ec 0c             	sub    $0xc,%esp
   108b3:	52                   	push   %edx
   108b4:	6a 01                	push   $0x1
   108b6:	ff 75 e8             	pushl  -0x18(%ebp)
   108b9:	ff 75 f4             	pushl  -0xc(%ebp)
   108bc:	50                   	push   %eax
   108bd:	e8 1d fd ff ff       	call   105df <memory_create_map>
   108c2:	83 c4 20             	add    $0x20,%esp
   108c5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(err < 0){
   108c8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   108cc:	79 1a                	jns    108e8 <memory_alloc_for_page_dir+0x9b>
            log_printf("create memory failed. err=%d",err);
   108ce:	83 ec 08             	sub    $0x8,%esp
   108d1:	ff 75 e4             	pushl  -0x1c(%ebp)
   108d4:	68 e5 5b 01 00       	push   $0x15be5
   108d9:	e8 9f 51 00 00       	call   15a7d <log_printf>
   108de:	83 c4 10             	add    $0x10,%esp
            return 0;
   108e1:	b8 00 00 00 00       	mov    $0x0,%eax
   108e6:	eb 17                	jmp    108ff <memory_alloc_for_page_dir+0xb2>
        }

        curr_vaddr+=MEM_PAGE_SIZE;
   108e8:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
    for(int i=0;i<page_count;i++){
   108ef:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   108f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   108f6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   108f9:	0f 8c 79 ff ff ff    	jl     10878 <memory_alloc_for_page_dir+0x2b>

    }
}
   108ff:	c9                   	leave  
   10900:	c3                   	ret    

00010901 <memory_alloc_page_for>:

int memory_alloc_page_for(uint32_t addr,uint32_t size,int perm){
   10901:	55                   	push   %ebp
   10902:	89 e5                	mov    %esp,%ebp
   10904:	83 ec 08             	sub    $0x8,%esp
    return memory_alloc_for_page_dir(task_current()->tss.cr3,addr,size,perm);
   10907:	e8 d0 0c 00 00       	call   115dc <task_current>
   1090c:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   10912:	ff 75 10             	pushl  0x10(%ebp)
   10915:	ff 75 0c             	pushl  0xc(%ebp)
   10918:	ff 75 08             	pushl  0x8(%ebp)
   1091b:	50                   	push   %eax
   1091c:	e8 2c ff ff ff       	call   1084d <memory_alloc_for_page_dir>
   10921:	83 c4 10             	add    $0x10,%esp
}
   10924:	c9                   	leave  
   10925:	c3                   	ret    

00010926 <memory_alloc_page>:

uint32_t memory_alloc_page(void){
   10926:	55                   	push   %ebp
   10927:	89 e5                	mov    %esp,%ebp
   10929:	83 ec 18             	sub    $0x18,%esp
    uint32_t addr=addr_alloc_page(&paddr_alloc,1);
   1092c:	83 ec 08             	sub    $0x8,%esp
   1092f:	6a 01                	push   $0x1
   10931:	68 00 80 01 00       	push   $0x18000
   10936:	e8 f4 fa ff ff       	call   1042f <addr_alloc_page>
   1093b:	83 c4 10             	add    $0x10,%esp
   1093e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return addr;
   10941:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10944:	c9                   	leave  
   10945:	c3                   	ret    

00010946 <curr_page_dir>:

static pde_t* curr_page_dir(void){
   10946:	55                   	push   %ebp
   10947:	89 e5                	mov    %esp,%ebp
   10949:	83 ec 08             	sub    $0x8,%esp
    return (pde_t*)(task_current()->tss.cr3);
   1094c:	e8 8b 0c 00 00       	call   115dc <task_current>
   10951:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
}
   10957:	c9                   	leave  
   10958:	c3                   	ret    

00010959 <memory_free_page>:

void memory_free_page(uint32_t addr){
   10959:	55                   	push   %ebp
   1095a:	89 e5                	mov    %esp,%ebp
   1095c:	83 ec 18             	sub    $0x18,%esp
    if(addr < MEMORY_TASK_BASE){
   1095f:	8b 45 08             	mov    0x8(%ebp),%eax
   10962:	85 c0                	test   %eax,%eax
   10964:	78 17                	js     1097d <memory_free_page+0x24>
        addr_free_page(&paddr_alloc,addr,1);
   10966:	83 ec 04             	sub    $0x4,%esp
   10969:	6a 01                	push   $0x1
   1096b:	ff 75 08             	pushl  0x8(%ebp)
   1096e:	68 00 80 01 00       	push   $0x18000
   10973:	e8 1e fb ff ff       	call   10496 <addr_free_page>
   10978:	83 c4 10             	add    $0x10,%esp
        pte_t* pte=find_pte(curr_page_dir(),addr,0);
        ASSERT((pte==(pte_t*)0) &&  pte->present);
        addr_free_page(&paddr_alloc,pte_paddr(pte),1);
        pte->v=0;
    }
}
   1097b:	eb 72                	jmp    109ef <memory_free_page+0x96>
        pte_t* pte=find_pte(curr_page_dir(),addr,0);
   1097d:	e8 c4 ff ff ff       	call   10946 <curr_page_dir>
   10982:	83 ec 04             	sub    $0x4,%esp
   10985:	6a 00                	push   $0x0
   10987:	ff 75 08             	pushl  0x8(%ebp)
   1098a:	50                   	push   %eax
   1098b:	e8 9f fb ff ff       	call   1052f <find_pte>
   10990:	83 c4 10             	add    $0x10,%esp
   10993:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ASSERT((pte==(pte_t*)0) &&  pte->present);
   10996:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1099a:	75 0d                	jne    109a9 <memory_free_page+0x50>
   1099c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1099f:	0f b6 00             	movzbl (%eax),%eax
   109a2:	83 e0 01             	and    $0x1,%eax
   109a5:	84 c0                	test   %al,%al
   109a7:	75 1c                	jne    109c5 <memory_free_page+0x6c>
   109a9:	68 04 5c 01 00       	push   $0x15c04
   109ae:	68 78 5c 01 00       	push   $0x15c78
   109b3:	68 b1 00 00 00       	push   $0xb1
   109b8:	68 6c 5b 01 00       	push   $0x15b6c
   109bd:	e8 eb 4d 00 00       	call   157ad <panic>
   109c2:	83 c4 10             	add    $0x10,%esp
        addr_free_page(&paddr_alloc,pte_paddr(pte),1);
   109c5:	83 ec 0c             	sub    $0xc,%esp
   109c8:	ff 75 f4             	pushl  -0xc(%ebp)
   109cb:	e8 e8 f9 ff ff       	call   103b8 <pte_paddr>
   109d0:	83 c4 10             	add    $0x10,%esp
   109d3:	83 ec 04             	sub    $0x4,%esp
   109d6:	6a 01                	push   $0x1
   109d8:	50                   	push   %eax
   109d9:	68 00 80 01 00       	push   $0x18000
   109de:	e8 b3 fa ff ff       	call   10496 <addr_free_page>
   109e3:	83 c4 10             	add    $0x10,%esp
        pte->v=0;
   109e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   109e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
   109ef:	90                   	nop
   109f0:	c9                   	leave  
   109f1:	c3                   	ret    

000109f2 <memory_destroy_uvm>:

void memory_destroy_uvm(uint32_t page_dir){
   109f2:	55                   	push   %ebp
   109f3:	89 e5                	mov    %esp,%ebp
   109f5:	83 ec 28             	sub    $0x28,%esp
    uint32_t user_pde_start=pde_index(MEMORY_TASK_BASE);
   109f8:	68 00 00 00 80       	push   $0x80000000
   109fd:	e8 8b f9 ff ff       	call   1038d <pde_index>
   10a02:	83 c4 04             	add    $0x4,%esp
   10a05:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    pde_t* pde=(pde_t*)page_dir+user_pde_start;
   10a08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10a0b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10a12:	8b 45 08             	mov    0x8(%ebp),%eax
   10a15:	01 d0                	add    %edx,%eax
   10a17:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10a1a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10a1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10a20:	e9 8f 00 00 00       	jmp    10ab4 <memory_destroy_uvm+0xc2>
        if(!pde->present){
   10a25:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a28:	0f b6 00             	movzbl (%eax),%eax
   10a2b:	83 e0 01             	and    $0x1,%eax
   10a2e:	84 c0                	test   %al,%al
   10a30:	74 79                	je     10aab <memory_destroy_uvm+0xb9>
            continue;
        }

        pte_t* pte=(pte_t*)pde_paddr(pde);
   10a32:	ff 75 f4             	pushl  -0xc(%ebp)
   10a35:	e8 6e f9 ff ff       	call   103a8 <pde_paddr>
   10a3a:	83 c4 04             	add    $0x4,%esp
   10a3d:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(int j=0;j<PTE_CNT;j++,pte++){
   10a40:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10a47:	eb 36                	jmp    10a7f <memory_destroy_uvm+0x8d>
            if(!pte->present){
   10a49:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10a4c:	0f b6 00             	movzbl (%eax),%eax
   10a4f:	83 e0 01             	and    $0x1,%eax
   10a52:	84 c0                	test   %al,%al
   10a54:	74 20                	je     10a76 <memory_destroy_uvm+0x84>
                continue;
            }

            addr_free_page(&paddr_alloc,pte_paddr(pte),1);
   10a56:	ff 75 ec             	pushl  -0x14(%ebp)
   10a59:	e8 5a f9 ff ff       	call   103b8 <pte_paddr>
   10a5e:	83 c4 04             	add    $0x4,%esp
   10a61:	83 ec 04             	sub    $0x4,%esp
   10a64:	6a 01                	push   $0x1
   10a66:	50                   	push   %eax
   10a67:	68 00 80 01 00       	push   $0x18000
   10a6c:	e8 25 fa ff ff       	call   10496 <addr_free_page>
   10a71:	83 c4 10             	add    $0x10,%esp
   10a74:	eb 01                	jmp    10a77 <memory_destroy_uvm+0x85>
                continue;
   10a76:	90                   	nop
        for(int j=0;j<PTE_CNT;j++,pte++){
   10a77:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   10a7b:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   10a7f:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   10a86:	7e c1                	jle    10a49 <memory_destroy_uvm+0x57>
        }

        addr_free_page(&paddr_alloc,(uint32_t)pde_paddr(pde),1);
   10a88:	83 ec 0c             	sub    $0xc,%esp
   10a8b:	ff 75 f4             	pushl  -0xc(%ebp)
   10a8e:	e8 15 f9 ff ff       	call   103a8 <pde_paddr>
   10a93:	83 c4 10             	add    $0x10,%esp
   10a96:	83 ec 04             	sub    $0x4,%esp
   10a99:	6a 01                	push   $0x1
   10a9b:	50                   	push   %eax
   10a9c:	68 00 80 01 00       	push   $0x18000
   10aa1:	e8 f0 f9 ff ff       	call   10496 <addr_free_page>
   10aa6:	83 c4 10             	add    $0x10,%esp
   10aa9:	eb 01                	jmp    10aac <memory_destroy_uvm+0xba>
            continue;
   10aab:	90                   	nop
    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10aac:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10ab0:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   10ab4:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   10abb:	0f 8e 64 ff ff ff    	jle    10a25 <memory_destroy_uvm+0x33>
    }

    addr_free_page(&paddr_alloc,page_dir,1);
   10ac1:	83 ec 04             	sub    $0x4,%esp
   10ac4:	6a 01                	push   $0x1
   10ac6:	ff 75 08             	pushl  0x8(%ebp)
   10ac9:	68 00 80 01 00       	push   $0x18000
   10ace:	e8 c3 f9 ff ff       	call   10496 <addr_free_page>
   10ad3:	83 c4 10             	add    $0x10,%esp
}
   10ad6:	90                   	nop
   10ad7:	c9                   	leave  
   10ad8:	c3                   	ret    

00010ad9 <memory_copy_uvm>:

uint32_t memory_copy_uvm(uint32_t page_dir){
   10ad9:	55                   	push   %ebp
   10ada:	89 e5                	mov    %esp,%ebp
   10adc:	83 ec 38             	sub    $0x38,%esp
    uint32_t to_page_dir=memory_create_uvm();
   10adf:	e8 e4 fc ff ff       	call   107c8 <memory_create_uvm>
   10ae4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(to_page_dir == 0){
   10ae7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10aeb:	0f 84 1b 01 00 00    	je     10c0c <memory_copy_uvm+0x133>
        goto copy_uvm_failed;
    }

    uint32_t user_pde_start=pde_index(MEMORY_TASK_BASE);
   10af1:	83 ec 0c             	sub    $0xc,%esp
   10af4:	68 00 00 00 80       	push   $0x80000000
   10af9:	e8 8f f8 ff ff       	call   1038d <pde_index>
   10afe:	83 c4 10             	add    $0x10,%esp
   10b01:	89 45 e0             	mov    %eax,-0x20(%ebp)
    pde_t* pde=(pde_t*)page_dir+user_pde_start;
   10b04:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10b07:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10b0e:	8b 45 08             	mov    0x8(%ebp),%eax
   10b11:	01 d0                	add    %edx,%eax
   10b13:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10b16:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10b19:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10b1c:	e9 d9 00 00 00       	jmp    10bfa <memory_copy_uvm+0x121>
        if(!pde->present){
   10b21:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b24:	0f b6 00             	movzbl (%eax),%eax
   10b27:	83 e0 01             	and    $0x1,%eax
   10b2a:	84 c0                	test   %al,%al
   10b2c:	0f 84 bf 00 00 00    	je     10bf1 <memory_copy_uvm+0x118>
            continue;
        }

        pte_t*pte=(pte_t*)pde_paddr(pde);
   10b32:	83 ec 0c             	sub    $0xc,%esp
   10b35:	ff 75 f4             	pushl  -0xc(%ebp)
   10b38:	e8 6b f8 ff ff       	call   103a8 <pde_paddr>
   10b3d:	83 c4 10             	add    $0x10,%esp
   10b40:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(int j=0;j<PTE_CNT;j++,pte++){
   10b43:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10b4a:	e9 93 00 00 00       	jmp    10be2 <memory_copy_uvm+0x109>
            if(!pte->present){
   10b4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10b52:	0f b6 00             	movzbl (%eax),%eax
   10b55:	83 e0 01             	and    $0x1,%eax
   10b58:	84 c0                	test   %al,%al
   10b5a:	74 7d                	je     10bd9 <memory_copy_uvm+0x100>
                continue;
            }

            uint32_t page=addr_alloc_page(&paddr_alloc,1);
   10b5c:	83 ec 08             	sub    $0x8,%esp
   10b5f:	6a 01                	push   $0x1
   10b61:	68 00 80 01 00       	push   $0x18000
   10b66:	e8 c4 f8 ff ff       	call   1042f <addr_alloc_page>
   10b6b:	83 c4 10             	add    $0x10,%esp
   10b6e:	89 45 dc             	mov    %eax,-0x24(%ebp)
            if(page==0) {
   10b71:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   10b75:	0f 84 94 00 00 00    	je     10c0f <memory_copy_uvm+0x136>
                goto copy_uvm_failed;
            }
            uint32_t vaddr=(i<<22) | (j<<12);
   10b7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b7e:	c1 e0 16             	shl    $0x16,%eax
   10b81:	89 c2                	mov    %eax,%edx
   10b83:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b86:	c1 e0 0c             	shl    $0xc,%eax
   10b89:	09 d0                	or     %edx,%eax
   10b8b:	89 45 d8             	mov    %eax,-0x28(%ebp)
            int err=memory_create_map((pde_t*)to_page_dir,vaddr,page,1,get_pte_perm(pte));
   10b8e:	83 ec 0c             	sub    $0xc,%esp
   10b91:	ff 75 ec             	pushl  -0x14(%ebp)
   10b94:	e8 2f f8 ff ff       	call   103c8 <get_pte_perm>
   10b99:	83 c4 10             	add    $0x10,%esp
   10b9c:	89 c2                	mov    %eax,%edx
   10b9e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10ba1:	83 ec 0c             	sub    $0xc,%esp
   10ba4:	52                   	push   %edx
   10ba5:	6a 01                	push   $0x1
   10ba7:	ff 75 dc             	pushl  -0x24(%ebp)
   10baa:	ff 75 d8             	pushl  -0x28(%ebp)
   10bad:	50                   	push   %eax
   10bae:	e8 2c fa ff ff       	call   105df <memory_create_map>
   10bb3:	83 c4 20             	add    $0x20,%esp
   10bb6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            if(err < 0){
   10bb9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   10bbd:	78 53                	js     10c12 <memory_copy_uvm+0x139>
                goto copy_uvm_failed;
            }

            kernel_memcpy((void*)page,(void*)vaddr,MEM_PAGE_SIZE);
   10bbf:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10bc2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10bc5:	83 ec 04             	sub    $0x4,%esp
   10bc8:	68 00 10 00 00       	push   $0x1000
   10bcd:	52                   	push   %edx
   10bce:	50                   	push   %eax
   10bcf:	e8 37 48 00 00       	call   1540b <kernel_memcpy>
   10bd4:	83 c4 10             	add    $0x10,%esp
   10bd7:	eb 01                	jmp    10bda <memory_copy_uvm+0x101>
                continue;
   10bd9:	90                   	nop
        for(int j=0;j<PTE_CNT;j++,pte++){
   10bda:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   10bde:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   10be2:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   10be9:	0f 8e 60 ff ff ff    	jle    10b4f <memory_copy_uvm+0x76>
   10bef:	eb 01                	jmp    10bf2 <memory_copy_uvm+0x119>
            continue;
   10bf1:	90                   	nop
    for(int i=user_pde_start;i<PDE_CNT;i++,pde++){
   10bf2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10bf6:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   10bfa:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   10c01:	0f 8e 1a ff ff ff    	jle    10b21 <memory_copy_uvm+0x48>
        }
    }

    return to_page_dir;
   10c07:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10c0a:	eb 20                	jmp    10c2c <memory_copy_uvm+0x153>
        goto copy_uvm_failed;
   10c0c:	90                   	nop
   10c0d:	eb 04                	jmp    10c13 <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   10c0f:	90                   	nop
   10c10:	eb 01                	jmp    10c13 <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   10c12:	90                   	nop
copy_uvm_failed:
    if(to_page_dir){
   10c13:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10c17:	74 0e                	je     10c27 <memory_copy_uvm+0x14e>
        memory_destroy_uvm(to_page_dir);
   10c19:	83 ec 0c             	sub    $0xc,%esp
   10c1c:	ff 75 e4             	pushl  -0x1c(%ebp)
   10c1f:	e8 ce fd ff ff       	call   109f2 <memory_destroy_uvm>
   10c24:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   10c27:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   10c2c:	c9                   	leave  
   10c2d:	c3                   	ret    

00010c2e <memory_get_paddr>:
 * @brief 获取页表项对应的物理地址
 * @param page_dir 获取该页物理地址所使用的页表
 * @param vaddr 虚拟地址
 * @return 成功返回物理地址，失败返回0
*/
uint32_t memory_get_paddr(uint32_t page_dir,uint32_t vaddr){
   10c2e:	55                   	push   %ebp
   10c2f:	89 e5                	mov    %esp,%ebp
   10c31:	83 ec 18             	sub    $0x18,%esp
    pte_t* pte=find_pte((pde_t*)page_dir,vaddr,0);
   10c34:	8b 45 08             	mov    0x8(%ebp),%eax
   10c37:	83 ec 04             	sub    $0x4,%esp
   10c3a:	6a 00                	push   $0x0
   10c3c:	ff 75 0c             	pushl  0xc(%ebp)
   10c3f:	50                   	push   %eax
   10c40:	e8 ea f8 ff ff       	call   1052f <find_pte>
   10c45:	83 c4 10             	add    $0x10,%esp
   10c48:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!pte){
   10c4b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10c4f:	75 07                	jne    10c58 <memory_get_paddr+0x2a>
        return 0;
   10c51:	b8 00 00 00 00       	mov    $0x0,%eax
   10c56:	eb 1a                	jmp    10c72 <memory_get_paddr+0x44>
    }

    return pte_paddr(pte) + (vaddr & (MEM_PAGE_SIZE-1));
   10c58:	83 ec 0c             	sub    $0xc,%esp
   10c5b:	ff 75 f4             	pushl  -0xc(%ebp)
   10c5e:	e8 55 f7 ff ff       	call   103b8 <pte_paddr>
   10c63:	83 c4 10             	add    $0x10,%esp
   10c66:	89 c2                	mov    %eax,%edx
   10c68:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c6b:	25 ff 0f 00 00       	and    $0xfff,%eax
   10c70:	01 d0                	add    %edx,%eax
}
   10c72:	c9                   	leave  
   10c73:	c3                   	ret    

00010c74 <memory_copy_uvm_data>:

int memory_copy_uvm_data(uint32_t to,uint32_t page_dir,uint32_t from,uint32_t size){
   10c74:	55                   	push   %ebp
   10c75:	89 e5                	mov    %esp,%ebp
   10c77:	83 ec 18             	sub    $0x18,%esp
    while(size > 0){
   10c7a:	eb 6d                	jmp    10ce9 <memory_copy_uvm_data+0x75>
        uint32_t to_paddr=memory_get_paddr(page_dir,to);
   10c7c:	83 ec 08             	sub    $0x8,%esp
   10c7f:	ff 75 08             	pushl  0x8(%ebp)
   10c82:	ff 75 0c             	pushl  0xc(%ebp)
   10c85:	e8 a4 ff ff ff       	call   10c2e <memory_get_paddr>
   10c8a:	83 c4 10             	add    $0x10,%esp
   10c8d:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(to_paddr == 0){
   10c90:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10c94:	75 07                	jne    10c9d <memory_copy_uvm_data+0x29>
            return -1;
   10c96:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10c9b:	eb 57                	jmp    10cf4 <memory_copy_uvm_data+0x80>
        }

        uint32_t offset_in_page=to_paddr & (MEM_PAGE_SIZE-1);
   10c9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ca0:	25 ff 0f 00 00       	and    $0xfff,%eax
   10ca5:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t curr_size=MEM_PAGE_SIZE-offset_in_page;
   10ca8:	b8 00 10 00 00       	mov    $0x1000,%eax
   10cad:	2b 45 ec             	sub    -0x14(%ebp),%eax
   10cb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(curr_size > size){
   10cb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cb6:	3b 45 14             	cmp    0x14(%ebp),%eax
   10cb9:	76 06                	jbe    10cc1 <memory_copy_uvm_data+0x4d>
            curr_size = size;
   10cbb:	8b 45 14             	mov    0x14(%ebp),%eax
   10cbe:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }

        kernel_memcpy((void*)to_paddr,(void*)from,curr_size);
   10cc1:	8b 55 10             	mov    0x10(%ebp),%edx
   10cc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10cc7:	83 ec 04             	sub    $0x4,%esp
   10cca:	ff 75 f4             	pushl  -0xc(%ebp)
   10ccd:	52                   	push   %edx
   10cce:	50                   	push   %eax
   10ccf:	e8 37 47 00 00       	call   1540b <kernel_memcpy>
   10cd4:	83 c4 10             	add    $0x10,%esp
        size -= curr_size;
   10cd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cda:	29 45 14             	sub    %eax,0x14(%ebp)
        to += curr_size;
   10cdd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10ce0:	01 45 08             	add    %eax,0x8(%ebp)
        from += curr_size;
   10ce3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10ce6:	01 45 10             	add    %eax,0x10(%ebp)
    while(size > 0){
   10ce9:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   10ced:	75 8d                	jne    10c7c <memory_copy_uvm_data+0x8>
    }
    return 0;
   10cef:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10cf4:	c9                   	leave  
   10cf5:	c3                   	ret    

00010cf6 <sys_sbrk>:

char* sys_sbrk(int incr){
   10cf6:	55                   	push   %ebp
   10cf7:	89 e5                	mov    %esp,%ebp
   10cf9:	83 ec 38             	sub    $0x38,%esp
    task_t* task=task_current();
   10cfc:	e8 db 08 00 00       	call   115dc <task_current>
   10d01:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint8_t*pre_heap_end=(uint8_t*) task->heap_end;
   10d04:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d07:	8b 40 10             	mov    0x10(%eax),%eax
   10d0a:	89 45 ec             	mov    %eax,-0x14(%ebp)

    ASSERT(incr>=0);
   10d0d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10d11:	79 1c                	jns    10d2f <sys_sbrk+0x39>
   10d13:	68 25 5c 01 00       	push   $0x15c25
   10d18:	68 8c 5c 01 00       	push   $0x15c8c
   10d1d:	68 21 01 00 00       	push   $0x121
   10d22:	68 6c 5b 01 00       	push   $0x15b6c
   10d27:	e8 81 4a 00 00       	call   157ad <panic>
   10d2c:	83 c4 10             	add    $0x10,%esp

    int pre_incr=incr;
   10d2f:	8b 45 08             	mov    0x8(%ebp),%eax
   10d32:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if(incr==0){
   10d35:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10d39:	75 1b                	jne    10d56 <sys_sbrk+0x60>
        log_printf("sbrk(0): end=0x%x",pre_heap_end);
   10d3b:	83 ec 08             	sub    $0x8,%esp
   10d3e:	ff 75 ec             	pushl  -0x14(%ebp)
   10d41:	68 2d 5c 01 00       	push   $0x15c2d
   10d46:	e8 32 4d 00 00       	call   15a7d <log_printf>
   10d4b:	83 c4 10             	add    $0x10,%esp
        return pre_heap_end;
   10d4e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d51:	e9 aa 00 00 00       	jmp    10e00 <sys_sbrk+0x10a>
    }

    uint32_t start=task->heap_end;
   10d56:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d59:	8b 40 10             	mov    0x10(%eax),%eax
   10d5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t end=start+incr;
   10d5f:	8b 55 08             	mov    0x8(%ebp),%edx
   10d62:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d65:	01 d0                	add    %edx,%eax
   10d67:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    int start_offset=start % MEM_PAGE_SIZE;
   10d6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d6d:	25 ff 0f 00 00       	and    $0xfff,%eax
   10d72:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(start_offset){
   10d75:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10d79:	74 37                	je     10db2 <sys_sbrk+0xbc>
        if(start_offset+incr <= MEM_PAGE_SIZE){
   10d7b:	8b 55 e0             	mov    -0x20(%ebp),%edx
   10d7e:	8b 45 08             	mov    0x8(%ebp),%eax
   10d81:	01 d0                	add    %edx,%eax
   10d83:	3d 00 10 00 00       	cmp    $0x1000,%eax
   10d88:	7f 0e                	jg     10d98 <sys_sbrk+0xa2>
            task->heap_end=end;
   10d8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d8d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10d90:	89 50 10             	mov    %edx,0x10(%eax)
            return pre_heap_end;
   10d93:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d96:	eb 68                	jmp    10e00 <sys_sbrk+0x10a>
        }
        else{
            uint32_t curr_size=MEM_PAGE_SIZE - start_offset;
   10d98:	b8 00 10 00 00       	mov    $0x1000,%eax
   10d9d:	2b 45 e0             	sub    -0x20(%ebp),%eax
   10da0:	89 45 dc             	mov    %eax,-0x24(%ebp)
            start+=curr_size;
   10da3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10da6:	01 45 f4             	add    %eax,-0xc(%ebp)
            incr-=curr_size;
   10da9:	8b 45 08             	mov    0x8(%ebp),%eax
   10dac:	2b 45 dc             	sub    -0x24(%ebp),%eax
   10daf:	89 45 08             	mov    %eax,0x8(%ebp)
        }
    }

    if(incr){
   10db2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10db6:	74 3c                	je     10df4 <sys_sbrk+0xfe>
        uint32_t curr_size=end-start;
   10db8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10dbb:	2b 45 f4             	sub    -0xc(%ebp),%eax
   10dbe:	89 45 d8             	mov    %eax,-0x28(%ebp)
        int err=memory_alloc_page_for(start,curr_size,PTE_P | PTE_U | PTE_W);
   10dc1:	83 ec 04             	sub    $0x4,%esp
   10dc4:	6a 07                	push   $0x7
   10dc6:	ff 75 d8             	pushl  -0x28(%ebp)
   10dc9:	ff 75 f4             	pushl  -0xc(%ebp)
   10dcc:	e8 30 fb ff ff       	call   10901 <memory_alloc_page_for>
   10dd1:	83 c4 10             	add    $0x10,%esp
   10dd4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        if(err<0){
   10dd7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   10ddb:	79 17                	jns    10df4 <sys_sbrk+0xfe>
            log_printf("sbrk: alloc mem failed.");
   10ddd:	83 ec 0c             	sub    $0xc,%esp
   10de0:	68 3f 5c 01 00       	push   $0x15c3f
   10de5:	e8 93 4c 00 00       	call   15a7d <log_printf>
   10dea:	83 c4 10             	add    $0x10,%esp
            return (char*)-1;
   10ded:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10df2:	eb 0c                	jmp    10e00 <sys_sbrk+0x10a>
        }
    }

    task->heap_end=end;
   10df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10df7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10dfa:	89 50 10             	mov    %edx,0x10(%eax)
    return (char*)pre_heap_end;
   10dfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e00:	c9                   	leave  
   10e01:	c3                   	ret    

00010e02 <sys_print_msg>:

/// @brief 系统调用的函数指针，统一以这种方式定义
typedef int (*syscall_handler_t)(uint32_t arg0,uint32_t arg1,uint32_t arg2,uint32_t arg3);


void sys_print_msg(char* fmt,int arg){
   10e02:	55                   	push   %ebp
   10e03:	89 e5                	mov    %esp,%ebp
   10e05:	83 ec 08             	sub    $0x8,%esp
    log_printf(fmt,arg);
   10e08:	83 ec 08             	sub    $0x8,%esp
   10e0b:	ff 75 0c             	pushl  0xc(%ebp)
   10e0e:	ff 75 08             	pushl  0x8(%ebp)
   10e11:	e8 67 4c 00 00       	call   15a7d <log_printf>
   10e16:	83 c4 10             	add    $0x10,%esp
}
   10e19:	90                   	nop
   10e1a:	c9                   	leave  
   10e1b:	c3                   	ret    

00010e1c <do_handler_syscall>:
    
    [SYS_PRINT_MSG]=(syscall_handler_t)sys_print_msg,
};


void do_handler_syscall(syscall_frame_t*frame){
   10e1c:	55                   	push   %ebp
   10e1d:	89 e5                	mov    %esp,%ebp
   10e1f:	53                   	push   %ebx
   10e20:	83 ec 14             	sub    $0x14,%esp
    if(frame->func_id < sizeof(sys_table)/sizeof(sys_table[0])){
   10e23:	8b 45 08             	mov    0x8(%ebp),%eax
   10e26:	8b 40 3c             	mov    0x3c(%eax),%eax
   10e29:	83 f8 64             	cmp    $0x64,%eax
   10e2c:	77 48                	ja     10e76 <do_handler_syscall+0x5a>
        syscall_handler_t handler=sys_table[frame->func_id];
   10e2e:	8b 45 08             	mov    0x8(%ebp),%eax
   10e31:	8b 40 3c             	mov    0x3c(%eax),%eax
   10e34:	8b 04 85 a0 5c 01 00 	mov    0x15ca0(,%eax,4),%eax
   10e3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(handler){
   10e3e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e42:	74 32                	je     10e76 <do_handler_syscall+0x5a>
            int ret=handler(frame->arg0,frame->arg1,frame->arg2,frame->arg3);
   10e44:	8b 45 08             	mov    0x8(%ebp),%eax
   10e47:	8b 58 4c             	mov    0x4c(%eax),%ebx
   10e4a:	8b 45 08             	mov    0x8(%ebp),%eax
   10e4d:	8b 48 48             	mov    0x48(%eax),%ecx
   10e50:	8b 45 08             	mov    0x8(%ebp),%eax
   10e53:	8b 50 44             	mov    0x44(%eax),%edx
   10e56:	8b 45 08             	mov    0x8(%ebp),%eax
   10e59:	8b 40 40             	mov    0x40(%eax),%eax
   10e5c:	53                   	push   %ebx
   10e5d:	51                   	push   %ecx
   10e5e:	52                   	push   %edx
   10e5f:	50                   	push   %eax
   10e60:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e63:	ff d0                	call   *%eax
   10e65:	83 c4 10             	add    $0x10,%esp
   10e68:	89 45 f0             	mov    %eax,-0x10(%ebp)
            frame->eax=ret;
   10e6b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10e6e:	8b 45 08             	mov    0x8(%ebp),%eax
   10e71:	89 50 30             	mov    %edx,0x30(%eax)
            return;
   10e74:	eb 30                	jmp    10ea6 <do_handler_syscall+0x8a>
        }
    }

    task_t* task=task_current();
   10e76:	e8 61 07 00 00       	call   115dc <task_current>
   10e7b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    log_printf("task: %s, Unknown syscall: %d",task->name,frame->func_id);
   10e7e:	8b 45 08             	mov    0x8(%ebp),%eax
   10e81:	8b 40 3c             	mov    0x3c(%eax),%eax
   10e84:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10e87:	83 c2 20             	add    $0x20,%edx
   10e8a:	83 ec 04             	sub    $0x4,%esp
   10e8d:	50                   	push   %eax
   10e8e:	52                   	push   %edx
   10e8f:	68 34 5e 01 00       	push   $0x15e34
   10e94:	e8 e4 4b 00 00       	call   15a7d <log_printf>
   10e99:	83 c4 10             	add    $0x10,%esp
    frame->eax=-1;
   10e9c:	8b 45 08             	mov    0x8(%ebp),%eax
   10e9f:	c7 40 30 ff ff ff ff 	movl   $0xffffffff,0x30(%eax)
   10ea6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10ea9:	c9                   	leave  
   10eaa:	c3                   	ret    

00010eab <read_cr0>:
static inline uint32_t read_cr0(void){
   10eab:	55                   	push   %ebp
   10eac:	89 e5                	mov    %esp,%ebp
   10eae:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__(
   10eb1:	0f 20 c0             	mov    %cr0,%eax
   10eb4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return cr0;
   10eb7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10eba:	c9                   	leave  
   10ebb:	c3                   	ret    

00010ebc <write_cr0>:
static inline void write_cr0(uint32_t v){
   10ebc:	55                   	push   %ebp
   10ebd:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10ebf:	8b 45 08             	mov    0x8(%ebp),%eax
   10ec2:	0f 22 c0             	mov    %eax,%cr0
}
   10ec5:	90                   	nop
   10ec6:	5d                   	pop    %ebp
   10ec7:	c3                   	ret    

00010ec8 <hlt>:
static inline void hlt(void){
   10ec8:	55                   	push   %ebp
   10ec9:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("hlt");
   10ecb:	f4                   	hlt    
}
   10ecc:	90                   	nop
   10ecd:	5d                   	pop    %ebp
   10ece:	c3                   	ret    

00010ecf <write_tr>:
static inline void write_tr(uint16_t tss_sel){
   10ecf:	55                   	push   %ebp
   10ed0:	89 e5                	mov    %esp,%ebp
   10ed2:	83 ec 04             	sub    $0x4,%esp
   10ed5:	8b 45 08             	mov    0x8(%ebp),%eax
   10ed8:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    __asm__ __volatile__(
   10edc:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
   10ee0:	0f 00 d8             	ltr    %ax
}
   10ee3:	90                   	nop
   10ee4:	c9                   	leave  
   10ee5:	c3                   	ret    

00010ee6 <write_cr3>:
static inline void write_cr3(uint32_t v){
   10ee6:	55                   	push   %ebp
   10ee7:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10ee9:	8b 45 08             	mov    0x8(%ebp),%eax
   10eec:	0f 22 d8             	mov    %eax,%cr3
}
   10eef:	90                   	nop
   10ef0:	5d                   	pop    %ebp
   10ef1:	c3                   	ret    

00010ef2 <write_cr4>:
static inline void write_cr4(uint32_t v){
   10ef2:	55                   	push   %ebp
   10ef3:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   10ef5:	8b 45 08             	mov    0x8(%ebp),%eax
   10ef8:	0f 22 e0             	mov    %eax,%cr4
}
   10efb:	90                   	nop
   10efc:	5d                   	pop    %ebp
   10efd:	c3                   	ret    

00010efe <read_cr4>:
static inline uint32_t read_cr4(void){
   10efe:	55                   	push   %ebp
   10eff:	89 e5                	mov    %esp,%ebp
   10f01:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__(
   10f04:	0f 20 e0             	mov    %cr4,%eax
   10f07:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return cr4;
   10f0a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10f0d:	c9                   	leave  
   10f0e:	c3                   	ret    

00010f0f <list_node_init>:
typedef struct _list_node_t{
    struct _list_node_t*pre;
    struct _list_node_t*next;
}list_node_t;

static inline void list_node_init(list_node_t* node){
   10f0f:	55                   	push   %ebp
   10f10:	89 e5                	mov    %esp,%ebp
    node->pre=node->next=(list_node_t*)0;
   10f12:	8b 45 08             	mov    0x8(%ebp),%eax
   10f15:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   10f1c:	8b 45 08             	mov    0x8(%ebp),%eax
   10f1f:	8b 50 04             	mov    0x4(%eax),%edx
   10f22:	8b 45 08             	mov    0x8(%ebp),%eax
   10f25:	89 10                	mov    %edx,(%eax)
}
   10f27:	90                   	nop
   10f28:	5d                   	pop    %ebp
   10f29:	c3                   	ret    

00010f2a <list_node_next>:

static inline list_node_t* list_node_pre(list_node_t* node){
    return node->pre;
}

static inline list_node_t* list_node_next(list_node_t* node){
   10f2a:	55                   	push   %ebp
   10f2b:	89 e5                	mov    %esp,%ebp
    return node->next;
   10f2d:	8b 45 08             	mov    0x8(%ebp),%eax
   10f30:	8b 40 04             	mov    0x4(%eax),%eax
}
   10f33:	5d                   	pop    %ebp
   10f34:	c3                   	ret    

00010f35 <list_count>:
void list_init(list_t* list);
static inline int list_is_empty(list_t* list){
    return list->count==0;
}

static inline int list_count(list_t* list){
   10f35:	55                   	push   %ebp
   10f36:	89 e5                	mov    %esp,%ebp
    return list->count;
   10f38:	8b 45 08             	mov    0x8(%ebp),%eax
   10f3b:	8b 40 08             	mov    0x8(%eax),%eax
}
   10f3e:	5d                   	pop    %ebp
   10f3f:	c3                   	ret    

00010f40 <list_first>:

static inline list_node_t* list_first(list_t* list){
   10f40:	55                   	push   %ebp
   10f41:	89 e5                	mov    %esp,%ebp
    return list->first;
   10f43:	8b 45 08             	mov    0x8(%ebp),%eax
   10f46:	8b 00                	mov    (%eax),%eax
}
   10f48:	5d                   	pop    %ebp
   10f49:	c3                   	ret    

00010f4a <mmu_set_page_dir>:
static inline void mmu_set_page_dir(uint32_t paddr){
   10f4a:	55                   	push   %ebp
   10f4b:	89 e5                	mov    %esp,%ebp
   10f4d:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr4=read_cr4();
   10f50:	e8 a9 ff ff ff       	call   10efe <read_cr4>
   10f55:	89 45 fc             	mov    %eax,-0x4(%ebp)
	write_cr4(cr4|CR4_PSE);
   10f58:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10f5b:	83 c8 10             	or     $0x10,%eax
   10f5e:	50                   	push   %eax
   10f5f:	e8 8e ff ff ff       	call   10ef2 <write_cr4>
   10f64:	83 c4 04             	add    $0x4,%esp
	write_cr3(paddr);
   10f67:	ff 75 08             	pushl  0x8(%ebp)
   10f6a:	e8 77 ff ff ff       	call   10ee6 <write_cr3>
   10f6f:	83 c4 04             	add    $0x4,%esp
	write_cr0(read_cr0()|CR0_PG);
   10f72:	e8 34 ff ff ff       	call   10eab <read_cr0>
   10f77:	0d 00 00 00 80       	or     $0x80000000,%eax
   10f7c:	50                   	push   %eax
   10f7d:	e8 3a ff ff ff       	call   10ebc <write_cr0>
   10f82:	83 c4 04             	add    $0x4,%esp
}
   10f85:	90                   	nop
   10f86:	c9                   	leave  
   10f87:	c3                   	ret    

00010f88 <tss_init>:
 * @param flag 任务的标志位，设置任务的特权级
 * @param entry 任务的入口地址
 * @param esp 任务的栈顶地址
 * @return 0 成功，-1 失败
 */
static int tss_init(task_t* task,int flag,uint32_t entry,uint32_t esp){
   10f88:	55                   	push   %ebp
   10f89:	89 e5                	mov    %esp,%ebp
   10f8b:	83 ec 28             	sub    $0x28,%esp
    int tss_sel=gdt_alloc_desc();
   10f8e:	e8 e1 14 00 00       	call   12474 <gdt_alloc_desc>
   10f93:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(tss_sel<0){
   10f96:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10f9a:	79 1a                	jns    10fb6 <tss_init+0x2e>
        log_printf("alloc tss failed.\n");
   10f9c:	83 ec 0c             	sub    $0xc,%esp
   10f9f:	68 54 5e 01 00       	push   $0x15e54
   10fa4:	e8 d4 4a 00 00       	call   15a7d <log_printf>
   10fa9:	83 c4 10             	add    $0x10,%esp
        return -1;
   10fac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10fb1:	e9 6b 01 00 00       	jmp    11121 <tss_init+0x199>
    }

    // 这里将tss_sel设置为特权级0的TSS段描述符为了防止任意修改tss
    segment_desc_set(tss_sel,(uint32_t)&task->tss,sizeof(tss_t),
   10fb6:	8b 45 08             	mov    0x8(%ebp),%eax
   10fb9:	05 58 02 00 00       	add    $0x258,%eax
   10fbe:	68 89 00 00 00       	push   $0x89
   10fc3:	6a 68                	push   $0x68
   10fc5:	50                   	push   %eax
   10fc6:	ff 75 ec             	pushl  -0x14(%ebp)
   10fc9:	e8 30 13 00 00       	call   122fe <segment_desc_set>
   10fce:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL0 | SEG_TYPE_TSS
    );
    kernel_memset(&task->tss,0,sizeof(tss_t));
   10fd1:	8b 45 08             	mov    0x8(%ebp),%eax
   10fd4:	05 58 02 00 00       	add    $0x258,%eax
   10fd9:	83 ec 04             	sub    $0x4,%esp
   10fdc:	6a 68                	push   $0x68
   10fde:	6a 00                	push   $0x0
   10fe0:	50                   	push   %eax
   10fe1:	e8 74 44 00 00       	call   1545a <kernel_memset>
   10fe6:	83 c4 10             	add    $0x10,%esp

    uint32_t kernel_stack=memory_alloc_page();
   10fe9:	e8 38 f9 ff ff       	call   10926 <memory_alloc_page>
   10fee:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(kernel_stack == 0){
   10ff1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   10ff5:	0f 84 fb 00 00 00    	je     110f6 <tss_init+0x16e>
        goto tss_init_failed;
    }
    
    int code_sel,data_sel;
    if(flag & TASK_FLAGS_SYSTEM){
   10ffb:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ffe:	83 e0 01             	and    $0x1,%eax
   11001:	85 c0                	test   %eax,%eax
   11003:	74 10                	je     11015 <tss_init+0x8d>
        code_sel=KERNEL_SELECTOR_CS;
   11005:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
        data_sel=KERNEL_SELECTOR_DS;
   1100c:	c7 45 f0 10 00 00 00 	movl   $0x10,-0x10(%ebp)
   11013:	eb 16                	jmp    1102b <tss_init+0xa3>
    }
    else{
        code_sel=task_manager.app_code_sel | SEG_CPL3;
   11015:	a1 b8 a5 01 00       	mov    0x1a5b8,%eax
   1101a:	83 c8 03             	or     $0x3,%eax
   1101d:	89 45 f4             	mov    %eax,-0xc(%ebp)
        data_sel=task_manager.app_data_sel | SEG_CPL3;
   11020:	a1 bc a5 01 00       	mov    0x1a5bc,%eax
   11025:	83 c8 03             	or     $0x3,%eax
   11028:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    task->tss.eip=entry;
   1102b:	8b 45 08             	mov    0x8(%ebp),%eax
   1102e:	8b 55 10             	mov    0x10(%ebp),%edx
   11031:	89 90 78 02 00 00    	mov    %edx,0x278(%eax)
    task->tss.esp=esp;
   11037:	8b 45 08             	mov    0x8(%ebp),%eax
   1103a:	8b 55 14             	mov    0x14(%ebp),%edx
   1103d:	89 90 90 02 00 00    	mov    %edx,0x290(%eax)
    task->tss.esp0=kernel_stack+MEM_PAGE_SIZE;
   11043:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11046:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
   1104c:	8b 45 08             	mov    0x8(%ebp),%eax
   1104f:	89 90 5c 02 00 00    	mov    %edx,0x25c(%eax)
    task->tss.ss=data_sel;
   11055:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11058:	8b 45 08             	mov    0x8(%ebp),%eax
   1105b:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%eax)
    task->tss.ss0=KERNEL_SELECTOR_DS;
   11061:	8b 45 08             	mov    0x8(%ebp),%eax
   11064:	c7 80 60 02 00 00 10 	movl   $0x10,0x260(%eax)
   1106b:	00 00 00 
    task->tss.es=task->tss.ds=task->tss.fs=task->tss.gs=data_sel;
   1106e:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11071:	8b 45 08             	mov    0x8(%ebp),%eax
   11074:	89 90 b4 02 00 00    	mov    %edx,0x2b4(%eax)
   1107a:	8b 45 08             	mov    0x8(%ebp),%eax
   1107d:	8b 90 b4 02 00 00    	mov    0x2b4(%eax),%edx
   11083:	8b 45 08             	mov    0x8(%ebp),%eax
   11086:	89 90 b0 02 00 00    	mov    %edx,0x2b0(%eax)
   1108c:	8b 45 08             	mov    0x8(%ebp),%eax
   1108f:	8b 90 b0 02 00 00    	mov    0x2b0(%eax),%edx
   11095:	8b 45 08             	mov    0x8(%ebp),%eax
   11098:	89 90 ac 02 00 00    	mov    %edx,0x2ac(%eax)
   1109e:	8b 45 08             	mov    0x8(%ebp),%eax
   110a1:	8b 90 ac 02 00 00    	mov    0x2ac(%eax),%edx
   110a7:	8b 45 08             	mov    0x8(%ebp),%eax
   110aa:	89 90 a0 02 00 00    	mov    %edx,0x2a0(%eax)
    task->tss.cs=code_sel;
   110b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   110b3:	8b 45 08             	mov    0x8(%ebp),%eax
   110b6:	89 90 a4 02 00 00    	mov    %edx,0x2a4(%eax)
    task->tss.eflags=EFLAGS_DEFAULT | EFLAGS_IF;
   110bc:	8b 45 08             	mov    0x8(%ebp),%eax
   110bf:	c7 80 7c 02 00 00 02 	movl   $0x202,0x27c(%eax)
   110c6:	02 00 00 

    uint32_t page_dir=memory_create_uvm();
   110c9:	e8 fa f6 ff ff       	call   107c8 <memory_create_uvm>
   110ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(page_dir == 0){
   110d1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   110d5:	74 22                	je     110f9 <tss_init+0x171>
        goto tss_init_failed;
    }
    task->tss.cr3=page_dir;
   110d7:	8b 45 08             	mov    0x8(%ebp),%eax
   110da:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   110dd:	89 90 74 02 00 00    	mov    %edx,0x274(%eax)
    task->tss_sel=tss_sel;
   110e3:	8b 45 08             	mov    0x8(%ebp),%eax
   110e6:	8b 55 ec             	mov    -0x14(%ebp),%edx
   110e9:	89 90 c0 02 00 00    	mov    %edx,0x2c0(%eax)
    return 0;
   110ef:	b8 00 00 00 00       	mov    $0x0,%eax
   110f4:	eb 2b                	jmp    11121 <tss_init+0x199>
        goto tss_init_failed;
   110f6:	90                   	nop
   110f7:	eb 01                	jmp    110fa <tss_init+0x172>
        goto tss_init_failed;
   110f9:	90                   	nop
tss_init_failed:
    gdt_free_sel(tss_sel);
   110fa:	83 ec 0c             	sub    $0xc,%esp
   110fd:	ff 75 ec             	pushl  -0x14(%ebp)
   11100:	e8 f8 13 00 00       	call   124fd <gdt_free_sel>
   11105:	83 c4 10             	add    $0x10,%esp
    if(kernel_stack){
   11108:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1110c:	74 0e                	je     1111c <tss_init+0x194>
        memory_free_page(kernel_stack);
   1110e:	83 ec 0c             	sub    $0xc,%esp
   11111:	ff 75 e8             	pushl  -0x18(%ebp)
   11114:	e8 40 f8 ff ff       	call   10959 <memory_free_page>
   11119:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   1111c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
   11121:	c9                   	leave  
   11122:	c3                   	ret    

00011123 <task_init>:

int task_init(task_t* task,const char*name,int flag,uint32_t entry,uint32_t esp){
   11123:	55                   	push   %ebp
   11124:	89 e5                	mov    %esp,%ebp
   11126:	83 ec 18             	sub    $0x18,%esp
    ASSERT(task!=(task_t*)0);
   11129:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1112d:	75 19                	jne    11148 <task_init+0x25>
   1112f:	68 67 5e 01 00       	push   $0x15e67
   11134:	68 78 5f 01 00       	push   $0x15f78
   11139:	6a 52                	push   $0x52
   1113b:	68 78 5e 01 00       	push   $0x15e78
   11140:	e8 68 46 00 00       	call   157ad <panic>
   11145:	83 c4 10             	add    $0x10,%esp
    int err=tss_init(task,flag,entry,esp);
   11148:	ff 75 18             	pushl  0x18(%ebp)
   1114b:	ff 75 14             	pushl  0x14(%ebp)
   1114e:	ff 75 10             	pushl  0x10(%ebp)
   11151:	ff 75 08             	pushl  0x8(%ebp)
   11154:	e8 2f fe ff ff       	call   10f88 <tss_init>
   11159:	83 c4 10             	add    $0x10,%esp
   1115c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(err<0){
   1115f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11163:	79 18                	jns    1117d <task_init+0x5a>
        log_printf("init task failed.");
   11165:	83 ec 0c             	sub    $0xc,%esp
   11168:	68 ab 5e 01 00       	push   $0x15eab
   1116d:	e8 0b 49 00 00       	call   15a7d <log_printf>
   11172:	83 c4 10             	add    $0x10,%esp
        return err;
   11175:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11178:	e9 fd 00 00 00       	jmp    1127a <task_init+0x157>
    }
    kernel_strncpy(task->name,name,TASK_NAME_SIZE);
   1117d:	8b 45 08             	mov    0x8(%ebp),%eax
   11180:	83 c0 20             	add    $0x20,%eax
   11183:	83 ec 04             	sub    $0x4,%esp
   11186:	6a 20                	push   $0x20
   11188:	ff 75 0c             	pushl  0xc(%ebp)
   1118b:	50                   	push   %eax
   1118c:	e8 55 41 00 00       	call   152e6 <kernel_strncpy>
   11191:	83 c4 10             	add    $0x10,%esp

    task->state=TASK_CREATED;
   11194:	8b 45 08             	mov    0x8(%ebp),%eax
   11197:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    task->time_ticks=TASK_TIME_SLICE_DEFAULT;
   1119d:	8b 45 08             	mov    0x8(%ebp),%eax
   111a0:	c7 40 1c 0a 00 00 00 	movl   $0xa,0x1c(%eax)
    task->slice_ticks=task->time_ticks;
   111a7:	8b 45 08             	mov    0x8(%ebp),%eax
   111aa:	8b 50 1c             	mov    0x1c(%eax),%edx
   111ad:	8b 45 08             	mov    0x8(%ebp),%eax
   111b0:	89 50 18             	mov    %edx,0x18(%eax)
    task->sleep_ticks=0;
   111b3:	8b 45 08             	mov    0x8(%ebp),%eax
   111b6:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
    task->status=0;
   111bd:	8b 45 08             	mov    0x8(%ebp),%eax
   111c0:	c7 80 c4 02 00 00 00 	movl   $0x0,0x2c4(%eax)
   111c7:	00 00 00 
    
    list_node_init(&task->all_node);
   111ca:	8b 45 08             	mov    0x8(%ebp),%eax
   111cd:	05 48 02 00 00       	add    $0x248,%eax
   111d2:	83 ec 0c             	sub    $0xc,%esp
   111d5:	50                   	push   %eax
   111d6:	e8 34 fd ff ff       	call   10f0f <list_node_init>
   111db:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->run_node);
   111de:	8b 45 08             	mov    0x8(%ebp),%eax
   111e1:	05 40 02 00 00       	add    $0x240,%eax
   111e6:	83 ec 0c             	sub    $0xc,%esp
   111e9:	50                   	push   %eax
   111ea:	e8 20 fd ff ff       	call   10f0f <list_node_init>
   111ef:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->wait_node);
   111f2:	8b 45 08             	mov    0x8(%ebp),%eax
   111f5:	05 50 02 00 00       	add    $0x250,%eax
   111fa:	83 ec 0c             	sub    $0xc,%esp
   111fd:	50                   	push   %eax
   111fe:	e8 0c fd ff ff       	call   10f0f <list_node_init>
   11203:	83 c4 10             	add    $0x10,%esp
    
    irq_state_t state=irq_enter_protection();
   11206:	e8 53 1c 00 00       	call   12e5e <irq_enter_protection>
   1120b:	89 45 f0             	mov    %eax,-0x10(%ebp)

    task->pid=(uint32_t)task;
   1120e:	8b 55 08             	mov    0x8(%ebp),%edx
   11211:	8b 45 08             	mov    0x8(%ebp),%eax
   11214:	89 50 04             	mov    %edx,0x4(%eax)
    task->parent=(task_t*)0;
   11217:	8b 45 08             	mov    0x8(%ebp),%eax
   1121a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    task->heap_start=0;
   11221:	8b 45 08             	mov    0x8(%ebp),%eax
   11224:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    task->heap_end=0;
   1122b:	8b 45 08             	mov    0x8(%ebp),%eax
   1122e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

    // 对task->file_table进行初始化
    kernel_memset(&task->file_table,0,sizeof(task->file_table));
   11235:	8b 45 08             	mov    0x8(%ebp),%eax
   11238:	83 c0 40             	add    $0x40,%eax
   1123b:	83 ec 04             	sub    $0x4,%esp
   1123e:	68 00 02 00 00       	push   $0x200
   11243:	6a 00                	push   $0x0
   11245:	50                   	push   %eax
   11246:	e8 0f 42 00 00       	call   1545a <kernel_memset>
   1124b:	83 c4 10             	add    $0x10,%esp

    list_insert_last(&task_manager.task_list,&task->all_node);
   1124e:	8b 45 08             	mov    0x8(%ebp),%eax
   11251:	05 48 02 00 00       	add    $0x248,%eax
   11256:	83 ec 08             	sub    $0x8,%esp
   11259:	50                   	push   %eax
   1125a:	68 10 a0 01 00       	push   $0x1a010
   1125f:	e8 89 46 00 00       	call   158ed <list_insert_last>
   11264:	83 c4 10             	add    $0x10,%esp

    irq_leave_protection(state);
   11267:	83 ec 0c             	sub    $0xc,%esp
   1126a:	ff 75 f0             	pushl  -0x10(%ebp)
   1126d:	e8 04 1c 00 00       	call   12e76 <irq_leave_protection>
   11272:	83 c4 10             	add    $0x10,%esp

    return 0;
   11275:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1127a:	c9                   	leave  
   1127b:	c3                   	ret    

0001127c <task_start>:

void task_start(task_t* task){
   1127c:	55                   	push   %ebp
   1127d:	89 e5                	mov    %esp,%ebp
   1127f:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   11282:	e8 d7 1b 00 00       	call   12e5e <irq_enter_protection>
   11287:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_set_ready(task);
   1128a:	83 ec 0c             	sub    $0xc,%esp
   1128d:	ff 75 08             	pushl  0x8(%ebp)
   11290:	e8 9f 02 00 00       	call   11534 <task_set_ready>
   11295:	83 c4 10             	add    $0x10,%esp
    irq_leave_protection(state);
   11298:	83 ec 0c             	sub    $0xc,%esp
   1129b:	ff 75 f4             	pushl  -0xc(%ebp)
   1129e:	e8 d3 1b 00 00       	call   12e76 <irq_leave_protection>
   112a3:	83 c4 10             	add    $0x10,%esp
}
   112a6:	90                   	nop
   112a7:	c9                   	leave  
   112a8:	c3                   	ret    

000112a9 <task_uninit>:

/**
 * @brief 释放任务的资源
 * @param task 需要释放的任务结构体
 */
void task_uninit(task_t* task){
   112a9:	55                   	push   %ebp
   112aa:	89 e5                	mov    %esp,%ebp
   112ac:	83 ec 08             	sub    $0x8,%esp
    if(task->tss_sel){
   112af:	8b 45 08             	mov    0x8(%ebp),%eax
   112b2:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
   112b8:	85 c0                	test   %eax,%eax
   112ba:	74 15                	je     112d1 <task_uninit+0x28>
        gdt_free_sel(task->tss_sel);
   112bc:	8b 45 08             	mov    0x8(%ebp),%eax
   112bf:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
   112c5:	83 ec 0c             	sub    $0xc,%esp
   112c8:	50                   	push   %eax
   112c9:	e8 2f 12 00 00       	call   124fd <gdt_free_sel>
   112ce:	83 c4 10             	add    $0x10,%esp
    }

    if(task->tss.esp0){
   112d1:	8b 45 08             	mov    0x8(%ebp),%eax
   112d4:	8b 80 5c 02 00 00    	mov    0x25c(%eax),%eax
   112da:	85 c0                	test   %eax,%eax
   112dc:	74 1a                	je     112f8 <task_uninit+0x4f>
        memory_free_page(task->tss.esp-MEM_PAGE_SIZE);
   112de:	8b 45 08             	mov    0x8(%ebp),%eax
   112e1:	8b 80 90 02 00 00    	mov    0x290(%eax),%eax
   112e7:	2d 00 10 00 00       	sub    $0x1000,%eax
   112ec:	83 ec 0c             	sub    $0xc,%esp
   112ef:	50                   	push   %eax
   112f0:	e8 64 f6 ff ff       	call   10959 <memory_free_page>
   112f5:	83 c4 10             	add    $0x10,%esp
    }

    if(task->tss.cr3){
   112f8:	8b 45 08             	mov    0x8(%ebp),%eax
   112fb:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   11301:	85 c0                	test   %eax,%eax
   11303:	74 15                	je     1131a <task_uninit+0x71>
        memory_destroy_uvm(task->tss.cr3);
   11305:	8b 45 08             	mov    0x8(%ebp),%eax
   11308:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   1130e:	83 ec 0c             	sub    $0xc,%esp
   11311:	50                   	push   %eax
   11312:	e8 db f6 ff ff       	call   109f2 <memory_destroy_uvm>
   11317:	83 c4 10             	add    $0x10,%esp
    }

    kernel_memset(task,0,sizeof(task));
   1131a:	83 ec 04             	sub    $0x4,%esp
   1131d:	6a 04                	push   $0x4
   1131f:	6a 00                	push   $0x0
   11321:	ff 75 08             	pushl  0x8(%ebp)
   11324:	e8 31 41 00 00       	call   1545a <kernel_memset>
   11329:	83 c4 10             	add    $0x10,%esp
}
   1132c:	90                   	nop
   1132d:	c9                   	leave  
   1132e:	c3                   	ret    

0001132f <task_switch_from_to>:

void task_switch_from_to(task_t*from,task_t*to){
   1132f:	55                   	push   %ebp
   11330:	89 e5                	mov    %esp,%ebp
   11332:	83 ec 08             	sub    $0x8,%esp
    switch_to_tss(to->tss_sel);
   11335:	8b 45 0c             	mov    0xc(%ebp),%eax
   11338:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
   1133e:	83 ec 0c             	sub    $0xc,%esp
   11341:	50                   	push   %eax
   11342:	e8 a2 11 00 00       	call   124e9 <switch_to_tss>
   11347:	83 c4 10             	add    $0x10,%esp
}
   1134a:	90                   	nop
   1134b:	c9                   	leave  
   1134c:	c3                   	ret    

0001134d <idle_task_entry>:

static void idle_task_entry(void){
   1134d:	55                   	push   %ebp
   1134e:	89 e5                	mov    %esp,%ebp
    for(;;){
        hlt();
   11350:	e8 73 fb ff ff       	call   10ec8 <hlt>
   11355:	eb f9                	jmp    11350 <idle_task_entry+0x3>

00011357 <task_manager_init>:
}

/**
 * @brief 初始化任务管理器
 */
void task_manager_init(void){
   11357:	55                   	push   %ebp
   11358:	89 e5                	mov    %esp,%ebp
   1135a:	83 ec 18             	sub    $0x18,%esp

    kernel_memset(task_table,0,sizeof(task_table));
   1135d:	83 ec 04             	sub    $0x4,%esp
   11360:	68 00 64 01 00       	push   $0x16400
   11365:	6a 00                	push   $0x0
   11367:	68 c0 b5 01 00       	push   $0x1b5c0
   1136c:	e8 e9 40 00 00       	call   1545a <kernel_memset>
   11371:	83 c4 10             	add    $0x10,%esp
    mutex_init(&table_mutex);
   11374:	83 ec 0c             	sub    $0xc,%esp
   11377:	68 c0 19 03 00       	push   $0x319c0
   1137c:	e8 e1 39 00 00       	call   14d62 <mutex_init>
   11381:	83 c4 10             	add    $0x10,%esp

    int sel=gdt_alloc_desc();
   11384:	e8 eb 10 00 00       	call   12474 <gdt_alloc_desc>
   11389:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 这里虽然设置的代码段和数据段范围还是0x0-0xFFFFFFFF，但使用该段的段选择子访问的方式为特权级3
    segment_desc_set(sel,0x0,0xFFFFFFFF,
   1138c:	68 f2 40 00 00       	push   $0x40f2
   11391:	6a ff                	push   $0xffffffff
   11393:	6a 00                	push   $0x0
   11395:	ff 75 f4             	pushl  -0xc(%ebp)
   11398:	e8 61 0f 00 00       	call   122fe <segment_desc_set>
   1139d:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW | SEG_D
    );
    task_manager.app_data_sel=sel;
   113a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   113a3:	a3 bc a5 01 00       	mov    %eax,0x1a5bc

    sel=gdt_alloc_desc();
   113a8:	e8 c7 10 00 00       	call   12474 <gdt_alloc_desc>
   113ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(sel,0x0,0xFFFFFFFF,
   113b0:	68 fa 40 00 00       	push   $0x40fa
   113b5:	6a ff                	push   $0xffffffff
   113b7:	6a 00                	push   $0x0
   113b9:	ff 75 f4             	pushl  -0xc(%ebp)
   113bc:	e8 3d 0f 00 00       	call   122fe <segment_desc_set>
   113c1:	83 c4 10             	add    $0x10,%esp
           SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL |SEG_TYPE_CODE | SEG_TYPE_RW | SEG_D
    );
    task_manager.app_code_sel=sel;
   113c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   113c7:	a3 b8 a5 01 00       	mov    %eax,0x1a5b8

    list_init(&task_manager.ready_list);
   113cc:	83 ec 0c             	sub    $0xc,%esp
   113cf:	68 04 a0 01 00       	push   $0x1a004
   113d4:	e8 90 44 00 00       	call   15869 <list_init>
   113d9:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.task_list);
   113dc:	83 ec 0c             	sub    $0xc,%esp
   113df:	68 10 a0 01 00       	push   $0x1a010
   113e4:	e8 80 44 00 00       	call   15869 <list_init>
   113e9:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.sleep_list);
   113ec:	83 ec 0c             	sub    $0xc,%esp
   113ef:	68 1c a0 01 00       	push   $0x1a01c
   113f4:	e8 70 44 00 00       	call   15869 <list_init>
   113f9:	83 c4 10             	add    $0x10,%esp
    task_manager.curr_task=(task_t*)0;
   113fc:	c7 05 00 a0 01 00 00 	movl   $0x0,0x1a000
   11403:	00 00 00 
    task_init(&task_manager.idle_task,"idle_task",TASK_FLAGS_SYSTEM,(uint32_t)idle_task_entry,
    (uint32_t)(idle_task_stack+IDLE_TASK_SIZE));
   11406:	b8 c0 b5 01 00       	mov    $0x1b5c0,%eax
    task_init(&task_manager.idle_task,"idle_task",TASK_FLAGS_SYSTEM,(uint32_t)idle_task_entry,
   1140b:	89 c2                	mov    %eax,%edx
   1140d:	b8 4d 13 01 00       	mov    $0x1134d,%eax
   11412:	83 ec 0c             	sub    $0xc,%esp
   11415:	52                   	push   %edx
   11416:	50                   	push   %eax
   11417:	6a 01                	push   $0x1
   11419:	68 bd 5e 01 00       	push   $0x15ebd
   1141e:	68 f0 a2 01 00       	push   $0x1a2f0
   11423:	e8 fb fc ff ff       	call   11123 <task_init>
   11428:	83 c4 20             	add    $0x20,%esp

    task_start(&task_manager.idle_task);
   1142b:	83 ec 0c             	sub    $0xc,%esp
   1142e:	68 f0 a2 01 00       	push   $0x1a2f0
   11433:	e8 44 fe ff ff       	call   1127c <task_start>
   11438:	83 c4 10             	add    $0x10,%esp
}
   1143b:	90                   	nop
   1143c:	c9                   	leave  
   1143d:	c3                   	ret    

0001143e <task_first_init>:

/**
 * @brief 初始化第一个任务
 * @note 该函数的运行的入口地址为first_task_entry，位于first_task_entry.S中
 */
void task_first_init(void){
   1143e:	55                   	push   %ebp
   1143f:	89 e5                	mov    %esp,%ebp
   11441:	83 ec 18             	sub    $0x18,%esp
    void first_task_entry(void);
    extern uint8_t s_first_task[],e_first_task[];

    uint32_t copy_size=(uint32_t)(e_first_task-s_first_task);
   11444:	ba 6d c9 06 00       	mov    $0x6c96d,%edx
   11449:	b8 e0 c5 06 00       	mov    $0x6c5e0,%eax
   1144e:	29 c2                	sub    %eax,%edx
   11450:	89 d0                	mov    %edx,%eax
   11452:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t alloc_size=10*MEM_PAGE_SIZE;
   11455:	c7 45 f0 00 a0 00 00 	movl   $0xa000,-0x10(%ebp)
    ASSERT(copy_size < alloc_size);
   1145c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1145f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   11462:	72 1c                	jb     11480 <task_first_init+0x42>
   11464:	68 c7 5e 01 00       	push   $0x15ec7
   11469:	68 84 5f 01 00       	push   $0x15f84
   1146e:	68 c3 00 00 00       	push   $0xc3
   11473:	68 78 5e 01 00       	push   $0x15e78
   11478:	e8 30 43 00 00       	call   157ad <panic>
   1147d:	83 c4 10             	add    $0x10,%esp

    uint32_t first_start=(uint32_t)first_task_entry;
   11480:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%ebp)

    task_init(&task_manager.first_task,"first task",0,first_start,first_start+alloc_size);
   11487:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1148a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1148d:	01 d0                	add    %edx,%eax
   1148f:	83 ec 0c             	sub    $0xc,%esp
   11492:	50                   	push   %eax
   11493:	ff 75 ec             	pushl  -0x14(%ebp)
   11496:	6a 00                	push   $0x0
   11498:	68 de 5e 01 00       	push   $0x15ede
   1149d:	68 28 a0 01 00       	push   $0x1a028
   114a2:	e8 7c fc ff ff       	call   11123 <task_init>
   114a7:	83 c4 20             	add    $0x20,%esp

    task_manager.first_task.heap_start=(uint32_t)e_first_task;
   114aa:	b8 6d c9 06 00       	mov    $0x6c96d,%eax
   114af:	a3 34 a0 01 00       	mov    %eax,0x1a034
    task_manager.first_task.heap_end=(uint32_t)e_first_task;
   114b4:	b8 6d c9 06 00       	mov    $0x6c96d,%eax
   114b9:	a3 38 a0 01 00       	mov    %eax,0x1a038

    write_tr(task_manager.first_task.tss_sel);
   114be:	a1 e8 a2 01 00       	mov    0x1a2e8,%eax
   114c3:	0f b7 c0             	movzwl %ax,%eax
   114c6:	83 ec 0c             	sub    $0xc,%esp
   114c9:	50                   	push   %eax
   114ca:	e8 00 fa ff ff       	call   10ecf <write_tr>
   114cf:	83 c4 10             	add    $0x10,%esp
    task_manager.curr_task=&task_manager.first_task;
   114d2:	c7 05 00 a0 01 00 28 	movl   $0x1a028,0x1a000
   114d9:	a0 01 00 

    mmu_set_page_dir(task_manager.first_task.tss.cr3);
   114dc:	a1 9c a2 01 00       	mov    0x1a29c,%eax
   114e1:	83 ec 0c             	sub    $0xc,%esp
   114e4:	50                   	push   %eax
   114e5:	e8 60 fa ff ff       	call   10f4a <mmu_set_page_dir>
   114ea:	83 c4 10             	add    $0x10,%esp

    memory_alloc_page_for(first_start,alloc_size,PTE_P | PTE_W | PTE_U);
   114ed:	83 ec 04             	sub    $0x4,%esp
   114f0:	6a 07                	push   $0x7
   114f2:	ff 75 f0             	pushl  -0x10(%ebp)
   114f5:	ff 75 ec             	pushl  -0x14(%ebp)
   114f8:	e8 04 f4 ff ff       	call   10901 <memory_alloc_page_for>
   114fd:	83 c4 10             	add    $0x10,%esp
    kernel_memcpy((void*)first_start,s_first_task,copy_size);
   11500:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11503:	83 ec 04             	sub    $0x4,%esp
   11506:	ff 75 f4             	pushl  -0xc(%ebp)
   11509:	68 e0 c5 06 00       	push   $0x6c5e0
   1150e:	50                   	push   %eax
   1150f:	e8 f7 3e 00 00       	call   1540b <kernel_memcpy>
   11514:	83 c4 10             	add    $0x10,%esp

    task_start(&task_manager.first_task);
   11517:	83 ec 0c             	sub    $0xc,%esp
   1151a:	68 28 a0 01 00       	push   $0x1a028
   1151f:	e8 58 fd ff ff       	call   1127c <task_start>
   11524:	83 c4 10             	add    $0x10,%esp
}
   11527:	90                   	nop
   11528:	c9                   	leave  
   11529:	c3                   	ret    

0001152a <task_first_task>:

task_t* task_first_task(void){
   1152a:	55                   	push   %ebp
   1152b:	89 e5                	mov    %esp,%ebp
    return &task_manager.first_task;
   1152d:	b8 28 a0 01 00       	mov    $0x1a028,%eax
}
   11532:	5d                   	pop    %ebp
   11533:	c3                   	ret    

00011534 <task_set_ready>:
 * @brief 设置任务为就绪状态
 * @param task 需要设置的任务
 * @return 0 成功，-1 失败
 * @note 该函数会将任务插入到就绪队列中，将任务的状态设置为就绪
 */
void task_set_ready(task_t* task){
   11534:	55                   	push   %ebp
   11535:	89 e5                	mov    %esp,%ebp
   11537:	83 ec 08             	sub    $0x8,%esp
    if(task==&task_manager.idle_task){
   1153a:	81 7d 08 f0 a2 01 00 	cmpl   $0x1a2f0,0x8(%ebp)
   11541:	74 24                	je     11567 <task_set_ready+0x33>
        return;
    }
    list_insert_last(&task_manager.ready_list,&task->run_node);
   11543:	8b 45 08             	mov    0x8(%ebp),%eax
   11546:	05 40 02 00 00       	add    $0x240,%eax
   1154b:	83 ec 08             	sub    $0x8,%esp
   1154e:	50                   	push   %eax
   1154f:	68 04 a0 01 00       	push   $0x1a004
   11554:	e8 94 43 00 00       	call   158ed <list_insert_last>
   11559:	83 c4 10             	add    $0x10,%esp
    task->state=TASK_READY;
   1155c:	8b 45 08             	mov    0x8(%ebp),%eax
   1155f:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   11565:	eb 01                	jmp    11568 <task_set_ready+0x34>
        return;
   11567:	90                   	nop
}
   11568:	c9                   	leave  
   11569:	c3                   	ret    

0001156a <task_set_block>:

void task_set_block(task_t* task){
   1156a:	55                   	push   %ebp
   1156b:	89 e5                	mov    %esp,%ebp
   1156d:	83 ec 08             	sub    $0x8,%esp
    if(task==&task_manager.idle_task){
   11570:	81 7d 08 f0 a2 01 00 	cmpl   $0x1a2f0,0x8(%ebp)
   11577:	74 1b                	je     11594 <task_set_block+0x2a>
        return;
    }
    list_remove(&task_manager.ready_list,&task->run_node);
   11579:	8b 45 08             	mov    0x8(%ebp),%eax
   1157c:	05 40 02 00 00       	add    $0x240,%eax
   11581:	83 ec 08             	sub    $0x8,%esp
   11584:	50                   	push   %eax
   11585:	68 04 a0 01 00       	push   $0x1a004
   1158a:	e8 3a 44 00 00       	call   159c9 <list_remove>
   1158f:	83 c4 10             	add    $0x10,%esp
   11592:	eb 01                	jmp    11595 <task_set_block+0x2b>
        return;
   11594:	90                   	nop
}
   11595:	c9                   	leave  
   11596:	c3                   	ret    

00011597 <task_next_run>:

task_t* task_next_run(void){
   11597:	55                   	push   %ebp
   11598:	89 e5                	mov    %esp,%ebp
   1159a:	83 ec 10             	sub    $0x10,%esp
    if(list_count(&task_manager.ready_list)==0){
   1159d:	68 04 a0 01 00       	push   $0x1a004
   115a2:	e8 8e f9 ff ff       	call   10f35 <list_count>
   115a7:	83 c4 04             	add    $0x4,%esp
   115aa:	85 c0                	test   %eax,%eax
   115ac:	75 07                	jne    115b5 <task_next_run+0x1e>
        return &task_manager.idle_task;
   115ae:	b8 f0 a2 01 00       	mov    $0x1a2f0,%eax
   115b3:	eb 25                	jmp    115da <task_next_run+0x43>
    }
    list_node_t* task_node=list_first(&task_manager.ready_list);
   115b5:	68 04 a0 01 00       	push   $0x1a004
   115ba:	e8 81 f9 ff ff       	call   10f40 <list_first>
   115bf:	83 c4 04             	add    $0x4,%esp
   115c2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return list_node_parent(task_node,task_t,run_node);
   115c5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   115c9:	74 0a                	je     115d5 <task_next_run+0x3e>
   115cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   115ce:	2d 40 02 00 00       	sub    $0x240,%eax
   115d3:	eb 05                	jmp    115da <task_next_run+0x43>
   115d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
   115da:	c9                   	leave  
   115db:	c3                   	ret    

000115dc <task_current>:

task_t* task_current(void){
   115dc:	55                   	push   %ebp
   115dd:	89 e5                	mov    %esp,%ebp
    return task_manager.curr_task;
   115df:	a1 00 a0 01 00       	mov    0x1a000,%eax
}
   115e4:	5d                   	pop    %ebp
   115e5:	c3                   	ret    

000115e6 <sys_sched_yield>:

int sys_sched_yield(void){
   115e6:	55                   	push   %ebp
   115e7:	89 e5                	mov    %esp,%ebp
   115e9:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   115ec:	e8 6d 18 00 00       	call   12e5e <irq_enter_protection>
   115f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(list_count(&task_manager.ready_list)>1){
   115f4:	83 ec 0c             	sub    $0xc,%esp
   115f7:	68 04 a0 01 00       	push   $0x1a004
   115fc:	e8 34 f9 ff ff       	call   10f35 <list_count>
   11601:	83 c4 10             	add    $0x10,%esp
   11604:	83 f8 01             	cmp    $0x1,%eax
   11607:	7e 29                	jle    11632 <sys_sched_yield+0x4c>
        task_t* curr_task=task_current();
   11609:	e8 ce ff ff ff       	call   115dc <task_current>
   1160e:	89 45 f0             	mov    %eax,-0x10(%ebp)

        task_set_block(curr_task);
   11611:	83 ec 0c             	sub    $0xc,%esp
   11614:	ff 75 f0             	pushl  -0x10(%ebp)
   11617:	e8 4e ff ff ff       	call   1156a <task_set_block>
   1161c:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task);
   1161f:	83 ec 0c             	sub    $0xc,%esp
   11622:	ff 75 f0             	pushl  -0x10(%ebp)
   11625:	e8 0a ff ff ff       	call   11534 <task_set_ready>
   1162a:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   1162d:	e8 15 00 00 00       	call   11647 <task_dispatch>
    }
    irq_leave_protection(state);
   11632:	83 ec 0c             	sub    $0xc,%esp
   11635:	ff 75 f4             	pushl  -0xc(%ebp)
   11638:	e8 39 18 00 00       	call   12e76 <irq_leave_protection>
   1163d:	83 c4 10             	add    $0x10,%esp
    return 0;
   11640:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11645:	c9                   	leave  
   11646:	c3                   	ret    

00011647 <task_dispatch>:

void task_dispatch(void){
   11647:	55                   	push   %ebp
   11648:	89 e5                	mov    %esp,%ebp
   1164a:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   1164d:	e8 0c 18 00 00       	call   12e5e <irq_enter_protection>
   11652:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* to=task_next_run();
   11655:	e8 3d ff ff ff       	call   11597 <task_next_run>
   1165a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(to!=task_manager.curr_task){
   1165d:	a1 00 a0 01 00       	mov    0x1a000,%eax
   11662:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11665:	74 2a                	je     11691 <task_dispatch+0x4a>
        task_t* from=task_current();
   11667:	e8 70 ff ff ff       	call   115dc <task_current>
   1166c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_manager.curr_task=to;
   1166f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11672:	a3 00 a0 01 00       	mov    %eax,0x1a000
        to->state=TASK_RUNNING;
   11677:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1167a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        task_switch_from_to(from,to);
   11680:	83 ec 08             	sub    $0x8,%esp
   11683:	ff 75 f0             	pushl  -0x10(%ebp)
   11686:	ff 75 ec             	pushl  -0x14(%ebp)
   11689:	e8 a1 fc ff ff       	call   1132f <task_switch_from_to>
   1168e:	83 c4 10             	add    $0x10,%esp
    }
    irq_leave_protection(state);
   11691:	83 ec 0c             	sub    $0xc,%esp
   11694:	ff 75 f4             	pushl  -0xc(%ebp)
   11697:	e8 da 17 00 00       	call   12e76 <irq_leave_protection>
   1169c:	83 c4 10             	add    $0x10,%esp
}
   1169f:	90                   	nop
   116a0:	c9                   	leave  
   116a1:	c3                   	ret    

000116a2 <task_time_tick>:

void task_time_tick(void){
   116a2:	55                   	push   %ebp
   116a3:	89 e5                	mov    %esp,%ebp
   116a5:	83 ec 28             	sub    $0x28,%esp
    irq_state_t state=irq_enter_protection();
   116a8:	e8 b1 17 00 00       	call   12e5e <irq_enter_protection>
   116ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
    task_t* curr_task=task_current();
   116b0:	e8 27 ff ff ff       	call   115dc <task_current>
   116b5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(--curr_task->slice_ticks==0){
   116b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116bb:	8b 40 18             	mov    0x18(%eax),%eax
   116be:	8d 50 ff             	lea    -0x1(%eax),%edx
   116c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116c4:	89 50 18             	mov    %edx,0x18(%eax)
   116c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116ca:	8b 40 18             	mov    0x18(%eax),%eax
   116cd:	85 c0                	test   %eax,%eax
   116cf:	75 28                	jne    116f9 <task_time_tick+0x57>
        curr_task->slice_ticks=curr_task->time_ticks;
   116d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116d4:	8b 50 1c             	mov    0x1c(%eax),%edx
   116d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116da:	89 50 18             	mov    %edx,0x18(%eax)
        task_set_block(curr_task);
   116dd:	83 ec 0c             	sub    $0xc,%esp
   116e0:	ff 75 ec             	pushl  -0x14(%ebp)
   116e3:	e8 82 fe ff ff       	call   1156a <task_set_block>
   116e8:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr_task);
   116eb:	83 ec 0c             	sub    $0xc,%esp
   116ee:	ff 75 ec             	pushl  -0x14(%ebp)
   116f1:	e8 3e fe ff ff       	call   11534 <task_set_ready>
   116f6:	83 c4 10             	add    $0x10,%esp
    }
    list_node_t* curr=list_first(&task_manager.sleep_list);
   116f9:	83 ec 0c             	sub    $0xc,%esp
   116fc:	68 1c a0 01 00       	push   $0x1a01c
   11701:	e8 3a f8 ff ff       	call   10f40 <list_first>
   11706:	83 c4 10             	add    $0x10,%esp
   11709:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(curr){
   1170c:	eb 64                	jmp    11772 <task_time_tick+0xd0>
        list_node_t*next=list_node_next(curr);
   1170e:	83 ec 0c             	sub    $0xc,%esp
   11711:	ff 75 f4             	pushl  -0xc(%ebp)
   11714:	e8 11 f8 ff ff       	call   10f2a <list_node_next>
   11719:	83 c4 10             	add    $0x10,%esp
   1171c:	89 45 e8             	mov    %eax,-0x18(%ebp)
        task_t* task=list_node_parent(curr,task_t,run_node);
   1171f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11723:	74 0a                	je     1172f <task_time_tick+0x8d>
   11725:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11728:	2d 40 02 00 00       	sub    $0x240,%eax
   1172d:	eb 05                	jmp    11734 <task_time_tick+0x92>
   1172f:	b8 00 00 00 00       	mov    $0x0,%eax
   11734:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(--task->sleep_ticks==0){
   11737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1173a:	8b 40 14             	mov    0x14(%eax),%eax
   1173d:	8d 50 ff             	lea    -0x1(%eax),%edx
   11740:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11743:	89 50 14             	mov    %edx,0x14(%eax)
   11746:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11749:	8b 40 14             	mov    0x14(%eax),%eax
   1174c:	85 c0                	test   %eax,%eax
   1174e:	75 1c                	jne    1176c <task_time_tick+0xca>
            task_set_wakeup(task);
   11750:	83 ec 0c             	sub    $0xc,%esp
   11753:	ff 75 e4             	pushl  -0x1c(%ebp)
   11756:	e8 6f 00 00 00       	call   117ca <task_set_wakeup>
   1175b:	83 c4 10             	add    $0x10,%esp
            task_set_ready(task);
   1175e:	83 ec 0c             	sub    $0xc,%esp
   11761:	ff 75 e4             	pushl  -0x1c(%ebp)
   11764:	e8 cb fd ff ff       	call   11534 <task_set_ready>
   11769:	83 c4 10             	add    $0x10,%esp
        }
        curr=next;
   1176c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1176f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(curr){
   11772:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11776:	75 96                	jne    1170e <task_time_tick+0x6c>
    }
    task_dispatch();
   11778:	e8 ca fe ff ff       	call   11647 <task_dispatch>
    irq_leave_protection(state);
   1177d:	83 ec 0c             	sub    $0xc,%esp
   11780:	ff 75 f0             	pushl  -0x10(%ebp)
   11783:	e8 ee 16 00 00       	call   12e76 <irq_leave_protection>
   11788:	83 c4 10             	add    $0x10,%esp
}
   1178b:	90                   	nop
   1178c:	c9                   	leave  
   1178d:	c3                   	ret    

0001178e <task_set_sleep>:

void task_set_sleep(task_t* task,uint32_t ticks){
   1178e:	55                   	push   %ebp
   1178f:	89 e5                	mov    %esp,%ebp
   11791:	83 ec 08             	sub    $0x8,%esp
    if(ticks==0){
   11794:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11798:	74 2d                	je     117c7 <task_set_sleep+0x39>
        return;
    }
    task->sleep_ticks=ticks;
   1179a:	8b 55 0c             	mov    0xc(%ebp),%edx
   1179d:	8b 45 08             	mov    0x8(%ebp),%eax
   117a0:	89 50 14             	mov    %edx,0x14(%eax)
    task->state=TASK_SLEEP;
   117a3:	8b 45 08             	mov    0x8(%ebp),%eax
   117a6:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    list_insert_last(&task_manager.sleep_list,&task->run_node);
   117ac:	8b 45 08             	mov    0x8(%ebp),%eax
   117af:	05 40 02 00 00       	add    $0x240,%eax
   117b4:	83 ec 08             	sub    $0x8,%esp
   117b7:	50                   	push   %eax
   117b8:	68 1c a0 01 00       	push   $0x1a01c
   117bd:	e8 2b 41 00 00       	call   158ed <list_insert_last>
   117c2:	83 c4 10             	add    $0x10,%esp
   117c5:	eb 01                	jmp    117c8 <task_set_sleep+0x3a>
        return;
   117c7:	90                   	nop
}
   117c8:	c9                   	leave  
   117c9:	c3                   	ret    

000117ca <task_set_wakeup>:

void task_set_wakeup(task_t* task){
   117ca:	55                   	push   %ebp
   117cb:	89 e5                	mov    %esp,%ebp
   117cd:	83 ec 08             	sub    $0x8,%esp
    list_remove(&task_manager.sleep_list,&task->run_node);
   117d0:	8b 45 08             	mov    0x8(%ebp),%eax
   117d3:	05 40 02 00 00       	add    $0x240,%eax
   117d8:	83 ec 08             	sub    $0x8,%esp
   117db:	50                   	push   %eax
   117dc:	68 1c a0 01 00       	push   $0x1a01c
   117e1:	e8 e3 41 00 00       	call   159c9 <list_remove>
   117e6:	83 c4 10             	add    $0x10,%esp
}
   117e9:	90                   	nop
   117ea:	c9                   	leave  
   117eb:	c3                   	ret    

000117ec <sys_msleep>:

void sys_msleep (uint32_t ms) {
   117ec:	55                   	push   %ebp
   117ed:	89 e5                	mov    %esp,%ebp
   117ef:	83 ec 18             	sub    $0x18,%esp
    if (ms < OS_TICK_MS) {
   117f2:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
   117f6:	77 07                	ja     117ff <sys_msleep+0x13>
        ms = OS_TICK_MS;
   117f8:	c7 45 08 0a 00 00 00 	movl   $0xa,0x8(%ebp)
    }

    irq_state_t state = irq_enter_protection();
   117ff:	e8 5a 16 00 00       	call   12e5e <irq_enter_protection>
   11804:	89 45 f4             	mov    %eax,-0xc(%ebp)

    task_set_block(task_manager.curr_task);
   11807:	a1 00 a0 01 00       	mov    0x1a000,%eax
   1180c:	83 ec 0c             	sub    $0xc,%esp
   1180f:	50                   	push   %eax
   11810:	e8 55 fd ff ff       	call   1156a <task_set_block>
   11815:	83 c4 10             	add    $0x10,%esp
    task_set_sleep(task_manager.curr_task, (ms + (OS_TICK_MS - 1))/ OS_TICK_MS);
   11818:	8b 45 08             	mov    0x8(%ebp),%eax
   1181b:	83 c0 09             	add    $0x9,%eax
   1181e:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
   11823:	f7 e2                	mul    %edx
   11825:	c1 ea 03             	shr    $0x3,%edx
   11828:	a1 00 a0 01 00       	mov    0x1a000,%eax
   1182d:	83 ec 08             	sub    $0x8,%esp
   11830:	52                   	push   %edx
   11831:	50                   	push   %eax
   11832:	e8 57 ff ff ff       	call   1178e <task_set_sleep>
   11837:	83 c4 10             	add    $0x10,%esp
    
    task_dispatch();
   1183a:	e8 08 fe ff ff       	call   11647 <task_dispatch>

    irq_leave_protection(state);
   1183f:	83 ec 0c             	sub    $0xc,%esp
   11842:	ff 75 f4             	pushl  -0xc(%ebp)
   11845:	e8 2c 16 00 00       	call   12e76 <irq_leave_protection>
   1184a:	83 c4 10             	add    $0x10,%esp
}
   1184d:	90                   	nop
   1184e:	c9                   	leave  
   1184f:	c3                   	ret    

00011850 <sys_getpid>:

int sys_getpid(void){
   11850:	55                   	push   %ebp
   11851:	89 e5                	mov    %esp,%ebp
   11853:	83 ec 10             	sub    $0x10,%esp
    task_t* task=task_current();
   11856:	e8 81 fd ff ff       	call   115dc <task_current>
   1185b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return task->pid;
   1185e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11861:	8b 40 04             	mov    0x4(%eax),%eax
}
   11864:	c9                   	leave  
   11865:	c3                   	ret    

00011866 <alloc_task>:

static task_t* alloc_task(void){
   11866:	55                   	push   %ebp
   11867:	89 e5                	mov    %esp,%ebp
   11869:	83 ec 18             	sub    $0x18,%esp
    task_t* task=(task_t*)0;
   1186c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    mutex_lock(&table_mutex);
   11873:	83 ec 0c             	sub    $0xc,%esp
   11876:	68 c0 19 03 00       	push   $0x319c0
   1187b:	e8 10 35 00 00       	call   14d90 <mutex_lock>
   11880:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<TASK_NR;i++){
   11883:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1188a:	eb 27                	jmp    118b3 <alloc_task+0x4d>
        task_t* curr=task_table+i;
   1188c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1188f:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   11895:	05 c0 b5 01 00       	add    $0x1b5c0,%eax
   1189a:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(curr->pid==0){
   1189d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   118a0:	8b 40 04             	mov    0x4(%eax),%eax
   118a3:	85 c0                	test   %eax,%eax
   118a5:	75 08                	jne    118af <alloc_task+0x49>
            task=curr;
   118a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   118aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
   118ad:	eb 0a                	jmp    118b9 <alloc_task+0x53>
    for(int i=0;i<TASK_NR;i++){
   118af:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   118b3:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
   118b7:	7e d3                	jle    1188c <alloc_task+0x26>
        }
    }   
    mutex_unlock(&table_mutex);
   118b9:	83 ec 0c             	sub    $0xc,%esp
   118bc:	68 c0 19 03 00       	push   $0x319c0
   118c1:	e8 59 35 00 00       	call   14e1f <mutex_unlock>
   118c6:	83 c4 10             	add    $0x10,%esp

    return task;
   118c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   118cc:	c9                   	leave  
   118cd:	c3                   	ret    

000118ce <free_task>:

static void free_task(task_t* task){
   118ce:	55                   	push   %ebp
   118cf:	89 e5                	mov    %esp,%ebp
   118d1:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&table_mutex);
   118d4:	83 ec 0c             	sub    $0xc,%esp
   118d7:	68 c0 19 03 00       	push   $0x319c0
   118dc:	e8 af 34 00 00       	call   14d90 <mutex_lock>
   118e1:	83 c4 10             	add    $0x10,%esp
    task->pid=0;
   118e4:	8b 45 08             	mov    0x8(%ebp),%eax
   118e7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    mutex_unlock(&table_mutex);
   118ee:	83 ec 0c             	sub    $0xc,%esp
   118f1:	68 c0 19 03 00       	push   $0x319c0
   118f6:	e8 24 35 00 00       	call   14e1f <mutex_unlock>
   118fb:	83 c4 10             	add    $0x10,%esp
}
   118fe:	90                   	nop
   118ff:	c9                   	leave  
   11900:	c3                   	ret    

00011901 <sys_fork>:

int sys_fork(void){
   11901:	55                   	push   %ebp
   11902:	89 e5                	mov    %esp,%ebp
   11904:	83 ec 28             	sub    $0x28,%esp
    task_t* parent_task=task_current();
   11907:	e8 d0 fc ff ff       	call   115dc <task_current>
   1190c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* child_task=alloc_task();
   1190f:	e8 52 ff ff ff       	call   11866 <alloc_task>
   11914:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(child_task==(task_t*)0){
   11917:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1191b:	0f 84 24 01 00 00    	je     11a45 <sys_fork+0x144>
        goto fork_failed;
    }

    syscall_frame_t* frame=(syscall_frame_t*)(parent_task->tss.esp0-sizeof(syscall_frame_t));
   11921:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11924:	8b 80 5c 02 00 00    	mov    0x25c(%eax),%eax
   1192a:	83 e8 58             	sub    $0x58,%eax
   1192d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    int err=task_init(child_task,parent_task->name,0,frame->eip,frame->esp+sizeof(uint32_t)*SYSCALL_PARAM_COUNT);
   11930:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11933:	8b 40 50             	mov    0x50(%eax),%eax
   11936:	8d 48 14             	lea    0x14(%eax),%ecx
   11939:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1193c:	8b 40 34             	mov    0x34(%eax),%eax
   1193f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11942:	83 c2 20             	add    $0x20,%edx
   11945:	83 ec 0c             	sub    $0xc,%esp
   11948:	51                   	push   %ecx
   11949:	50                   	push   %eax
   1194a:	6a 00                	push   $0x0
   1194c:	52                   	push   %edx
   1194d:	ff 75 f0             	pushl  -0x10(%ebp)
   11950:	e8 ce f7 ff ff       	call   11123 <task_init>
   11955:	83 c4 20             	add    $0x20,%esp
   11958:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(err < 0){
   1195b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1195f:	0f 88 e3 00 00 00    	js     11a48 <sys_fork+0x147>
        goto fork_failed;
    }

    tss_t* tss=&child_task->tss;
   11965:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11968:	05 58 02 00 00       	add    $0x258,%eax
   1196d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tss->eax= 0;
   11970:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11973:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
    tss->ebx=frame->ebx;
   1197a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1197d:	8b 50 24             	mov    0x24(%eax),%edx
   11980:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11983:	89 50 34             	mov    %edx,0x34(%eax)
    tss->ecx=frame->ecx;
   11986:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11989:	8b 50 2c             	mov    0x2c(%eax),%edx
   1198c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1198f:	89 50 2c             	mov    %edx,0x2c(%eax)
    tss->edx=frame->edx;
   11992:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11995:	8b 50 28             	mov    0x28(%eax),%edx
   11998:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1199b:	89 50 30             	mov    %edx,0x30(%eax)
    tss->esi=frame->esi;
   1199e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119a1:	8b 50 18             	mov    0x18(%eax),%edx
   119a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119a7:	89 50 40             	mov    %edx,0x40(%eax)
    tss->edi=frame->edi;
   119aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119ad:	8b 50 14             	mov    0x14(%eax),%edx
   119b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119b3:	89 50 44             	mov    %edx,0x44(%eax)
    tss->ebp=frame->ebp;
   119b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119b9:	8b 50 1c             	mov    0x1c(%eax),%edx
   119bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119bf:	89 50 3c             	mov    %edx,0x3c(%eax)

    tss->cs=frame->cs;
   119c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119c5:	8b 50 38             	mov    0x38(%eax),%edx
   119c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119cb:	89 50 4c             	mov    %edx,0x4c(%eax)
    tss->ds=frame->ds;
   119ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119d1:	8b 50 10             	mov    0x10(%eax),%edx
   119d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119d7:	89 50 54             	mov    %edx,0x54(%eax)
    tss->es=frame->es;
   119da:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119dd:	8b 50 0c             	mov    0xc(%eax),%edx
   119e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119e3:	89 50 48             	mov    %edx,0x48(%eax)
    tss->fs=frame->fs;
   119e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119e9:	8b 50 08             	mov    0x8(%eax),%edx
   119ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119ef:	89 50 58             	mov    %edx,0x58(%eax)
    tss->gs=frame->gs;
   119f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119f5:	8b 50 04             	mov    0x4(%eax),%edx
   119f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   119fb:	89 50 5c             	mov    %edx,0x5c(%eax)
    tss->eflags=frame->eflags;
   119fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a01:	8b 10                	mov    (%eax),%edx
   11a03:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a06:	89 50 24             	mov    %edx,0x24(%eax)

    child_task->parent=parent_task;
   11a09:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a0f:	89 50 08             	mov    %edx,0x8(%eax)

    if((tss->cr3=memory_copy_uvm(parent_task->tss.cr3))<0){
   11a12:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a15:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   11a1b:	83 ec 0c             	sub    $0xc,%esp
   11a1e:	50                   	push   %eax
   11a1f:	e8 b5 f0 ff ff       	call   10ad9 <memory_copy_uvm>
   11a24:	83 c4 10             	add    $0x10,%esp
   11a27:	89 c2                	mov    %eax,%edx
   11a29:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a2c:	89 50 1c             	mov    %edx,0x1c(%eax)
        goto fork_failed;
    }

    task_start(child_task);
   11a2f:	83 ec 0c             	sub    $0xc,%esp
   11a32:	ff 75 f0             	pushl  -0x10(%ebp)
   11a35:	e8 42 f8 ff ff       	call   1127c <task_start>
   11a3a:	83 c4 10             	add    $0x10,%esp

    return child_task->pid;
   11a3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a40:	8b 40 04             	mov    0x4(%eax),%eax
   11a43:	eb 2b                	jmp    11a70 <sys_fork+0x16f>
        goto fork_failed;
   11a45:	90                   	nop
   11a46:	eb 01                	jmp    11a49 <sys_fork+0x148>
        goto fork_failed;
   11a48:	90                   	nop

fork_failed:
    if(child_task){
   11a49:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11a4d:	74 1c                	je     11a6b <sys_fork+0x16a>
        task_uninit(child_task);
   11a4f:	83 ec 0c             	sub    $0xc,%esp
   11a52:	ff 75 f0             	pushl  -0x10(%ebp)
   11a55:	e8 4f f8 ff ff       	call   112a9 <task_uninit>
   11a5a:	83 c4 10             	add    $0x10,%esp
        free_task(child_task);
   11a5d:	83 ec 0c             	sub    $0xc,%esp
   11a60:	ff 75 f0             	pushl  -0x10(%ebp)
   11a63:	e8 66 fe ff ff       	call   118ce <free_task>
   11a68:	83 c4 10             	add    $0x10,%esp
    }

    return -1;
   11a6b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11a70:	c9                   	leave  
   11a71:	c3                   	ret    

00011a72 <load_phdr>:

static int load_phdr(int file,Elf32_Phdr*phdr ,uint32_t page_dir){
   11a72:	55                   	push   %ebp
   11a73:	89 e5                	mov    %esp,%ebp
   11a75:	83 ec 28             	sub    $0x28,%esp
    int err=memory_alloc_for_page_dir(page_dir,phdr->p_vaddr,phdr->p_memsz,PTE_P|PTE_U|PTE_W);
   11a78:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a7b:	8b 50 14             	mov    0x14(%eax),%edx
   11a7e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a81:	8b 40 08             	mov    0x8(%eax),%eax
   11a84:	6a 07                	push   $0x7
   11a86:	52                   	push   %edx
   11a87:	50                   	push   %eax
   11a88:	ff 75 10             	pushl  0x10(%ebp)
   11a8b:	e8 bd ed ff ff       	call   1084d <memory_alloc_for_page_dir>
   11a90:	83 c4 10             	add    $0x10,%esp
   11a93:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(err < 0){
   11a96:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11a9a:	79 1a                	jns    11ab6 <load_phdr+0x44>
        log_printf("no memory");
   11a9c:	83 ec 0c             	sub    $0xc,%esp
   11a9f:	68 e9 5e 01 00       	push   $0x15ee9
   11aa4:	e8 d4 3f 00 00       	call   15a7d <log_printf>
   11aa9:	83 c4 10             	add    $0x10,%esp
        return -1;
   11aac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11ab1:	e9 b8 00 00 00       	jmp    11b6e <load_phdr+0xfc>
    }

    if(sys_lseek(file,phdr->p_offset,0)<0){
   11ab6:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ab9:	8b 40 04             	mov    0x4(%eax),%eax
   11abc:	83 ec 04             	sub    $0x4,%esp
   11abf:	6a 00                	push   $0x0
   11ac1:	50                   	push   %eax
   11ac2:	ff 75 08             	pushl  0x8(%ebp)
   11ac5:	e8 ef 30 00 00       	call   14bb9 <sys_lseek>
   11aca:	83 c4 10             	add    $0x10,%esp
   11acd:	85 c0                	test   %eax,%eax
   11acf:	79 1a                	jns    11aeb <load_phdr+0x79>
        log_printf("read file failed");
   11ad1:	83 ec 0c             	sub    $0xc,%esp
   11ad4:	68 f3 5e 01 00       	push   $0x15ef3
   11ad9:	e8 9f 3f 00 00       	call   15a7d <log_printf>
   11ade:	83 c4 10             	add    $0x10,%esp
        return -1;
   11ae1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11ae6:	e9 83 00 00 00       	jmp    11b6e <load_phdr+0xfc>
    }

    uint32_t vaddr=phdr->p_vaddr;
   11aeb:	8b 45 0c             	mov    0xc(%ebp),%eax
   11aee:	8b 40 08             	mov    0x8(%eax),%eax
   11af1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t size=phdr->p_filesz;
   11af4:	8b 45 0c             	mov    0xc(%ebp),%eax
   11af7:	8b 40 10             	mov    0x10(%eax),%eax
   11afa:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while(size > 0){
   11afd:	eb 64                	jmp    11b63 <load_phdr+0xf1>
        int curr_size=(size > MEM_PAGE_SIZE) ? MEM_PAGE_SIZE : size;
   11aff:	b8 00 10 00 00       	mov    $0x1000,%eax
   11b04:	81 7d f0 00 10 00 00 	cmpl   $0x1000,-0x10(%ebp)
   11b0b:	0f 46 45 f0          	cmovbe -0x10(%ebp),%eax
   11b0f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t paddr=memory_get_paddr(page_dir,vaddr);
   11b12:	83 ec 08             	sub    $0x8,%esp
   11b15:	ff 75 f4             	pushl  -0xc(%ebp)
   11b18:	ff 75 10             	pushl  0x10(%ebp)
   11b1b:	e8 0e f1 ff ff       	call   10c2e <memory_get_paddr>
   11b20:	83 c4 10             	add    $0x10,%esp
   11b23:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if(sys_read(file,(char*)paddr,curr_size)<curr_size){
   11b26:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b29:	83 ec 04             	sub    $0x4,%esp
   11b2c:	ff 75 e8             	pushl  -0x18(%ebp)
   11b2f:	50                   	push   %eax
   11b30:	ff 75 08             	pushl  0x8(%ebp)
   11b33:	e8 ad 2f 00 00       	call   14ae5 <sys_read>
   11b38:	83 c4 10             	add    $0x10,%esp
   11b3b:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   11b3e:	7e 17                	jle    11b57 <load_phdr+0xe5>
            log_printf("read file failed.");
   11b40:	83 ec 0c             	sub    $0xc,%esp
   11b43:	68 04 5f 01 00       	push   $0x15f04
   11b48:	e8 30 3f 00 00       	call   15a7d <log_printf>
   11b4d:	83 c4 10             	add    $0x10,%esp
            return -1;
   11b50:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11b55:	eb 17                	jmp    11b6e <load_phdr+0xfc>
        }

        size-=curr_size;
   11b57:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11b5a:	29 45 f0             	sub    %eax,-0x10(%ebp)
        vaddr+=curr_size;
   11b5d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11b60:	01 45 f4             	add    %eax,-0xc(%ebp)
    while(size > 0){
   11b63:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11b67:	75 96                	jne    11aff <load_phdr+0x8d>
    }

    return 0;
   11b69:	b8 00 00 00 00       	mov    $0x0,%eax

}
   11b6e:	c9                   	leave  
   11b6f:	c3                   	ret    

00011b70 <load_elf_file>:

static uint32_t load_elf_file(task_t* task,const char* name,uint32_t page_dir){
   11b70:	55                   	push   %ebp
   11b71:	89 e5                	mov    %esp,%ebp
   11b73:	83 ec 78             	sub    $0x78,%esp
    Elf32_Ehdr elf_hdr;
    Elf32_Phdr elf_phdr;

    int file=sys_open(name,0);
   11b76:	83 ec 08             	sub    $0x8,%esp
   11b79:	6a 00                	push   $0x0
   11b7b:	ff 75 0c             	pushl  0xc(%ebp)
   11b7e:	e8 02 2e 00 00       	call   14985 <sys_open>
   11b83:	83 c4 10             	add    $0x10,%esp
   11b86:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(file<0){
   11b89:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11b8d:	79 18                	jns    11ba7 <load_elf_file+0x37>
        log_printf("open failed. %s",name);
   11b8f:	83 ec 08             	sub    $0x8,%esp
   11b92:	ff 75 0c             	pushl  0xc(%ebp)
   11b95:	68 16 5f 01 00       	push   $0x15f16
   11b9a:	e8 de 3e 00 00       	call   15a7d <log_printf>
   11b9f:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11ba2:	e9 6c 01 00 00       	jmp    11d13 <load_elf_file+0x1a3>
    }

    int cnt=sys_read(file,(char*)&elf_hdr,sizeof(elf_hdr));
   11ba7:	83 ec 04             	sub    $0x4,%esp
   11baa:	6a 34                	push   $0x34
   11bac:	8d 45 b0             	lea    -0x50(%ebp),%eax
   11baf:	50                   	push   %eax
   11bb0:	ff 75 ec             	pushl  -0x14(%ebp)
   11bb3:	e8 2d 2f 00 00       	call   14ae5 <sys_read>
   11bb8:	83 c4 10             	add    $0x10,%esp
   11bbb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(cnt<sizeof(Elf32_Ehdr)){
   11bbe:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11bc1:	83 f8 33             	cmp    $0x33,%eax
   11bc4:	77 18                	ja     11bde <load_elf_file+0x6e>
        log_printf("elf hdr too small. size=%d",cnt);
   11bc6:	83 ec 08             	sub    $0x8,%esp
   11bc9:	ff 75 e8             	pushl  -0x18(%ebp)
   11bcc:	68 26 5f 01 00       	push   $0x15f26
   11bd1:	e8 a7 3e 00 00       	call   15a7d <log_printf>
   11bd6:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   11bd9:	e9 35 01 00 00       	jmp    11d13 <load_elf_file+0x1a3>
    }

    if((elf_hdr.e_ident[0]!=0x7f)||(elf_hdr.e_ident[1]!='E')
   11bde:	0f b6 45 b0          	movzbl -0x50(%ebp),%eax
   11be2:	3c 7f                	cmp    $0x7f,%al
   11be4:	75 18                	jne    11bfe <load_elf_file+0x8e>
   11be6:	0f b6 45 b1          	movzbl -0x4f(%ebp),%eax
   11bea:	3c 45                	cmp    $0x45,%al
   11bec:	75 10                	jne    11bfe <load_elf_file+0x8e>
		|| (elf_hdr.e_ident[2]!='L')||(elf_hdr.e_ident[3]!='F')){
   11bee:	0f b6 45 b2          	movzbl -0x4e(%ebp),%eax
   11bf2:	3c 4c                	cmp    $0x4c,%al
   11bf4:	75 08                	jne    11bfe <load_elf_file+0x8e>
   11bf6:	0f b6 45 b3          	movzbl -0x4d(%ebp),%eax
   11bfa:	3c 46                	cmp    $0x46,%al
   11bfc:	74 15                	je     11c13 <load_elf_file+0xa3>
            log_printf("check elf ident failed.");
   11bfe:	83 ec 0c             	sub    $0xc,%esp
   11c01:	68 41 5f 01 00       	push   $0x15f41
   11c06:	e8 72 3e 00 00       	call   15a7d <log_printf>
   11c0b:	83 c4 10             	add    $0x10,%esp
			goto load_failed;
   11c0e:	e9 00 01 00 00       	jmp    11d13 <load_elf_file+0x1a3>
	}

    uint32_t e_phoff=elf_hdr.e_phoff;
   11c13:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11c16:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(int i=0;i<elf_hdr.e_phnum;i++,e_phoff+=elf_hdr.e_phentsize){
   11c19:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11c20:	e9 cb 00 00 00       	jmp    11cf0 <load_elf_file+0x180>
        if(sys_lseek(file,e_phoff,0)<0){
   11c25:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c28:	83 ec 04             	sub    $0x4,%esp
   11c2b:	6a 00                	push   $0x0
   11c2d:	50                   	push   %eax
   11c2e:	ff 75 ec             	pushl  -0x14(%ebp)
   11c31:	e8 83 2f 00 00       	call   14bb9 <sys_lseek>
   11c36:	83 c4 10             	add    $0x10,%esp
   11c39:	85 c0                	test   %eax,%eax
   11c3b:	79 15                	jns    11c52 <load_elf_file+0xe2>
            log_printf("read file failed.");
   11c3d:	83 ec 0c             	sub    $0xc,%esp
   11c40:	68 04 5f 01 00       	push   $0x15f04
   11c45:	e8 33 3e 00 00       	call   15a7d <log_printf>
   11c4a:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11c4d:	e9 c1 00 00 00       	jmp    11d13 <load_elf_file+0x1a3>
        }

        cnt=sys_read(file,(char*)&elf_phdr,sizeof(elf_phdr));
   11c52:	83 ec 04             	sub    $0x4,%esp
   11c55:	6a 20                	push   $0x20
   11c57:	8d 45 90             	lea    -0x70(%ebp),%eax
   11c5a:	50                   	push   %eax
   11c5b:	ff 75 ec             	pushl  -0x14(%ebp)
   11c5e:	e8 82 2e 00 00       	call   14ae5 <sys_read>
   11c63:	83 c4 10             	add    $0x10,%esp
   11c66:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(cnt<sizeof(elf_phdr)){
   11c69:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11c6c:	83 f8 1f             	cmp    $0x1f,%eax
   11c6f:	77 15                	ja     11c86 <load_elf_file+0x116>
            log_printf("read file failed.");
   11c71:	83 ec 0c             	sub    $0xc,%esp
   11c74:	68 04 5f 01 00       	push   $0x15f04
   11c79:	e8 ff 3d 00 00       	call   15a7d <log_printf>
   11c7e:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11c81:	e9 8d 00 00 00       	jmp    11d13 <load_elf_file+0x1a3>
        }

        if((elf_phdr.p_type!=1)|| (elf_phdr.p_vaddr<MEMORY_TASK_BASE)){
   11c86:	8b 45 90             	mov    -0x70(%ebp),%eax
   11c89:	83 f8 01             	cmp    $0x1,%eax
   11c8c:	75 53                	jne    11ce1 <load_elf_file+0x171>
   11c8e:	8b 45 98             	mov    -0x68(%ebp),%eax
   11c91:	85 c0                	test   %eax,%eax
   11c93:	79 4c                	jns    11ce1 <load_elf_file+0x171>
            continue;
        }

        int err=load_phdr(file,&elf_phdr,page_dir);
   11c95:	83 ec 04             	sub    $0x4,%esp
   11c98:	ff 75 10             	pushl  0x10(%ebp)
   11c9b:	8d 45 90             	lea    -0x70(%ebp),%eax
   11c9e:	50                   	push   %eax
   11c9f:	ff 75 ec             	pushl  -0x14(%ebp)
   11ca2:	e8 cb fd ff ff       	call   11a72 <load_phdr>
   11ca7:	83 c4 10             	add    $0x10,%esp
   11caa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(err<0){
   11cad:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   11cb1:	79 12                	jns    11cc5 <load_elf_file+0x155>
            log_printf("load program failed.");
   11cb3:	83 ec 0c             	sub    $0xc,%esp
   11cb6:	68 59 5f 01 00       	push   $0x15f59
   11cbb:	e8 bd 3d 00 00       	call   15a7d <log_printf>
   11cc0:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   11cc3:	eb 4e                	jmp    11d13 <load_elf_file+0x1a3>
        }

        task->heap_start=elf_phdr.p_vaddr+elf_phdr.p_memsz;
   11cc5:	8b 55 98             	mov    -0x68(%ebp),%edx
   11cc8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
   11ccb:	01 c2                	add    %eax,%edx
   11ccd:	8b 45 08             	mov    0x8(%ebp),%eax
   11cd0:	89 50 0c             	mov    %edx,0xc(%eax)
        task->heap_end=task->heap_start;
   11cd3:	8b 45 08             	mov    0x8(%ebp),%eax
   11cd6:	8b 50 0c             	mov    0xc(%eax),%edx
   11cd9:	8b 45 08             	mov    0x8(%ebp),%eax
   11cdc:	89 50 10             	mov    %edx,0x10(%eax)
   11cdf:	eb 01                	jmp    11ce2 <load_elf_file+0x172>
            continue;
   11ce1:	90                   	nop
    for(int i=0;i<elf_hdr.e_phnum;i++,e_phoff+=elf_hdr.e_phentsize){
   11ce2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11ce6:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
   11cea:	0f b7 c0             	movzwl %ax,%eax
   11ced:	01 45 f4             	add    %eax,-0xc(%ebp)
   11cf0:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
   11cf4:	0f b7 c0             	movzwl %ax,%eax
   11cf7:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11cfa:	0f 8c 25 ff ff ff    	jl     11c25 <load_elf_file+0xb5>
    }


    sys_close(file);
   11d00:	83 ec 0c             	sub    $0xc,%esp
   11d03:	ff 75 ec             	pushl  -0x14(%ebp)
   11d06:	e8 d2 2e 00 00       	call   14bdd <sys_close>
   11d0b:	83 c4 10             	add    $0x10,%esp
    return elf_hdr.e_entry;
   11d0e:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11d11:	eb 19                	jmp    11d2c <load_elf_file+0x1bc>

load_failed:
    if(file){
   11d13:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11d17:	74 0e                	je     11d27 <load_elf_file+0x1b7>
        sys_close(file);
   11d19:	83 ec 0c             	sub    $0xc,%esp
   11d1c:	ff 75 ec             	pushl  -0x14(%ebp)
   11d1f:	e8 b9 2e 00 00       	call   14bdd <sys_close>
   11d24:	83 c4 10             	add    $0x10,%esp
    }
    return 0;
   11d27:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11d2c:	c9                   	leave  
   11d2d:	c3                   	ret    

00011d2e <copy_args>:

static int copy_args(char* to,uint32_t page_dir,int argc,char**argv){
   11d2e:	55                   	push   %ebp
   11d2f:	89 e5                	mov    %esp,%ebp
   11d31:	83 ec 38             	sub    $0x38,%esp
    task_args_t task_args;
    task_args.argc=argc;
   11d34:	8b 45 10             	mov    0x10(%ebp),%eax
   11d37:	89 45 d8             	mov    %eax,-0x28(%ebp)
    task_args.argv=(char**)(to+sizeof(task_args_t));
   11d3a:	8b 45 08             	mov    0x8(%ebp),%eax
   11d3d:	83 c0 0c             	add    $0xc,%eax
   11d40:	89 45 dc             	mov    %eax,-0x24(%ebp)

    char* dest_arg=to+sizeof(task_args_t)+sizeof(char*)*argc;
   11d43:	8b 45 10             	mov    0x10(%ebp),%eax
   11d46:	83 c0 03             	add    $0x3,%eax
   11d49:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11d50:	8b 45 08             	mov    0x8(%ebp),%eax
   11d53:	01 d0                	add    %edx,%eax
   11d55:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char** dest_arg_tb=(char**)memory_get_paddr(page_dir,(uint32_t)(to+sizeof(task_args_t)));
   11d58:	8b 45 08             	mov    0x8(%ebp),%eax
   11d5b:	83 c0 0c             	add    $0xc,%eax
   11d5e:	83 ec 08             	sub    $0x8,%esp
   11d61:	50                   	push   %eax
   11d62:	ff 75 0c             	pushl  0xc(%ebp)
   11d65:	e8 c4 ee ff ff       	call   10c2e <memory_get_paddr>
   11d6a:	83 c4 10             	add    $0x10,%esp
   11d6d:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for(int i=0;i<argc;i++){
   11d70:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d77:	e9 82 00 00 00       	jmp    11dfe <copy_args+0xd0>
        char* from=argv[i];
   11d7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d7f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11d86:	8b 45 14             	mov    0x14(%ebp),%eax
   11d89:	01 d0                	add    %edx,%eax
   11d8b:	8b 00                	mov    (%eax),%eax
   11d8d:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int len=kernel_strlen(from)+1;
   11d90:	83 ec 0c             	sub    $0xc,%esp
   11d93:	ff 75 e8             	pushl  -0x18(%ebp)
   11d96:	e8 35 36 00 00       	call   153d0 <kernel_strlen>
   11d9b:	83 c4 10             	add    $0x10,%esp
   11d9e:	83 c0 01             	add    $0x1,%eax
   11da1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int err=memory_copy_uvm_data((uint32_t)dest_arg,page_dir,(uint32_t)from,len);
   11da4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   11da7:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11daa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11dad:	51                   	push   %ecx
   11dae:	52                   	push   %edx
   11daf:	ff 75 0c             	pushl  0xc(%ebp)
   11db2:	50                   	push   %eax
   11db3:	e8 bc ee ff ff       	call   10c74 <memory_copy_uvm_data>
   11db8:	83 c4 10             	add    $0x10,%esp
   11dbb:	89 45 e0             	mov    %eax,-0x20(%ebp)
        ASSERT(err >= 0);
   11dbe:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11dc2:	79 1c                	jns    11de0 <copy_args+0xb2>
   11dc4:	68 6e 5f 01 00       	push   $0x15f6e
   11dc9:	68 94 5f 01 00       	push   $0x15f94
   11dce:	68 fb 01 00 00       	push   $0x1fb
   11dd3:	68 78 5e 01 00       	push   $0x15e78
   11dd8:	e8 d0 39 00 00       	call   157ad <panic>
   11ddd:	83 c4 10             	add    $0x10,%esp

        dest_arg_tb[i]=dest_arg;
   11de0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11de3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11dea:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11ded:	01 c2                	add    %eax,%edx
   11def:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11df2:	89 02                	mov    %eax,(%edx)
        dest_arg+=len;
   11df4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11df7:	01 45 f4             	add    %eax,-0xc(%ebp)
    for(int i=0;i<argc;i++){
   11dfa:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e01:	3b 45 10             	cmp    0x10(%ebp),%eax
   11e04:	0f 8c 72 ff ff ff    	jl     11d7c <copy_args+0x4e>

    }
    return memory_copy_uvm_data((uint32_t)to,page_dir,(uint32_t)&task_args,sizeof(task_args));
   11e0a:	8d 55 d4             	lea    -0x2c(%ebp),%edx
   11e0d:	8b 45 08             	mov    0x8(%ebp),%eax
   11e10:	6a 0c                	push   $0xc
   11e12:	52                   	push   %edx
   11e13:	ff 75 0c             	pushl  0xc(%ebp)
   11e16:	50                   	push   %eax
   11e17:	e8 58 ee ff ff       	call   10c74 <memory_copy_uvm_data>
   11e1c:	83 c4 10             	add    $0x10,%esp

}
   11e1f:	c9                   	leave  
   11e20:	c3                   	ret    

00011e21 <sys_execve>:

int sys_execve(char* name,char** argv,char** env){
   11e21:	55                   	push   %ebp
   11e22:	89 e5                	mov    %esp,%ebp
   11e24:	83 ec 28             	sub    $0x28,%esp
    task_t* task=task_current();
   11e27:	e8 b0 f7 ff ff       	call   115dc <task_current>
   11e2c:	89 45 f4             	mov    %eax,-0xc(%ebp)

    kernel_strncpy(task->name,get_file_name(name),TASK_NAME_SIZE);
   11e2f:	83 ec 0c             	sub    $0xc,%esp
   11e32:	ff 75 08             	pushl  0x8(%ebp)
   11e35:	e8 d6 39 00 00       	call   15810 <get_file_name>
   11e3a:	83 c4 10             	add    $0x10,%esp
   11e3d:	89 c2                	mov    %eax,%edx
   11e3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e42:	83 c0 20             	add    $0x20,%eax
   11e45:	83 ec 04             	sub    $0x4,%esp
   11e48:	6a 20                	push   $0x20
   11e4a:	52                   	push   %edx
   11e4b:	50                   	push   %eax
   11e4c:	e8 95 34 00 00       	call   152e6 <kernel_strncpy>
   11e51:	83 c4 10             	add    $0x10,%esp

    uint32_t old_page_dir=task->tss.cr3;
   11e54:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e57:	8b 80 74 02 00 00    	mov    0x274(%eax),%eax
   11e5d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t new_page_dir=memory_create_uvm();
   11e60:	e8 63 e9 ff ff       	call   107c8 <memory_create_uvm>
   11e65:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(!new_page_dir){
   11e68:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11e6c:	0f 84 1f 01 00 00    	je     11f91 <sys_execve+0x170>
        goto exec_failed;
    }

    uint32_t entry=load_elf_file(task,name,new_page_dir);
   11e72:	83 ec 04             	sub    $0x4,%esp
   11e75:	ff 75 ec             	pushl  -0x14(%ebp)
   11e78:	ff 75 08             	pushl  0x8(%ebp)
   11e7b:	ff 75 f4             	pushl  -0xc(%ebp)
   11e7e:	e8 ed fc ff ff       	call   11b70 <load_elf_file>
   11e83:	83 c4 10             	add    $0x10,%esp
   11e86:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if(entry==0){
   11e89:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11e8d:	0f 84 01 01 00 00    	je     11f94 <sys_execve+0x173>
        goto exec_failed;
    }

    uint32_t stack_top=MEM_TASK_STACK_TOP-MEM_TASK_ARG_SIZE;
   11e93:	c7 45 e4 00 c0 ff df 	movl   $0xdfffc000,-0x1c(%ebp)

    int err=memory_alloc_for_page_dir(new_page_dir,
   11e9a:	6a 07                	push   $0x7
   11e9c:	68 00 40 1f 00       	push   $0x1f4000
   11ea1:	68 00 c0 e0 df       	push   $0xdfe0c000
   11ea6:	ff 75 ec             	pushl  -0x14(%ebp)
   11ea9:	e8 9f e9 ff ff       	call   1084d <memory_alloc_for_page_dir>
   11eae:	83 c4 10             	add    $0x10,%esp
   11eb1:	89 45 e0             	mov    %eax,-0x20(%ebp)
        MEM_TASK_STACK_TOP-MEM_TASK_STACK_SIZE,MEM_TASK_STACK_SIZE,
        PTE_P | PTE_U | PTE_W
    );

    if(err < 0){
   11eb4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11eb8:	0f 88 d9 00 00 00    	js     11f97 <sys_execve+0x176>
        goto exec_failed;
    }
    
    int argc=string_count(argv);
   11ebe:	83 ec 0c             	sub    $0xc,%esp
   11ec1:	ff 75 0c             	pushl  0xc(%ebp)
   11ec4:	e8 1a 39 00 00       	call   157e3 <string_count>
   11ec9:	83 c4 10             	add    $0x10,%esp
   11ecc:	89 45 dc             	mov    %eax,-0x24(%ebp)
    err=copy_args((char*)stack_top,new_page_dir,argc,argv);
   11ecf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11ed2:	ff 75 0c             	pushl  0xc(%ebp)
   11ed5:	ff 75 dc             	pushl  -0x24(%ebp)
   11ed8:	ff 75 ec             	pushl  -0x14(%ebp)
   11edb:	50                   	push   %eax
   11edc:	e8 4d fe ff ff       	call   11d2e <copy_args>
   11ee1:	83 c4 10             	add    $0x10,%esp
   11ee4:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(err<0){
   11ee7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11eeb:	0f 88 a9 00 00 00    	js     11f9a <sys_execve+0x179>
        goto exec_failed;
    }

    syscall_frame_t* frame=(syscall_frame_t*)(task->tss.esp0-sizeof(syscall_frame_t));
   11ef1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ef4:	8b 80 5c 02 00 00    	mov    0x25c(%eax),%eax
   11efa:	83 e8 58             	sub    $0x58,%eax
   11efd:	89 45 d8             	mov    %eax,-0x28(%ebp)
    frame->eip=entry;
   11f00:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f03:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11f06:	89 50 34             	mov    %edx,0x34(%eax)
    frame->eax=frame->ebx=frame->edx=0;
   11f09:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f0c:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
   11f13:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f16:	8b 50 28             	mov    0x28(%eax),%edx
   11f19:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f1c:	89 50 24             	mov    %edx,0x24(%eax)
   11f1f:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f22:	8b 50 24             	mov    0x24(%eax),%edx
   11f25:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f28:	89 50 30             	mov    %edx,0x30(%eax)
    frame->esi=frame->edi=frame->ebp=0;
   11f2b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f2e:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
   11f35:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f38:	8b 50 1c             	mov    0x1c(%eax),%edx
   11f3b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f3e:	89 50 14             	mov    %edx,0x14(%eax)
   11f41:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f44:	8b 50 14             	mov    0x14(%eax),%edx
   11f47:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f4a:	89 50 18             	mov    %edx,0x18(%eax)
    frame->eflags=EFLAGS_DEFAULT|EFLAGS_IF;
   11f4d:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f50:	c7 00 02 02 00 00    	movl   $0x202,(%eax)

    frame->esp=stack_top-sizeof(uint32_t)*SYSCALL_PARAM_COUNT;
   11f56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11f59:	8d 50 ec             	lea    -0x14(%eax),%edx
   11f5c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f5f:	89 50 50             	mov    %edx,0x50(%eax)

    task->tss.cr3=new_page_dir;
   11f62:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f65:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11f68:	89 90 74 02 00 00    	mov    %edx,0x274(%eax)
    mmu_set_page_dir(new_page_dir);
   11f6e:	83 ec 0c             	sub    $0xc,%esp
   11f71:	ff 75 ec             	pushl  -0x14(%ebp)
   11f74:	e8 d1 ef ff ff       	call   10f4a <mmu_set_page_dir>
   11f79:	83 c4 10             	add    $0x10,%esp

    memory_destroy_uvm(old_page_dir);
   11f7c:	83 ec 0c             	sub    $0xc,%esp
   11f7f:	ff 75 f0             	pushl  -0x10(%ebp)
   11f82:	e8 6b ea ff ff       	call   109f2 <memory_destroy_uvm>
   11f87:	83 c4 10             	add    $0x10,%esp

    return 0;
   11f8a:	b8 00 00 00 00       	mov    $0x0,%eax
   11f8f:	eb 3d                	jmp    11fce <sys_execve+0x1ad>
        goto exec_failed;
   11f91:	90                   	nop
   11f92:	eb 07                	jmp    11f9b <sys_execve+0x17a>
        goto exec_failed;
   11f94:	90                   	nop
   11f95:	eb 04                	jmp    11f9b <sys_execve+0x17a>
        goto exec_failed;
   11f97:	90                   	nop
   11f98:	eb 01                	jmp    11f9b <sys_execve+0x17a>
        goto exec_failed;
   11f9a:	90                   	nop

exec_failed:
    if(new_page_dir){
   11f9b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11f9f:	74 28                	je     11fc9 <sys_execve+0x1a8>
        task->tss.cr3=old_page_dir;
   11fa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11fa4:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11fa7:	89 90 74 02 00 00    	mov    %edx,0x274(%eax)
        mmu_set_page_dir(old_page_dir);
   11fad:	83 ec 0c             	sub    $0xc,%esp
   11fb0:	ff 75 f0             	pushl  -0x10(%ebp)
   11fb3:	e8 92 ef ff ff       	call   10f4a <mmu_set_page_dir>
   11fb8:	83 c4 10             	add    $0x10,%esp

        memory_destroy_uvm(new_page_dir);
   11fbb:	83 ec 0c             	sub    $0xc,%esp
   11fbe:	ff 75 ec             	pushl  -0x14(%ebp)
   11fc1:	e8 2c ea ff ff       	call   109f2 <memory_destroy_uvm>
   11fc6:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   11fc9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11fce:	c9                   	leave  
   11fcf:	c3                   	ret    

00011fd0 <task_file>:
/**
 * @brief 获取文件描述符对应的文件
 * @param fd 文件描述符
 * @return 获取成功返回对应的文件指针，不成功返回NULL
 */
file_t* task_file(int fd){
   11fd0:	55                   	push   %ebp
   11fd1:	89 e5                	mov    %esp,%ebp
   11fd3:	83 ec 10             	sub    $0x10,%esp
    if((fd>=0) && (fd<TASK_OFILE_NR)){
   11fd6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11fda:	78 1e                	js     11ffa <task_file+0x2a>
   11fdc:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   11fe0:	7f 18                	jg     11ffa <task_file+0x2a>
        file_t* file=task_current()->file_table[fd];
   11fe2:	e8 f5 f5 ff ff       	call   115dc <task_current>
   11fe7:	89 c2                	mov    %eax,%edx
   11fe9:	8b 45 08             	mov    0x8(%ebp),%eax
   11fec:	83 c0 10             	add    $0x10,%eax
   11fef:	8b 04 82             	mov    (%edx,%eax,4),%eax
   11ff2:	89 45 fc             	mov    %eax,-0x4(%ebp)
        return file;
   11ff5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11ff8:	eb 05                	jmp    11fff <task_file+0x2f>
    }

    return (file_t*)0;
   11ffa:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11fff:	c9                   	leave  
   12000:	c3                   	ret    

00012001 <task_alloc_fd>:
/**
 * @brief 给文件分配描述符
 * @param file 指向一个文件的指针
 * @return 如果分配成功返回对应的fd如果分配失败返回-1
 */
int task_alloc_fd(file_t* file){
   12001:	55                   	push   %ebp
   12002:	89 e5                	mov    %esp,%ebp
   12004:	83 ec 10             	sub    $0x10,%esp
    task_t* task=task_current();
   12007:	e8 d0 f5 ff ff       	call   115dc <task_current>
   1200c:	89 45 f8             	mov    %eax,-0x8(%ebp)

    for(int i=0;i<TASK_OFILE_NR;i++){
   1200f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12016:	eb 2d                	jmp    12045 <task_alloc_fd+0x44>
        file_t* p=task->file_table[i];
   12018:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1201b:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1201e:	83 c2 10             	add    $0x10,%edx
   12021:	8b 04 90             	mov    (%eax,%edx,4),%eax
   12024:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(p==(file_t*)0){
   12027:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1202b:	75 14                	jne    12041 <task_alloc_fd+0x40>
            task->file_table[i]=file;
   1202d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12030:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12033:	8d 4a 10             	lea    0x10(%edx),%ecx
   12036:	8b 55 08             	mov    0x8(%ebp),%edx
   12039:	89 14 88             	mov    %edx,(%eax,%ecx,4)
            return i;
   1203c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1203f:	eb 0f                	jmp    12050 <task_alloc_fd+0x4f>
    for(int i=0;i<TASK_OFILE_NR;i++){
   12041:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12045:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%ebp)
   12049:	7e cd                	jle    12018 <task_alloc_fd+0x17>
        }
    }

    return -1;
   1204b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   12050:	c9                   	leave  
   12051:	c3                   	ret    

00012052 <task_remove_fd>:

/**
 * @brief 释放一个文件描述符
 * @param fd 要释放的文件描述符
 */
void task_remove_fd(int fd){
   12052:	55                   	push   %ebp
   12053:	89 e5                	mov    %esp,%ebp
   if((fd>=0) && (fd<TASK_OFILE_NR)){
   12055:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   12059:	78 1a                	js     12075 <task_remove_fd+0x23>
   1205b:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   1205f:	7f 14                	jg     12075 <task_remove_fd+0x23>
       task_current()->file_table[fd]=(file_t*)0;
   12061:	e8 76 f5 ff ff       	call   115dc <task_current>
   12066:	89 c2                	mov    %eax,%edx
   12068:	8b 45 08             	mov    0x8(%ebp),%eax
   1206b:	83 c0 10             	add    $0x10,%eax
   1206e:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
    }
}
   12075:	90                   	nop
   12076:	5d                   	pop    %ebp
   12077:	c3                   	ret    

00012078 <sys_exit>:

void sys_exit(int status){
   12078:	55                   	push   %ebp
   12079:	89 e5                	mov    %esp,%ebp
   1207b:	83 ec 28             	sub    $0x28,%esp
    task_t* curr_task=task_current();
   1207e:	e8 59 f5 ff ff       	call   115dc <task_current>
   12083:	89 45 e8             	mov    %eax,-0x18(%ebp)

    for(int fd=0;fd<TASK_OFILE_NR;fd++){
   12086:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1208d:	eb 37                	jmp    120c6 <sys_exit+0x4e>
        file_t* file=curr_task->file_table[fd];
   1208f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12092:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12095:	83 c2 10             	add    $0x10,%edx
   12098:	8b 04 90             	mov    (%eax,%edx,4),%eax
   1209b:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(file){
   1209e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   120a2:	74 1e                	je     120c2 <sys_exit+0x4a>
            sys_close(fd);
   120a4:	83 ec 0c             	sub    $0xc,%esp
   120a7:	ff 75 f4             	pushl  -0xc(%ebp)
   120aa:	e8 2e 2b 00 00       	call   14bdd <sys_close>
   120af:	83 c4 10             	add    $0x10,%esp
            curr_task->file_table[fd]=(file_t*)0;
   120b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   120b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   120b8:	83 c2 10             	add    $0x10,%edx
   120bb:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
    for(int fd=0;fd<TASK_OFILE_NR;fd++){
   120c2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   120c6:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   120ca:	7e c3                	jle    1208f <sys_exit+0x17>
        }
    }

    int move_child=0;
   120cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    mutex_lock(&table_mutex);
   120d3:	83 ec 0c             	sub    $0xc,%esp
   120d6:	68 c0 19 03 00       	push   $0x319c0
   120db:	e8 b0 2c 00 00       	call   14d90 <mutex_lock>
   120e0:	83 c4 10             	add    $0x10,%esp

    for(int i=0;i<TASK_NR;i++){
   120e3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   120ea:	eb 3b                	jmp    12127 <sys_exit+0xaf>
        task_t* task=task_table+i;
   120ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
   120ef:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   120f5:	05 c0 b5 01 00       	add    $0x1b5c0,%eax
   120fa:	89 45 dc             	mov    %eax,-0x24(%ebp)
        if(task->parent==curr_task){
   120fd:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12100:	8b 40 08             	mov    0x8(%eax),%eax
   12103:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   12106:	75 1b                	jne    12123 <sys_exit+0xab>
            task->parent=&task_manager.first_task;
   12108:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1210b:	c7 40 08 28 a0 01 00 	movl   $0x1a028,0x8(%eax)
            if(task->state==TASK_ZOMBIE){
   12112:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12115:	8b 00                	mov    (%eax),%eax
   12117:	83 f8 05             	cmp    $0x5,%eax
   1211a:	75 07                	jne    12123 <sys_exit+0xab>
                move_child=1;  
   1211c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    for(int i=0;i<TASK_NR;i++){
   12123:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12127:	83 7d ec 7f          	cmpl   $0x7f,-0x14(%ebp)
   1212b:	7e bf                	jle    120ec <sys_exit+0x74>
            }
        }
    }

    mutex_unlock(&table_mutex);
   1212d:	83 ec 0c             	sub    $0xc,%esp
   12130:	68 c0 19 03 00       	push   $0x319c0
   12135:	e8 e5 2c 00 00       	call   14e1f <mutex_unlock>
   1213a:	83 c4 10             	add    $0x10,%esp

    irq_state_t state=irq_enter_protection();
   1213d:	e8 1c 0d 00 00       	call   12e5e <irq_enter_protection>
   12142:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    task_t* parent=curr_task->parent;
   12145:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12148:	8b 40 08             	mov    0x8(%eax),%eax
   1214b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(move_child && (parent!=&task_manager.first_task)){
   1214e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   12152:	74 23                	je     12177 <sys_exit+0xff>
   12154:	81 7d e0 28 a0 01 00 	cmpl   $0x1a028,-0x20(%ebp)
   1215b:	74 1a                	je     12177 <sys_exit+0xff>
        if(task_manager.first_task.state==TASK_WAITING){
   1215d:	a1 28 a0 01 00       	mov    0x1a028,%eax
   12162:	83 f8 04             	cmp    $0x4,%eax
   12165:	75 10                	jne    12177 <sys_exit+0xff>
            task_set_ready(&task_manager.first_task);
   12167:	83 ec 0c             	sub    $0xc,%esp
   1216a:	68 28 a0 01 00       	push   $0x1a028
   1216f:	e8 c0 f3 ff ff       	call   11534 <task_set_ready>
   12174:	83 c4 10             	add    $0x10,%esp
        }
    }

    if(parent->state==TASK_WAITING){
   12177:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1217a:	8b 00                	mov    (%eax),%eax
   1217c:	83 f8 04             	cmp    $0x4,%eax
   1217f:	75 12                	jne    12193 <sys_exit+0x11b>
        task_set_ready(curr_task->parent);
   12181:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12184:	8b 40 08             	mov    0x8(%eax),%eax
   12187:	83 ec 0c             	sub    $0xc,%esp
   1218a:	50                   	push   %eax
   1218b:	e8 a4 f3 ff ff       	call   11534 <task_set_ready>
   12190:	83 c4 10             	add    $0x10,%esp
    }

    curr_task->status=status;
   12193:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12196:	8b 55 08             	mov    0x8(%ebp),%edx
   12199:	89 90 c4 02 00 00    	mov    %edx,0x2c4(%eax)
    curr_task->state=TASK_ZOMBIE;
   1219f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   121a2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    task_set_block(curr_task);
   121a8:	83 ec 0c             	sub    $0xc,%esp
   121ab:	ff 75 e8             	pushl  -0x18(%ebp)
   121ae:	e8 b7 f3 ff ff       	call   1156a <task_set_block>
   121b3:	83 c4 10             	add    $0x10,%esp

    irq_leave_protection(state);
   121b6:	83 ec 0c             	sub    $0xc,%esp
   121b9:	ff 75 e4             	pushl  -0x1c(%ebp)
   121bc:	e8 b5 0c 00 00       	call   12e76 <irq_leave_protection>
   121c1:	83 c4 10             	add    $0x10,%esp
    
    task_dispatch();
   121c4:	e8 7e f4 ff ff       	call   11647 <task_dispatch>


}
   121c9:	90                   	nop
   121ca:	c9                   	leave  
   121cb:	c3                   	ret    

000121cc <sys_wait>:
/**
 * @brief 等待子进程结束
 * @param status 退出状态码
 * @return 返回子进程的pid
 */
int sys_wait(int* status){
   121cc:	55                   	push   %ebp
   121cd:	89 e5                	mov    %esp,%ebp
   121cf:	83 ec 28             	sub    $0x28,%esp
    task_t* curr_task=task_current();
   121d2:	e8 05 f4 ff ff       	call   115dc <task_current>
   121d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(;;){
        mutex_lock(&table_mutex);
   121da:	83 ec 0c             	sub    $0xc,%esp
   121dd:	68 c0 19 03 00       	push   $0x319c0
   121e2:	e8 a9 2b 00 00       	call   14d90 <mutex_lock>
   121e7:	83 c4 10             	add    $0x10,%esp

        for(int i=0;i<TASK_NR;i++){
   121ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   121f1:	eb 7a                	jmp    1226d <sys_wait+0xa1>
            task_t* task=task_table+i;
   121f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   121f6:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   121fc:	05 c0 b5 01 00       	add    $0x1b5c0,%eax
   12201:	89 45 e8             	mov    %eax,-0x18(%ebp)
            if(task->parent != curr_task){
   12204:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12207:	8b 40 08             	mov    0x8(%eax),%eax
   1220a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1220d:	75 59                	jne    12268 <sys_wait+0x9c>
                continue;
            }    

            if(task->state==TASK_ZOMBIE){
   1220f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12212:	8b 00                	mov    (%eax),%eax
   12214:	83 f8 05             	cmp    $0x5,%eax
   12217:	75 50                	jne    12269 <sys_wait+0x9d>
                int pid=task->pid;
   12219:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1221c:	8b 40 04             	mov    0x4(%eax),%eax
   1221f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                *status=task->status;
   12222:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12225:	8b 90 c4 02 00 00    	mov    0x2c4(%eax),%edx
   1222b:	8b 45 08             	mov    0x8(%ebp),%eax
   1222e:	89 10                	mov    %edx,(%eax)
                
                task_uninit(task);
   12230:	83 ec 0c             	sub    $0xc,%esp
   12233:	ff 75 e8             	pushl  -0x18(%ebp)
   12236:	e8 6e f0 ff ff       	call   112a9 <task_uninit>
   1223b:	83 c4 10             	add    $0x10,%esp
                kernel_memset(task,0,sizeof(task_t));
   1223e:	83 ec 04             	sub    $0x4,%esp
   12241:	68 c8 02 00 00       	push   $0x2c8
   12246:	6a 00                	push   $0x0
   12248:	ff 75 e8             	pushl  -0x18(%ebp)
   1224b:	e8 0a 32 00 00       	call   1545a <kernel_memset>
   12250:	83 c4 10             	add    $0x10,%esp

                mutex_unlock(&table_mutex);
   12253:	83 ec 0c             	sub    $0xc,%esp
   12256:	68 c0 19 03 00       	push   $0x319c0
   1225b:	e8 bf 2b 00 00       	call   14e1f <mutex_unlock>
   12260:	83 c4 10             	add    $0x10,%esp

                return pid;
   12263:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12266:	eb 52                	jmp    122ba <sys_wait+0xee>
                continue;
   12268:	90                   	nop
        for(int i=0;i<TASK_NR;i++){
   12269:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1226d:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   12271:	7e 80                	jle    121f3 <sys_wait+0x27>
            }
        }

        irq_state_t state=irq_enter_protection();
   12273:	e8 e6 0b 00 00       	call   12e5e <irq_enter_protection>
   12278:	89 45 ec             	mov    %eax,-0x14(%ebp)

        task_set_block(curr_task);
   1227b:	83 ec 0c             	sub    $0xc,%esp
   1227e:	ff 75 f0             	pushl  -0x10(%ebp)
   12281:	e8 e4 f2 ff ff       	call   1156a <task_set_block>
   12286:	83 c4 10             	add    $0x10,%esp
        curr_task->state=TASK_WAITING;
   12289:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1228c:	c7 00 04 00 00 00    	movl   $0x4,(%eax)

        irq_leave_protection(state);
   12292:	83 ec 0c             	sub    $0xc,%esp
   12295:	ff 75 ec             	pushl  -0x14(%ebp)
   12298:	e8 d9 0b 00 00       	call   12e76 <irq_leave_protection>
   1229d:	83 c4 10             	add    $0x10,%esp

        mutex_unlock(&table_mutex);
   122a0:	83 ec 0c             	sub    $0xc,%esp
   122a3:	68 c0 19 03 00       	push   $0x319c0
   122a8:	e8 72 2b 00 00       	call   14e1f <mutex_unlock>
   122ad:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   122b0:	e8 92 f3 ff ff       	call   11647 <task_dispatch>
    for(;;){
   122b5:	e9 20 ff ff ff       	jmp    121da <sys_wait+0xe>
    }
   122ba:	c9                   	leave  
   122bb:	c3                   	ret    

000122bc <lgdt>:
static inline void lgdt(uint32_t start,uint32_t size){
   122bc:	55                   	push   %ebp
   122bd:	89 e5                	mov    %esp,%ebp
   122bf:	83 ec 10             	sub    $0x10,%esp
    gdt.start31_16=start>>16;
   122c2:	8b 45 08             	mov    0x8(%ebp),%eax
   122c5:	c1 e8 10             	shr    $0x10,%eax
   122c8:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    gdt.start15_0=start&0xFFFF;
   122cc:	8b 45 08             	mov    0x8(%ebp),%eax
   122cf:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    gdt.limit=size-1;
   122d3:	8b 45 0c             	mov    0xc(%ebp),%eax
   122d6:	83 e8 01             	sub    $0x1,%eax
   122d9:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__(
   122dd:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
}
   122e1:	90                   	nop
   122e2:	c9                   	leave  
   122e3:	c3                   	ret    

000122e4 <far_jump>:
static inline void far_jump(uint32_t selector,uint32_t offset){
   122e4:	55                   	push   %ebp
   122e5:	89 e5                	mov    %esp,%ebp
   122e7:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[]={offset,selector};
   122ea:	8b 45 0c             	mov    0xc(%ebp),%eax
   122ed:	89 45 f8             	mov    %eax,-0x8(%ebp)
   122f0:	8b 45 08             	mov    0x8(%ebp),%eax
   122f3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    __asm__ __volatile__(
   122f6:	8d 45 f8             	lea    -0x8(%ebp),%eax
   122f9:	ff 28                	ljmp   *(%eax)
}
   122fb:	90                   	nop
   122fc:	c9                   	leave  
   122fd:	c3                   	ret    

000122fe <segment_desc_set>:
 * @param base 段基址
 * @param limit 段界限
 * @param attr 段属性
 * @return void
*/
void segment_desc_set(int selector,uint32_t base,uint32_t limit,uint16_t attr){
   122fe:	55                   	push   %ebp
   122ff:	89 e5                	mov    %esp,%ebp
   12301:	83 ec 14             	sub    $0x14,%esp
   12304:	8b 45 14             	mov    0x14(%ebp),%eax
   12307:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    segment_desc_t* desc=gdt_table+(selector >> 3);
   1230b:	8b 45 08             	mov    0x8(%ebp),%eax
   1230e:	c1 f8 03             	sar    $0x3,%eax
   12311:	c1 e0 03             	shl    $0x3,%eax
   12314:	05 e0 19 03 00       	add    $0x319e0,%eax
   12319:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // 设置G标志位决定粒度4kb or 1B
    if(limit > 0xFFFFF){
   1231c:	81 7d 10 ff ff 0f 00 	cmpl   $0xfffff,0x10(%ebp)
   12323:	76 0f                	jbe    12334 <segment_desc_set+0x36>
        attr|=0x8000;
   12325:	66 81 4d ec 00 80    	orw    $0x8000,-0x14(%ebp)
        limit/=0x1000;
   1232b:	8b 45 10             	mov    0x10(%ebp),%eax
   1232e:	c1 e8 0c             	shr    $0xc,%eax
   12331:	89 45 10             	mov    %eax,0x10(%ebp)
    }
    desc->limit15_0=limit&0xFFFF;
   12334:	8b 45 10             	mov    0x10(%ebp),%eax
   12337:	89 c2                	mov    %eax,%edx
   12339:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1233c:	66 89 10             	mov    %dx,(%eax)
    desc->base15_0=base&0xFFFF;
   1233f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12342:	89 c2                	mov    %eax,%edx
   12344:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12347:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->base23_16=(base>>16)&0xFF;
   1234b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1234e:	c1 e8 10             	shr    $0x10,%eax
   12351:	89 c2                	mov    %eax,%edx
   12353:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12356:	88 50 04             	mov    %dl,0x4(%eax)
    desc->attr=attr|(((limit>>16)&0xF)<<8);
   12359:	8b 45 10             	mov    0x10(%ebp),%eax
   1235c:	c1 e8 10             	shr    $0x10,%eax
   1235f:	c1 e0 08             	shl    $0x8,%eax
   12362:	66 25 00 0f          	and    $0xf00,%ax
   12366:	66 0b 45 ec          	or     -0x14(%ebp),%ax
   1236a:	89 c2                	mov    %eax,%edx
   1236c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1236f:	66 89 50 05          	mov    %dx,0x5(%eax)
    desc->base31_24=(base>>24)&0xFF;
   12373:	8b 45 0c             	mov    0xc(%ebp),%eax
   12376:	c1 e8 18             	shr    $0x18,%eax
   12379:	89 c2                	mov    %eax,%edx
   1237b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1237e:	88 50 07             	mov    %dl,0x7(%eax)

}
   12381:	90                   	nop
   12382:	c9                   	leave  
   12383:	c3                   	ret    

00012384 <init_gdt>:

// 初始化gdt表
void init_gdt(void){
   12384:	55                   	push   %ebp
   12385:	89 e5                	mov    %esp,%ebp
   12387:	83 ec 18             	sub    $0x18,%esp
    for(int i=0;i<GDT_TABLE_SIZE;i++){
   1238a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12391:	eb 19                	jmp    123ac <init_gdt+0x28>
        segment_desc_set(i<<3,0,0,0);
   12393:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12396:	c1 e0 03             	shl    $0x3,%eax
   12399:	6a 00                	push   $0x0
   1239b:	6a 00                	push   $0x0
   1239d:	6a 00                	push   $0x0
   1239f:	50                   	push   %eax
   123a0:	e8 59 ff ff ff       	call   122fe <segment_desc_set>
   123a5:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<GDT_TABLE_SIZE;i++){
   123a8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   123ac:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   123b3:	7e de                	jle    12393 <init_gdt+0xf>
    }
    segment_desc_set(KERNEL_SELECTOR_DS,0,0xFFFFFFFF,
   123b5:	68 92 40 00 00       	push   $0x4092
   123ba:	6a ff                	push   $0xffffffff
   123bc:	6a 00                	push   $0x0
   123be:	6a 10                	push   $0x10
   123c0:	e8 39 ff ff ff       	call   122fe <segment_desc_set>
   123c5:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA | SEG_TYPE_RW
        | SEG_D
    );
    segment_desc_set(KERNEL_SELECTOR_CS, 0x00000000, 0xFFFFFFFF,
   123c8:	68 9a c0 00 00       	push   $0xc09a
   123cd:	6a ff                	push   $0xffffffff
   123cf:	6a 00                	push   $0x0
   123d1:	6a 08                	push   $0x8
   123d3:	e8 26 ff ff ff       	call   122fe <segment_desc_set>
   123d8:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE
        | SEG_TYPE_RW | SEG_D | SEG_G);
    gate_desc_set((gate_desc_t*)(gdt_table+(SELECTOR_SYSCALL >> 3)),
   123db:	ba c7 02 01 00       	mov    $0x102c7,%edx
   123e0:	b8 f8 19 03 00       	mov    $0x319f8,%eax
   123e5:	68 05 ec 00 00       	push   $0xec05
   123ea:	52                   	push   %edx
   123eb:	6a 08                	push   $0x8
   123ed:	50                   	push   %eax
   123ee:	e8 1c 00 00 00       	call   1240f <gate_desc_set>
   123f3:	83 c4 10             	add    $0x10,%esp
        KERNEL_SELECTOR_CS,(uint32_t)exception_handler_syscall,
        GATE_P_PRESENT | GATE_DPL3 | GATE_TYPE_SYSCALL | SYSCALL_PARAM_COUNT
    );
    lgdt((uint32_t)gdt_table,sizeof(gdt_table));
   123f6:	b8 e0 19 03 00       	mov    $0x319e0,%eax
   123fb:	83 ec 08             	sub    $0x8,%esp
   123fe:	68 00 08 00 00       	push   $0x800
   12403:	50                   	push   %eax
   12404:	e8 b3 fe ff ff       	call   122bc <lgdt>
   12409:	83 c4 10             	add    $0x10,%esp
}
   1240c:	90                   	nop
   1240d:	c9                   	leave  
   1240e:	c3                   	ret    

0001240f <gate_desc_set>:

// 设置idt表项
void gate_desc_set(gate_desc_t* desc,uint16_t selector,uint32_t offset,uint16_t attr){
   1240f:	55                   	push   %ebp
   12410:	89 e5                	mov    %esp,%ebp
   12412:	83 ec 08             	sub    $0x8,%esp
   12415:	8b 55 0c             	mov    0xc(%ebp),%edx
   12418:	8b 45 14             	mov    0x14(%ebp),%eax
   1241b:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   1241f:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    desc->offset15_0=offset&0xFFFF;
   12423:	8b 45 10             	mov    0x10(%ebp),%eax
   12426:	89 c2                	mov    %eax,%edx
   12428:	8b 45 08             	mov    0x8(%ebp),%eax
   1242b:	66 89 10             	mov    %dx,(%eax)
    desc->selector=selector;
   1242e:	8b 45 08             	mov    0x8(%ebp),%eax
   12431:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12435:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->attr=attr;
   12439:	8b 45 08             	mov    0x8(%ebp),%eax
   1243c:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
   12440:	66 89 50 04          	mov    %dx,0x4(%eax)
    desc->offset31_16=(offset>>16)&0xFFFF;
   12444:	8b 45 10             	mov    0x10(%ebp),%eax
   12447:	c1 e8 10             	shr    $0x10,%eax
   1244a:	89 c2                	mov    %eax,%edx
   1244c:	8b 45 08             	mov    0x8(%ebp),%eax
   1244f:	66 89 50 06          	mov    %dx,0x6(%eax)
}
   12453:	90                   	nop
   12454:	c9                   	leave  
   12455:	c3                   	ret    

00012456 <cpu_init>:

/**
 * @brief 初始化mutex锁以及gdt表
 * @return void
*/
void cpu_init(void){
   12456:	55                   	push   %ebp
   12457:	89 e5                	mov    %esp,%ebp
   12459:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   1245c:	83 ec 0c             	sub    $0xc,%esp
   1245f:	68 e0 21 03 00       	push   $0x321e0
   12464:	e8 f9 28 00 00       	call   14d62 <mutex_init>
   12469:	83 c4 10             	add    $0x10,%esp
    init_gdt();
   1246c:	e8 13 ff ff ff       	call   12384 <init_gdt>
}
   12471:	90                   	nop
   12472:	c9                   	leave  
   12473:	c3                   	ret    

00012474 <gdt_alloc_desc>:

/**
 * @brief 分配gdt表项
 * @return 分配成功返回gdt表项的索引，失败返回-1
*/
int gdt_alloc_desc(){
   12474:	55                   	push   %ebp
   12475:	89 e5                	mov    %esp,%ebp
   12477:	83 ec 18             	sub    $0x18,%esp
    mutex_lock(&mutex);
   1247a:	83 ec 0c             	sub    $0xc,%esp
   1247d:	68 e0 21 03 00       	push   $0x321e0
   12482:	e8 09 29 00 00       	call   14d90 <mutex_lock>
   12487:	83 c4 10             	add    $0x10,%esp
    for(int i=1;i<GDT_TABLE_SIZE;i++){
   1248a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   12491:	eb 36                	jmp    124c9 <gdt_alloc_desc+0x55>
        segment_desc_t* desc=gdt_table+i;
   12493:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12496:	c1 e0 03             	shl    $0x3,%eax
   12499:	05 e0 19 03 00       	add    $0x319e0,%eax
   1249e:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(desc->attr==0){
   124a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   124a4:	0f b7 40 05          	movzwl 0x5(%eax),%eax
   124a8:	66 85 c0             	test   %ax,%ax
   124ab:	75 18                	jne    124c5 <gdt_alloc_desc+0x51>
            mutex_unlock(&mutex);
   124ad:	83 ec 0c             	sub    $0xc,%esp
   124b0:	68 e0 21 03 00       	push   $0x321e0
   124b5:	e8 65 29 00 00       	call   14e1f <mutex_unlock>
   124ba:	83 c4 10             	add    $0x10,%esp
            return i*sizeof(segment_desc_t);
   124bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   124c0:	c1 e0 03             	shl    $0x3,%eax
   124c3:	eb 22                	jmp    124e7 <gdt_alloc_desc+0x73>
    for(int i=1;i<GDT_TABLE_SIZE;i++){
   124c5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   124c9:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   124d0:	7e c1                	jle    12493 <gdt_alloc_desc+0x1f>
        }
    }
    mutex_unlock(&mutex);
   124d2:	83 ec 0c             	sub    $0xc,%esp
   124d5:	68 e0 21 03 00       	push   $0x321e0
   124da:	e8 40 29 00 00       	call   14e1f <mutex_unlock>
   124df:	83 c4 10             	add    $0x10,%esp
    return -1;
   124e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   124e7:	c9                   	leave  
   124e8:	c3                   	ret    

000124e9 <switch_to_tss>:

void switch_to_tss(int tss_sel){
   124e9:	55                   	push   %ebp
   124ea:	89 e5                	mov    %esp,%ebp
    far_jump(tss_sel,0);
   124ec:	8b 45 08             	mov    0x8(%ebp),%eax
   124ef:	6a 00                	push   $0x0
   124f1:	50                   	push   %eax
   124f2:	e8 ed fd ff ff       	call   122e4 <far_jump>
   124f7:	83 c4 08             	add    $0x8,%esp
}
   124fa:	90                   	nop
   124fb:	c9                   	leave  
   124fc:	c3                   	ret    

000124fd <gdt_free_sel>:

void gdt_free_sel(int sel){
   124fd:	55                   	push   %ebp
   124fe:	89 e5                	mov    %esp,%ebp
   12500:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&mutex);
   12503:	83 ec 0c             	sub    $0xc,%esp
   12506:	68 e0 21 03 00       	push   $0x321e0
   1250b:	e8 80 28 00 00       	call   14d90 <mutex_lock>
   12510:	83 c4 10             	add    $0x10,%esp
    gdt_table[sel/sizeof(segment_desc_set)].attr=0;
   12513:	8b 45 08             	mov    0x8(%ebp),%eax
   12516:	66 c7 04 c5 e5 19 03 	movw   $0x0,0x319e5(,%eax,8)
   1251d:	00 00 00 
    mutex_unlock(&mutex);
   12520:	83 ec 0c             	sub    $0xc,%esp
   12523:	68 e0 21 03 00       	push   $0x321e0
   12528:	e8 f2 28 00 00       	call   14e1f <mutex_unlock>
   1252d:	83 c4 10             	add    $0x10,%esp
   12530:	90                   	nop
   12531:	c9                   	leave  
   12532:	c3                   	ret    

00012533 <cli>:
static inline void cli(void){
   12533:	55                   	push   %ebp
   12534:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("cli");
   12536:	fa                   	cli    
}
   12537:	90                   	nop
   12538:	5d                   	pop    %ebp
   12539:	c3                   	ret    

0001253a <sti>:
static inline void sti(void){
   1253a:	55                   	push   %ebp
   1253b:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("sti");
   1253d:	fb                   	sti    
}
   1253e:	90                   	nop
   1253f:	5d                   	pop    %ebp
   12540:	c3                   	ret    

00012541 <inb>:
static inline uint8_t inb(uint16_t port){
   12541:	55                   	push   %ebp
   12542:	89 e5                	mov    %esp,%ebp
   12544:	83 ec 14             	sub    $0x14,%esp
   12547:	8b 45 08             	mov    0x8(%ebp),%eax
   1254a:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   1254e:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   12552:	89 c2                	mov    %eax,%edx
   12554:	ec                   	in     (%dx),%al
   12555:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   12558:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   1255c:	c9                   	leave  
   1255d:	c3                   	ret    

0001255e <outb>:
static inline void outb(uint16_t port,uint8_t data){
   1255e:	55                   	push   %ebp
   1255f:	89 e5                	mov    %esp,%ebp
   12561:	83 ec 08             	sub    $0x8,%esp
   12564:	8b 55 08             	mov    0x8(%ebp),%edx
   12567:	8b 45 0c             	mov    0xc(%ebp),%eax
   1256a:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   1256e:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   12571:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12575:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   12579:	ee                   	out    %al,(%dx)
}
   1257a:	90                   	nop
   1257b:	c9                   	leave  
   1257c:	c3                   	ret    

0001257d <lidt>:
static inline void lidt(uint32_t start,uint32_t size){
   1257d:	55                   	push   %ebp
   1257e:	89 e5                	mov    %esp,%ebp
   12580:	83 ec 10             	sub    $0x10,%esp
    idt.start31_16=start>>16;
   12583:	8b 45 08             	mov    0x8(%ebp),%eax
   12586:	c1 e8 10             	shr    $0x10,%eax
   12589:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    idt.start15_0=start&0xFFFF;
   1258d:	8b 45 08             	mov    0x8(%ebp),%eax
   12590:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    idt.limit=size-1;
   12594:	8b 45 0c             	mov    0xc(%ebp),%eax
   12597:	83 e8 01             	sub    $0x1,%eax
   1259a:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    __asm__ __volatile__(
   1259e:	0f 01 5d fa          	lidtl  -0x6(%ebp)
}
   125a2:	90                   	nop
   125a3:	c9                   	leave  
   125a4:	c3                   	ret    

000125a5 <hlt>:
static inline void hlt(void){
   125a5:	55                   	push   %ebp
   125a6:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("hlt");
   125a8:	f4                   	hlt    
}
   125a9:	90                   	nop
   125aa:	5d                   	pop    %ebp
   125ab:	c3                   	ret    

000125ac <read_eflags>:
static inline uint32_t read_eflags(void){
   125ac:	55                   	push   %ebp
   125ad:	89 e5                	mov    %esp,%ebp
   125af:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__(
   125b2:	9c                   	pushf  
   125b3:	58                   	pop    %eax
   125b4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return eflags;
   125b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   125ba:	c9                   	leave  
   125bb:	c3                   	ret    

000125bc <write_eflags>:
static inline void write_eflags(uint32_t eflags){
   125bc:	55                   	push   %ebp
   125bd:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__(
   125bf:	8b 45 08             	mov    0x8(%ebp),%eax
   125c2:	50                   	push   %eax
   125c3:	9d                   	popf   
}
   125c4:	90                   	nop
   125c5:	5d                   	pop    %ebp
   125c6:	c3                   	ret    

000125c7 <read_cr2>:

/**
 * @brief 读取cr2寄存器
 * @return cr2寄存器的值
 */
static inline uint32_t read_cr2(void){
   125c7:	55                   	push   %ebp
   125c8:	89 e5                	mov    %esp,%ebp
   125ca:	83 ec 10             	sub    $0x10,%esp
    uint32_t cr2;
    __asm__ __volatile__(
   125cd:	0f 20 e0             	mov    %cr4,%eax
   125d0:	89 45 fc             	mov    %eax,-0x4(%ebp)
        "mov %%cr4,%[v]"
        :[v]"=r"(cr2)
        :
    );
    return cr2;
   125d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   125d6:	c9                   	leave  
   125d7:	c3                   	ret    

000125d8 <init_pic>:
#include "cpu/irq.h"

// 初始化8259，开启中断
static void init_pic(void){
   125d8:	55                   	push   %ebp
   125d9:	89 e5                	mov    %esp,%ebp
	outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   125db:	6a 11                	push   $0x11
   125dd:	6a 20                	push   $0x20
   125df:	e8 7a ff ff ff       	call   1255e <outb>
   125e4:	83 c4 08             	add    $0x8,%esp
	outb(PIC0_ICW2, IRQ_PIC_START);
   125e7:	6a 20                	push   $0x20
   125e9:	6a 21                	push   $0x21
   125eb:	e8 6e ff ff ff       	call   1255e <outb>
   125f0:	83 c4 08             	add    $0x8,%esp
	outb(PIC0_ICW3, 1 << 2);
   125f3:	6a 04                	push   $0x4
   125f5:	6a 21                	push   $0x21
   125f7:	e8 62 ff ff ff       	call   1255e <outb>
   125fc:	83 c4 08             	add    $0x8,%esp
	outb(PIC0_ICW4, PIC_ICW4_8086);
   125ff:	6a 01                	push   $0x1
   12601:	6a 21                	push   $0x21
   12603:	e8 56 ff ff ff       	call   1255e <outb>
   12608:	83 c4 08             	add    $0x8,%esp

	outb(PIC1_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   1260b:	6a 11                	push   $0x11
   1260d:	68 a0 00 00 00       	push   $0xa0
   12612:	e8 47 ff ff ff       	call   1255e <outb>
   12617:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_ICW2, IRQ_PIC_START+8);
   1261a:	6a 28                	push   $0x28
   1261c:	68 a1 00 00 00       	push   $0xa1
   12621:	e8 38 ff ff ff       	call   1255e <outb>
   12626:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_ICW3, 2);
   12629:	6a 02                	push   $0x2
   1262b:	68 a1 00 00 00       	push   $0xa1
   12630:	e8 29 ff ff ff       	call   1255e <outb>
   12635:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_ICW4, PIC_ICW4_8086);
   12638:	6a 01                	push   $0x1
   1263a:	68 a1 00 00 00       	push   $0xa1
   1263f:	e8 1a ff ff ff       	call   1255e <outb>
   12644:	83 c4 08             	add    $0x8,%esp

	outb(PIC0_IMR,0xFF & ~(1 << 2));
   12647:	68 fb 00 00 00       	push   $0xfb
   1264c:	6a 21                	push   $0x21
   1264e:	e8 0b ff ff ff       	call   1255e <outb>
   12653:	83 c4 08             	add    $0x8,%esp
	outb(PIC1_IMR, 0xFF);
   12656:	68 ff 00 00 00       	push   $0xff
   1265b:	68 a1 00 00 00       	push   $0xa1
   12660:	e8 f9 fe ff ff       	call   1255e <outb>
   12665:	83 c4 08             	add    $0x8,%esp
}
   12668:	90                   	nop
   12669:	c9                   	leave  
   1266a:	c3                   	ret    

0001266b <irq_disable_global>:

// 关中断
void irq_disable_global(void){
   1266b:	55                   	push   %ebp
   1266c:	89 e5                	mov    %esp,%ebp
	cli();
   1266e:	e8 c0 fe ff ff       	call   12533 <cli>
}
   12673:	90                   	nop
   12674:	5d                   	pop    %ebp
   12675:	c3                   	ret    

00012676 <irq_enable_global>:

// 开中断
void irq_enable_global(void){
   12676:	55                   	push   %ebp
   12677:	89 e5                	mov    %esp,%ebp
	sti();
   12679:	e8 bc fe ff ff       	call   1253a <sti>
}
   1267e:	90                   	nop
   1267f:	5d                   	pop    %ebp
   12680:	c3                   	ret    

00012681 <irq_enable>:

// 开启特定中断
void irq_enable(int irq_num){
   12681:	55                   	push   %ebp
   12682:	89 e5                	mov    %esp,%ebp
   12684:	53                   	push   %ebx
   12685:	83 ec 10             	sub    $0x10,%esp
	if(irq_num < IRQ_PIC_START){
   12688:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   1268c:	7e 78                	jle    12706 <irq_enable+0x85>
		return;
	}
	irq_num-=IRQ_PIC_START;
   1268e:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
	if(irq_num<8){
   12692:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12696:	7f 32                	jg     126ca <irq_enable+0x49>
		uint8_t mask=inb(PIC0_IMR) & ~(1<<irq_num);
   12698:	6a 21                	push   $0x21
   1269a:	e8 a2 fe ff ff       	call   12541 <inb>
   1269f:	83 c4 04             	add    $0x4,%esp
   126a2:	89 c2                	mov    %eax,%edx
   126a4:	8b 45 08             	mov    0x8(%ebp),%eax
   126a7:	bb 01 00 00 00       	mov    $0x1,%ebx
   126ac:	89 c1                	mov    %eax,%ecx
   126ae:	d3 e3                	shl    %cl,%ebx
   126b0:	89 d8                	mov    %ebx,%eax
   126b2:	f7 d0                	not    %eax
   126b4:	21 d0                	and    %edx,%eax
   126b6:	88 45 fa             	mov    %al,-0x6(%ebp)
		outb(PIC0_IMR,mask);
   126b9:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   126bd:	50                   	push   %eax
   126be:	6a 21                	push   $0x21
   126c0:	e8 99 fe ff ff       	call   1255e <outb>
   126c5:	83 c4 08             	add    $0x8,%esp
   126c8:	eb 3d                	jmp    12707 <irq_enable+0x86>
	}
	else{
		irq_num-=8;
   126ca:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
		uint8_t mask=inb(PIC1_IMR) & ~(1<<irq_num);
   126ce:	68 a1 00 00 00       	push   $0xa1
   126d3:	e8 69 fe ff ff       	call   12541 <inb>
   126d8:	83 c4 04             	add    $0x4,%esp
   126db:	89 c2                	mov    %eax,%edx
   126dd:	8b 45 08             	mov    0x8(%ebp),%eax
   126e0:	bb 01 00 00 00       	mov    $0x1,%ebx
   126e5:	89 c1                	mov    %eax,%ecx
   126e7:	d3 e3                	shl    %cl,%ebx
   126e9:	89 d8                	mov    %ebx,%eax
   126eb:	f7 d0                	not    %eax
   126ed:	21 d0                	and    %edx,%eax
   126ef:	88 45 fb             	mov    %al,-0x5(%ebp)
		outb(PIC1_IMR,mask);
   126f2:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   126f6:	50                   	push   %eax
   126f7:	68 a1 00 00 00       	push   $0xa1
   126fc:	e8 5d fe ff ff       	call   1255e <outb>
   12701:	83 c4 08             	add    $0x8,%esp
   12704:	eb 01                	jmp    12707 <irq_enable+0x86>
		return;
   12706:	90                   	nop
	}
}
   12707:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1270a:	c9                   	leave  
   1270b:	c3                   	ret    

0001270c <irq_disable>:

// 关闭特定中断
void irq_disable(int irq_num){
   1270c:	55                   	push   %ebp
   1270d:	89 e5                	mov    %esp,%ebp
   1270f:	53                   	push   %ebx
   12710:	83 ec 10             	sub    $0x10,%esp
	if(irq_num < IRQ_PIC_START){
   12713:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   12717:	7e 74                	jle    1278d <irq_disable+0x81>
		return;
	}
	irq_num-=IRQ_PIC_START;
   12719:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
	if(irq_num<8){
   1271d:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12721:	7f 30                	jg     12753 <irq_disable+0x47>
		uint8_t mask=inb(PIC0_IMR) | (1<<irq_num);
   12723:	6a 21                	push   $0x21
   12725:	e8 17 fe ff ff       	call   12541 <inb>
   1272a:	83 c4 04             	add    $0x4,%esp
   1272d:	89 c3                	mov    %eax,%ebx
   1272f:	8b 45 08             	mov    0x8(%ebp),%eax
   12732:	ba 01 00 00 00       	mov    $0x1,%edx
   12737:	89 c1                	mov    %eax,%ecx
   12739:	d3 e2                	shl    %cl,%edx
   1273b:	89 d0                	mov    %edx,%eax
   1273d:	09 d8                	or     %ebx,%eax
   1273f:	88 45 fa             	mov    %al,-0x6(%ebp)
		outb(PIC0_IMR,mask);
   12742:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   12746:	50                   	push   %eax
   12747:	6a 21                	push   $0x21
   12749:	e8 10 fe ff ff       	call   1255e <outb>
   1274e:	83 c4 08             	add    $0x8,%esp
   12751:	eb 3b                	jmp    1278e <irq_disable+0x82>
	}
	else{
		irq_num-=8;
   12753:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
		uint8_t mask=inb(PIC1_IMR) | (1<<irq_num);
   12757:	68 a1 00 00 00       	push   $0xa1
   1275c:	e8 e0 fd ff ff       	call   12541 <inb>
   12761:	83 c4 04             	add    $0x4,%esp
   12764:	89 c3                	mov    %eax,%ebx
   12766:	8b 45 08             	mov    0x8(%ebp),%eax
   12769:	ba 01 00 00 00       	mov    $0x1,%edx
   1276e:	89 c1                	mov    %eax,%ecx
   12770:	d3 e2                	shl    %cl,%edx
   12772:	89 d0                	mov    %edx,%eax
   12774:	09 d8                	or     %ebx,%eax
   12776:	88 45 fb             	mov    %al,-0x5(%ebp)
		outb(PIC1_IMR,mask);
   12779:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   1277d:	50                   	push   %eax
   1277e:	68 a1 00 00 00       	push   $0xa1
   12783:	e8 d6 fd ff ff       	call   1255e <outb>
   12788:	83 c4 08             	add    $0x8,%esp
   1278b:	eb 01                	jmp    1278e <irq_disable+0x82>
		return;
   1278d:	90                   	nop
	}
}
   1278e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12791:	c9                   	leave  
   12792:	c3                   	ret    

00012793 <irq_init>:

// 定义中断向量表
static gate_desc_t idt_table[IDT_TABLE_NR];
void irq_init(void){
   12793:	55                   	push   %ebp
   12794:	89 e5                	mov    %esp,%ebp
   12796:	83 ec 18             	sub    $0x18,%esp
    for(uint32_t i=0;i<IDT_TABLE_NR;i++){
   12799:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   127a0:	eb 25                	jmp    127c7 <irq_init+0x34>
        gate_desc_set(idt_table+i,KERNEL_SELECTOR_CS,(uint32_t)exception_handler_unknown,
   127a2:	ba 2b 00 01 00       	mov    $0x1002b,%edx
   127a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   127aa:	c1 e0 03             	shl    $0x3,%eax
   127ad:	05 00 22 03 00       	add    $0x32200,%eax
   127b2:	68 00 8e 00 00       	push   $0x8e00
   127b7:	52                   	push   %edx
   127b8:	6a 08                	push   $0x8
   127ba:	50                   	push   %eax
   127bb:	e8 4f fc ff ff       	call   1240f <gate_desc_set>
   127c0:	83 c4 10             	add    $0x10,%esp
    for(uint32_t i=0;i<IDT_TABLE_NR;i++){
   127c3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   127c7:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   127cb:	76 d5                	jbe    127a2 <irq_init+0xf>
        GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);
    }

    
    irq_install(IRQ0_DE, (irq_handler_t)exception_handler_divider);
   127cd:	83 ec 08             	sub    $0x8,%esp
   127d0:	68 4a 00 01 00       	push   $0x1004a
   127d5:	6a 00                	push   $0x0
   127d7:	e8 65 01 00 00       	call   12941 <irq_install>
   127dc:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ1_DB, (irq_handler_t)exception_handler_Debug);
   127df:	83 ec 08             	sub    $0x8,%esp
   127e2:	68 69 00 01 00       	push   $0x10069
   127e7:	6a 01                	push   $0x1
   127e9:	e8 53 01 00 00       	call   12941 <irq_install>
   127ee:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ2_NMI, (irq_handler_t)exception_handler_NMI);
   127f1:	83 ec 08             	sub    $0x8,%esp
   127f4:	68 88 00 01 00       	push   $0x10088
   127f9:	6a 02                	push   $0x2
   127fb:	e8 41 01 00 00       	call   12941 <irq_install>
   12800:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ3_BP, (irq_handler_t)exception_handler_breakpoint);
   12803:	83 ec 08             	sub    $0x8,%esp
   12806:	68 a7 00 01 00       	push   $0x100a7
   1280b:	6a 03                	push   $0x3
   1280d:	e8 2f 01 00 00       	call   12941 <irq_install>
   12812:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ4_OF, (irq_handler_t)exception_handler_overflow);
   12815:	83 ec 08             	sub    $0x8,%esp
   12818:	68 c6 00 01 00       	push   $0x100c6
   1281d:	6a 04                	push   $0x4
   1281f:	e8 1d 01 00 00       	call   12941 <irq_install>
   12824:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ5_BR, (irq_handler_t)exception_handler_bound_range);
   12827:	83 ec 08             	sub    $0x8,%esp
   1282a:	68 e5 00 01 00       	push   $0x100e5
   1282f:	6a 05                	push   $0x5
   12831:	e8 0b 01 00 00       	call   12941 <irq_install>
   12836:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ6_UD, (irq_handler_t)exception_handler_invalid_opcode);
   12839:	83 ec 08             	sub    $0x8,%esp
   1283c:	68 04 01 01 00       	push   $0x10104
   12841:	6a 06                	push   $0x6
   12843:	e8 f9 00 00 00       	call   12941 <irq_install>
   12848:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ7_NM, (irq_handler_t)exception_handler_device_unavailable);
   1284b:	83 ec 08             	sub    $0x8,%esp
   1284e:	68 23 01 01 00       	push   $0x10123
   12853:	6a 07                	push   $0x7
   12855:	e8 e7 00 00 00       	call   12941 <irq_install>
   1285a:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ8_DF, (irq_handler_t)exception_handler_double_fault);
   1285d:	83 ec 08             	sub    $0x8,%esp
   12860:	68 42 01 01 00       	push   $0x10142
   12865:	6a 08                	push   $0x8
   12867:	e8 d5 00 00 00       	call   12941 <irq_install>
   1286c:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ10_TS, (irq_handler_t)exception_handler_invalid_tss);
   1286f:	83 ec 08             	sub    $0x8,%esp
   12872:	68 5f 01 01 00       	push   $0x1015f
   12877:	6a 0a                	push   $0xa
   12879:	e8 c3 00 00 00       	call   12941 <irq_install>
   1287e:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ11_NP, (irq_handler_t)exception_handler_segment_not_present);
   12881:	83 ec 08             	sub    $0x8,%esp
   12884:	68 7c 01 01 00       	push   $0x1017c
   12889:	6a 0b                	push   $0xb
   1288b:	e8 b1 00 00 00       	call   12941 <irq_install>
   12890:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ12_SS, (irq_handler_t)exception_handler_stack_segment_fault);
   12893:	83 ec 08             	sub    $0x8,%esp
   12896:	68 99 01 01 00       	push   $0x10199
   1289b:	6a 0c                	push   $0xc
   1289d:	e8 9f 00 00 00       	call   12941 <irq_install>
   128a2:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ13_GP, (irq_handler_t)exception_handler_general_protection);
   128a5:	83 ec 08             	sub    $0x8,%esp
   128a8:	68 b6 01 01 00       	push   $0x101b6
   128ad:	6a 0d                	push   $0xd
   128af:	e8 8d 00 00 00       	call   12941 <irq_install>
   128b4:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ14_PF, (irq_handler_t)exception_handler_page_fault);
   128b7:	83 ec 08             	sub    $0x8,%esp
   128ba:	68 d3 01 01 00       	push   $0x101d3
   128bf:	6a 0e                	push   $0xe
   128c1:	e8 7b 00 00 00       	call   12941 <irq_install>
   128c6:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ16_MF, (irq_handler_t)exception_handler_fpu_error);
   128c9:	83 ec 08             	sub    $0x8,%esp
   128cc:	68 f0 01 01 00       	push   $0x101f0
   128d1:	6a 10                	push   $0x10
   128d3:	e8 69 00 00 00       	call   12941 <irq_install>
   128d8:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ17_AC, (irq_handler_t)exception_handler_alignment_check);
   128db:	83 ec 08             	sub    $0x8,%esp
   128de:	68 0f 02 01 00       	push   $0x1020f
   128e3:	6a 11                	push   $0x11
   128e5:	e8 57 00 00 00       	call   12941 <irq_install>
   128ea:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ18_MC, (irq_handler_t)exception_handler_machine_check);
   128ed:	83 ec 08             	sub    $0x8,%esp
   128f0:	68 2c 02 01 00       	push   $0x1022c
   128f5:	6a 12                	push   $0x12
   128f7:	e8 45 00 00 00       	call   12941 <irq_install>
   128fc:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ19_XM, (irq_handler_t)exception_handler_smd_exception);
   128ff:	83 ec 08             	sub    $0x8,%esp
   12902:	68 4b 02 01 00       	push   $0x1024b
   12907:	6a 13                	push   $0x13
   12909:	e8 33 00 00 00       	call   12941 <irq_install>
   1290e:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ20_VE, (irq_handler_t)exception_handler_virtual_exception);
   12911:	83 ec 08             	sub    $0x8,%esp
   12914:	68 6a 02 01 00       	push   $0x1026a
   12919:	6a 14                	push   $0x14
   1291b:	e8 21 00 00 00       	call   12941 <irq_install>
   12920:	83 c4 10             	add    $0x10,%esp

    lidt((uint32_t)idt_table,sizeof(idt_table));
   12923:	b8 00 22 03 00       	mov    $0x32200,%eax
   12928:	83 ec 08             	sub    $0x8,%esp
   1292b:	68 00 04 00 00       	push   $0x400
   12930:	50                   	push   %eax
   12931:	e8 47 fc ff ff       	call   1257d <lidt>
   12936:	83 c4 10             	add    $0x10,%esp

	// 初始化8259用于开启中断
	init_pic();
   12939:	e8 9a fc ff ff       	call   125d8 <init_pic>

}
   1293e:	90                   	nop
   1293f:	c9                   	leave  
   12940:	c3                   	ret    

00012941 <irq_install>:

// 将对应的中断添加到idt表中
int irq_install(int irq_num,irq_handler_t handler){
   12941:	55                   	push   %ebp
   12942:	89 e5                	mov    %esp,%ebp
   12944:	83 ec 08             	sub    $0x8,%esp
    if(irq_num >= IDT_TABLE_NR){
   12947:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   1294b:	7e 07                	jle    12954 <irq_install+0x13>
        return -1;
   1294d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   12952:	eb 25                	jmp    12979 <irq_install+0x38>
    }
    gate_desc_set(idt_table+irq_num,KERNEL_SELECTOR_CS,(uint32_t)handler,
   12954:	8b 45 0c             	mov    0xc(%ebp),%eax
   12957:	8b 55 08             	mov    0x8(%ebp),%edx
   1295a:	c1 e2 03             	shl    $0x3,%edx
   1295d:	81 c2 00 22 03 00    	add    $0x32200,%edx
   12963:	68 00 8e 00 00       	push   $0x8e00
   12968:	50                   	push   %eax
   12969:	6a 08                	push   $0x8
   1296b:	52                   	push   %edx
   1296c:	e8 9e fa ff ff       	call   1240f <gate_desc_set>
   12971:	83 c4 10             	add    $0x10,%esp
     GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_INT);
    return 0;
   12974:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12979:	c9                   	leave  
   1297a:	c3                   	ret    

0001297b <dump_core_regs>:


static void dump_core_regs(exception_frame_t*frame){
   1297b:	55                   	push   %ebp
   1297c:	89 e5                	mov    %esp,%ebp
   1297e:	57                   	push   %edi
   1297f:	56                   	push   %esi
   12980:	53                   	push   %ebx
   12981:	83 ec 2c             	sub    $0x2c,%esp
	log_printf("IRQ: %d, error code: %d",frame->num,frame->error_code);
   12984:	8b 45 08             	mov    0x8(%ebp),%eax
   12987:	8b 50 34             	mov    0x34(%eax),%edx
   1298a:	8b 45 08             	mov    0x8(%ebp),%eax
   1298d:	8b 40 30             	mov    0x30(%eax),%eax
   12990:	83 ec 04             	sub    $0x4,%esp
   12993:	52                   	push   %edx
   12994:	50                   	push   %eax
   12995:	68 a0 5f 01 00       	push   $0x15fa0
   1299a:	e8 de 30 00 00       	call   15a7d <log_printf>
   1299f:	83 c4 10             	add    $0x10,%esp
	uint32_t ss,esp;
	if(frame->cs & 0x3){
   129a2:	8b 45 08             	mov    0x8(%ebp),%eax
   129a5:	8b 40 3c             	mov    0x3c(%eax),%eax
   129a8:	83 e0 03             	and    $0x3,%eax
   129ab:	85 c0                	test   %eax,%eax
   129ad:	74 14                	je     129c3 <dump_core_regs+0x48>
		ss=frame->ss3;
   129af:	8b 45 08             	mov    0x8(%ebp),%eax
   129b2:	8b 40 48             	mov    0x48(%eax),%eax
   129b5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		esp=frame->esp3;
   129b8:	8b 45 08             	mov    0x8(%ebp),%eax
   129bb:	8b 40 44             	mov    0x44(%eax),%eax
   129be:	89 45 e0             	mov    %eax,-0x20(%ebp)
   129c1:	eb 12                	jmp    129d5 <dump_core_regs+0x5a>
	}else{
		ss=frame->ds;
   129c3:	8b 45 08             	mov    0x8(%ebp),%eax
   129c6:	8b 40 0c             	mov    0xc(%eax),%eax
   129c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		esp=frame->esp;
   129cc:	8b 45 08             	mov    0x8(%ebp),%eax
   129cf:	8b 40 1c             	mov    0x1c(%eax),%eax
   129d2:	89 45 e0             	mov    %eax,-0x20(%ebp)
	}
	log_printf("CS: %d\nDS: %d\nES: %d\nSS: %d\nFS: %d\nGS: %d",
   129d5:	8b 45 08             	mov    0x8(%ebp),%eax
   129d8:	8b 18                	mov    (%eax),%ebx
   129da:	8b 45 08             	mov    0x8(%ebp),%eax
   129dd:	8b 48 08             	mov    0x8(%eax),%ecx
   129e0:	8b 45 08             	mov    0x8(%ebp),%eax
   129e3:	8b 50 0c             	mov    0xc(%eax),%edx
   129e6:	8b 45 08             	mov    0x8(%ebp),%eax
   129e9:	8b 40 3c             	mov    0x3c(%eax),%eax
   129ec:	83 ec 08             	sub    $0x8,%esp
   129ef:	53                   	push   %ebx
   129f0:	ff 75 e4             	pushl  -0x1c(%ebp)
   129f3:	51                   	push   %ecx
   129f4:	52                   	push   %edx
   129f5:	50                   	push   %eax
   129f6:	68 b8 5f 01 00       	push   $0x15fb8
   129fb:	e8 7d 30 00 00       	call   15a7d <log_printf>
   12a00:	83 c4 20             	add    $0x20,%esp
		frame->cs,frame->ds,frame->es,ss,frame->gs
	);
	log_printf("EAX: 0x%x\nEBX: 0x%x\nECX: 0x%x\nEDX: 0x%x\nEDI: 0x%x\nESI: 0x%x\n"
   12a03:	8b 45 08             	mov    0x8(%ebp),%eax
   12a06:	8b 40 18             	mov    0x18(%eax),%eax
   12a09:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   12a0c:	8b 45 08             	mov    0x8(%ebp),%eax
   12a0f:	8b 78 14             	mov    0x14(%eax),%edi
   12a12:	8b 45 08             	mov    0x8(%ebp),%eax
   12a15:	8b 70 10             	mov    0x10(%eax),%esi
   12a18:	8b 45 08             	mov    0x8(%ebp),%eax
   12a1b:	8b 58 24             	mov    0x24(%eax),%ebx
   12a1e:	8b 45 08             	mov    0x8(%ebp),%eax
   12a21:	8b 48 28             	mov    0x28(%eax),%ecx
   12a24:	8b 45 08             	mov    0x8(%ebp),%eax
   12a27:	8b 50 20             	mov    0x20(%eax),%edx
   12a2a:	8b 45 08             	mov    0x8(%ebp),%eax
   12a2d:	8b 40 2c             	mov    0x2c(%eax),%eax
   12a30:	83 ec 0c             	sub    $0xc,%esp
   12a33:	ff 75 e0             	pushl  -0x20(%ebp)
   12a36:	ff 75 d4             	pushl  -0x2c(%ebp)
   12a39:	57                   	push   %edi
   12a3a:	56                   	push   %esi
   12a3b:	53                   	push   %ebx
   12a3c:	51                   	push   %ecx
   12a3d:	52                   	push   %edx
   12a3e:	50                   	push   %eax
   12a3f:	68 e4 5f 01 00       	push   $0x15fe4
   12a44:	e8 34 30 00 00       	call   15a7d <log_printf>
   12a49:	83 c4 30             	add    $0x30,%esp
	"EBP: 0x%x\nESP: 0x%x",
		frame->eax,frame->ebx,frame->ecx,frame->edx,
		frame->edi,frame->esi,frame->ebp,esp
	);
	log_printf("EIP: 0x%x\nEFLAGS:0x%x\n",frame->eip,frame->eflags);
   12a4c:	8b 45 08             	mov    0x8(%ebp),%eax
   12a4f:	8b 50 40             	mov    0x40(%eax),%edx
   12a52:	8b 45 08             	mov    0x8(%ebp),%eax
   12a55:	8b 40 38             	mov    0x38(%eax),%eax
   12a58:	83 ec 04             	sub    $0x4,%esp
   12a5b:	52                   	push   %edx
   12a5c:	50                   	push   %eax
   12a5d:	68 34 60 01 00       	push   $0x16034
   12a62:	e8 16 30 00 00       	call   15a7d <log_printf>
   12a67:	83 c4 10             	add    $0x10,%esp
}
   12a6a:	90                   	nop
   12a6b:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12a6e:	5b                   	pop    %ebx
   12a6f:	5e                   	pop    %esi
   12a70:	5f                   	pop    %edi
   12a71:	5d                   	pop    %ebp
   12a72:	c3                   	ret    

00012a73 <do_default_handler>:

static void do_default_handler(exception_frame_t* frame,char* message){
   12a73:	55                   	push   %ebp
   12a74:	89 e5                	mov    %esp,%ebp
   12a76:	83 ec 08             	sub    $0x8,%esp
	log_printf("---------------");
   12a79:	83 ec 0c             	sub    $0xc,%esp
   12a7c:	68 4b 60 01 00       	push   $0x1604b
   12a81:	e8 f7 2f 00 00       	call   15a7d <log_printf>
   12a86:	83 c4 10             	add    $0x10,%esp
	log_printf("IRQ/Exception happened: %s",message);
   12a89:	83 ec 08             	sub    $0x8,%esp
   12a8c:	ff 75 0c             	pushl  0xc(%ebp)
   12a8f:	68 5b 60 01 00       	push   $0x1605b
   12a94:	e8 e4 2f 00 00       	call   15a7d <log_printf>
   12a99:	83 c4 10             	add    $0x10,%esp
	dump_core_regs(frame);
   12a9c:	83 ec 0c             	sub    $0xc,%esp
   12a9f:	ff 75 08             	pushl  0x8(%ebp)
   12aa2:	e8 d4 fe ff ff       	call   1297b <dump_core_regs>
   12aa7:	83 c4 10             	add    $0x10,%esp
    hlt();
   12aaa:	e8 f6 fa ff ff       	call   125a5 <hlt>
}
   12aaf:	90                   	nop
   12ab0:	c9                   	leave  
   12ab1:	c3                   	ret    

00012ab2 <do_handler_unknown>:

// 会被对应exception_handler的call调用
void do_handler_unknown(exception_frame_t* frame){
   12ab2:	55                   	push   %ebp
   12ab3:	89 e5                	mov    %esp,%ebp
   12ab5:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"unknown exception");
   12ab8:	83 ec 08             	sub    $0x8,%esp
   12abb:	68 76 60 01 00       	push   $0x16076
   12ac0:	ff 75 08             	pushl  0x8(%ebp)
   12ac3:	e8 ab ff ff ff       	call   12a73 <do_default_handler>
   12ac8:	83 c4 10             	add    $0x10,%esp
}
   12acb:	90                   	nop
   12acc:	c9                   	leave  
   12acd:	c3                   	ret    

00012ace <do_handler_divider>:

void do_handler_divider(exception_frame_t* frame){
   12ace:	55                   	push   %ebp
   12acf:	89 e5                	mov    %esp,%ebp
   12ad1:	83 ec 08             	sub    $0x8,%esp
    do_default_handler(frame,"Divider exception");
   12ad4:	83 ec 08             	sub    $0x8,%esp
   12ad7:	68 88 60 01 00       	push   $0x16088
   12adc:	ff 75 08             	pushl  0x8(%ebp)
   12adf:	e8 8f ff ff ff       	call   12a73 <do_default_handler>
   12ae4:	83 c4 10             	add    $0x10,%esp
}
   12ae7:	90                   	nop
   12ae8:	c9                   	leave  
   12ae9:	c3                   	ret    

00012aea <do_handler_Debug>:

void do_handler_Debug(exception_frame_t * frame) {
   12aea:	55                   	push   %ebp
   12aeb:	89 e5                	mov    %esp,%ebp
   12aed:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Debug Exception");
   12af0:	83 ec 08             	sub    $0x8,%esp
   12af3:	68 9a 60 01 00       	push   $0x1609a
   12af8:	ff 75 08             	pushl  0x8(%ebp)
   12afb:	e8 73 ff ff ff       	call   12a73 <do_default_handler>
   12b00:	83 c4 10             	add    $0x10,%esp
}
   12b03:	90                   	nop
   12b04:	c9                   	leave  
   12b05:	c3                   	ret    

00012b06 <do_handler_NMI>:

void do_handler_NMI(exception_frame_t * frame) {
   12b06:	55                   	push   %ebp
   12b07:	89 e5                	mov    %esp,%ebp
   12b09:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "NMI Interrupt.");
   12b0c:	83 ec 08             	sub    $0x8,%esp
   12b0f:	68 aa 60 01 00       	push   $0x160aa
   12b14:	ff 75 08             	pushl  0x8(%ebp)
   12b17:	e8 57 ff ff ff       	call   12a73 <do_default_handler>
   12b1c:	83 c4 10             	add    $0x10,%esp
}
   12b1f:	90                   	nop
   12b20:	c9                   	leave  
   12b21:	c3                   	ret    

00012b22 <do_handler_breakpoint>:

void do_handler_breakpoint(exception_frame_t * frame) {
   12b22:	55                   	push   %ebp
   12b23:	89 e5                	mov    %esp,%ebp
   12b25:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Breakpoint.");
   12b28:	83 ec 08             	sub    $0x8,%esp
   12b2b:	68 b9 60 01 00       	push   $0x160b9
   12b30:	ff 75 08             	pushl  0x8(%ebp)
   12b33:	e8 3b ff ff ff       	call   12a73 <do_default_handler>
   12b38:	83 c4 10             	add    $0x10,%esp
}
   12b3b:	90                   	nop
   12b3c:	c9                   	leave  
   12b3d:	c3                   	ret    

00012b3e <do_handler_overflow>:

void do_handler_overflow(exception_frame_t * frame) {
   12b3e:	55                   	push   %ebp
   12b3f:	89 e5                	mov    %esp,%ebp
   12b41:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Overflow.");
   12b44:	83 ec 08             	sub    $0x8,%esp
   12b47:	68 c5 60 01 00       	push   $0x160c5
   12b4c:	ff 75 08             	pushl  0x8(%ebp)
   12b4f:	e8 1f ff ff ff       	call   12a73 <do_default_handler>
   12b54:	83 c4 10             	add    $0x10,%esp
}
   12b57:	90                   	nop
   12b58:	c9                   	leave  
   12b59:	c3                   	ret    

00012b5a <do_handler_bound_range>:

void do_handler_bound_range(exception_frame_t * frame) {
   12b5a:	55                   	push   %ebp
   12b5b:	89 e5                	mov    %esp,%ebp
   12b5d:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "BOUND Range Exceeded.");
   12b60:	83 ec 08             	sub    $0x8,%esp
   12b63:	68 cf 60 01 00       	push   $0x160cf
   12b68:	ff 75 08             	pushl  0x8(%ebp)
   12b6b:	e8 03 ff ff ff       	call   12a73 <do_default_handler>
   12b70:	83 c4 10             	add    $0x10,%esp
}
   12b73:	90                   	nop
   12b74:	c9                   	leave  
   12b75:	c3                   	ret    

00012b76 <do_handler_invalid_opcode>:

void do_handler_invalid_opcode(exception_frame_t * frame) {
   12b76:	55                   	push   %ebp
   12b77:	89 e5                	mov    %esp,%ebp
   12b79:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Invalid Opcode.");
   12b7c:	83 ec 08             	sub    $0x8,%esp
   12b7f:	68 e5 60 01 00       	push   $0x160e5
   12b84:	ff 75 08             	pushl  0x8(%ebp)
   12b87:	e8 e7 fe ff ff       	call   12a73 <do_default_handler>
   12b8c:	83 c4 10             	add    $0x10,%esp
}
   12b8f:	90                   	nop
   12b90:	c9                   	leave  
   12b91:	c3                   	ret    

00012b92 <do_handler_device_unavailable>:

void do_handler_device_unavailable(exception_frame_t * frame) {
   12b92:	55                   	push   %ebp
   12b93:	89 e5                	mov    %esp,%ebp
   12b95:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Device Not Available.");
   12b98:	83 ec 08             	sub    $0x8,%esp
   12b9b:	68 f5 60 01 00       	push   $0x160f5
   12ba0:	ff 75 08             	pushl  0x8(%ebp)
   12ba3:	e8 cb fe ff ff       	call   12a73 <do_default_handler>
   12ba8:	83 c4 10             	add    $0x10,%esp
}
   12bab:	90                   	nop
   12bac:	c9                   	leave  
   12bad:	c3                   	ret    

00012bae <do_handler_double_fault>:

void do_handler_double_fault(exception_frame_t * frame) {
   12bae:	55                   	push   %ebp
   12baf:	89 e5                	mov    %esp,%ebp
   12bb1:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Double Fault.");
   12bb4:	83 ec 08             	sub    $0x8,%esp
   12bb7:	68 0b 61 01 00       	push   $0x1610b
   12bbc:	ff 75 08             	pushl  0x8(%ebp)
   12bbf:	e8 af fe ff ff       	call   12a73 <do_default_handler>
   12bc4:	83 c4 10             	add    $0x10,%esp
}
   12bc7:	90                   	nop
   12bc8:	c9                   	leave  
   12bc9:	c3                   	ret    

00012bca <do_handler_invalid_tss>:

void do_handler_invalid_tss(exception_frame_t * frame) {
   12bca:	55                   	push   %ebp
   12bcb:	89 e5                	mov    %esp,%ebp
   12bcd:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Invalid TSS");
   12bd0:	83 ec 08             	sub    $0x8,%esp
   12bd3:	68 19 61 01 00       	push   $0x16119
   12bd8:	ff 75 08             	pushl  0x8(%ebp)
   12bdb:	e8 93 fe ff ff       	call   12a73 <do_default_handler>
   12be0:	83 c4 10             	add    $0x10,%esp
}
   12be3:	90                   	nop
   12be4:	c9                   	leave  
   12be5:	c3                   	ret    

00012be6 <do_handler_segment_not_present>:

void do_handler_segment_not_present(exception_frame_t * frame) {
   12be6:	55                   	push   %ebp
   12be7:	89 e5                	mov    %esp,%ebp
   12be9:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Segment Not Present.");
   12bec:	83 ec 08             	sub    $0x8,%esp
   12bef:	68 25 61 01 00       	push   $0x16125
   12bf4:	ff 75 08             	pushl  0x8(%ebp)
   12bf7:	e8 77 fe ff ff       	call   12a73 <do_default_handler>
   12bfc:	83 c4 10             	add    $0x10,%esp
}
   12bff:	90                   	nop
   12c00:	c9                   	leave  
   12c01:	c3                   	ret    

00012c02 <do_handler_stack_segment_fault>:

void do_handler_stack_segment_fault(exception_frame_t * frame) {
   12c02:	55                   	push   %ebp
   12c03:	89 e5                	mov    %esp,%ebp
   12c05:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Stack-Segment Fault.");
   12c08:	83 ec 08             	sub    $0x8,%esp
   12c0b:	68 3a 61 01 00       	push   $0x1613a
   12c10:	ff 75 08             	pushl  0x8(%ebp)
   12c13:	e8 5b fe ff ff       	call   12a73 <do_default_handler>
   12c18:	83 c4 10             	add    $0x10,%esp
}
   12c1b:	90                   	nop
   12c1c:	c9                   	leave  
   12c1d:	c3                   	ret    

00012c1e <do_handler_general_protection>:

void do_handler_general_protection(exception_frame_t * frame) {
   12c1e:	55                   	push   %ebp
   12c1f:	89 e5                	mov    %esp,%ebp
   12c21:	83 ec 08             	sub    $0x8,%esp
	log_printf("--------------------------------");
   12c24:	83 ec 0c             	sub    $0xc,%esp
   12c27:	68 50 61 01 00       	push   $0x16150
   12c2c:	e8 4c 2e 00 00       	call   15a7d <log_printf>
   12c31:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: General Protection.");
   12c34:	83 ec 0c             	sub    $0xc,%esp
   12c37:	68 74 61 01 00       	push   $0x16174
   12c3c:	e8 3c 2e 00 00       	call   15a7d <log_printf>
   12c41:	83 c4 10             	add    $0x10,%esp
    if (frame->error_code & ERR_EXT) {
   12c44:	8b 45 08             	mov    0x8(%ebp),%eax
   12c47:	8b 40 34             	mov    0x34(%eax),%eax
   12c4a:	83 e0 01             	and    $0x1,%eax
   12c4d:	85 c0                	test   %eax,%eax
   12c4f:	74 12                	je     12c63 <do_handler_general_protection+0x45>
        log_printf("the exception occurred during delivery of an "
   12c51:	83 ec 0c             	sub    $0xc,%esp
   12c54:	68 a0 61 01 00       	push   $0x161a0
   12c59:	e8 1f 2e 00 00       	call   15a7d <log_printf>
   12c5e:	83 c4 10             	add    $0x10,%esp
   12c61:	eb 10                	jmp    12c73 <do_handler_general_protection+0x55>
                "event external to the program, such as an interrupt"
                "or an earlier exception.");
    } else {
        log_printf("the exception occurred during delivery of a"
   12c63:	83 ec 0c             	sub    $0xc,%esp
   12c66:	68 1c 62 01 00       	push   $0x1621c
   12c6b:	e8 0d 2e 00 00       	call   15a7d <log_printf>
   12c70:	83 c4 10             	add    $0x10,%esp
                    "software interrupt (INT n, INT3, or INTO).");
    }
    
    if (frame->error_code & ERR_IDT) {
   12c73:	8b 45 08             	mov    0x8(%ebp),%eax
   12c76:	8b 40 34             	mov    0x34(%eax),%eax
   12c79:	83 e0 02             	and    $0x2,%eax
   12c7c:	85 c0                	test   %eax,%eax
   12c7e:	74 12                	je     12c92 <do_handler_general_protection+0x74>
        log_printf("the index portion of the error code refers "
   12c80:	83 ec 0c             	sub    $0xc,%esp
   12c83:	68 74 62 01 00       	push   $0x16274
   12c88:	e8 f0 2d 00 00       	call   15a7d <log_printf>
   12c8d:	83 c4 10             	add    $0x10,%esp
   12c90:	eb 10                	jmp    12ca2 <do_handler_general_protection+0x84>
                    "to a gate descriptor in the IDT");
    } else {
        log_printf("the index refers to a descriptor in the GDT");
   12c92:	83 ec 0c             	sub    $0xc,%esp
   12c95:	68 c0 62 01 00       	push   $0x162c0
   12c9a:	e8 de 2d 00 00       	call   15a7d <log_printf>
   12c9f:	83 c4 10             	add    $0x10,%esp
    }
    
    log_printf("segment index: %d", frame->error_code & 0xFFF8);
   12ca2:	8b 45 08             	mov    0x8(%ebp),%eax
   12ca5:	8b 40 34             	mov    0x34(%eax),%eax
   12ca8:	25 f8 ff 00 00       	and    $0xfff8,%eax
   12cad:	83 ec 08             	sub    $0x8,%esp
   12cb0:	50                   	push   %eax
   12cb1:	68 ec 62 01 00       	push   $0x162ec
   12cb6:	e8 c2 2d 00 00       	call   15a7d <log_printf>
   12cbb:	83 c4 10             	add    $0x10,%esp

    dump_core_regs(frame);
   12cbe:	83 ec 0c             	sub    $0xc,%esp
   12cc1:	ff 75 08             	pushl  0x8(%ebp)
   12cc4:	e8 b2 fc ff ff       	call   1297b <dump_core_regs>
   12cc9:	83 c4 10             	add    $0x10,%esp
    while (1) {
        hlt();
   12ccc:	e8 d4 f8 ff ff       	call   125a5 <hlt>
   12cd1:	eb f9                	jmp    12ccc <do_handler_general_protection+0xae>

00012cd3 <do_handler_page_fault>:
    }	
}

void do_handler_page_fault(exception_frame_t * frame) {
   12cd3:	55                   	push   %ebp
   12cd4:	89 e5                	mov    %esp,%ebp
   12cd6:	83 ec 08             	sub    $0x8,%esp
	log_printf("--------------------------------");
   12cd9:	83 ec 0c             	sub    $0xc,%esp
   12cdc:	68 50 61 01 00       	push   $0x16150
   12ce1:	e8 97 2d 00 00       	call   15a7d <log_printf>
   12ce6:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: Page fault.");
   12ce9:	83 ec 0c             	sub    $0xc,%esp
   12cec:	68 00 63 01 00       	push   $0x16300
   12cf1:	e8 87 2d 00 00       	call   15a7d <log_printf>
   12cf6:	83 c4 10             	add    $0x10,%esp
    if (frame->error_code & ERR_PAGE_P) {
   12cf9:	8b 45 08             	mov    0x8(%ebp),%eax
   12cfc:	8b 40 34             	mov    0x34(%eax),%eax
   12cff:	83 e0 01             	and    $0x1,%eax
   12d02:	85 c0                	test   %eax,%eax
   12d04:	74 18                	je     12d1e <do_handler_page_fault+0x4b>
        log_printf("\tpage-level protection violation: 0x%x.", read_cr2());
   12d06:	e8 bc f8 ff ff       	call   125c7 <read_cr2>
   12d0b:	83 ec 08             	sub    $0x8,%esp
   12d0e:	50                   	push   %eax
   12d0f:	68 24 63 01 00       	push   $0x16324
   12d14:	e8 64 2d 00 00       	call   15a7d <log_printf>
   12d19:	83 c4 10             	add    $0x10,%esp
   12d1c:	eb 16                	jmp    12d34 <do_handler_page_fault+0x61>
    } else {
         log_printf("\tPage doesn't present 0x%x", read_cr2());
   12d1e:	e8 a4 f8 ff ff       	call   125c7 <read_cr2>
   12d23:	83 ec 08             	sub    $0x8,%esp
   12d26:	50                   	push   %eax
   12d27:	68 4c 63 01 00       	push   $0x1634c
   12d2c:	e8 4c 2d 00 00       	call   15a7d <log_printf>
   12d31:	83 c4 10             	add    $0x10,%esp
   }
    
    if (frame->error_code & ERR_PAGE_WR) {
   12d34:	8b 45 08             	mov    0x8(%ebp),%eax
   12d37:	8b 40 34             	mov    0x34(%eax),%eax
   12d3a:	83 e0 02             	and    $0x2,%eax
   12d3d:	85 c0                	test   %eax,%eax
   12d3f:	74 12                	je     12d53 <do_handler_page_fault+0x80>
        log_printf("\tThe access causing the fault was a read.");
   12d41:	83 ec 0c             	sub    $0xc,%esp
   12d44:	68 68 63 01 00       	push   $0x16368
   12d49:	e8 2f 2d 00 00       	call   15a7d <log_printf>
   12d4e:	83 c4 10             	add    $0x10,%esp
   12d51:	eb 10                	jmp    12d63 <do_handler_page_fault+0x90>
    } else {
        log_printf("\tThe access causing the fault was a write.");
   12d53:	83 ec 0c             	sub    $0xc,%esp
   12d56:	68 94 63 01 00       	push   $0x16394
   12d5b:	e8 1d 2d 00 00       	call   15a7d <log_printf>
   12d60:	83 c4 10             	add    $0x10,%esp
    }
    
    if (frame->error_code & ERR_PAGE_US) {
   12d63:	8b 45 08             	mov    0x8(%ebp),%eax
   12d66:	8b 40 34             	mov    0x34(%eax),%eax
   12d69:	83 e0 02             	and    $0x2,%eax
   12d6c:	85 c0                	test   %eax,%eax
   12d6e:	74 12                	je     12d82 <do_handler_page_fault+0xaf>
        log_printf("\tA supervisor-mode access caused the fault.");
   12d70:	83 ec 0c             	sub    $0xc,%esp
   12d73:	68 c0 63 01 00       	push   $0x163c0
   12d78:	e8 00 2d 00 00       	call   15a7d <log_printf>
   12d7d:	83 c4 10             	add    $0x10,%esp
   12d80:	eb 10                	jmp    12d92 <do_handler_page_fault+0xbf>
    } else {
        log_printf("\tA user-mode access caused the fault.");
   12d82:	83 ec 0c             	sub    $0xc,%esp
   12d85:	68 ec 63 01 00       	push   $0x163ec
   12d8a:	e8 ee 2c 00 00       	call   15a7d <log_printf>
   12d8f:	83 c4 10             	add    $0x10,%esp
    }

    dump_core_regs(frame);
   12d92:	83 ec 0c             	sub    $0xc,%esp
   12d95:	ff 75 08             	pushl  0x8(%ebp)
   12d98:	e8 de fb ff ff       	call   1297b <dump_core_regs>
   12d9d:	83 c4 10             	add    $0x10,%esp
    while (1) {
        hlt();
   12da0:	e8 00 f8 ff ff       	call   125a5 <hlt>
   12da5:	eb f9                	jmp    12da0 <do_handler_page_fault+0xcd>

00012da7 <do_handler_fpu_error>:
    }
}

void do_handler_fpu_error(exception_frame_t * frame) {
   12da7:	55                   	push   %ebp
   12da8:	89 e5                	mov    %esp,%ebp
   12daa:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "X87 FPU Floating Point Error.");
   12dad:	83 ec 08             	sub    $0x8,%esp
   12db0:	68 12 64 01 00       	push   $0x16412
   12db5:	ff 75 08             	pushl  0x8(%ebp)
   12db8:	e8 b6 fc ff ff       	call   12a73 <do_default_handler>
   12dbd:	83 c4 10             	add    $0x10,%esp
}
   12dc0:	90                   	nop
   12dc1:	c9                   	leave  
   12dc2:	c3                   	ret    

00012dc3 <do_handler_alignment_check>:

void do_handler_alignment_check(exception_frame_t * frame) {
   12dc3:	55                   	push   %ebp
   12dc4:	89 e5                	mov    %esp,%ebp
   12dc6:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Alignment Check.");
   12dc9:	83 ec 08             	sub    $0x8,%esp
   12dcc:	68 30 64 01 00       	push   $0x16430
   12dd1:	ff 75 08             	pushl  0x8(%ebp)
   12dd4:	e8 9a fc ff ff       	call   12a73 <do_default_handler>
   12dd9:	83 c4 10             	add    $0x10,%esp
}
   12ddc:	90                   	nop
   12ddd:	c9                   	leave  
   12dde:	c3                   	ret    

00012ddf <do_handler_machine_check>:

void do_handler_machine_check(exception_frame_t * frame) {
   12ddf:	55                   	push   %ebp
   12de0:	89 e5                	mov    %esp,%ebp
   12de2:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Machine Check.");
   12de5:	83 ec 08             	sub    $0x8,%esp
   12de8:	68 41 64 01 00       	push   $0x16441
   12ded:	ff 75 08             	pushl  0x8(%ebp)
   12df0:	e8 7e fc ff ff       	call   12a73 <do_default_handler>
   12df5:	83 c4 10             	add    $0x10,%esp
}
   12df8:	90                   	nop
   12df9:	c9                   	leave  
   12dfa:	c3                   	ret    

00012dfb <do_handler_smd_exception>:

void do_handler_smd_exception(exception_frame_t * frame) {
   12dfb:	55                   	push   %ebp
   12dfc:	89 e5                	mov    %esp,%ebp
   12dfe:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "SIMD Floating Point Exception.");
   12e01:	83 ec 08             	sub    $0x8,%esp
   12e04:	68 50 64 01 00       	push   $0x16450
   12e09:	ff 75 08             	pushl  0x8(%ebp)
   12e0c:	e8 62 fc ff ff       	call   12a73 <do_default_handler>
   12e11:	83 c4 10             	add    $0x10,%esp
}
   12e14:	90                   	nop
   12e15:	c9                   	leave  
   12e16:	c3                   	ret    

00012e17 <do_handler_virtual_exception>:

void do_handler_virtual_exception(exception_frame_t * frame) {
   12e17:	55                   	push   %ebp
   12e18:	89 e5                	mov    %esp,%ebp
   12e1a:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Virtualization Exception.");
   12e1d:	83 ec 08             	sub    $0x8,%esp
   12e20:	68 6f 64 01 00       	push   $0x1646f
   12e25:	ff 75 08             	pushl  0x8(%ebp)
   12e28:	e8 46 fc ff ff       	call   12a73 <do_default_handler>
   12e2d:	83 c4 10             	add    $0x10,%esp
}
   12e30:	90                   	nop
   12e31:	c9                   	leave  
   12e32:	c3                   	ret    

00012e33 <pic_send_eoi>:

void pic_send_eoi(int irq_num){
   12e33:	55                   	push   %ebp
   12e34:	89 e5                	mov    %esp,%ebp
	irq_num-=IRQ_PIC_START;
   12e36:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
	if(irq_num >=8){
   12e3a:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   12e3e:	7e 0f                	jle    12e4f <pic_send_eoi+0x1c>
		outb(PIC1_OCW2,PIC_OCW2_EOI);
   12e40:	6a 20                	push   $0x20
   12e42:	68 a0 00 00 00       	push   $0xa0
   12e47:	e8 12 f7 ff ff       	call   1255e <outb>
   12e4c:	83 c4 08             	add    $0x8,%esp
	}
	outb(PIC0_OCW2,PIC_OCW2_EOI);
   12e4f:	6a 20                	push   $0x20
   12e51:	6a 20                	push   $0x20
   12e53:	e8 06 f7 ff ff       	call   1255e <outb>
   12e58:	83 c4 08             	add    $0x8,%esp
}
   12e5b:	90                   	nop
   12e5c:	c9                   	leave  
   12e5d:	c3                   	ret    

00012e5e <irq_enter_protection>:

/**
 * @brief 进入临界区
 * @return 进入临界区时的状态
 */
irq_state_t irq_enter_protection(void){
   12e5e:	55                   	push   %ebp
   12e5f:	89 e5                	mov    %esp,%ebp
   12e61:	83 ec 10             	sub    $0x10,%esp
	irq_state_t state=read_eflags();
   12e64:	e8 43 f7 ff ff       	call   125ac <read_eflags>
   12e69:	89 45 fc             	mov    %eax,-0x4(%ebp)
	irq_disable_global();
   12e6c:	e8 fa f7 ff ff       	call   1266b <irq_disable_global>
	return state;
   12e71:	8b 45 fc             	mov    -0x4(%ebp),%eax
	
}
   12e74:	c9                   	leave  
   12e75:	c3                   	ret    

00012e76 <irq_leave_protection>:

/**
 * @brief 退出临界区
 * @param state 进入临界区时的状态
 */
void irq_leave_protection(irq_state_t state){
   12e76:	55                   	push   %ebp
   12e77:	89 e5                	mov    %esp,%ebp
	write_eflags(state);
   12e79:	ff 75 08             	pushl  0x8(%ebp)
   12e7c:	e8 3b f7 ff ff       	call   125bc <write_eflags>
   12e81:	83 c4 04             	add    $0x4,%esp
}
   12e84:	90                   	nop
   12e85:	c9                   	leave  
   12e86:	c3                   	ret    

00012e87 <inb>:
static inline uint8_t inb(uint16_t port){
   12e87:	55                   	push   %ebp
   12e88:	89 e5                	mov    %esp,%ebp
   12e8a:	83 ec 14             	sub    $0x14,%esp
   12e8d:	8b 45 08             	mov    0x8(%ebp),%eax
   12e90:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   12e94:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   12e98:	89 c2                	mov    %eax,%edx
   12e9a:	ec                   	in     (%dx),%al
   12e9b:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   12e9e:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   12ea2:	c9                   	leave  
   12ea3:	c3                   	ret    

00012ea4 <outb>:
static inline void outb(uint16_t port,uint8_t data){
   12ea4:	55                   	push   %ebp
   12ea5:	89 e5                	mov    %esp,%ebp
   12ea7:	83 ec 08             	sub    $0x8,%esp
   12eaa:	8b 55 08             	mov    0x8(%ebp),%edx
   12ead:	8b 45 0c             	mov    0xc(%ebp),%eax
   12eb0:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   12eb4:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   12eb7:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12ebb:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   12ebf:	ee                   	out    %al,(%dx)
}
   12ec0:	90                   	nop
   12ec1:	c9                   	leave  
   12ec2:	c3                   	ret    

00012ec3 <read_cursor_pos>:

/**
 * @brief 读取光标位置
 * @return 光标位置
*/
static int read_cursor_pos(void){
   12ec3:	55                   	push   %ebp
   12ec4:	89 e5                	mov    %esp,%ebp
   12ec6:	83 ec 18             	sub    $0x18,%esp
    int pos;

    irq_state_t state=irq_enter_protection();
   12ec9:	e8 90 ff ff ff       	call   12e5e <irq_enter_protection>
   12ece:	89 45 f4             	mov    %eax,-0xc(%ebp)

    outb(0x3D4,0xF);
   12ed1:	83 ec 08             	sub    $0x8,%esp
   12ed4:	6a 0f                	push   $0xf
   12ed6:	68 d4 03 00 00       	push   $0x3d4
   12edb:	e8 c4 ff ff ff       	call   12ea4 <outb>
   12ee0:	83 c4 10             	add    $0x10,%esp
    pos=inb(0x3d5);
   12ee3:	83 ec 0c             	sub    $0xc,%esp
   12ee6:	68 d5 03 00 00       	push   $0x3d5
   12eeb:	e8 97 ff ff ff       	call   12e87 <inb>
   12ef0:	83 c4 10             	add    $0x10,%esp
   12ef3:	0f b6 c0             	movzbl %al,%eax
   12ef6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    outb(0x3D4,0xE);
   12ef9:	83 ec 08             	sub    $0x8,%esp
   12efc:	6a 0e                	push   $0xe
   12efe:	68 d4 03 00 00       	push   $0x3d4
   12f03:	e8 9c ff ff ff       	call   12ea4 <outb>
   12f08:	83 c4 10             	add    $0x10,%esp
    pos |= inb(0x3d5) << 8;
   12f0b:	83 ec 0c             	sub    $0xc,%esp
   12f0e:	68 d5 03 00 00       	push   $0x3d5
   12f13:	e8 6f ff ff ff       	call   12e87 <inb>
   12f18:	83 c4 10             	add    $0x10,%esp
   12f1b:	0f b6 c0             	movzbl %al,%eax
   12f1e:	c1 e0 08             	shl    $0x8,%eax
   12f21:	09 45 f0             	or     %eax,-0x10(%ebp)

    irq_leave_protection(state);
   12f24:	83 ec 0c             	sub    $0xc,%esp
   12f27:	ff 75 f4             	pushl  -0xc(%ebp)
   12f2a:	e8 47 ff ff ff       	call   12e76 <irq_leave_protection>
   12f2f:	83 c4 10             	add    $0x10,%esp
    return pos;
   12f32:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   12f35:	c9                   	leave  
   12f36:	c3                   	ret    

00012f37 <update_cursor_pos>:

/**
 * @brief 更新光标位置
 * @param console 要更新光标的console
*/
static int update_cursor_pos(console_t* console){
   12f37:	55                   	push   %ebp
   12f38:	89 e5                	mov    %esp,%ebp
   12f3a:	83 ec 18             	sub    $0x18,%esp
    int pos = (console - console_buf)*console->display_cols*console->display_rows;
   12f3d:	8b 45 08             	mov    0x8(%ebp),%eax
   12f40:	ba 00 26 03 00       	mov    $0x32600,%edx
   12f45:	29 d0                	sub    %edx,%eax
   12f47:	c1 f8 02             	sar    $0x2,%eax
   12f4a:	69 c0 3d cf f3 3c    	imul   $0x3cf3cf3d,%eax,%eax
   12f50:	89 c2                	mov    %eax,%edx
   12f52:	8b 45 08             	mov    0x8(%ebp),%eax
   12f55:	8b 40 14             	mov    0x14(%eax),%eax
   12f58:	0f af d0             	imul   %eax,%edx
   12f5b:	8b 45 08             	mov    0x8(%ebp),%eax
   12f5e:	8b 40 10             	mov    0x10(%eax),%eax
   12f61:	0f af c2             	imul   %edx,%eax
   12f64:	89 45 f4             	mov    %eax,-0xc(%ebp)
    pos += console->cursor_row * console->display_cols + console->cursor_col;
   12f67:	8b 45 08             	mov    0x8(%ebp),%eax
   12f6a:	8b 50 08             	mov    0x8(%eax),%edx
   12f6d:	8b 45 08             	mov    0x8(%ebp),%eax
   12f70:	8b 40 14             	mov    0x14(%eax),%eax
   12f73:	0f af d0             	imul   %eax,%edx
   12f76:	8b 45 08             	mov    0x8(%ebp),%eax
   12f79:	8b 40 0c             	mov    0xc(%eax),%eax
   12f7c:	01 d0                	add    %edx,%eax
   12f7e:	01 45 f4             	add    %eax,-0xc(%ebp)

    irq_state_t state=irq_enter_protection();
   12f81:	e8 d8 fe ff ff       	call   12e5e <irq_enter_protection>
   12f86:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // 0xE和0xF分别是光标的高8位和低8位寄存器
    outb(0x3D4,0xF);
   12f89:	83 ec 08             	sub    $0x8,%esp
   12f8c:	6a 0f                	push   $0xf
   12f8e:	68 d4 03 00 00       	push   $0x3d4
   12f93:	e8 0c ff ff ff       	call   12ea4 <outb>
   12f98:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5,(uint8_t)(pos & 0xFF));
   12f9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12f9e:	0f b6 c0             	movzbl %al,%eax
   12fa1:	83 ec 08             	sub    $0x8,%esp
   12fa4:	50                   	push   %eax
   12fa5:	68 d5 03 00 00       	push   $0x3d5
   12faa:	e8 f5 fe ff ff       	call   12ea4 <outb>
   12faf:	83 c4 10             	add    $0x10,%esp
    outb(0x3D4,0xE);
   12fb2:	83 ec 08             	sub    $0x8,%esp
   12fb5:	6a 0e                	push   $0xe
   12fb7:	68 d4 03 00 00       	push   $0x3d4
   12fbc:	e8 e3 fe ff ff       	call   12ea4 <outb>
   12fc1:	83 c4 10             	add    $0x10,%esp
    outb(0x3D5,(uint8_t)((pos >> 8) & 0xFF));
   12fc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12fc7:	c1 f8 08             	sar    $0x8,%eax
   12fca:	0f b6 c0             	movzbl %al,%eax
   12fcd:	83 ec 08             	sub    $0x8,%esp
   12fd0:	50                   	push   %eax
   12fd1:	68 d5 03 00 00       	push   $0x3d5
   12fd6:	e8 c9 fe ff ff       	call   12ea4 <outb>
   12fdb:	83 c4 10             	add    $0x10,%esp

    irq_leave_protection(state);
   12fde:	83 ec 0c             	sub    $0xc,%esp
   12fe1:	ff 75 f0             	pushl  -0x10(%ebp)
   12fe4:	e8 8d fe ff ff       	call   12e76 <irq_leave_protection>
   12fe9:	83 c4 10             	add    $0x10,%esp

    return pos;
   12fec:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   12fef:	c9                   	leave  
   12ff0:	c3                   	ret    

00012ff1 <erase_rows>:

static void erase_rows(console_t*console,int start,int end){
   12ff1:	55                   	push   %ebp
   12ff2:	89 e5                	mov    %esp,%ebp
   12ff4:	83 ec 10             	sub    $0x10,%esp
    disp_char_t* disp_start=console->disp_base+console->display_cols*start;
   12ff7:	8b 45 08             	mov    0x8(%ebp),%eax
   12ffa:	8b 50 04             	mov    0x4(%eax),%edx
   12ffd:	8b 45 08             	mov    0x8(%ebp),%eax
   13000:	8b 40 14             	mov    0x14(%eax),%eax
   13003:	0f af 45 0c          	imul   0xc(%ebp),%eax
   13007:	01 c0                	add    %eax,%eax
   13009:	01 d0                	add    %edx,%eax
   1300b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    disp_char_t* disp_end=console->disp_base+console->display_cols*(end+1);
   1300e:	8b 45 08             	mov    0x8(%ebp),%eax
   13011:	8b 50 04             	mov    0x4(%eax),%edx
   13014:	8b 45 08             	mov    0x8(%ebp),%eax
   13017:	8b 40 14             	mov    0x14(%eax),%eax
   1301a:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1301d:	83 c1 01             	add    $0x1,%ecx
   13020:	0f af c1             	imul   %ecx,%eax
   13023:	01 c0                	add    %eax,%eax
   13025:	01 d0                	add    %edx,%eax
   13027:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while(disp_start < disp_end){
   1302a:	eb 4d                	jmp    13079 <erase_rows+0x88>
        disp_start->c=' ';
   1302c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1302f:	c6 00 20             	movb   $0x20,(%eax)
        disp_start->foreground=console->foreground;
   13032:	8b 45 08             	mov    0x8(%ebp),%eax
   13035:	8b 40 18             	mov    0x18(%eax),%eax
   13038:	c1 e0 04             	shl    $0x4,%eax
   1303b:	c0 f8 04             	sar    $0x4,%al
   1303e:	8b 55 fc             	mov    -0x4(%ebp),%edx
   13041:	83 e0 0f             	and    $0xf,%eax
   13044:	89 c1                	mov    %eax,%ecx
   13046:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   1304a:	83 e0 f0             	and    $0xfffffff0,%eax
   1304d:	09 c8                	or     %ecx,%eax
   1304f:	88 42 01             	mov    %al,0x1(%edx)
        disp_start->background=console->background;
   13052:	8b 45 08             	mov    0x8(%ebp),%eax
   13055:	8b 40 1c             	mov    0x1c(%eax),%eax
   13058:	c1 e0 05             	shl    $0x5,%eax
   1305b:	c0 f8 05             	sar    $0x5,%al
   1305e:	8b 55 fc             	mov    -0x4(%ebp),%edx
   13061:	83 e0 07             	and    $0x7,%eax
   13064:	c1 e0 04             	shl    $0x4,%eax
   13067:	89 c1                	mov    %eax,%ecx
   13069:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   1306d:	83 e0 8f             	and    $0xffffff8f,%eax
   13070:	09 c8                	or     %ecx,%eax
   13072:	88 42 01             	mov    %al,0x1(%edx)

        disp_start++;
   13075:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
    while(disp_start < disp_end){
   13079:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1307c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   1307f:	72 ab                	jb     1302c <erase_rows+0x3b>
    }
}
   13081:	90                   	nop
   13082:	c9                   	leave  
   13083:	c3                   	ret    

00013084 <scroll_up>:

static void scroll_up(console_t* console,int lines){
   13084:	55                   	push   %ebp
   13085:	89 e5                	mov    %esp,%ebp
   13087:	83 ec 18             	sub    $0x18,%esp
    disp_char_t* dest=console->disp_base;
   1308a:	8b 45 08             	mov    0x8(%ebp),%eax
   1308d:	8b 40 04             	mov    0x4(%eax),%eax
   13090:	89 45 f4             	mov    %eax,-0xc(%ebp)
    disp_char_t* src=console->disp_base+console->display_cols*lines;
   13093:	8b 45 08             	mov    0x8(%ebp),%eax
   13096:	8b 50 04             	mov    0x4(%eax),%edx
   13099:	8b 45 08             	mov    0x8(%ebp),%eax
   1309c:	8b 40 14             	mov    0x14(%eax),%eax
   1309f:	0f af 45 0c          	imul   0xc(%ebp),%eax
   130a3:	01 c0                	add    %eax,%eax
   130a5:	01 d0                	add    %edx,%eax
   130a7:	89 45 f0             	mov    %eax,-0x10(%ebp)

    uint32_t size=(console->display_rows-lines)*console->display_cols*sizeof(disp_char_t);
   130aa:	8b 45 08             	mov    0x8(%ebp),%eax
   130ad:	8b 40 10             	mov    0x10(%eax),%eax
   130b0:	2b 45 0c             	sub    0xc(%ebp),%eax
   130b3:	89 c2                	mov    %eax,%edx
   130b5:	8b 45 08             	mov    0x8(%ebp),%eax
   130b8:	8b 40 14             	mov    0x14(%eax),%eax
   130bb:	0f af c2             	imul   %edx,%eax
   130be:	01 c0                	add    %eax,%eax
   130c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    kernel_memcpy(dest,src,size);
   130c3:	83 ec 04             	sub    $0x4,%esp
   130c6:	ff 75 ec             	pushl  -0x14(%ebp)
   130c9:	ff 75 f0             	pushl  -0x10(%ebp)
   130cc:	ff 75 f4             	pushl  -0xc(%ebp)
   130cf:	e8 37 23 00 00       	call   1540b <kernel_memcpy>
   130d4:	83 c4 10             	add    $0x10,%esp

    erase_rows(console,console->display_rows-lines,console->display_rows-1);
   130d7:	8b 45 08             	mov    0x8(%ebp),%eax
   130da:	8b 40 10             	mov    0x10(%eax),%eax
   130dd:	8d 50 ff             	lea    -0x1(%eax),%edx
   130e0:	8b 45 08             	mov    0x8(%ebp),%eax
   130e3:	8b 40 10             	mov    0x10(%eax),%eax
   130e6:	2b 45 0c             	sub    0xc(%ebp),%eax
   130e9:	83 ec 04             	sub    $0x4,%esp
   130ec:	52                   	push   %edx
   130ed:	50                   	push   %eax
   130ee:	ff 75 08             	pushl  0x8(%ebp)
   130f1:	e8 fb fe ff ff       	call   12ff1 <erase_rows>
   130f6:	83 c4 10             	add    $0x10,%esp
    console->cursor_row-=lines;
   130f9:	8b 45 08             	mov    0x8(%ebp),%eax
   130fc:	8b 40 08             	mov    0x8(%eax),%eax
   130ff:	2b 45 0c             	sub    0xc(%ebp),%eax
   13102:	89 c2                	mov    %eax,%edx
   13104:	8b 45 08             	mov    0x8(%ebp),%eax
   13107:	89 50 08             	mov    %edx,0x8(%eax)
}
   1310a:	90                   	nop
   1310b:	c9                   	leave  
   1310c:	c3                   	ret    

0001310d <clear_display>:

static void clear_display(console_t*console){
   1310d:	55                   	push   %ebp
   1310e:	89 e5                	mov    %esp,%ebp
   13110:	83 ec 10             	sub    $0x10,%esp
    int size=console->display_cols*console->display_rows;
   13113:	8b 45 08             	mov    0x8(%ebp),%eax
   13116:	8b 50 14             	mov    0x14(%eax),%edx
   13119:	8b 45 08             	mov    0x8(%ebp),%eax
   1311c:	8b 40 10             	mov    0x10(%eax),%eax
   1311f:	0f af c2             	imul   %edx,%eax
   13122:	89 45 f4             	mov    %eax,-0xc(%ebp)

    disp_char_t* start=console->disp_base;
   13125:	8b 45 08             	mov    0x8(%ebp),%eax
   13128:	8b 40 04             	mov    0x4(%eax),%eax
   1312b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    for(int i=0;i<size;i++,start++){
   1312e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   13135:	eb 51                	jmp    13188 <clear_display+0x7b>
        start->c=' ';
   13137:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1313a:	c6 00 20             	movb   $0x20,(%eax)
        start->foreground=console->foreground;
   1313d:	8b 45 08             	mov    0x8(%ebp),%eax
   13140:	8b 40 18             	mov    0x18(%eax),%eax
   13143:	c1 e0 04             	shl    $0x4,%eax
   13146:	c0 f8 04             	sar    $0x4,%al
   13149:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1314c:	83 e0 0f             	and    $0xf,%eax
   1314f:	89 c1                	mov    %eax,%ecx
   13151:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   13155:	83 e0 f0             	and    $0xfffffff0,%eax
   13158:	09 c8                	or     %ecx,%eax
   1315a:	88 42 01             	mov    %al,0x1(%edx)
        start->background=console->background; 
   1315d:	8b 45 08             	mov    0x8(%ebp),%eax
   13160:	8b 40 1c             	mov    0x1c(%eax),%eax
   13163:	c1 e0 05             	shl    $0x5,%eax
   13166:	c0 f8 05             	sar    $0x5,%al
   13169:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1316c:	83 e0 07             	and    $0x7,%eax
   1316f:	c1 e0 04             	shl    $0x4,%eax
   13172:	89 c1                	mov    %eax,%ecx
   13174:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   13178:	83 e0 8f             	and    $0xffffff8f,%eax
   1317b:	09 c8                	or     %ecx,%eax
   1317d:	88 42 01             	mov    %al,0x1(%edx)
    for(int i=0;i<size;i++,start++){
   13180:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   13184:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   13188:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1318b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1318e:	7c a7                	jl     13137 <clear_display+0x2a>
    }
}
   13190:	90                   	nop
   13191:	c9                   	leave  
   13192:	c3                   	ret    

00013193 <move_to_col0>:

static void move_to_col0(console_t* console){
   13193:	55                   	push   %ebp
   13194:	89 e5                	mov    %esp,%ebp
    console->cursor_col=0;
   13196:	8b 45 08             	mov    0x8(%ebp),%eax
   13199:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
   131a0:	90                   	nop
   131a1:	5d                   	pop    %ebp
   131a2:	c3                   	ret    

000131a3 <move_next_line>:

static void move_next_line(console_t*console){
   131a3:	55                   	push   %ebp
   131a4:	89 e5                	mov    %esp,%ebp
   131a6:	83 ec 08             	sub    $0x8,%esp
    console->cursor_row++;
   131a9:	8b 45 08             	mov    0x8(%ebp),%eax
   131ac:	8b 40 08             	mov    0x8(%eax),%eax
   131af:	8d 50 01             	lea    0x1(%eax),%edx
   131b2:	8b 45 08             	mov    0x8(%ebp),%eax
   131b5:	89 50 08             	mov    %edx,0x8(%eax)
    if(console->cursor_row >= console->display_rows){
   131b8:	8b 45 08             	mov    0x8(%ebp),%eax
   131bb:	8b 50 08             	mov    0x8(%eax),%edx
   131be:	8b 45 08             	mov    0x8(%ebp),%eax
   131c1:	8b 40 10             	mov    0x10(%eax),%eax
   131c4:	39 c2                	cmp    %eax,%edx
   131c6:	7c 10                	jl     131d8 <move_next_line+0x35>
        scroll_up(console,1);
   131c8:	83 ec 08             	sub    $0x8,%esp
   131cb:	6a 01                	push   $0x1
   131cd:	ff 75 08             	pushl  0x8(%ebp)
   131d0:	e8 af fe ff ff       	call   13084 <scroll_up>
   131d5:	83 c4 10             	add    $0x10,%esp
    }
}
   131d8:	90                   	nop
   131d9:	c9                   	leave  
   131da:	c3                   	ret    

000131db <move_forward>:

static void move_forward(console_t* console,int n){
   131db:	55                   	push   %ebp
   131dc:	89 e5                	mov    %esp,%ebp
   131de:	83 ec 18             	sub    $0x18,%esp
    for(int i=0;i<n;i++){
   131e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   131e8:	eb 5c                	jmp    13246 <move_forward+0x6b>
        if(++console->cursor_col >= console->display_cols){
   131ea:	8b 45 08             	mov    0x8(%ebp),%eax
   131ed:	8b 40 0c             	mov    0xc(%eax),%eax
   131f0:	8d 50 01             	lea    0x1(%eax),%edx
   131f3:	8b 45 08             	mov    0x8(%ebp),%eax
   131f6:	89 50 0c             	mov    %edx,0xc(%eax)
   131f9:	8b 45 08             	mov    0x8(%ebp),%eax
   131fc:	8b 50 0c             	mov    0xc(%eax),%edx
   131ff:	8b 45 08             	mov    0x8(%ebp),%eax
   13202:	8b 40 14             	mov    0x14(%eax),%eax
   13205:	39 c2                	cmp    %eax,%edx
   13207:	7c 39                	jl     13242 <move_forward+0x67>
            console->cursor_row++;
   13209:	8b 45 08             	mov    0x8(%ebp),%eax
   1320c:	8b 40 08             	mov    0x8(%eax),%eax
   1320f:	8d 50 01             	lea    0x1(%eax),%edx
   13212:	8b 45 08             	mov    0x8(%ebp),%eax
   13215:	89 50 08             	mov    %edx,0x8(%eax)
            console->cursor_col=0;
   13218:	8b 45 08             	mov    0x8(%ebp),%eax
   1321b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            
            if(console->cursor_row >= console->display_rows){
   13222:	8b 45 08             	mov    0x8(%ebp),%eax
   13225:	8b 50 08             	mov    0x8(%eax),%edx
   13228:	8b 45 08             	mov    0x8(%ebp),%eax
   1322b:	8b 40 10             	mov    0x10(%eax),%eax
   1322e:	39 c2                	cmp    %eax,%edx
   13230:	7c 10                	jl     13242 <move_forward+0x67>
                scroll_up(console,1);
   13232:	83 ec 08             	sub    $0x8,%esp
   13235:	6a 01                	push   $0x1
   13237:	ff 75 08             	pushl  0x8(%ebp)
   1323a:	e8 45 fe ff ff       	call   13084 <scroll_up>
   1323f:	83 c4 10             	add    $0x10,%esp
    for(int i=0;i<n;i++){
   13242:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   13246:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13249:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1324c:	7c 9c                	jl     131ea <move_forward+0xf>
            }
        }
    }
}
   1324e:	90                   	nop
   1324f:	c9                   	leave  
   13250:	c3                   	ret    

00013251 <move_backword>:

static int move_backword(console_t* console,int n){
   13251:	55                   	push   %ebp
   13252:	89 e5                	mov    %esp,%ebp
   13254:	83 ec 10             	sub    $0x10,%esp
    int status=-1;
   13257:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
    for(int i=0;i<n;i++){
   1325e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   13265:	eb 55                	jmp    132bc <move_backword+0x6b>
        if(console->cursor_col > 0){
   13267:	8b 45 08             	mov    0x8(%ebp),%eax
   1326a:	8b 40 0c             	mov    0xc(%eax),%eax
   1326d:	85 c0                	test   %eax,%eax
   1326f:	7e 18                	jle    13289 <move_backword+0x38>
            console->cursor_col--;
   13271:	8b 45 08             	mov    0x8(%ebp),%eax
   13274:	8b 40 0c             	mov    0xc(%eax),%eax
   13277:	8d 50 ff             	lea    -0x1(%eax),%edx
   1327a:	8b 45 08             	mov    0x8(%ebp),%eax
   1327d:	89 50 0c             	mov    %edx,0xc(%eax)
            status=0;
   13280:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   13287:	eb 2f                	jmp    132b8 <move_backword+0x67>
        }
        else if(console->cursor_row > 0){
   13289:	8b 45 08             	mov    0x8(%ebp),%eax
   1328c:	8b 40 08             	mov    0x8(%eax),%eax
   1328f:	85 c0                	test   %eax,%eax
   13291:	7e 25                	jle    132b8 <move_backword+0x67>
            console->cursor_row--;
   13293:	8b 45 08             	mov    0x8(%ebp),%eax
   13296:	8b 40 08             	mov    0x8(%eax),%eax
   13299:	8d 50 ff             	lea    -0x1(%eax),%edx
   1329c:	8b 45 08             	mov    0x8(%ebp),%eax
   1329f:	89 50 08             	mov    %edx,0x8(%eax)
            console->cursor_col=console->display_cols-1;
   132a2:	8b 45 08             	mov    0x8(%ebp),%eax
   132a5:	8b 40 14             	mov    0x14(%eax),%eax
   132a8:	8d 50 ff             	lea    -0x1(%eax),%edx
   132ab:	8b 45 08             	mov    0x8(%ebp),%eax
   132ae:	89 50 0c             	mov    %edx,0xc(%eax)
            status=0;
   132b1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for(int i=0;i<n;i++){
   132b8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   132bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
   132bf:	3b 45 0c             	cmp    0xc(%ebp),%eax
   132c2:	7c a3                	jl     13267 <move_backword+0x16>
        }

    }
    
    return status;
   132c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   132c7:	c9                   	leave  
   132c8:	c3                   	ret    

000132c9 <console_init>:


int console_init(int idx){
   132c9:	55                   	push   %ebp
   132ca:	89 e5                	mov    %esp,%ebp
   132cc:	83 ec 18             	sub    $0x18,%esp

    console_t* console=console_buf+idx;
   132cf:	8b 45 08             	mov    0x8(%ebp),%eax
   132d2:	6b c0 54             	imul   $0x54,%eax,%eax
   132d5:	05 00 26 03 00       	add    $0x32600,%eax
   132da:	89 45 f4             	mov    %eax,-0xc(%ebp)

    console->display_cols=CONSOLE_COL_MAX;
   132dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   132e0:	c7 40 14 50 00 00 00 	movl   $0x50,0x14(%eax)
    console->display_rows=CONSOLE_ROW_MAX;
   132e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   132ea:	c7 40 10 19 00 00 00 	movl   $0x19,0x10(%eax)
    console->disp_base=(disp_char_t*)CONSOLE_DISP_ADDR+idx*(CONSOLE_COL_MAX*CONSOLE_ROW_MAX);
   132f1:	8b 45 08             	mov    0x8(%ebp),%eax
   132f4:	69 c0 a0 0f 00 00    	imul   $0xfa0,%eax,%eax
   132fa:	8d 90 00 80 0b 00    	lea    0xb8000(%eax),%edx
   13300:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13303:	89 50 04             	mov    %edx,0x4(%eax)

    console->foreground=WHITE;
   13306:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13309:	c7 40 18 0f 00 00 00 	movl   $0xf,0x18(%eax)
    console->background=BLACK;
   13310:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13313:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

    if(idx==0){
   1331a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1331e:	75 30                	jne    13350 <console_init+0x87>
        int cursor_pos=read_cursor_pos();
   13320:	e8 9e fb ff ff       	call   12ec3 <read_cursor_pos>
   13325:	89 45 f0             	mov    %eax,-0x10(%ebp)
        console->cursor_row=cursor_pos / console->display_cols;        
   13328:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1332b:	8b 48 14             	mov    0x14(%eax),%ecx
   1332e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13331:	99                   	cltd   
   13332:	f7 f9                	idiv   %ecx
   13334:	89 c2                	mov    %eax,%edx
   13336:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13339:	89 50 08             	mov    %edx,0x8(%eax)
        console->cursor_col=cursor_pos % console->display_cols;
   1333c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1333f:	8b 48 14             	mov    0x14(%eax),%ecx
   13342:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13345:	99                   	cltd   
   13346:	f7 f9                	idiv   %ecx
   13348:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1334b:	89 50 0c             	mov    %edx,0xc(%eax)
   1334e:	eb 22                	jmp    13372 <console_init+0xa9>
    }
    else{
        console->cursor_row=0;
   13350:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13353:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        console->cursor_col=0;
   1335a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1335d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
        clear_display(console);
   13364:	83 ec 0c             	sub    $0xc,%esp
   13367:	ff 75 f4             	pushl  -0xc(%ebp)
   1336a:	e8 9e fd ff ff       	call   1310d <clear_display>
   1336f:	83 c4 10             	add    $0x10,%esp
    }

    console->old_cursor_col=console->cursor_col;
   13372:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13375:	8b 50 0c             	mov    0xc(%eax),%edx
   13378:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1337b:	89 50 20             	mov    %edx,0x20(%eax)
    console->old_cursor_row=console->cursor_row;
   1337e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13381:	8b 50 08             	mov    0x8(%eax),%edx
   13384:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13387:	89 50 24             	mov    %edx,0x24(%eax)

    console->write_state=CONSOLE_WRITE_NORMAL; 
   1338a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1338d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    return 0;
   13393:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13398:	c9                   	leave  
   13399:	c3                   	ret    

0001339a <show_char>:

static void show_char(console_t* console,char c){
   1339a:	55                   	push   %ebp
   1339b:	89 e5                	mov    %esp,%ebp
   1339d:	83 ec 28             	sub    $0x28,%esp
   133a0:	8b 45 0c             	mov    0xc(%ebp),%eax
   133a3:	88 45 e4             	mov    %al,-0x1c(%ebp)
    int offset=console->cursor_col+console->cursor_row*console->display_cols;
   133a6:	8b 45 08             	mov    0x8(%ebp),%eax
   133a9:	8b 50 0c             	mov    0xc(%eax),%edx
   133ac:	8b 45 08             	mov    0x8(%ebp),%eax
   133af:	8b 48 08             	mov    0x8(%eax),%ecx
   133b2:	8b 45 08             	mov    0x8(%ebp),%eax
   133b5:	8b 40 14             	mov    0x14(%eax),%eax
   133b8:	0f af c1             	imul   %ecx,%eax
   133bb:	01 d0                	add    %edx,%eax
   133bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    disp_char_t* p=console->disp_base+offset;
   133c0:	8b 45 08             	mov    0x8(%ebp),%eax
   133c3:	8b 40 04             	mov    0x4(%eax),%eax
   133c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
   133c9:	01 d2                	add    %edx,%edx
   133cb:	01 d0                	add    %edx,%eax
   133cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
    p->c=c;
   133d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   133d3:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
   133d7:	88 10                	mov    %dl,(%eax)
    p->foreground=console->foreground;
   133d9:	8b 45 08             	mov    0x8(%ebp),%eax
   133dc:	8b 40 18             	mov    0x18(%eax),%eax
   133df:	c1 e0 04             	shl    $0x4,%eax
   133e2:	c0 f8 04             	sar    $0x4,%al
   133e5:	8b 55 f0             	mov    -0x10(%ebp),%edx
   133e8:	83 e0 0f             	and    $0xf,%eax
   133eb:	89 c1                	mov    %eax,%ecx
   133ed:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   133f1:	83 e0 f0             	and    $0xfffffff0,%eax
   133f4:	09 c8                	or     %ecx,%eax
   133f6:	88 42 01             	mov    %al,0x1(%edx)
    p->background=console->background;
   133f9:	8b 45 08             	mov    0x8(%ebp),%eax
   133fc:	8b 40 1c             	mov    0x1c(%eax),%eax
   133ff:	c1 e0 05             	shl    $0x5,%eax
   13402:	c0 f8 05             	sar    $0x5,%al
   13405:	8b 55 f0             	mov    -0x10(%ebp),%edx
   13408:	83 e0 07             	and    $0x7,%eax
   1340b:	c1 e0 04             	shl    $0x4,%eax
   1340e:	89 c1                	mov    %eax,%ecx
   13410:	0f b6 42 01          	movzbl 0x1(%edx),%eax
   13414:	83 e0 8f             	and    $0xffffff8f,%eax
   13417:	09 c8                	or     %ecx,%eax
   13419:	88 42 01             	mov    %al,0x1(%edx)
    move_forward(console,1);
   1341c:	83 ec 08             	sub    $0x8,%esp
   1341f:	6a 01                	push   $0x1
   13421:	ff 75 08             	pushl  0x8(%ebp)
   13424:	e8 b2 fd ff ff       	call   131db <move_forward>
   13429:	83 c4 10             	add    $0x10,%esp
}
   1342c:	90                   	nop
   1342d:	c9                   	leave  
   1342e:	c3                   	ret    

0001342f <erase_backword>:

static void erase_backword(console_t*console){
   1342f:	55                   	push   %ebp
   13430:	89 e5                	mov    %esp,%ebp
   13432:	83 ec 08             	sub    $0x8,%esp
    if(move_backword(console,1)==0){
   13435:	6a 01                	push   $0x1
   13437:	ff 75 08             	pushl  0x8(%ebp)
   1343a:	e8 12 fe ff ff       	call   13251 <move_backword>
   1343f:	83 c4 08             	add    $0x8,%esp
   13442:	85 c0                	test   %eax,%eax
   13444:	75 20                	jne    13466 <erase_backword+0x37>
        show_char(console,' ');
   13446:	83 ec 08             	sub    $0x8,%esp
   13449:	6a 20                	push   $0x20
   1344b:	ff 75 08             	pushl  0x8(%ebp)
   1344e:	e8 47 ff ff ff       	call   1339a <show_char>
   13453:	83 c4 10             	add    $0x10,%esp
        move_backword(console,1);
   13456:	83 ec 08             	sub    $0x8,%esp
   13459:	6a 01                	push   $0x1
   1345b:	ff 75 08             	pushl  0x8(%ebp)
   1345e:	e8 ee fd ff ff       	call   13251 <move_backword>
   13463:	83 c4 10             	add    $0x10,%esp
    }

}
   13466:	90                   	nop
   13467:	c9                   	leave  
   13468:	c3                   	ret    

00013469 <save_cursor>:

static void save_cursor(console_t* console){
   13469:	55                   	push   %ebp
   1346a:	89 e5                	mov    %esp,%ebp
    console->old_cursor_col=console->cursor_col;
   1346c:	8b 45 08             	mov    0x8(%ebp),%eax
   1346f:	8b 50 0c             	mov    0xc(%eax),%edx
   13472:	8b 45 08             	mov    0x8(%ebp),%eax
   13475:	89 50 20             	mov    %edx,0x20(%eax)
    console->old_cursor_row=console->cursor_row;
   13478:	8b 45 08             	mov    0x8(%ebp),%eax
   1347b:	8b 50 08             	mov    0x8(%eax),%edx
   1347e:	8b 45 08             	mov    0x8(%ebp),%eax
   13481:	89 50 24             	mov    %edx,0x24(%eax)
}
   13484:	90                   	nop
   13485:	5d                   	pop    %ebp
   13486:	c3                   	ret    

00013487 <restore_cursor>:

static void restore_cursor(console_t* console){
   13487:	55                   	push   %ebp
   13488:	89 e5                	mov    %esp,%ebp
    console->cursor_col=console->old_cursor_col;
   1348a:	8b 45 08             	mov    0x8(%ebp),%eax
   1348d:	8b 50 20             	mov    0x20(%eax),%edx
   13490:	8b 45 08             	mov    0x8(%ebp),%eax
   13493:	89 50 0c             	mov    %edx,0xc(%eax)
    console->cursor_row=console->old_cursor_row;
   13496:	8b 45 08             	mov    0x8(%ebp),%eax
   13499:	8b 50 24             	mov    0x24(%eax),%edx
   1349c:	8b 45 08             	mov    0x8(%ebp),%eax
   1349f:	89 50 08             	mov    %edx,0x8(%eax)
}
   134a2:	90                   	nop
   134a3:	5d                   	pop    %ebp
   134a4:	c3                   	ret    

000134a5 <clear_esc_param>:

static void clear_esc_param(console_t* console){
   134a5:	55                   	push   %ebp
   134a6:	89 e5                	mov    %esp,%ebp
   134a8:	83 ec 08             	sub    $0x8,%esp
    kernel_memset(console->esc_param,0,sizeof(console->esc_param));
   134ab:	8b 45 08             	mov    0x8(%ebp),%eax
   134ae:	83 c0 28             	add    $0x28,%eax
   134b1:	83 ec 04             	sub    $0x4,%esp
   134b4:	6a 28                	push   $0x28
   134b6:	6a 00                	push   $0x0
   134b8:	50                   	push   %eax
   134b9:	e8 9c 1f 00 00       	call   1545a <kernel_memset>
   134be:	83 c4 10             	add    $0x10,%esp
    console->curr_param_index=0;
   134c1:	8b 45 08             	mov    0x8(%ebp),%eax
   134c4:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
}
   134cb:	90                   	nop
   134cc:	c9                   	leave  
   134cd:	c3                   	ret    

000134ce <write_esc>:

static void write_esc(console_t* console,char c){
   134ce:	55                   	push   %ebp
   134cf:	89 e5                	mov    %esp,%ebp
   134d1:	83 ec 18             	sub    $0x18,%esp
   134d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   134d7:	88 45 f4             	mov    %al,-0xc(%ebp)
    switch (c)
   134da:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   134de:	83 f8 38             	cmp    $0x38,%eax
   134e1:	74 20                	je     13503 <write_esc+0x35>
   134e3:	83 f8 5b             	cmp    $0x5b,%eax
   134e6:	74 31                	je     13519 <write_esc+0x4b>
   134e8:	83 f8 37             	cmp    $0x37,%eax
   134eb:	75 45                	jne    13532 <write_esc+0x64>
    {
    case '7':
        save_cursor(console);
   134ed:	ff 75 08             	pushl  0x8(%ebp)
   134f0:	e8 74 ff ff ff       	call   13469 <save_cursor>
   134f5:	83 c4 04             	add    $0x4,%esp
        console->write_state=CONSOLE_WRITE_NORMAL;
   134f8:	8b 45 08             	mov    0x8(%ebp),%eax
   134fb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        break;
   13501:	eb 39                	jmp    1353c <write_esc+0x6e>
    case '8':
        restore_cursor(console);
   13503:	ff 75 08             	pushl  0x8(%ebp)
   13506:	e8 7c ff ff ff       	call   13487 <restore_cursor>
   1350b:	83 c4 04             	add    $0x4,%esp
        console->write_state=CONSOLE_WRITE_NORMAL;
   1350e:	8b 45 08             	mov    0x8(%ebp),%eax
   13511:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        break;
   13517:	eb 23                	jmp    1353c <write_esc+0x6e>
    case '[':
        clear_esc_param(console);
   13519:	83 ec 0c             	sub    $0xc,%esp
   1351c:	ff 75 08             	pushl  0x8(%ebp)
   1351f:	e8 81 ff ff ff       	call   134a5 <clear_esc_param>
   13524:	83 c4 10             	add    $0x10,%esp
        console->write_state=CONSOLE_WRITE_SQUARE;
   13527:	8b 45 08             	mov    0x8(%ebp),%eax
   1352a:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        break;
   13530:	eb 0a                	jmp    1353c <write_esc+0x6e>
    default:
        console->write_state=CONSOLE_WRITE_NORMAL;
   13532:	8b 45 08             	mov    0x8(%ebp),%eax
   13535:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        break;
   1353b:	90                   	nop
    }
}
   1353c:	90                   	nop
   1353d:	c9                   	leave  
   1353e:	c3                   	ret    

0001353f <set_font_style>:

static void set_font_style(console_t* console){
   1353f:	55                   	push   %ebp
   13540:	89 e5                	mov    %esp,%ebp
   13542:	83 ec 10             	sub    $0x10,%esp
    static const color_t color_table[]={
        BLACK,RED,GREEN,YELLOW,BLUE,
        MAGENTA,CYAN,WHITE
    };

    for(int i=0;i<=console->curr_param_index;i++){
   13545:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1354c:	eb 78                	jmp    135c6 <set_font_style+0x87>
        int param=console->esc_param[i];
   1354e:	8b 45 08             	mov    0x8(%ebp),%eax
   13551:	8b 55 fc             	mov    -0x4(%ebp),%edx
   13554:	83 c2 08             	add    $0x8,%edx
   13557:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   1355b:	89 45 f8             	mov    %eax,-0x8(%ebp)
        if((param>=30) && (param <= 37)){
   1355e:	83 7d f8 1d          	cmpl   $0x1d,-0x8(%ebp)
   13562:	7e 1b                	jle    1357f <set_font_style+0x40>
   13564:	83 7d f8 25          	cmpl   $0x25,-0x8(%ebp)
   13568:	7f 15                	jg     1357f <set_font_style+0x40>
            console->foreground=color_table[param-30];
   1356a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1356d:	83 e8 1e             	sub    $0x1e,%eax
   13570:	8b 14 85 60 65 01 00 	mov    0x16560(,%eax,4),%edx
   13577:	8b 45 08             	mov    0x8(%ebp),%eax
   1357a:	89 50 18             	mov    %edx,0x18(%eax)
   1357d:	eb 43                	jmp    135c2 <set_font_style+0x83>
        }
        else if((param >= 40)&&(param <= 47)){
   1357f:	83 7d f8 27          	cmpl   $0x27,-0x8(%ebp)
   13583:	7e 1b                	jle    135a0 <set_font_style+0x61>
   13585:	83 7d f8 2f          	cmpl   $0x2f,-0x8(%ebp)
   13589:	7f 15                	jg     135a0 <set_font_style+0x61>
            console->background=color_table[param-40];
   1358b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1358e:	83 e8 28             	sub    $0x28,%eax
   13591:	8b 14 85 60 65 01 00 	mov    0x16560(,%eax,4),%edx
   13598:	8b 45 08             	mov    0x8(%ebp),%eax
   1359b:	89 50 1c             	mov    %edx,0x1c(%eax)
   1359e:	eb 22                	jmp    135c2 <set_font_style+0x83>
        }
        else if(param == 39){
   135a0:	83 7d f8 27          	cmpl   $0x27,-0x8(%ebp)
   135a4:	75 0c                	jne    135b2 <set_font_style+0x73>
            console->foreground=WHITE;
   135a6:	8b 45 08             	mov    0x8(%ebp),%eax
   135a9:	c7 40 18 0f 00 00 00 	movl   $0xf,0x18(%eax)
   135b0:	eb 10                	jmp    135c2 <set_font_style+0x83>
        }
        else if(param == 49){
   135b2:	83 7d f8 31          	cmpl   $0x31,-0x8(%ebp)
   135b6:	75 0a                	jne    135c2 <set_font_style+0x83>
            console->background=BLACK;
   135b8:	8b 45 08             	mov    0x8(%ebp),%eax
   135bb:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    for(int i=0;i<=console->curr_param_index;i++){
   135c2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   135c6:	8b 45 08             	mov    0x8(%ebp),%eax
   135c9:	8b 40 50             	mov    0x50(%eax),%eax
   135cc:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   135cf:	0f 8e 79 ff ff ff    	jle    1354e <set_font_style+0xf>
        }
    }

}
   135d5:	90                   	nop
   135d6:	c9                   	leave  
   135d7:	c3                   	ret    

000135d8 <erase_in_display>:

static void erase_in_display(console_t* console){
   135d8:	55                   	push   %ebp
   135d9:	89 e5                	mov    %esp,%ebp
   135db:	83 ec 10             	sub    $0x10,%esp
    if(console->curr_param_index < 0){
   135de:	8b 45 08             	mov    0x8(%ebp),%eax
   135e1:	8b 40 50             	mov    0x50(%eax),%eax
   135e4:	85 c0                	test   %eax,%eax
   135e6:	78 3e                	js     13626 <erase_in_display+0x4e>
        return;
    }

    int param=console->esc_param[0];
   135e8:	8b 45 08             	mov    0x8(%ebp),%eax
   135eb:	8b 40 28             	mov    0x28(%eax),%eax
   135ee:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if(param==2){
   135f1:	83 7d fc 02          	cmpl   $0x2,-0x4(%ebp)
   135f5:	75 30                	jne    13627 <erase_in_display+0x4f>
        erase_rows(console,0,console->display_cols-1);
   135f7:	8b 45 08             	mov    0x8(%ebp),%eax
   135fa:	8b 40 14             	mov    0x14(%eax),%eax
   135fd:	83 e8 01             	sub    $0x1,%eax
   13600:	50                   	push   %eax
   13601:	6a 00                	push   $0x0
   13603:	ff 75 08             	pushl  0x8(%ebp)
   13606:	e8 e6 f9 ff ff       	call   12ff1 <erase_rows>
   1360b:	83 c4 0c             	add    $0xc,%esp
        console->cursor_col=console->cursor_row=0;
   1360e:	8b 45 08             	mov    0x8(%ebp),%eax
   13611:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   13618:	8b 45 08             	mov    0x8(%ebp),%eax
   1361b:	8b 50 08             	mov    0x8(%eax),%edx
   1361e:	8b 45 08             	mov    0x8(%ebp),%eax
   13621:	89 50 0c             	mov    %edx,0xc(%eax)
   13624:	eb 01                	jmp    13627 <erase_in_display+0x4f>
        return;
   13626:	90                   	nop
    }

}
   13627:	c9                   	leave  
   13628:	c3                   	ret    

00013629 <move_cursor>:

static void move_cursor(console_t* console){
   13629:	55                   	push   %ebp
   1362a:	89 e5                	mov    %esp,%ebp
    console->cursor_row=console->esc_param[0];
   1362c:	8b 45 08             	mov    0x8(%ebp),%eax
   1362f:	8b 50 28             	mov    0x28(%eax),%edx
   13632:	8b 45 08             	mov    0x8(%ebp),%eax
   13635:	89 50 08             	mov    %edx,0x8(%eax)
    console->cursor_col=console->esc_param[1];
   13638:	8b 45 08             	mov    0x8(%ebp),%eax
   1363b:	8b 50 2c             	mov    0x2c(%eax),%edx
   1363e:	8b 45 08             	mov    0x8(%ebp),%eax
   13641:	89 50 0c             	mov    %edx,0xc(%eax)
}
   13644:	90                   	nop
   13645:	5d                   	pop    %ebp
   13646:	c3                   	ret    

00013647 <move_left>:

static void move_left(console_t* console,int n){
   13647:	55                   	push   %ebp
   13648:	89 e5                	mov    %esp,%ebp
   1364a:	83 ec 10             	sub    $0x10,%esp
    if(n==0){
   1364d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13651:	75 07                	jne    1365a <move_left+0x13>
        n=1;
   13653:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
    }

    int col=console->cursor_col-n;
   1365a:	8b 45 08             	mov    0x8(%ebp),%eax
   1365d:	8b 40 0c             	mov    0xc(%eax),%eax
   13660:	2b 45 0c             	sub    0xc(%ebp),%eax
   13663:	89 45 fc             	mov    %eax,-0x4(%ebp)

    console->cursor_col=(col>=0)?col:0;
   13666:	b8 00 00 00 00       	mov    $0x0,%eax
   1366b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1366f:	0f 49 45 fc          	cmovns -0x4(%ebp),%eax
   13673:	89 c2                	mov    %eax,%edx
   13675:	8b 45 08             	mov    0x8(%ebp),%eax
   13678:	89 50 0c             	mov    %edx,0xc(%eax)
}
   1367b:	90                   	nop
   1367c:	c9                   	leave  
   1367d:	c3                   	ret    

0001367e <move_right>:

static void move_right(console_t* console,int n){
   1367e:	55                   	push   %ebp
   1367f:	89 e5                	mov    %esp,%ebp
   13681:	83 ec 10             	sub    $0x10,%esp
    if(n==0){
   13684:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13688:	75 07                	jne    13691 <move_right+0x13>
        n=1;
   1368a:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
    }

    int col=console->cursor_col+n;
   13691:	8b 45 08             	mov    0x8(%ebp),%eax
   13694:	8b 50 0c             	mov    0xc(%eax),%edx
   13697:	8b 45 0c             	mov    0xc(%ebp),%eax
   1369a:	01 d0                	add    %edx,%eax
   1369c:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if(col >= console->display_cols){
   1369f:	8b 45 08             	mov    0x8(%ebp),%eax
   136a2:	8b 40 14             	mov    0x14(%eax),%eax
   136a5:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   136a8:	7c 11                	jl     136bb <move_right+0x3d>
        console->cursor_col=console->display_cols-1;
   136aa:	8b 45 08             	mov    0x8(%ebp),%eax
   136ad:	8b 40 14             	mov    0x14(%eax),%eax
   136b0:	8d 50 ff             	lea    -0x1(%eax),%edx
   136b3:	8b 45 08             	mov    0x8(%ebp),%eax
   136b6:	89 50 0c             	mov    %edx,0xc(%eax)
    }
    else{
        console->cursor_col=col;
    }
}
   136b9:	eb 09                	jmp    136c4 <move_right+0x46>
        console->cursor_col=col;
   136bb:	8b 45 08             	mov    0x8(%ebp),%eax
   136be:	8b 55 fc             	mov    -0x4(%ebp),%edx
   136c1:	89 50 0c             	mov    %edx,0xc(%eax)
}
   136c4:	90                   	nop
   136c5:	c9                   	leave  
   136c6:	c3                   	ret    

000136c7 <write_esc_square>:

static void write_esc_square(console_t* console,char c){
   136c7:	55                   	push   %ebp
   136c8:	89 e5                	mov    %esp,%ebp
   136ca:	83 ec 14             	sub    $0x14,%esp
   136cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   136d0:	88 45 ec             	mov    %al,-0x14(%ebp)
    if((c>='0') && (c<='9')){
   136d3:	80 7d ec 2f          	cmpb   $0x2f,-0x14(%ebp)
   136d7:	7e 44                	jle    1371d <write_esc_square+0x56>
   136d9:	80 7d ec 39          	cmpb   $0x39,-0x14(%ebp)
   136dd:	7f 3e                	jg     1371d <write_esc_square+0x56>
        int *param=&console->esc_param[console->curr_param_index];
   136df:	8b 45 08             	mov    0x8(%ebp),%eax
   136e2:	8b 40 50             	mov    0x50(%eax),%eax
   136e5:	83 c0 08             	add    $0x8,%eax
   136e8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   136ef:	8b 45 08             	mov    0x8(%ebp),%eax
   136f2:	01 d0                	add    %edx,%eax
   136f4:	83 c0 08             	add    $0x8,%eax
   136f7:	89 45 fc             	mov    %eax,-0x4(%ebp)
        *param=*param*10+c-'0';
   136fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
   136fd:	8b 10                	mov    (%eax),%edx
   136ff:	89 d0                	mov    %edx,%eax
   13701:	c1 e0 02             	shl    $0x2,%eax
   13704:	01 d0                	add    %edx,%eax
   13706:	01 c0                	add    %eax,%eax
   13708:	89 c2                	mov    %eax,%edx
   1370a:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
   1370e:	01 d0                	add    %edx,%eax
   13710:	8d 50 d0             	lea    -0x30(%eax),%edx
   13713:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13716:	89 10                	mov    %edx,(%eax)
    if((c>='0') && (c<='9')){
   13718:	e9 9b 00 00 00       	jmp    137b8 <write_esc_square+0xf1>
    }
    else if((c==';') && (console->curr_param_index < ESC_PARAM_MAX)){
   1371d:	80 7d ec 3b          	cmpb   $0x3b,-0x14(%ebp)
   13721:	75 1c                	jne    1373f <write_esc_square+0x78>
   13723:	8b 45 08             	mov    0x8(%ebp),%eax
   13726:	8b 40 50             	mov    0x50(%eax),%eax
   13729:	83 f8 09             	cmp    $0x9,%eax
   1372c:	7f 11                	jg     1373f <write_esc_square+0x78>
        console->curr_param_index++;
   1372e:	8b 45 08             	mov    0x8(%ebp),%eax
   13731:	8b 40 50             	mov    0x50(%eax),%eax
   13734:	8d 50 01             	lea    0x1(%eax),%edx
   13737:	8b 45 08             	mov    0x8(%ebp),%eax
   1373a:	89 50 50             	mov    %edx,0x50(%eax)
   1373d:	eb 79                	jmp    137b8 <write_esc_square+0xf1>
    }
    else{
        switch(c){
   1373f:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
   13743:	83 e8 43             	sub    $0x43,%eax
   13746:	83 f8 2a             	cmp    $0x2a,%eax
   13749:	77 63                	ja     137ae <write_esc_square+0xe7>
   1374b:	8b 04 85 a0 64 01 00 	mov    0x164a0(,%eax,4),%eax
   13752:	ff e0                	jmp    *%eax
            case 'm':
                set_font_style(console);
   13754:	ff 75 08             	pushl  0x8(%ebp)
   13757:	e8 e3 fd ff ff       	call   1353f <set_font_style>
   1375c:	83 c4 04             	add    $0x4,%esp
                break;
   1375f:	eb 4e                	jmp    137af <write_esc_square+0xe8>
            case 'D':
                move_left(console,console->esc_param[0]);
   13761:	8b 45 08             	mov    0x8(%ebp),%eax
   13764:	8b 40 28             	mov    0x28(%eax),%eax
   13767:	50                   	push   %eax
   13768:	ff 75 08             	pushl  0x8(%ebp)
   1376b:	e8 d7 fe ff ff       	call   13647 <move_left>
   13770:	83 c4 08             	add    $0x8,%esp
                break;
   13773:	eb 3a                	jmp    137af <write_esc_square+0xe8>
            case 'C':
                move_right(console,console->esc_param[0]);
   13775:	8b 45 08             	mov    0x8(%ebp),%eax
   13778:	8b 40 28             	mov    0x28(%eax),%eax
   1377b:	50                   	push   %eax
   1377c:	ff 75 08             	pushl  0x8(%ebp)
   1377f:	e8 fa fe ff ff       	call   1367e <move_right>
   13784:	83 c4 08             	add    $0x8,%esp
                break;
   13787:	eb 26                	jmp    137af <write_esc_square+0xe8>
            case 'H':
                move_cursor(console);
   13789:	ff 75 08             	pushl  0x8(%ebp)
   1378c:	e8 98 fe ff ff       	call   13629 <move_cursor>
   13791:	83 c4 04             	add    $0x4,%esp
                break;
   13794:	eb 19                	jmp    137af <write_esc_square+0xe8>
            case 'f':
                 move_cursor(console);
   13796:	ff 75 08             	pushl  0x8(%ebp)
   13799:	e8 8b fe ff ff       	call   13629 <move_cursor>
   1379e:	83 c4 04             	add    $0x4,%esp
                break;
   137a1:	eb 0c                	jmp    137af <write_esc_square+0xe8>
            case 'J':
                erase_in_display(console);
   137a3:	ff 75 08             	pushl  0x8(%ebp)
   137a6:	e8 2d fe ff ff       	call   135d8 <erase_in_display>
   137ab:	83 c4 04             	add    $0x4,%esp
            default:
                break;
   137ae:	90                   	nop
        }
        console->write_state=CONSOLE_WRITE_NORMAL;
   137af:	8b 45 08             	mov    0x8(%ebp),%eax
   137b2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
   137b8:	90                   	nop
   137b9:	c9                   	leave  
   137ba:	c3                   	ret    

000137bb <write_normal>:

static void write_normal(console_t* console,char c){
   137bb:	55                   	push   %ebp
   137bc:	89 e5                	mov    %esp,%ebp
   137be:	83 ec 18             	sub    $0x18,%esp
   137c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   137c4:	88 45 f4             	mov    %al,-0xc(%ebp)
    switch (c)
   137c7:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   137cb:	83 f8 0d             	cmp    $0xd,%eax
   137ce:	74 4a                	je     1381a <write_normal+0x5f>
   137d0:	83 f8 0d             	cmp    $0xd,%eax
   137d3:	7f 0c                	jg     137e1 <write_normal+0x26>
   137d5:	83 f8 08             	cmp    $0x8,%eax
   137d8:	74 2e                	je     13808 <write_normal+0x4d>
   137da:	83 f8 0a             	cmp    $0xa,%eax
   137dd:	74 4b                	je     1382a <write_normal+0x6f>
   137df:	eb 59                	jmp    1383a <write_normal+0x7f>
   137e1:	83 f8 1b             	cmp    $0x1b,%eax
   137e4:	74 07                	je     137ed <write_normal+0x32>
   137e6:	83 f8 7f             	cmp    $0x7f,%eax
   137e9:	74 0d                	je     137f8 <write_normal+0x3d>
   137eb:	eb 4d                	jmp    1383a <write_normal+0x7f>
    {
        case ASCII_ESC:
            console->write_state=CONSOLE_WRITE_ESC;
   137ed:	8b 45 08             	mov    0x8(%ebp),%eax
   137f0:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
            break;
   137f6:	eb 62                	jmp    1385a <write_normal+0x9f>
        case 0x7F:
            erase_backword(console);
   137f8:	83 ec 0c             	sub    $0xc,%esp
   137fb:	ff 75 08             	pushl  0x8(%ebp)
   137fe:	e8 2c fc ff ff       	call   1342f <erase_backword>
   13803:	83 c4 10             	add    $0x10,%esp
            break;
   13806:	eb 52                	jmp    1385a <write_normal+0x9f>
        case '\b':
            move_backword(console,1);
   13808:	83 ec 08             	sub    $0x8,%esp
   1380b:	6a 01                	push   $0x1
   1380d:	ff 75 08             	pushl  0x8(%ebp)
   13810:	e8 3c fa ff ff       	call   13251 <move_backword>
   13815:	83 c4 10             	add    $0x10,%esp
            break;
   13818:	eb 40                	jmp    1385a <write_normal+0x9f>
        case '\r':
            move_to_col0(console);
   1381a:	83 ec 0c             	sub    $0xc,%esp
   1381d:	ff 75 08             	pushl  0x8(%ebp)
   13820:	e8 6e f9 ff ff       	call   13193 <move_to_col0>
   13825:	83 c4 10             	add    $0x10,%esp
            break;
   13828:	eb 30                	jmp    1385a <write_normal+0x9f>
        case '\n':  
            move_next_line(console);
   1382a:	83 ec 0c             	sub    $0xc,%esp
   1382d:	ff 75 08             	pushl  0x8(%ebp)
   13830:	e8 6e f9 ff ff       	call   131a3 <move_next_line>
   13835:	83 c4 10             	add    $0x10,%esp
            break;
   13838:	eb 20                	jmp    1385a <write_normal+0x9f>
        default:
            if((c >= ' ') && (c <= '~')){
   1383a:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
   1383e:	7e 19                	jle    13859 <write_normal+0x9e>
   13840:	80 7d f4 7f          	cmpb   $0x7f,-0xc(%ebp)
   13844:	74 13                	je     13859 <write_normal+0x9e>
                show_char(console,c);
   13846:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   1384a:	83 ec 08             	sub    $0x8,%esp
   1384d:	50                   	push   %eax
   1384e:	ff 75 08             	pushl  0x8(%ebp)
   13851:	e8 44 fb ff ff       	call   1339a <show_char>
   13856:	83 c4 10             	add    $0x10,%esp
            }
            break;
   13859:	90                   	nop
    }
}
   1385a:	90                   	nop
   1385b:	c9                   	leave  
   1385c:	c3                   	ret    

0001385d <console_write>:

int console_write(tty_t* tty){
   1385d:	55                   	push   %ebp
   1385e:	89 e5                	mov    %esp,%ebp
   13860:	83 ec 18             	sub    $0x18,%esp
    console_t* console=console_buf+tty->console_index;
   13863:	8b 45 08             	mov    0x8(%ebp),%eax
   13866:	8b 80 28 04 00 00    	mov    0x428(%eax),%eax
   1386c:	6b c0 54             	imul   $0x54,%eax,%eax
   1386f:	05 00 26 03 00       	add    $0x32600,%eax
   13874:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int len=0;
   13877:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    do{
        char c;
        int err=tty_fifo_get(&tty->ofifo,&c);
   1387e:	8b 45 08             	mov    0x8(%ebp),%eax
   13881:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
   13887:	83 ec 08             	sub    $0x8,%esp
   1388a:	8d 45 eb             	lea    -0x15(%ebp),%eax
   1388d:	50                   	push   %eax
   1388e:	52                   	push   %edx
   1388f:	e8 ff 09 00 00       	call   14293 <tty_fifo_get>
   13894:	83 c4 10             	add    $0x10,%esp
   13897:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(err<0){
   1389a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1389e:	79 17                	jns    138b7 <console_write+0x5a>
        }
        
        len++;
    }while(1);

    if(tty->console_index==curr_console_idx){
   138a0:	8b 45 08             	mov    0x8(%ebp),%eax
   138a3:	8b 90 28 04 00 00    	mov    0x428(%eax),%edx
   138a9:	a1 a0 28 03 00       	mov    0x328a0,%eax
   138ae:	39 c2                	cmp    %eax,%edx
   138b0:	74 7f                	je     13931 <console_write+0xd4>
   138b2:	e9 88 00 00 00       	jmp    1393f <console_write+0xe2>
        sem_notify(&tty->osem);
   138b7:	8b 45 08             	mov    0x8(%ebp),%eax
   138ba:	05 2c 04 00 00       	add    $0x42c,%eax
   138bf:	83 ec 0c             	sub    $0xc,%esp
   138c2:	50                   	push   %eax
   138c3:	e8 b2 16 00 00       	call   14f7a <sem_notify>
   138c8:	83 c4 10             	add    $0x10,%esp
        switch(console->write_state){
   138cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   138ce:	8b 00                	mov    (%eax),%eax
   138d0:	83 f8 01             	cmp    $0x1,%eax
   138d3:	74 24                	je     138f9 <console_write+0x9c>
   138d5:	83 f8 01             	cmp    $0x1,%eax
   138d8:	72 07                	jb     138e1 <console_write+0x84>
   138da:	83 f8 02             	cmp    $0x2,%eax
   138dd:	74 32                	je     13911 <console_write+0xb4>
                break;
   138df:	eb 47                	jmp    13928 <console_write+0xcb>
                write_normal(console,c);
   138e1:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   138e5:	0f be c0             	movsbl %al,%eax
   138e8:	83 ec 08             	sub    $0x8,%esp
   138eb:	50                   	push   %eax
   138ec:	ff 75 f0             	pushl  -0x10(%ebp)
   138ef:	e8 c7 fe ff ff       	call   137bb <write_normal>
   138f4:	83 c4 10             	add    $0x10,%esp
                break;
   138f7:	eb 2f                	jmp    13928 <console_write+0xcb>
                write_esc(console,c);
   138f9:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   138fd:	0f be c0             	movsbl %al,%eax
   13900:	83 ec 08             	sub    $0x8,%esp
   13903:	50                   	push   %eax
   13904:	ff 75 f0             	pushl  -0x10(%ebp)
   13907:	e8 c2 fb ff ff       	call   134ce <write_esc>
   1390c:	83 c4 10             	add    $0x10,%esp
                break;
   1390f:	eb 17                	jmp    13928 <console_write+0xcb>
                write_esc_square(console,c);
   13911:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   13915:	0f be c0             	movsbl %al,%eax
   13918:	83 ec 08             	sub    $0x8,%esp
   1391b:	50                   	push   %eax
   1391c:	ff 75 f0             	pushl  -0x10(%ebp)
   1391f:	e8 a3 fd ff ff       	call   136c7 <write_esc_square>
   13924:	83 c4 10             	add    $0x10,%esp
                break;
   13927:	90                   	nop
        len++;
   13928:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    do{
   1392c:	e9 4d ff ff ff       	jmp    1387e <console_write+0x21>
        update_cursor_pos(console);
   13931:	83 ec 0c             	sub    $0xc,%esp
   13934:	ff 75 f0             	pushl  -0x10(%ebp)
   13937:	e8 fb f5 ff ff       	call   12f37 <update_cursor_pos>
   1393c:	83 c4 10             	add    $0x10,%esp
    }

    return len;
   1393f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13942:	c9                   	leave  
   13943:	c3                   	ret    

00013944 <console_close>:

void console_close(int console){
   13944:	55                   	push   %ebp
   13945:	89 e5                	mov    %esp,%ebp
    
}
   13947:	90                   	nop
   13948:	5d                   	pop    %ebp
   13949:	c3                   	ret    

0001394a <console_select>:

/** 
 * @brief 选择对应的console 
 * @param idx 要切换到的console的索引号
*/ 
void console_select(int idx){
   1394a:	55                   	push   %ebp
   1394b:	89 e5                	mov    %esp,%ebp
   1394d:	83 ec 18             	sub    $0x18,%esp
    console_t* console=console_buf+idx;
   13950:	8b 45 08             	mov    0x8(%ebp),%eax
   13953:	6b c0 54             	imul   $0x54,%eax,%eax
   13956:	05 00 26 03 00       	add    $0x32600,%eax
   1395b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    // 如果显存地址为0说明未初始化，要初始化对应的console
    if(console->disp_base==0){
   1395e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13961:	8b 40 04             	mov    0x4(%eax),%eax
   13964:	85 c0                	test   %eax,%eax
   13966:	75 0e                	jne    13976 <console_select+0x2c>
        console_init(idx);
   13968:	83 ec 0c             	sub    $0xc,%esp
   1396b:	ff 75 08             	pushl  0x8(%ebp)
   1396e:	e8 56 f9 ff ff       	call   132c9 <console_init>
   13973:	83 c4 10             	add    $0x10,%esp
    }

    uint16_t pos=idx*console->display_cols*console->display_rows;
   13976:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13979:	8b 40 14             	mov    0x14(%eax),%eax
   1397c:	89 c2                	mov    %eax,%edx
   1397e:	8b 45 08             	mov    0x8(%ebp),%eax
   13981:	0f af d0             	imul   %eax,%edx
   13984:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13987:	8b 40 10             	mov    0x10(%eax),%eax
   1398a:	0f af c2             	imul   %edx,%eax
   1398d:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

    // 向端口 0x3D4 写入值 0xC，这是用于选择 VGA 控制器的初始屏幕的位置的高八位
    outb(0x3D4,0xC);
   13991:	83 ec 08             	sub    $0x8,%esp
   13994:	6a 0c                	push   $0xc
   13996:	68 d4 03 00 00       	push   $0x3d4
   1399b:	e8 04 f5 ff ff       	call   12ea4 <outb>
   139a0:	83 c4 10             	add    $0x10,%esp
    
    // 写入高八位
    outb(0x3D5,(uint8_t)((pos >> 8) & 0xFF));
   139a3:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   139a7:	66 c1 e8 08          	shr    $0x8,%ax
   139ab:	0f b6 c0             	movzbl %al,%eax
   139ae:	83 ec 08             	sub    $0x8,%esp
   139b1:	50                   	push   %eax
   139b2:	68 d5 03 00 00       	push   $0x3d5
   139b7:	e8 e8 f4 ff ff       	call   12ea4 <outb>
   139bc:	83 c4 10             	add    $0x10,%esp

    // 向端口 0x3D4 写入值 0xD，这是用于选择 VGA 控制器的初始屏幕的位置的低八位
    outb(0x3D4,0xD);
   139bf:	83 ec 08             	sub    $0x8,%esp
   139c2:	6a 0d                	push   $0xd
   139c4:	68 d4 03 00 00       	push   $0x3d4
   139c9:	e8 d6 f4 ff ff       	call   12ea4 <outb>
   139ce:	83 c4 10             	add    $0x10,%esp

    // 写入低八位
    outb(0x3D5,(uint8_t)(pos & 0xFF));
   139d1:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   139d5:	0f b6 c0             	movzbl %al,%eax
   139d8:	83 ec 08             	sub    $0x8,%esp
   139db:	50                   	push   %eax
   139dc:	68 d5 03 00 00       	push   $0x3d5
   139e1:	e8 be f4 ff ff       	call   12ea4 <outb>
   139e6:	83 c4 10             	add    $0x10,%esp

    curr_console_idx=idx;
   139e9:	8b 45 08             	mov    0x8(%ebp),%eax
   139ec:	a3 a0 28 03 00       	mov    %eax,0x328a0

    update_cursor_pos(console);
   139f1:	83 ec 0c             	sub    $0xc,%esp
   139f4:	ff 75 f4             	pushl  -0xc(%ebp)
   139f7:	e8 3b f5 ff ff       	call   12f37 <update_cursor_pos>
   139fc:	83 c4 10             	add    $0x10,%esp
}
   139ff:	90                   	nop
   13a00:	c9                   	leave  
   13a01:	c3                   	ret    

00013a02 <is_devid_bad>:
    &dev_tty_desc,
};

static device_t dev_tb[DEV_TABLE_SIZE];

static int is_devid_bad(int dev_id){
   13a02:	55                   	push   %ebp
   13a03:	89 e5                	mov    %esp,%ebp
    if((dev_id<0) || (dev_id>=DEV_TABLE_SIZE)){
   13a05:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13a09:	78 06                	js     13a11 <is_devid_bad+0xf>
   13a0b:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   13a0f:	7e 07                	jle    13a18 <is_devid_bad+0x16>
        return 1;
   13a11:	b8 01 00 00 00       	mov    $0x1,%eax
   13a16:	eb 24                	jmp    13a3c <is_devid_bad+0x3a>
    }

    if(dev_tb[dev_id].desc==(dev_desc_t*)0){
   13a18:	8b 55 08             	mov    0x8(%ebp),%edx
   13a1b:	89 d0                	mov    %edx,%eax
   13a1d:	c1 e0 02             	shl    $0x2,%eax
   13a20:	01 d0                	add    %edx,%eax
   13a22:	c1 e0 02             	shl    $0x2,%eax
   13a25:	05 c0 28 03 00       	add    $0x328c0,%eax
   13a2a:	8b 00                	mov    (%eax),%eax
   13a2c:	85 c0                	test   %eax,%eax
   13a2e:	75 07                	jne    13a37 <is_devid_bad+0x35>
        return 1;
   13a30:	b8 01 00 00 00       	mov    $0x1,%eax
   13a35:	eb 05                	jmp    13a3c <is_devid_bad+0x3a>
    }

    return 0;
   13a37:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13a3c:	5d                   	pop    %ebp
   13a3d:	c3                   	ret    

00013a3e <dev_open>:
 * @param major 主设备号
 * @param minor 从设备号
 * @param data 设备传入的参数
 * @return 设备id，失败返回-1
*/
int dev_open(int major,int minor,void* data){
   13a3e:	55                   	push   %ebp
   13a3f:	89 e5                	mov    %esp,%ebp
   13a41:	83 ec 28             	sub    $0x28,%esp
    irq_state_t state=irq_enter_protection();
   13a44:	e8 15 f4 ff ff       	call   12e5e <irq_enter_protection>
   13a49:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    device_t* free_dev=(device_t*)0;
   13a4c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    for(int i=0;i<sizeof(dev_tb)/sizeof(dev_tb[0]);i++){
   13a53:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13a5a:	eb 68                	jmp    13ac4 <dev_open+0x86>
        device_t* dev=dev_tb+i;
   13a5c:	8b 55 f0             	mov    -0x10(%ebp),%edx
   13a5f:	89 d0                	mov    %edx,%eax
   13a61:	c1 e0 02             	shl    $0x2,%eax
   13a64:	01 d0                	add    %edx,%eax
   13a66:	c1 e0 02             	shl    $0x2,%eax
   13a69:	05 c0 28 03 00       	add    $0x328c0,%eax
   13a6e:	89 45 dc             	mov    %eax,-0x24(%ebp)
        if(dev->open_count == 0){
   13a71:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13a74:	8b 40 10             	mov    0x10(%eax),%eax
   13a77:	85 c0                	test   %eax,%eax
   13a79:	75 08                	jne    13a83 <dev_open+0x45>
            free_dev=dev;
   13a7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13a7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
   13a81:	eb 3d                	jmp    13ac0 <dev_open+0x82>
        }
        else if((dev->desc->major == major) && (dev->minor == minor)){
   13a83:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13a86:	8b 00                	mov    (%eax),%eax
   13a88:	8b 40 20             	mov    0x20(%eax),%eax
   13a8b:	39 45 08             	cmp    %eax,0x8(%ebp)
   13a8e:	75 30                	jne    13ac0 <dev_open+0x82>
   13a90:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13a93:	8b 40 08             	mov    0x8(%eax),%eax
   13a96:	39 45 0c             	cmp    %eax,0xc(%ebp)
   13a99:	75 25                	jne    13ac0 <dev_open+0x82>
            dev->open_count++;
   13a9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13a9e:	8b 40 10             	mov    0x10(%eax),%eax
   13aa1:	8d 50 01             	lea    0x1(%eax),%edx
   13aa4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13aa7:	89 50 10             	mov    %edx,0x10(%eax)
            irq_leave_protection(state);
   13aaa:	83 ec 0c             	sub    $0xc,%esp
   13aad:	ff 75 e4             	pushl  -0x1c(%ebp)
   13ab0:	e8 c1 f3 ff ff       	call   12e76 <irq_leave_protection>
   13ab5:	83 c4 10             	add    $0x10,%esp
            return i;
   13ab8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13abb:	e9 cc 00 00 00       	jmp    13b8c <dev_open+0x14e>
    for(int i=0;i<sizeof(dev_tb)/sizeof(dev_tb[0]);i++){
   13ac0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   13ac4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13ac7:	83 f8 7f             	cmp    $0x7f,%eax
   13aca:	76 90                	jbe    13a5c <dev_open+0x1e>
        }
    }

    dev_desc_t* desc=(dev_desc_t*)0;
   13acc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(int i=0;i<sizeof(dev_desc_tbl)/sizeof(dev_desc_tbl[0]);i++){
   13ad3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   13ada:	eb 25                	jmp    13b01 <dev_open+0xc3>
        if(dev_desc_tbl[i]->major == major){
   13adc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13adf:	8b 04 85 50 70 01 00 	mov    0x17050(,%eax,4),%eax
   13ae6:	8b 40 20             	mov    0x20(%eax),%eax
   13ae9:	39 45 08             	cmp    %eax,0x8(%ebp)
   13aec:	75 0f                	jne    13afd <dev_open+0xbf>
            desc=dev_desc_tbl[i];
   13aee:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13af1:	8b 04 85 50 70 01 00 	mov    0x17050(,%eax,4),%eax
   13af8:	89 45 ec             	mov    %eax,-0x14(%ebp)
            break;
   13afb:	eb 0a                	jmp    13b07 <dev_open+0xc9>
    for(int i=0;i<sizeof(dev_desc_tbl)/sizeof(dev_desc_tbl[0]);i++){
   13afd:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   13b01:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   13b05:	74 d5                	je     13adc <dev_open+0x9e>
        }
    }

    if(desc && free_dev){
   13b07:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   13b0b:	74 6c                	je     13b79 <dev_open+0x13b>
   13b0d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13b11:	74 66                	je     13b79 <dev_open+0x13b>
       free_dev->minor=minor;
   13b13:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13b16:	8b 55 0c             	mov    0xc(%ebp),%edx
   13b19:	89 50 08             	mov    %edx,0x8(%eax)
       free_dev->desc=desc;
   13b1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13b1f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   13b22:	89 10                	mov    %edx,(%eax)
       free_dev->data=data;
   13b24:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13b27:	8b 55 10             	mov    0x10(%ebp),%edx
   13b2a:	89 50 0c             	mov    %edx,0xc(%eax)

       int err=desc->open(free_dev);
   13b2d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13b30:	8b 40 24             	mov    0x24(%eax),%eax
   13b33:	83 ec 0c             	sub    $0xc,%esp
   13b36:	ff 75 f4             	pushl  -0xc(%ebp)
   13b39:	ff d0                	call   *%eax
   13b3b:	83 c4 10             	add    $0x10,%esp
   13b3e:	89 45 e0             	mov    %eax,-0x20(%ebp)
       if(err==0){
   13b41:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   13b45:	75 32                	jne    13b79 <dev_open+0x13b>
           free_dev->open_count++;
   13b47:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13b4a:	8b 40 10             	mov    0x10(%eax),%eax
   13b4d:	8d 50 01             	lea    0x1(%eax),%edx
   13b50:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13b53:	89 50 10             	mov    %edx,0x10(%eax)
           irq_leave_protection(state);
   13b56:	83 ec 0c             	sub    $0xc,%esp
   13b59:	ff 75 e4             	pushl  -0x1c(%ebp)
   13b5c:	e8 15 f3 ff ff       	call   12e76 <irq_leave_protection>
   13b61:	83 c4 10             	add    $0x10,%esp

           // dev_tb是起始位置，free_dev是当前位置，两者相减得到当前位置的偏移量
           return free_dev-dev_tb;
   13b64:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13b67:	ba c0 28 03 00       	mov    $0x328c0,%edx
   13b6c:	29 d0                	sub    %edx,%eax
   13b6e:	c1 f8 02             	sar    $0x2,%eax
   13b71:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
   13b77:	eb 13                	jmp    13b8c <dev_open+0x14e>
       }
    }

    irq_leave_protection(state);
   13b79:	83 ec 0c             	sub    $0xc,%esp
   13b7c:	ff 75 e4             	pushl  -0x1c(%ebp)
   13b7f:	e8 f2 f2 ff ff       	call   12e76 <irq_leave_protection>
   13b84:	83 c4 10             	add    $0x10,%esp
    return -1;
   13b87:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   13b8c:	c9                   	leave  
   13b8d:	c3                   	ret    

00013b8e <dev_read>:

// dev_id:设备id，addr:从哪里开始读取
int dev_read(int dev_id,int addr,char* buf,int size){
   13b8e:	55                   	push   %ebp
   13b8f:	89 e5                	mov    %esp,%ebp
   13b91:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   13b94:	ff 75 08             	pushl  0x8(%ebp)
   13b97:	e8 66 fe ff ff       	call   13a02 <is_devid_bad>
   13b9c:	83 c4 04             	add    $0x4,%esp
   13b9f:	85 c0                	test   %eax,%eax
   13ba1:	74 07                	je     13baa <dev_read+0x1c>
        return -1;
   13ba3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13ba8:	eb 2e                	jmp    13bd8 <dev_read+0x4a>
    }

    device_t* dev=dev_tb+dev_id;
   13baa:	8b 55 08             	mov    0x8(%ebp),%edx
   13bad:	89 d0                	mov    %edx,%eax
   13baf:	c1 e0 02             	shl    $0x2,%eax
   13bb2:	01 d0                	add    %edx,%eax
   13bb4:	c1 e0 02             	shl    $0x2,%eax
   13bb7:	05 c0 28 03 00       	add    $0x328c0,%eax
   13bbc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return dev->desc->read(dev,addr,buf,size);
   13bbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13bc2:	8b 00                	mov    (%eax),%eax
   13bc4:	8b 40 28             	mov    0x28(%eax),%eax
   13bc7:	ff 75 14             	pushl  0x14(%ebp)
   13bca:	ff 75 10             	pushl  0x10(%ebp)
   13bcd:	ff 75 0c             	pushl  0xc(%ebp)
   13bd0:	ff 75 f4             	pushl  -0xc(%ebp)
   13bd3:	ff d0                	call   *%eax
   13bd5:	83 c4 10             	add    $0x10,%esp
}
   13bd8:	c9                   	leave  
   13bd9:	c3                   	ret    

00013bda <dev_write>:

int dev_write(int dev_id,int addr,char* buf,int size){
   13bda:	55                   	push   %ebp
   13bdb:	89 e5                	mov    %esp,%ebp
   13bdd:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   13be0:	ff 75 08             	pushl  0x8(%ebp)
   13be3:	e8 1a fe ff ff       	call   13a02 <is_devid_bad>
   13be8:	83 c4 04             	add    $0x4,%esp
   13beb:	85 c0                	test   %eax,%eax
   13bed:	74 07                	je     13bf6 <dev_write+0x1c>
        return -1;
   13bef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13bf4:	eb 2e                	jmp    13c24 <dev_write+0x4a>
    }

    device_t* dev=dev_tb+dev_id;
   13bf6:	8b 55 08             	mov    0x8(%ebp),%edx
   13bf9:	89 d0                	mov    %edx,%eax
   13bfb:	c1 e0 02             	shl    $0x2,%eax
   13bfe:	01 d0                	add    %edx,%eax
   13c00:	c1 e0 02             	shl    $0x2,%eax
   13c03:	05 c0 28 03 00       	add    $0x328c0,%eax
   13c08:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return dev->desc->write(dev,addr,buf,size);
   13c0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13c0e:	8b 00                	mov    (%eax),%eax
   13c10:	8b 40 2c             	mov    0x2c(%eax),%eax
   13c13:	ff 75 14             	pushl  0x14(%ebp)
   13c16:	ff 75 10             	pushl  0x10(%ebp)
   13c19:	ff 75 0c             	pushl  0xc(%ebp)
   13c1c:	ff 75 f4             	pushl  -0xc(%ebp)
   13c1f:	ff d0                	call   *%eax
   13c21:	83 c4 10             	add    $0x10,%esp
}
   13c24:	c9                   	leave  
   13c25:	c3                   	ret    

00013c26 <dev_control>:

int dev_control(int dev_id,int cmd,int arg0,int arg1){
   13c26:	55                   	push   %ebp
   13c27:	89 e5                	mov    %esp,%ebp
   13c29:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   13c2c:	ff 75 08             	pushl  0x8(%ebp)
   13c2f:	e8 ce fd ff ff       	call   13a02 <is_devid_bad>
   13c34:	83 c4 04             	add    $0x4,%esp
   13c37:	85 c0                	test   %eax,%eax
   13c39:	74 07                	je     13c42 <dev_control+0x1c>
        return -1;
   13c3b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13c40:	eb 2e                	jmp    13c70 <dev_control+0x4a>
    }

    device_t* dev=dev_tb+dev_id;
   13c42:	8b 55 08             	mov    0x8(%ebp),%edx
   13c45:	89 d0                	mov    %edx,%eax
   13c47:	c1 e0 02             	shl    $0x2,%eax
   13c4a:	01 d0                	add    %edx,%eax
   13c4c:	c1 e0 02             	shl    $0x2,%eax
   13c4f:	05 c0 28 03 00       	add    $0x328c0,%eax
   13c54:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return dev->desc->control(dev,cmd,arg0,arg1);
   13c57:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13c5a:	8b 00                	mov    (%eax),%eax
   13c5c:	8b 40 30             	mov    0x30(%eax),%eax
   13c5f:	ff 75 14             	pushl  0x14(%ebp)
   13c62:	ff 75 10             	pushl  0x10(%ebp)
   13c65:	ff 75 0c             	pushl  0xc(%ebp)
   13c68:	ff 75 f4             	pushl  -0xc(%ebp)
   13c6b:	ff d0                	call   *%eax
   13c6d:	83 c4 10             	add    $0x10,%esp
}
   13c70:	c9                   	leave  
   13c71:	c3                   	ret    

00013c72 <dev_close>:

void dev_close(int dev_id){
   13c72:	55                   	push   %ebp
   13c73:	89 e5                	mov    %esp,%ebp
   13c75:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id)){
   13c78:	ff 75 08             	pushl  0x8(%ebp)
   13c7b:	e8 82 fd ff ff       	call   13a02 <is_devid_bad>
   13c80:	83 c4 04             	add    $0x4,%esp
   13c83:	85 c0                	test   %eax,%eax
   13c85:	75 6c                	jne    13cf3 <dev_close+0x81>
        return;
    }
    
    device_t* dev=dev_tb+dev_id;
   13c87:	8b 55 08             	mov    0x8(%ebp),%edx
   13c8a:	89 d0                	mov    %edx,%eax
   13c8c:	c1 e0 02             	shl    $0x2,%eax
   13c8f:	01 d0                	add    %edx,%eax
   13c91:	c1 e0 02             	shl    $0x2,%eax
   13c94:	05 c0 28 03 00       	add    $0x328c0,%eax
   13c99:	89 45 f4             	mov    %eax,-0xc(%ebp)

    irq_state_t state=irq_enter_protection();
   13c9c:	e8 bd f1 ff ff       	call   12e5e <irq_enter_protection>
   13ca1:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if(--dev->open_count == 0){
   13ca4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13ca7:	8b 40 10             	mov    0x10(%eax),%eax
   13caa:	8d 50 ff             	lea    -0x1(%eax),%edx
   13cad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13cb0:	89 50 10             	mov    %edx,0x10(%eax)
   13cb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13cb6:	8b 40 10             	mov    0x10(%eax),%eax
   13cb9:	85 c0                	test   %eax,%eax
   13cbb:	75 25                	jne    13ce2 <dev_close+0x70>
        dev->desc->close(dev);
   13cbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13cc0:	8b 00                	mov    (%eax),%eax
   13cc2:	8b 40 34             	mov    0x34(%eax),%eax
   13cc5:	83 ec 0c             	sub    $0xc,%esp
   13cc8:	ff 75 f4             	pushl  -0xc(%ebp)
   13ccb:	ff d0                	call   *%eax
   13ccd:	83 c4 10             	add    $0x10,%esp
        kernel_memset(dev,0,sizeof(device_t));
   13cd0:	83 ec 04             	sub    $0x4,%esp
   13cd3:	6a 14                	push   $0x14
   13cd5:	6a 00                	push   $0x0
   13cd7:	ff 75 f4             	pushl  -0xc(%ebp)
   13cda:	e8 7b 17 00 00       	call   1545a <kernel_memset>
   13cdf:	83 c4 10             	add    $0x10,%esp
    }

    irq_leave_protection(state);
   13ce2:	83 ec 0c             	sub    $0xc,%esp
   13ce5:	ff 75 f0             	pushl  -0x10(%ebp)
   13ce8:	e8 89 f1 ff ff       	call   12e76 <irq_leave_protection>
   13ced:	83 c4 10             	add    $0x10,%esp
    
    return;
   13cf0:	90                   	nop
   13cf1:	eb 01                	jmp    13cf4 <dev_close+0x82>
        return;
   13cf3:	90                   	nop
}
   13cf4:	c9                   	leave  
   13cf5:	c3                   	ret    

00013cf6 <inb>:
static inline uint8_t inb(uint16_t port){
   13cf6:	55                   	push   %ebp
   13cf7:	89 e5                	mov    %esp,%ebp
   13cf9:	83 ec 14             	sub    $0x14,%esp
   13cfc:	8b 45 08             	mov    0x8(%ebp),%eax
   13cff:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   13d03:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   13d07:	89 c2                	mov    %eax,%edx
   13d09:	ec                   	in     (%dx),%al
   13d0a:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   13d0d:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   13d11:	c9                   	leave  
   13d12:	c3                   	ret    

00013d13 <kbd_init>:

/**
 * @brief 键盘初始化函数，将键盘中断处理函数注册到中断向量表中
 * @param none
*/
void kbd_init(void){
   13d13:	55                   	push   %ebp
   13d14:	89 e5                	mov    %esp,%ebp
   13d16:	83 ec 08             	sub    $0x8,%esp
    static int inited=0;

    if(!inited){
   13d19:	a1 c4 32 03 00       	mov    0x332c4,%eax
   13d1e:	85 c0                	test   %eax,%eax
   13d20:	75 3d                	jne    13d5f <kbd_init+0x4c>
        kernel_memset(&kbd_stat,0,sizeof(kbd_stat));
   13d22:	83 ec 04             	sub    $0x4,%esp
   13d25:	6a 04                	push   $0x4
   13d27:	6a 00                	push   $0x0
   13d29:	68 c0 32 03 00       	push   $0x332c0
   13d2e:	e8 27 17 00 00       	call   1545a <kernel_memset>
   13d33:	83 c4 10             	add    $0x10,%esp
        irq_install(IRQ1_KEYBOARD,(irq_handler_t)exception_handler_kbd);
   13d36:	83 ec 08             	sub    $0x8,%esp
   13d39:	68 a8 02 01 00       	push   $0x102a8
   13d3e:	6a 21                	push   $0x21
   13d40:	e8 fc eb ff ff       	call   12941 <irq_install>
   13d45:	83 c4 10             	add    $0x10,%esp
        irq_enable(IRQ1_KEYBOARD);
   13d48:	83 ec 0c             	sub    $0xc,%esp
   13d4b:	6a 21                	push   $0x21
   13d4d:	e8 2f e9 ff ff       	call   12681 <irq_enable>
   13d52:	83 c4 10             	add    $0x10,%esp

        inited=1;
   13d55:	c7 05 c4 32 03 00 01 	movl   $0x1,0x332c4
   13d5c:	00 00 00 
    }

}
   13d5f:	90                   	nop
   13d60:	c9                   	leave  
   13d61:	c3                   	ret    

00013d62 <is_make_code>:

static inline int is_make_code(uint8_t key_code){
   13d62:	55                   	push   %ebp
   13d63:	89 e5                	mov    %esp,%ebp
   13d65:	83 ec 04             	sub    $0x4,%esp
   13d68:	8b 45 08             	mov    0x8(%ebp),%eax
   13d6b:	88 45 fc             	mov    %al,-0x4(%ebp)
    return !(key_code & 0x80);
   13d6e:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
   13d72:	f7 d0                	not    %eax
   13d74:	c0 e8 07             	shr    $0x7,%al
   13d77:	0f b6 c0             	movzbl %al,%eax
}
   13d7a:	c9                   	leave  
   13d7b:	c3                   	ret    

00013d7c <get_key>:

static inline char get_key(uint8_t key_code){
   13d7c:	55                   	push   %ebp
   13d7d:	89 e5                	mov    %esp,%ebp
   13d7f:	83 ec 04             	sub    $0x4,%esp
   13d82:	8b 45 08             	mov    0x8(%ebp),%eax
   13d85:	88 45 fc             	mov    %al,-0x4(%ebp)
    return key_code & 0x7f;
   13d88:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
   13d8c:	83 e0 7f             	and    $0x7f,%eax
}
   13d8f:	c9                   	leave  
   13d90:	c3                   	ret    

00013d91 <do_fx_key>:

/**
 * @brief 根据F1-F8的按键值，切换到对应的屏幕，通过ctrl+F1-F8来切换
 * @param key F1-F8的按键值
*/
static void do_fx_key(int key){
   13d91:	55                   	push   %ebp
   13d92:	89 e5                	mov    %esp,%ebp
   13d94:	83 ec 18             	sub    $0x18,%esp
    int index=key-KEY_F1;
   13d97:	8b 45 08             	mov    0x8(%ebp),%eax
   13d9a:	83 e8 3b             	sub    $0x3b,%eax
   13d9d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(kbd_stat.lctrl_press || kbd_stat.rctrl_press){
   13da0:	0f b6 05 c0 32 03 00 	movzbl 0x332c0,%eax
   13da7:	83 e0 20             	and    $0x20,%eax
   13daa:	84 c0                	test   %al,%al
   13dac:	75 0e                	jne    13dbc <do_fx_key+0x2b>
   13dae:	0f b6 05 c0 32 03 00 	movzbl 0x332c0,%eax
   13db5:	83 e0 40             	and    $0x40,%eax
   13db8:	84 c0                	test   %al,%al
   13dba:	74 0e                	je     13dca <do_fx_key+0x39>
        tty_select(index);
   13dbc:	83 ec 0c             	sub    $0xc,%esp
   13dbf:	ff 75 f4             	pushl  -0xc(%ebp)
   13dc2:	e8 f4 08 00 00       	call   146bb <tty_select>
   13dc7:	83 c4 10             	add    $0x10,%esp
    }
}
   13dca:	90                   	nop
   13dcb:	c9                   	leave  
   13dcc:	c3                   	ret    

00013dcd <do_normal_key>:

static void do_normal_key(uint8_t raw_code){
   13dcd:	55                   	push   %ebp
   13dce:	89 e5                	mov    %esp,%ebp
   13dd0:	83 ec 28             	sub    $0x28,%esp
   13dd3:	8b 45 08             	mov    0x8(%ebp),%eax
   13dd6:	88 45 e4             	mov    %al,-0x1c(%ebp)
    char key=get_key(raw_code);
   13dd9:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   13ddd:	50                   	push   %eax
   13dde:	e8 99 ff ff ff       	call   13d7c <get_key>
   13de3:	83 c4 04             	add    $0x4,%esp
   13de6:	88 45 f7             	mov    %al,-0x9(%ebp)
    int is_make=is_make_code(raw_code);
   13de9:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   13ded:	50                   	push   %eax
   13dee:	e8 6f ff ff ff       	call   13d62 <is_make_code>
   13df3:	83 c4 04             	add    $0x4,%esp
   13df6:	89 45 f0             	mov    %eax,-0x10(%ebp)

    switch(key)
   13df9:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   13dfd:	83 e8 1d             	sub    $0x1d,%eax
   13e00:	83 f8 25             	cmp    $0x25,%eax
   13e03:	0f 87 fc 00 00 00    	ja     13f05 <do_normal_key+0x138>
   13e09:	8b 04 85 f4 65 01 00 	mov    0x165f4(,%eax,4),%eax
   13e10:	ff e0                	jmp    *%eax
    {
    case KEY_RSHIFT:
        kbd_stat.rshift_press=is_make ? 1 : 0;
   13e12:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13e16:	0f 95 c0             	setne  %al
   13e19:	c1 e0 07             	shl    $0x7,%eax
   13e1c:	c0 f8 07             	sar    $0x7,%al
   13e1f:	83 e0 01             	and    $0x1,%eax
   13e22:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13e29:	0f b6 05 c0 32 03 00 	movzbl 0x332c0,%eax
   13e30:	83 e0 fb             	and    $0xfffffffb,%eax
   13e33:	09 d0                	or     %edx,%eax
   13e35:	a2 c0 32 03 00       	mov    %al,0x332c0
        break;
   13e3a:	e9 5e 01 00 00       	jmp    13f9d <do_normal_key+0x1d0>
    case KEY_LSHIFT:
        kbd_stat.lshift_press=is_make ? 1 : 0;
   13e3f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13e43:	0f 95 c0             	setne  %al
   13e46:	c1 e0 07             	shl    $0x7,%eax
   13e49:	c0 f8 07             	sar    $0x7,%al
   13e4c:	83 e0 01             	and    $0x1,%eax
   13e4f:	8d 14 00             	lea    (%eax,%eax,1),%edx
   13e52:	0f b6 05 c0 32 03 00 	movzbl 0x332c0,%eax
   13e59:	83 e0 fd             	and    $0xfffffffd,%eax
   13e5c:	09 d0                	or     %edx,%eax
   13e5e:	a2 c0 32 03 00       	mov    %al,0x332c0
        break;
   13e63:	e9 35 01 00 00       	jmp    13f9d <do_normal_key+0x1d0>
    case KEY_CAPS:
        if(is_make){
   13e68:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13e6c:	0f 84 27 01 00 00    	je     13f99 <do_normal_key+0x1cc>
            kbd_stat.caps_lock=~kbd_stat.caps_lock;
   13e72:	0f b6 05 c0 32 03 00 	movzbl 0x332c0,%eax
   13e79:	c1 e0 07             	shl    $0x7,%eax
   13e7c:	c0 f8 07             	sar    $0x7,%al
   13e7f:	f7 d0                	not    %eax
   13e81:	c1 e0 07             	shl    $0x7,%eax
   13e84:	c0 f8 07             	sar    $0x7,%al
   13e87:	83 e0 01             	and    $0x1,%eax
   13e8a:	89 c2                	mov    %eax,%edx
   13e8c:	0f b6 05 c0 32 03 00 	movzbl 0x332c0,%eax
   13e93:	83 e0 fe             	and    $0xfffffffe,%eax
   13e96:	09 d0                	or     %edx,%eax
   13e98:	a2 c0 32 03 00       	mov    %al,0x332c0
        }
        break;
   13e9d:	e9 f7 00 00 00       	jmp    13f99 <do_normal_key+0x1cc>
    case KEY_ALT:
        kbd_stat.lalt_press=is_make;
   13ea2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13ea5:	c1 e0 07             	shl    $0x7,%eax
   13ea8:	c0 f8 07             	sar    $0x7,%al
   13eab:	83 e0 01             	and    $0x1,%eax
   13eae:	c1 e0 04             	shl    $0x4,%eax
   13eb1:	89 c2                	mov    %eax,%edx
   13eb3:	0f b6 05 c0 32 03 00 	movzbl 0x332c0,%eax
   13eba:	83 e0 ef             	and    $0xffffffef,%eax
   13ebd:	09 d0                	or     %edx,%eax
   13ebf:	a2 c0 32 03 00       	mov    %al,0x332c0
        break;
   13ec4:	e9 d4 00 00 00       	jmp    13f9d <do_normal_key+0x1d0>
    case KEY_CTRL:
        kbd_stat.lctrl_press=is_make;
   13ec9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13ecc:	c1 e0 07             	shl    $0x7,%eax
   13ecf:	c0 f8 07             	sar    $0x7,%al
   13ed2:	83 e0 01             	and    $0x1,%eax
   13ed5:	c1 e0 05             	shl    $0x5,%eax
   13ed8:	89 c2                	mov    %eax,%edx
   13eda:	0f b6 05 c0 32 03 00 	movzbl 0x332c0,%eax
   13ee1:	83 e0 df             	and    $0xffffffdf,%eax
   13ee4:	09 d0                	or     %edx,%eax
   13ee6:	a2 c0 32 03 00       	mov    %al,0x332c0
        break;
   13eeb:	e9 ad 00 00 00       	jmp    13f9d <do_normal_key+0x1d0>
    case KEY_F4:
    case KEY_F5:
    case KEY_F6:
    case KEY_F7:
    case KEY_F8:
        do_fx_key(key);
   13ef0:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   13ef4:	83 ec 0c             	sub    $0xc,%esp
   13ef7:	50                   	push   %eax
   13ef8:	e8 94 fe ff ff       	call   13d91 <do_fx_key>
   13efd:	83 c4 10             	add    $0x10,%esp
        break;
   13f00:	e9 98 00 00 00       	jmp    13f9d <do_normal_key+0x1d0>
    default:
        if(is_make){
   13f05:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13f09:	0f 84 8d 00 00 00    	je     13f9c <do_normal_key+0x1cf>
            if(kbd_stat.lshift_press || kbd_stat.rshift_press){
   13f0f:	0f b6 05 c0 32 03 00 	movzbl 0x332c0,%eax
   13f16:	83 e0 02             	and    $0x2,%eax
   13f19:	84 c0                	test   %al,%al
   13f1b:	75 0e                	jne    13f2b <do_normal_key+0x15e>
   13f1d:	0f b6 05 c0 32 03 00 	movzbl 0x332c0,%eax
   13f24:	83 e0 04             	and    $0x4,%eax
   13f27:	84 c0                	test   %al,%al
   13f29:	74 11                	je     13f3c <do_normal_key+0x16f>
                key=map_table[key].func;
   13f2b:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   13f2f:	0f b6 84 00 81 65 01 	movzbl 0x16581(%eax,%eax,1),%eax
   13f36:	00 
   13f37:	88 45 f7             	mov    %al,-0x9(%ebp)
   13f3a:	eb 0f                	jmp    13f4b <do_normal_key+0x17e>
            }
            else{
                key=map_table[key].normal;
   13f3c:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   13f40:	0f b6 84 00 80 65 01 	movzbl 0x16580(%eax,%eax,1),%eax
   13f47:	00 
   13f48:	88 45 f7             	mov    %al,-0x9(%ebp)
            }

            if(kbd_stat.caps_lock){
   13f4b:	0f b6 05 c0 32 03 00 	movzbl 0x332c0,%eax
   13f52:	83 e0 01             	and    $0x1,%eax
   13f55:	84 c0                	test   %al,%al
   13f57:	74 2e                	je     13f87 <do_normal_key+0x1ba>
                if((key>='A') && (key <='Z')){
   13f59:	80 7d f7 40          	cmpb   $0x40,-0x9(%ebp)
   13f5d:	7e 12                	jle    13f71 <do_normal_key+0x1a4>
   13f5f:	80 7d f7 5a          	cmpb   $0x5a,-0x9(%ebp)
   13f63:	7f 0c                	jg     13f71 <do_normal_key+0x1a4>
                    key=key-'A'+'a';
   13f65:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   13f69:	83 c0 20             	add    $0x20,%eax
   13f6c:	88 45 f7             	mov    %al,-0x9(%ebp)
   13f6f:	eb 16                	jmp    13f87 <do_normal_key+0x1ba>
                }
                else if((key >= 'a') && (key <= 'z')){
   13f71:	80 7d f7 60          	cmpb   $0x60,-0x9(%ebp)
   13f75:	7e 10                	jle    13f87 <do_normal_key+0x1ba>
   13f77:	80 7d f7 7a          	cmpb   $0x7a,-0x9(%ebp)
   13f7b:	7f 0a                	jg     13f87 <do_normal_key+0x1ba>
                    key=key-'a'+'A';
   13f7d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   13f81:	83 e8 20             	sub    $0x20,%eax
   13f84:	88 45 f7             	mov    %al,-0x9(%ebp)
                }
            }

            tty_in(key);
   13f87:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
   13f8b:	83 ec 0c             	sub    $0xc,%esp
   13f8e:	50                   	push   %eax
   13f8f:	e8 ba 06 00 00       	call   1464e <tty_in>
   13f94:	83 c4 10             	add    $0x10,%esp
        }
        break;
   13f97:	eb 03                	jmp    13f9c <do_normal_key+0x1cf>
        break;
   13f99:	90                   	nop
   13f9a:	eb 01                	jmp    13f9d <do_normal_key+0x1d0>
        break;
   13f9c:	90                   	nop
    }
}
   13f9d:	90                   	nop
   13f9e:	c9                   	leave  
   13f9f:	c3                   	ret    

00013fa0 <do_e0_key>:

void do_e0_key(uint8_t raw_code){
   13fa0:	55                   	push   %ebp
   13fa1:	89 e5                	mov    %esp,%ebp
   13fa3:	83 ec 14             	sub    $0x14,%esp
   13fa6:	8b 45 08             	mov    0x8(%ebp),%eax
   13fa9:	88 45 ec             	mov    %al,-0x14(%ebp)
    char key=get_key(raw_code);
   13fac:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
   13fb0:	50                   	push   %eax
   13fb1:	e8 c6 fd ff ff       	call   13d7c <get_key>
   13fb6:	83 c4 04             	add    $0x4,%esp
   13fb9:	88 45 ff             	mov    %al,-0x1(%ebp)
    int is_make=is_make_code(raw_code);
   13fbc:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
   13fc0:	50                   	push   %eax
   13fc1:	e8 9c fd ff ff       	call   13d62 <is_make_code>
   13fc6:	83 c4 04             	add    $0x4,%esp
   13fc9:	89 45 f8             	mov    %eax,-0x8(%ebp)

    switch (key)
   13fcc:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
   13fd0:	83 f8 1d             	cmp    $0x1d,%eax
   13fd3:	74 07                	je     13fdc <do_e0_key+0x3c>
   13fd5:	83 f8 38             	cmp    $0x38,%eax
   13fd8:	74 26                	je     14000 <do_e0_key+0x60>
        break;
    case KEY_ALT:
        kbd_stat.ralt_press;
        break;
    default:
        break;
   13fda:	eb 25                	jmp    14001 <do_e0_key+0x61>
        kbd_stat.rctrl_press=is_make;
   13fdc:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13fdf:	c1 e0 07             	shl    $0x7,%eax
   13fe2:	c0 f8 07             	sar    $0x7,%al
   13fe5:	83 e0 01             	and    $0x1,%eax
   13fe8:	c1 e0 06             	shl    $0x6,%eax
   13feb:	89 c2                	mov    %eax,%edx
   13fed:	0f b6 05 c0 32 03 00 	movzbl 0x332c0,%eax
   13ff4:	83 e0 bf             	and    $0xffffffbf,%eax
   13ff7:	09 d0                	or     %edx,%eax
   13ff9:	a2 c0 32 03 00       	mov    %al,0x332c0
        break;
   13ffe:	eb 01                	jmp    14001 <do_e0_key+0x61>
        break;
   14000:	90                   	nop
    }
}
   14001:	90                   	nop
   14002:	c9                   	leave  
   14003:	c3                   	ret    

00014004 <do_handler_kbd>:

void do_handler_kbd(exception_frame_t *frame){
   14004:	55                   	push   %ebp
   14005:	89 e5                	mov    %esp,%ebp
   14007:	83 ec 18             	sub    $0x18,%esp
    static enum{
        NORMAL,
        BEGIN_E0,
        BEGIN_E1,
    }recv_state=NORMAL;
    uint8_t status=inb(KBD_PORT_STAT);
   1400a:	6a 64                	push   $0x64
   1400c:	e8 e5 fc ff ff       	call   13cf6 <inb>
   14011:	83 c4 04             	add    $0x4,%esp
   14014:	88 45 f7             	mov    %al,-0x9(%ebp)

    if(!(status & KBD_STAT_RECV_READY)){
   14017:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   1401b:	83 e0 01             	and    $0x1,%eax
   1401e:	85 c0                	test   %eax,%eax
   14020:	75 12                	jne    14034 <do_handler_kbd+0x30>
        pic_send_eoi(IRQ1_KEYBOARD);
   14022:	83 ec 0c             	sub    $0xc,%esp
   14025:	6a 21                	push   $0x21
   14027:	e8 07 ee ff ff       	call   12e33 <pic_send_eoi>
   1402c:	83 c4 10             	add    $0x10,%esp
        return;
   1402f:	e9 8e 00 00 00       	jmp    140c2 <do_handler_kbd+0xbe>
    }

    uint8_t raw_code=inb(KBD_PORT_DATA);
   14034:	83 ec 0c             	sub    $0xc,%esp
   14037:	6a 60                	push   $0x60
   14039:	e8 b8 fc ff ff       	call   13cf6 <inb>
   1403e:	83 c4 10             	add    $0x10,%esp
   14041:	88 45 f6             	mov    %al,-0xa(%ebp)

    if(raw_code == KEY_E0){
   14044:	80 7d f6 e0          	cmpb   $0xe0,-0xa(%ebp)
   14048:	75 0a                	jne    14054 <do_handler_kbd+0x50>
        recv_state=BEGIN_E0;
   1404a:	c7 05 c8 32 03 00 01 	movl   $0x1,0x332c8
   14051:	00 00 00 
    }

    if(raw_code == KEY_E1){
   14054:	80 7d f6 e1          	cmpb   $0xe1,-0xa(%ebp)
   14058:	75 0c                	jne    14066 <do_handler_kbd+0x62>
        recv_state=BEGIN_E1;
   1405a:	c7 05 c8 32 03 00 02 	movl   $0x2,0x332c8
   14061:	00 00 00 
   14064:	eb 4f                	jmp    140b5 <do_handler_kbd+0xb1>
    }
    else{
        switch (recv_state)
   14066:	a1 c8 32 03 00       	mov    0x332c8,%eax
   1406b:	83 f8 01             	cmp    $0x1,%eax
   1406e:	74 1e                	je     1408e <do_handler_kbd+0x8a>
   14070:	83 f8 01             	cmp    $0x1,%eax
   14073:	72 07                	jb     1407c <do_handler_kbd+0x78>
   14075:	83 f8 02             	cmp    $0x2,%eax
   14078:	74 30                	je     140aa <do_handler_kbd+0xa6>
            break;
        case BEGIN_E1:
            recv_state=NORMAL;
            break;
        default:
            break;
   1407a:	eb 39                	jmp    140b5 <do_handler_kbd+0xb1>
            do_normal_key(raw_code);
   1407c:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
   14080:	83 ec 0c             	sub    $0xc,%esp
   14083:	50                   	push   %eax
   14084:	e8 44 fd ff ff       	call   13dcd <do_normal_key>
   14089:	83 c4 10             	add    $0x10,%esp
            break;
   1408c:	eb 27                	jmp    140b5 <do_handler_kbd+0xb1>
            do_e0_key(raw_code);
   1408e:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
   14092:	83 ec 0c             	sub    $0xc,%esp
   14095:	50                   	push   %eax
   14096:	e8 05 ff ff ff       	call   13fa0 <do_e0_key>
   1409b:	83 c4 10             	add    $0x10,%esp
            recv_state=NORMAL;
   1409e:	c7 05 c8 32 03 00 00 	movl   $0x0,0x332c8
   140a5:	00 00 00 
            break;
   140a8:	eb 0b                	jmp    140b5 <do_handler_kbd+0xb1>
            recv_state=NORMAL;
   140aa:	c7 05 c8 32 03 00 00 	movl   $0x0,0x332c8
   140b1:	00 00 00 
            break;
   140b4:	90                   	nop
        }
    }

    pic_send_eoi(IRQ1_KEYBOARD);
   140b5:	83 ec 0c             	sub    $0xc,%esp
   140b8:	6a 21                	push   $0x21
   140ba:	e8 74 ed ff ff       	call   12e33 <pic_send_eoi>
   140bf:	83 c4 10             	add    $0x10,%esp
   140c2:	c9                   	leave  
   140c3:	c3                   	ret    

000140c4 <outb>:
static inline void outb(uint16_t port,uint8_t data){
   140c4:	55                   	push   %ebp
   140c5:	89 e5                	mov    %esp,%ebp
   140c7:	83 ec 08             	sub    $0x8,%esp
   140ca:	8b 55 08             	mov    0x8(%ebp),%edx
   140cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   140d0:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   140d4:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   140d7:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   140db:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   140df:	ee                   	out    %al,(%dx)
}
   140e0:	90                   	nop
   140e1:	c9                   	leave  
   140e2:	c3                   	ret    

000140e3 <do_handler_time>:
#include "dev/time.h"

// 定时器计数
static uint32_t sys_tick;

void do_handler_time(exception_frame_t* frame){
   140e3:	55                   	push   %ebp
   140e4:	89 e5                	mov    %esp,%ebp
   140e6:	83 ec 08             	sub    $0x8,%esp
    sys_tick++;
   140e9:	a1 cc 32 03 00       	mov    0x332cc,%eax
   140ee:	83 c0 01             	add    $0x1,%eax
   140f1:	a3 cc 32 03 00       	mov    %eax,0x332cc
    pic_send_eoi(IRQ0_TIMER);
   140f6:	83 ec 0c             	sub    $0xc,%esp
   140f9:	6a 20                	push   $0x20
   140fb:	e8 33 ed ff ff       	call   12e33 <pic_send_eoi>
   14100:	83 c4 10             	add    $0x10,%esp
    task_time_tick();
   14103:	e8 9a d5 ff ff       	call   116a2 <task_time_tick>
}
   14108:	90                   	nop
   14109:	c9                   	leave  
   1410a:	c3                   	ret    

0001410b <init_pit>:

// 定时器硬件初始化
static void init_pit(void){
   1410b:	55                   	push   %ebp
   1410c:	89 e5                	mov    %esp,%ebp
   1410e:	83 ec 18             	sub    $0x18,%esp
    
    uint32_t reload_count = PIT_OSC_FREQ / (1000.0 / OS_TICK_MS);
   14111:	c7 45 f4 9b 2e 00 00 	movl   $0x2e9b,-0xc(%ebp)
    // 设置多少秒产生中断
    outb(PIT_COMMAND_MODE_PORT, PIT_CHANNEL0 | PIT_LOAD_LOHI | PIT_MODE3);
   14118:	6a 36                	push   $0x36
   1411a:	6a 43                	push   $0x43
   1411c:	e8 a3 ff ff ff       	call   140c4 <outb>
   14121:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, reload_count & 0xFF);   // 加载低8位
   14124:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14127:	0f b6 c0             	movzbl %al,%eax
   1412a:	50                   	push   %eax
   1412b:	6a 40                	push   $0x40
   1412d:	e8 92 ff ff ff       	call   140c4 <outb>
   14132:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, (reload_count >> 8) & 0xFF); // 再加载高8位
   14135:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14138:	c1 e8 08             	shr    $0x8,%eax
   1413b:	0f b6 c0             	movzbl %al,%eax
   1413e:	50                   	push   %eax
   1413f:	6a 40                	push   $0x40
   14141:	e8 7e ff ff ff       	call   140c4 <outb>
   14146:	83 c4 08             	add    $0x8,%esp

    irq_install(IRQ0_TIMER, (irq_handler_t)exception_handler_time);
   14149:	83 ec 08             	sub    $0x8,%esp
   1414c:	68 89 02 01 00       	push   $0x10289
   14151:	6a 20                	push   $0x20
   14153:	e8 e9 e7 ff ff       	call   12941 <irq_install>
   14158:	83 c4 10             	add    $0x10,%esp
    irq_enable(IRQ0_TIMER);
   1415b:	83 ec 0c             	sub    $0xc,%esp
   1415e:	6a 20                	push   $0x20
   14160:	e8 1c e5 ff ff       	call   12681 <irq_enable>
   14165:	83 c4 10             	add    $0x10,%esp
}
   14168:	90                   	nop
   14169:	c9                   	leave  
   1416a:	c3                   	ret    

0001416b <time_init>:

// 定时器初始化
void time_init(void){
   1416b:	55                   	push   %ebp
   1416c:	89 e5                	mov    %esp,%ebp
   1416e:	83 ec 08             	sub    $0x8,%esp
    sys_tick=0;
   14171:	c7 05 cc 32 03 00 00 	movl   $0x0,0x332cc
   14178:	00 00 00 
    init_pit();
   1417b:	e8 8b ff ff ff       	call   1410b <init_pit>
   14180:	90                   	nop
   14181:	c9                   	leave  
   14182:	c3                   	ret    

00014183 <get_tty>:
static tty_t tty_devs[TTY_NR];

/// @brief 当前使用的tty设备的索引
static int curr_tty=0;

static tty_t* get_tty(device_t* dev){
   14183:	55                   	push   %ebp
   14184:	89 e5                	mov    %esp,%ebp
   14186:	83 ec 18             	sub    $0x18,%esp
    int idx=dev->minor;
   14189:	8b 45 08             	mov    0x8(%ebp),%eax
   1418c:	8b 40 08             	mov    0x8(%eax),%eax
   1418f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if((idx<0) || (idx>=TTY_NR) || (!dev->open_count)){
   14192:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14196:	78 10                	js     141a8 <get_tty+0x25>
   14198:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   1419c:	7f 0a                	jg     141a8 <get_tty+0x25>
   1419e:	8b 45 08             	mov    0x8(%ebp),%eax
   141a1:	8b 40 10             	mov    0x10(%eax),%eax
   141a4:	85 c0                	test   %eax,%eax
   141a6:	75 1a                	jne    141c2 <get_tty+0x3f>
        log_printf("tty is not opened. tty=%d\n",idx);
   141a8:	83 ec 08             	sub    $0x8,%esp
   141ab:	ff 75 f4             	pushl  -0xc(%ebp)
   141ae:	68 8c 66 01 00       	push   $0x1668c
   141b3:	e8 c5 18 00 00       	call   15a7d <log_printf>
   141b8:	83 c4 10             	add    $0x10,%esp
        return (tty_t*)0;
   141bb:	b8 00 00 00 00       	mov    $0x0,%eax
   141c0:	eb 0e                	jmp    141d0 <get_tty+0x4d>
    }

    return tty_devs+idx;
   141c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   141c5:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   141cb:	05 e0 32 03 00       	add    $0x332e0,%eax
}
   141d0:	c9                   	leave  
   141d1:	c3                   	ret    

000141d2 <tty_fifo_init>:

void tty_fifo_init(tty_fifo_t* fifo,char* buf,int size){
   141d2:	55                   	push   %ebp
   141d3:	89 e5                	mov    %esp,%ebp
    fifo->buf=buf;
   141d5:	8b 45 08             	mov    0x8(%ebp),%eax
   141d8:	8b 55 0c             	mov    0xc(%ebp),%edx
   141db:	89 10                	mov    %edx,(%eax)
    fifo->size=size;
   141dd:	8b 45 08             	mov    0x8(%ebp),%eax
   141e0:	8b 55 10             	mov    0x10(%ebp),%edx
   141e3:	89 50 04             	mov    %edx,0x4(%eax)
    fifo->count=0;
   141e6:	8b 45 08             	mov    0x8(%ebp),%eax
   141e9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    fifo->read=fifo->write=0;
   141f0:	8b 45 08             	mov    0x8(%ebp),%eax
   141f3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   141fa:	8b 45 08             	mov    0x8(%ebp),%eax
   141fd:	8b 50 0c             	mov    0xc(%eax),%edx
   14200:	8b 45 08             	mov    0x8(%ebp),%eax
   14203:	89 50 08             	mov    %edx,0x8(%eax)
}
   14206:	90                   	nop
   14207:	5d                   	pop    %ebp
   14208:	c3                   	ret    

00014209 <tty_fifo_put>:
 * @brief 向tty的输出缓存中写入一个字符
 * @param fifo tty的输出缓存
 * @param c 要写入的字符
 * @return 0 成功，-1 失败
 */
int tty_fifo_put(tty_fifo_t* fifo,char c){
   14209:	55                   	push   %ebp
   1420a:	89 e5                	mov    %esp,%ebp
   1420c:	53                   	push   %ebx
   1420d:	83 ec 24             	sub    $0x24,%esp
   14210:	8b 45 0c             	mov    0xc(%ebp),%eax
   14213:	88 45 e4             	mov    %al,-0x1c(%ebp)
    irq_state_t state=irq_enter_protection();
   14216:	e8 43 ec ff ff       	call   12e5e <irq_enter_protection>
   1421b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(fifo->count>=fifo->size){
   1421e:	8b 45 08             	mov    0x8(%ebp),%eax
   14221:	8b 50 10             	mov    0x10(%eax),%edx
   14224:	8b 45 08             	mov    0x8(%ebp),%eax
   14227:	8b 40 04             	mov    0x4(%eax),%eax
   1422a:	39 c2                	cmp    %eax,%edx
   1422c:	7c 15                	jl     14243 <tty_fifo_put+0x3a>

        irq_leave_protection(state);
   1422e:	83 ec 0c             	sub    $0xc,%esp
   14231:	ff 75 f4             	pushl  -0xc(%ebp)
   14234:	e8 3d ec ff ff       	call   12e76 <irq_leave_protection>
   14239:	83 c4 10             	add    $0x10,%esp
        return -1;
   1423c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14241:	eb 4b                	jmp    1428e <tty_fifo_put+0x85>
    }

    fifo->buf[fifo->write++]=c;
   14243:	8b 45 08             	mov    0x8(%ebp),%eax
   14246:	8b 18                	mov    (%eax),%ebx
   14248:	8b 45 08             	mov    0x8(%ebp),%eax
   1424b:	8b 40 0c             	mov    0xc(%eax),%eax
   1424e:	8d 48 01             	lea    0x1(%eax),%ecx
   14251:	8b 55 08             	mov    0x8(%ebp),%edx
   14254:	89 4a 0c             	mov    %ecx,0xc(%edx)
   14257:	8d 14 03             	lea    (%ebx,%eax,1),%edx
   1425a:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   1425e:	88 02                	mov    %al,(%edx)
    if(fifo->write>=fifo->size){
   14260:	8b 45 08             	mov    0x8(%ebp),%eax
   14263:	8b 50 0c             	mov    0xc(%eax),%edx
   14266:	8b 45 08             	mov    0x8(%ebp),%eax
   14269:	8b 40 04             	mov    0x4(%eax),%eax
   1426c:	39 c2                	cmp    %eax,%edx
   1426e:	7c 0a                	jl     1427a <tty_fifo_put+0x71>
        fifo->write=0;
   14270:	8b 45 08             	mov    0x8(%ebp),%eax
   14273:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    }
    
    fifo->count++;
   1427a:	8b 45 08             	mov    0x8(%ebp),%eax
   1427d:	8b 40 10             	mov    0x10(%eax),%eax
   14280:	8d 50 01             	lea    0x1(%eax),%edx
   14283:	8b 45 08             	mov    0x8(%ebp),%eax
   14286:	89 50 10             	mov    %edx,0x10(%eax)

    return 0;
   14289:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1428e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14291:	c9                   	leave  
   14292:	c3                   	ret    

00014293 <tty_fifo_get>:

int tty_fifo_get(tty_fifo_t* fifo,char* c){
   14293:	55                   	push   %ebp
   14294:	89 e5                	mov    %esp,%ebp
   14296:	53                   	push   %ebx
   14297:	83 ec 14             	sub    $0x14,%esp
    irq_state_t state=irq_enter_protection();
   1429a:	e8 bf eb ff ff       	call   12e5e <irq_enter_protection>
   1429f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(fifo->count<=0){
   142a2:	8b 45 08             	mov    0x8(%ebp),%eax
   142a5:	8b 40 10             	mov    0x10(%eax),%eax
   142a8:	85 c0                	test   %eax,%eax
   142aa:	7f 15                	jg     142c1 <tty_fifo_get+0x2e>
        irq_leave_protection(state);
   142ac:	83 ec 0c             	sub    $0xc,%esp
   142af:	ff 75 f4             	pushl  -0xc(%ebp)
   142b2:	e8 bf eb ff ff       	call   12e76 <irq_leave_protection>
   142b7:	83 c4 10             	add    $0x10,%esp
        return -1;
   142ba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   142bf:	eb 5a                	jmp    1431b <tty_fifo_get+0x88>
    }

    *c=fifo->buf[fifo->read++];
   142c1:	8b 45 08             	mov    0x8(%ebp),%eax
   142c4:	8b 18                	mov    (%eax),%ebx
   142c6:	8b 45 08             	mov    0x8(%ebp),%eax
   142c9:	8b 40 08             	mov    0x8(%eax),%eax
   142cc:	8d 48 01             	lea    0x1(%eax),%ecx
   142cf:	8b 55 08             	mov    0x8(%ebp),%edx
   142d2:	89 4a 08             	mov    %ecx,0x8(%edx)
   142d5:	01 d8                	add    %ebx,%eax
   142d7:	0f b6 10             	movzbl (%eax),%edx
   142da:	8b 45 0c             	mov    0xc(%ebp),%eax
   142dd:	88 10                	mov    %dl,(%eax)
    if(fifo->read>=fifo->size){
   142df:	8b 45 08             	mov    0x8(%ebp),%eax
   142e2:	8b 50 08             	mov    0x8(%eax),%edx
   142e5:	8b 45 08             	mov    0x8(%ebp),%eax
   142e8:	8b 40 04             	mov    0x4(%eax),%eax
   142eb:	39 c2                	cmp    %eax,%edx
   142ed:	7c 0a                	jl     142f9 <tty_fifo_get+0x66>
        fifo->read=0;
   142ef:	8b 45 08             	mov    0x8(%ebp),%eax
   142f2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    }
    fifo->count--;
   142f9:	8b 45 08             	mov    0x8(%ebp),%eax
   142fc:	8b 40 10             	mov    0x10(%eax),%eax
   142ff:	8d 50 ff             	lea    -0x1(%eax),%edx
   14302:	8b 45 08             	mov    0x8(%ebp),%eax
   14305:	89 50 10             	mov    %edx,0x10(%eax)

    irq_leave_protection(state);
   14308:	83 ec 0c             	sub    $0xc,%esp
   1430b:	ff 75 f4             	pushl  -0xc(%ebp)
   1430e:	e8 63 eb ff ff       	call   12e76 <irq_leave_protection>
   14313:	83 c4 10             	add    $0x10,%esp
    return 0;
   14316:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1431b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1431e:	c9                   	leave  
   1431f:	c3                   	ret    

00014320 <tty_open>:

int tty_open(device_t* dev){
   14320:	55                   	push   %ebp
   14321:	89 e5                	mov    %esp,%ebp
   14323:	83 ec 18             	sub    $0x18,%esp
    int idx=dev->minor;
   14326:	8b 45 08             	mov    0x8(%ebp),%eax
   14329:	8b 40 08             	mov    0x8(%eax),%eax
   1432c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if((idx<0)&&(idx>=TTY_NR)){
   1432f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14333:	79 23                	jns    14358 <tty_open+0x38>
   14335:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14339:	7e 1d                	jle    14358 <tty_open+0x38>
        log_printf("open tty failed. incorrect tty num=%d\n",idx);
   1433b:	83 ec 08             	sub    $0x8,%esp
   1433e:	ff 75 f4             	pushl  -0xc(%ebp)
   14341:	68 a8 66 01 00       	push   $0x166a8
   14346:	e8 32 17 00 00       	call   15a7d <log_printf>
   1434b:	83 c4 10             	add    $0x10,%esp
        return -1;
   1434e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14353:	e9 c6 00 00 00       	jmp    1441e <tty_open+0xfe>
    }

    tty_t* tty=tty_devs+idx;
   14358:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1435b:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   14361:	05 e0 32 03 00       	add    $0x332e0,%eax
   14366:	89 45 f0             	mov    %eax,-0x10(%ebp)

    tty_fifo_init(&tty->ofifo,tty->obuf,TTY_OBUF_SIZE);
   14369:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1436c:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1436f:	81 c2 00 04 00 00    	add    $0x400,%edx
   14375:	83 ec 04             	sub    $0x4,%esp
   14378:	68 00 02 00 00       	push   $0x200
   1437d:	50                   	push   %eax
   1437e:	52                   	push   %edx
   1437f:	e8 4e fe ff ff       	call   141d2 <tty_fifo_init>
   14384:	83 c4 10             	add    $0x10,%esp
    sem_init(&tty->osem,TTY_OBUF_SIZE);
   14387:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1438a:	05 2c 04 00 00       	add    $0x42c,%eax
   1438f:	83 ec 08             	sub    $0x8,%esp
   14392:	68 00 02 00 00       	push   $0x200
   14397:	50                   	push   %eax
   14398:	e8 4c 0b 00 00       	call   14ee9 <sem_init>
   1439d:	83 c4 10             	add    $0x10,%esp
    tty_fifo_init(&tty->ififo,tty->ibuf,TTY_IBUF_SIZE);
   143a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   143a3:	8d 90 00 02 00 00    	lea    0x200(%eax),%edx
   143a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   143ac:	05 14 04 00 00       	add    $0x414,%eax
   143b1:	83 ec 04             	sub    $0x4,%esp
   143b4:	68 00 02 00 00       	push   $0x200
   143b9:	52                   	push   %edx
   143ba:	50                   	push   %eax
   143bb:	e8 12 fe ff ff       	call   141d2 <tty_fifo_init>
   143c0:	83 c4 10             	add    $0x10,%esp
    sem_init(&tty->isem,0);
   143c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   143c6:	05 3c 04 00 00       	add    $0x43c,%eax
   143cb:	83 ec 08             	sub    $0x8,%esp
   143ce:	6a 00                	push   $0x0
   143d0:	50                   	push   %eax
   143d1:	e8 13 0b 00 00       	call   14ee9 <sem_init>
   143d6:	83 c4 10             	add    $0x10,%esp

    tty->oflags=TTY_OCRLF;
   143d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   143dc:	c7 80 50 04 00 00 01 	movl   $0x1,0x450(%eax)
   143e3:	00 00 00 
    tty->console_index=idx;
   143e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   143e9:	8b 55 f4             	mov    -0xc(%ebp),%edx
   143ec:	89 90 28 04 00 00    	mov    %edx,0x428(%eax)

    tty->iflags=TTY_IECHO | TTY_INCLR;
   143f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   143f5:	c7 80 4c 04 00 00 03 	movl   $0x3,0x44c(%eax)
   143fc:	00 00 00 

    kbd_init();    
   143ff:	e8 0f f9 ff ff       	call   13d13 <kbd_init>
    console_init(tty->console_index);
   14404:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14407:	8b 80 28 04 00 00    	mov    0x428(%eax),%eax
   1440d:	83 ec 0c             	sub    $0xc,%esp
   14410:	50                   	push   %eax
   14411:	e8 b3 ee ff ff       	call   132c9 <console_init>
   14416:	83 c4 10             	add    $0x10,%esp
    
    return 0;
   14419:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1441e:	c9                   	leave  
   1441f:	c3                   	ret    

00014420 <tty_read>:
 * @param addr 读的起始地址，暂时不使用
 * @param buf 读到的字符存放的地址
 * @param size 读的字符的个数
 * @return 读到的字符的个数，失败返回-1
 */
int tty_read(device_t* dev,int addr,char* buf,int size){
   14420:	55                   	push   %ebp
   14421:	89 e5                	mov    %esp,%ebp
   14423:	83 ec 18             	sub    $0x18,%esp
    if(size < 0){
   14426:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   1442a:	79 0a                	jns    14436 <tty_read+0x16>
        return -1;
   1442c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14431:	e9 09 01 00 00       	jmp    1453f <tty_read+0x11f>
    }

    tty_t* tty=get_tty(dev);
   14436:	83 ec 0c             	sub    $0xc,%esp
   14439:	ff 75 08             	pushl  0x8(%ebp)
   1443c:	e8 42 fd ff ff       	call   14183 <get_tty>
   14441:	83 c4 10             	add    $0x10,%esp
   14444:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char* pbuf=buf;
   14447:	8b 45 10             	mov    0x10(%ebp),%eax
   1444a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int len=0;
   1444d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while(len < size){
   14454:	e9 d7 00 00 00       	jmp    14530 <tty_read+0x110>
        sem_wait(&tty->isem);
   14459:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1445c:	05 3c 04 00 00       	add    $0x43c,%eax
   14461:	83 ec 0c             	sub    $0xc,%esp
   14464:	50                   	push   %eax
   14465:	e8 a2 0a 00 00       	call   14f0c <sem_wait>
   1446a:	83 c4 10             	add    $0x10,%esp

        char ch;
        tty_fifo_get(&tty->ififo,&ch);
   1446d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14470:	8d 90 14 04 00 00    	lea    0x414(%eax),%edx
   14476:	83 ec 08             	sub    $0x8,%esp
   14479:	8d 45 eb             	lea    -0x15(%ebp),%eax
   1447c:	50                   	push   %eax
   1447d:	52                   	push   %edx
   1447e:	e8 10 fe ff ff       	call   14293 <tty_fifo_get>
   14483:	83 c4 10             	add    $0x10,%esp
        switch(ch){
   14486:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   1448a:	0f be c0             	movsbl %al,%eax
   1448d:	83 f8 0a             	cmp    $0xa,%eax
   14490:	74 1a                	je     144ac <tty_read+0x8c>
   14492:	83 f8 7f             	cmp    $0x7f,%eax
   14495:	75 52                	jne    144e9 <tty_read+0xc9>
            
            // 处理推格键
            case 0x7F:
                if(len == 0){
   14497:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1449b:	75 05                	jne    144a2 <tty_read+0x82>
   1449d:	e9 8e 00 00 00       	jmp    14530 <tty_read+0x110>
                   continue;
                }

                len--;
   144a2:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
                pbuf--;
   144a6:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
                break;
   144aa:	eb 51                	jmp    144fd <tty_read+0xdd>
            case '\n':
                if((tty->iflags & TTY_INCLR) && (len < size-1)){
   144ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
   144af:	8b 80 4c 04 00 00    	mov    0x44c(%eax),%eax
   144b5:	83 e0 01             	and    $0x1,%eax
   144b8:	85 c0                	test   %eax,%eax
   144ba:	74 1b                	je     144d7 <tty_read+0xb7>
   144bc:	8b 45 14             	mov    0x14(%ebp),%eax
   144bf:	83 e8 01             	sub    $0x1,%eax
   144c2:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   144c5:	7d 10                	jge    144d7 <tty_read+0xb7>
                    *pbuf++='\r';
   144c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144ca:	8d 50 01             	lea    0x1(%eax),%edx
   144cd:	89 55 f4             	mov    %edx,-0xc(%ebp)
   144d0:	c6 00 0d             	movb   $0xd,(%eax)
                    len++;
   144d3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
                }
                *pbuf++='\n';
   144d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144da:	8d 50 01             	lea    0x1(%eax),%edx
   144dd:	89 55 f4             	mov    %edx,-0xc(%ebp)
   144e0:	c6 00 0a             	movb   $0xa,(%eax)
                len++;
   144e3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
                break;
   144e7:	eb 14                	jmp    144fd <tty_read+0xdd>
            default:
                *pbuf++=ch;
   144e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144ec:	8d 50 01             	lea    0x1(%eax),%edx
   144ef:	89 55 f4             	mov    %edx,-0xc(%ebp)
   144f2:	0f b6 55 eb          	movzbl -0x15(%ebp),%edx
   144f6:	88 10                	mov    %dl,(%eax)
                len++;
   144f8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
                break;
   144fc:	90                   	nop
        }

        // 处理回显
        if(tty->iflags & TTY_IECHO){
   144fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14500:	8b 80 4c 04 00 00    	mov    0x44c(%eax),%eax
   14506:	83 e0 02             	and    $0x2,%eax
   14509:	85 c0                	test   %eax,%eax
   1450b:	74 13                	je     14520 <tty_read+0x100>
            tty_write(dev,0,&ch,1);
   1450d:	6a 01                	push   $0x1
   1450f:	8d 45 eb             	lea    -0x15(%ebp),%eax
   14512:	50                   	push   %eax
   14513:	6a 00                	push   $0x0
   14515:	ff 75 08             	pushl  0x8(%ebp)
   14518:	e8 24 00 00 00       	call   14541 <tty_write>
   1451d:	83 c4 10             	add    $0x10,%esp
        }

        if((ch == '\n') || (ch == '\r')){
   14520:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   14524:	3c 0a                	cmp    $0xa,%al
   14526:	74 14                	je     1453c <tty_read+0x11c>
   14528:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   1452c:	3c 0d                	cmp    $0xd,%al
   1452e:	74 0c                	je     1453c <tty_read+0x11c>
    while(len < size){
   14530:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14533:	3b 45 14             	cmp    0x14(%ebp),%eax
   14536:	0f 8c 1d ff ff ff    	jl     14459 <tty_read+0x39>
            break;
        }
    }
    return len;
   1453c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   1453f:	c9                   	leave  
   14540:	c3                   	ret    

00014541 <tty_write>:

int tty_write(device_t* dev,int addr,char* buf,int size){
   14541:	55                   	push   %ebp
   14542:	89 e5                	mov    %esp,%ebp
   14544:	83 ec 28             	sub    $0x28,%esp
    if (size < 0){
   14547:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   1454b:	79 0a                	jns    14557 <tty_write+0x16>
        return -1;
   1454d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14552:	e9 e5 00 00 00       	jmp    1463c <tty_write+0xfb>
    }

    tty_t* tty=get_tty(dev);
   14557:	83 ec 0c             	sub    $0xc,%esp
   1455a:	ff 75 08             	pushl  0x8(%ebp)
   1455d:	e8 21 fc ff ff       	call   14183 <get_tty>
   14562:	83 c4 10             	add    $0x10,%esp
   14565:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (!tty){
   14568:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1456c:	75 0a                	jne    14578 <tty_write+0x37>
        return -1;
   1456e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14573:	e9 c4 00 00 00       	jmp    1463c <tty_write+0xfb>
    }

    int len =0;
   14578:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(size){
   1457f:	e9 a5 00 00 00       	jmp    14629 <tty_write+0xe8>
        char c=*buf++;
   14584:	8b 45 10             	mov    0x10(%ebp),%eax
   14587:	8d 50 01             	lea    0x1(%eax),%edx
   1458a:	89 55 10             	mov    %edx,0x10(%ebp)
   1458d:	0f b6 00             	movzbl (%eax),%eax
   14590:	88 45 ef             	mov    %al,-0x11(%ebp)

        if(c == '\n' && (tty->oflags & TTY_OCRLF)){
   14593:	80 7d ef 0a          	cmpb   $0xa,-0x11(%ebp)
   14597:	75 43                	jne    145dc <tty_write+0x9b>
   14599:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1459c:	8b 80 50 04 00 00    	mov    0x450(%eax),%eax
   145a2:	83 e0 01             	and    $0x1,%eax
   145a5:	85 c0                	test   %eax,%eax
   145a7:	74 33                	je     145dc <tty_write+0x9b>
            sem_wait(&tty->osem);
   145a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   145ac:	05 2c 04 00 00       	add    $0x42c,%eax
   145b1:	83 ec 0c             	sub    $0xc,%esp
   145b4:	50                   	push   %eax
   145b5:	e8 52 09 00 00       	call   14f0c <sem_wait>
   145ba:	83 c4 10             	add    $0x10,%esp
            int err=tty_fifo_put(&tty->ofifo,'\r');
   145bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   145c0:	05 00 04 00 00       	add    $0x400,%eax
   145c5:	83 ec 08             	sub    $0x8,%esp
   145c8:	6a 0d                	push   $0xd
   145ca:	50                   	push   %eax
   145cb:	e8 39 fc ff ff       	call   14209 <tty_fifo_put>
   145d0:	83 c4 10             	add    $0x10,%esp
   145d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
            if (err<0){
   145d6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   145da:	78 59                	js     14635 <tty_write+0xf4>
                break;
            }
        }

        sem_wait(&tty->osem);
   145dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   145df:	05 2c 04 00 00       	add    $0x42c,%eax
   145e4:	83 ec 0c             	sub    $0xc,%esp
   145e7:	50                   	push   %eax
   145e8:	e8 1f 09 00 00       	call   14f0c <sem_wait>
   145ed:	83 c4 10             	add    $0x10,%esp
        int err=tty_fifo_put(&tty->ofifo,c);
   145f0:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
   145f4:	8b 55 f0             	mov    -0x10(%ebp),%edx
   145f7:	81 c2 00 04 00 00    	add    $0x400,%edx
   145fd:	83 ec 08             	sub    $0x8,%esp
   14600:	50                   	push   %eax
   14601:	52                   	push   %edx
   14602:	e8 02 fc ff ff       	call   14209 <tty_fifo_put>
   14607:	83 c4 10             	add    $0x10,%esp
   1460a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (err<0){
   1460d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   14611:	78 25                	js     14638 <tty_write+0xf7>
            break;
        }
        len++;
   14613:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        size--;
   14617:	83 6d 14 01          	subl   $0x1,0x14(%ebp)

        console_write(tty);
   1461b:	83 ec 0c             	sub    $0xc,%esp
   1461e:	ff 75 f0             	pushl  -0x10(%ebp)
   14621:	e8 37 f2 ff ff       	call   1385d <console_write>
   14626:	83 c4 10             	add    $0x10,%esp
    while(size){
   14629:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   1462d:	0f 85 51 ff ff ff    	jne    14584 <tty_write+0x43>
   14633:	eb 04                	jmp    14639 <tty_write+0xf8>
                break;
   14635:	90                   	nop
   14636:	eb 01                	jmp    14639 <tty_write+0xf8>
            break;
   14638:	90                   	nop
    }

    return len;
   14639:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1463c:	c9                   	leave  
   1463d:	c3                   	ret    

0001463e <tty_control>:

int tty_control(device_t*dev,int cmd,int arg0,int arg1){
   1463e:	55                   	push   %ebp
   1463f:	89 e5                	mov    %esp,%ebp
    return 0;
   14641:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14646:	5d                   	pop    %ebp
   14647:	c3                   	ret    

00014648 <tty_close>:

void tty_close(device_t* dev){
   14648:	55                   	push   %ebp
   14649:	89 e5                	mov    %esp,%ebp

}
   1464b:	90                   	nop
   1464c:	5d                   	pop    %ebp
   1464d:	c3                   	ret    

0001464e <tty_in>:

/**
* @brief 选择curr_tty索引的tty设备，然后将ch放入tty的输入缓存中
* @param ch 要放入tty设备的输入缓存中的字符
*/ 
void tty_in(char ch){
   1464e:	55                   	push   %ebp
   1464f:	89 e5                	mov    %esp,%ebp
   14651:	83 ec 28             	sub    $0x28,%esp
   14654:	8b 45 08             	mov    0x8(%ebp),%eax
   14657:	88 45 e4             	mov    %al,-0x1c(%ebp)
    tty_t* tty=tty_devs+curr_tty;
   1465a:	a1 80 55 03 00       	mov    0x35580,%eax
   1465f:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   14665:	05 e0 32 03 00       	add    $0x332e0,%eax
   1466a:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(sem_count(&tty->isem) >= TTY_IBUF_SIZE){
   1466d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14670:	05 3c 04 00 00       	add    $0x43c,%eax
   14675:	83 ec 0c             	sub    $0xc,%esp
   14678:	50                   	push   %eax
   14679:	e8 80 09 00 00       	call   14ffe <sem_count>
   1467e:	83 c4 10             	add    $0x10,%esp
   14681:	3d ff 01 00 00       	cmp    $0x1ff,%eax
   14686:	7f 30                	jg     146b8 <tty_in+0x6a>
        return;
    }

    tty_fifo_put(&tty->ififo,ch);
   14688:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
   1468c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1468f:	81 c2 14 04 00 00    	add    $0x414,%edx
   14695:	83 ec 08             	sub    $0x8,%esp
   14698:	50                   	push   %eax
   14699:	52                   	push   %edx
   1469a:	e8 6a fb ff ff       	call   14209 <tty_fifo_put>
   1469f:	83 c4 10             	add    $0x10,%esp
    sem_notify(&tty->isem);
   146a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   146a5:	05 3c 04 00 00       	add    $0x43c,%eax
   146aa:	83 ec 0c             	sub    $0xc,%esp
   146ad:	50                   	push   %eax
   146ae:	e8 c7 08 00 00       	call   14f7a <sem_notify>
   146b3:	83 c4 10             	add    $0x10,%esp
   146b6:	eb 01                	jmp    146b9 <tty_in+0x6b>
        return;
   146b8:	90                   	nop

}
   146b9:	c9                   	leave  
   146ba:	c3                   	ret    

000146bb <tty_select>:

/**
 * @brief 选择tty设备
 * @param tty 要切换的tty设备的索引号
*/
void tty_select(int tty){
   146bb:	55                   	push   %ebp
   146bc:	89 e5                	mov    %esp,%ebp
   146be:	83 ec 08             	sub    $0x8,%esp
    if(tty!=curr_tty){
   146c1:	a1 80 55 03 00       	mov    0x35580,%eax
   146c6:	39 45 08             	cmp    %eax,0x8(%ebp)
   146c9:	74 16                	je     146e1 <tty_select+0x26>
        console_select(tty);
   146cb:	83 ec 0c             	sub    $0xc,%esp
   146ce:	ff 75 08             	pushl  0x8(%ebp)
   146d1:	e8 74 f2 ff ff       	call   1394a <console_select>
   146d6:	83 c4 10             	add    $0x10,%esp
        curr_tty=tty;
   146d9:	8b 45 08             	mov    0x8(%ebp),%eax
   146dc:	a3 80 55 03 00       	mov    %eax,0x35580
    }
}
   146e1:	90                   	nop
   146e2:	c9                   	leave  
   146e3:	c3                   	ret    

000146e4 <file_alloc>:
/// @brief 文件表
static file_t file_table[FILE_TABLE_SIZE]; // 文件表
/// @brief 文件互斥锁
static mutex_t file_alloc_mutex; 

file_t* file_alloc(void){
   146e4:	55                   	push   %ebp
   146e5:	89 e5                	mov    %esp,%ebp
   146e7:	83 ec 18             	sub    $0x18,%esp
    file_t* file=(file_t*)0;
   146ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    mutex_lock(&file_alloc_mutex);
   146f1:	83 ec 0c             	sub    $0xc,%esp
   146f4:	68 a0 15 05 00       	push   $0x515a0
   146f9:	e8 92 06 00 00       	call   14d90 <mutex_lock>
   146fe:	83 c4 10             	add    $0x10,%esp

    for(int i=0;i<FILE_TABLE_SIZE;i++){
   14701:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   14708:	eb 40                	jmp    1474a <file_alloc+0x66>
       file_t* p_file=file_table+i;
   1470a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1470d:	6b c0 38             	imul   $0x38,%eax,%eax
   14710:	05 a0 55 03 00       	add    $0x355a0,%eax
   14715:	89 45 ec             	mov    %eax,-0x14(%ebp)
       if(p_file->ref==0){
   14718:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1471b:	8b 40 28             	mov    0x28(%eax),%eax
   1471e:	85 c0                	test   %eax,%eax
   14720:	75 24                	jne    14746 <file_alloc+0x62>
           kernel_memset(p_file,0,sizeof(file_t));
   14722:	83 ec 04             	sub    $0x4,%esp
   14725:	6a 38                	push   $0x38
   14727:	6a 00                	push   $0x0
   14729:	ff 75 ec             	pushl  -0x14(%ebp)
   1472c:	e8 29 0d 00 00       	call   1545a <kernel_memset>
   14731:	83 c4 10             	add    $0x10,%esp
           p_file->ref=1;
   14734:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14737:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
           file=p_file;
   1473e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14741:	89 45 f4             	mov    %eax,-0xc(%ebp)
           break;
   14744:	eb 0d                	jmp    14753 <file_alloc+0x6f>
    for(int i=0;i<FILE_TABLE_SIZE;i++){
   14746:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1474a:	81 7d f0 ff 07 00 00 	cmpl   $0x7ff,-0x10(%ebp)
   14751:	7e b7                	jle    1470a <file_alloc+0x26>
       }
    }

    mutex_unlock(&file_alloc_mutex);
   14753:	83 ec 0c             	sub    $0xc,%esp
   14756:	68 a0 15 05 00       	push   $0x515a0
   1475b:	e8 bf 06 00 00       	call   14e1f <mutex_unlock>
   14760:	83 c4 10             	add    $0x10,%esp
    return file;
   14763:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14766:	c9                   	leave  
   14767:	c3                   	ret    

00014768 <file_free>:

void file_free(file_t* file){
   14768:	55                   	push   %ebp
   14769:	89 e5                	mov    %esp,%ebp
   1476b:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&file_alloc_mutex);
   1476e:	83 ec 0c             	sub    $0xc,%esp
   14771:	68 a0 15 05 00       	push   $0x515a0
   14776:	e8 15 06 00 00       	call   14d90 <mutex_lock>
   1477b:	83 c4 10             	add    $0x10,%esp

    if(file->ref){
   1477e:	8b 45 08             	mov    0x8(%ebp),%eax
   14781:	8b 40 28             	mov    0x28(%eax),%eax
   14784:	85 c0                	test   %eax,%eax
   14786:	74 0f                	je     14797 <file_free+0x2f>
        file->ref--;
   14788:	8b 45 08             	mov    0x8(%ebp),%eax
   1478b:	8b 40 28             	mov    0x28(%eax),%eax
   1478e:	8d 50 ff             	lea    -0x1(%eax),%edx
   14791:	8b 45 08             	mov    0x8(%ebp),%eax
   14794:	89 50 28             	mov    %edx,0x28(%eax)
    }
    
    mutex_unlock(&file_alloc_mutex);
   14797:	83 ec 0c             	sub    $0xc,%esp
   1479a:	68 a0 15 05 00       	push   $0x515a0
   1479f:	e8 7b 06 00 00       	call   14e1f <mutex_unlock>
   147a4:	83 c4 10             	add    $0x10,%esp
}
   147a7:	90                   	nop
   147a8:	c9                   	leave  
   147a9:	c3                   	ret    

000147aa <file_table_init>:

void file_table_init(void){
   147aa:	55                   	push   %ebp
   147ab:	89 e5                	mov    %esp,%ebp
   147ad:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&file_alloc_mutex);
   147b0:	83 ec 0c             	sub    $0xc,%esp
   147b3:	68 a0 15 05 00       	push   $0x515a0
   147b8:	e8 a5 05 00 00       	call   14d62 <mutex_init>
   147bd:	83 c4 10             	add    $0x10,%esp
    kernel_memset(file_table,0,sizeof(file_table));
   147c0:	83 ec 04             	sub    $0x4,%esp
   147c3:	68 00 c0 01 00       	push   $0x1c000
   147c8:	6a 00                	push   $0x0
   147ca:	68 a0 55 03 00       	push   $0x355a0
   147cf:	e8 86 0c 00 00       	call   1545a <kernel_memset>
   147d4:	83 c4 10             	add    $0x10,%esp
   147d7:	90                   	nop
   147d8:	c9                   	leave  
   147d9:	c3                   	ret    

000147da <inb>:
static inline uint8_t inb(uint16_t port){
   147da:	55                   	push   %ebp
   147db:	89 e5                	mov    %esp,%ebp
   147dd:	83 ec 14             	sub    $0x14,%esp
   147e0:	8b 45 08             	mov    0x8(%ebp),%eax
   147e3:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   147e7:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   147eb:	89 c2                	mov    %eax,%edx
   147ed:	ec                   	in     (%dx),%al
   147ee:	88 45 ff             	mov    %al,-0x1(%ebp)
    return rv;
   147f1:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   147f5:	c9                   	leave  
   147f6:	c3                   	ret    

000147f7 <inw>:
static inline uint16_t inw(uint16_t port){
   147f7:	55                   	push   %ebp
   147f8:	89 e5                	mov    %esp,%ebp
   147fa:	83 ec 14             	sub    $0x14,%esp
   147fd:	8b 45 08             	mov    0x8(%ebp),%eax
   14800:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    __asm__ __volatile__(
   14804:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   14808:	89 c2                	mov    %eax,%edx
   1480a:	66 ed                	in     (%dx),%ax
   1480c:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
    return rv;
   14810:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   14814:	c9                   	leave  
   14815:	c3                   	ret    

00014816 <outb>:
static inline void outb(uint16_t port,uint8_t data){
   14816:	55                   	push   %ebp
   14817:	89 e5                	mov    %esp,%ebp
   14819:	83 ec 08             	sub    $0x8,%esp
   1481c:	8b 55 08             	mov    0x8(%ebp),%edx
   1481f:	8b 45 0c             	mov    0xc(%ebp),%eax
   14822:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   14826:	88 45 f8             	mov    %al,-0x8(%ebp)
    __asm__ __volatile(
   14829:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   1482d:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   14831:	ee                   	out    %al,(%dx)
}
   14832:	90                   	nop
   14833:	c9                   	leave  
   14834:	c3                   	ret    

00014835 <read_disk>:
#define TEMP_FILE_ID        100

static uint8_t TEMP_ADDR[100*1024];
static uint8_t* temp_pos;

static void read_disk(int sector, int sector_count, uint8_t * buf) {
   14835:	55                   	push   %ebp
   14836:	89 e5                	mov    %esp,%ebp
   14838:	53                   	push   %ebx
   14839:	83 ec 10             	sub    $0x10,%esp
    outb(0x1F6, (uint8_t) (0xE0));
   1483c:	68 e0 00 00 00       	push   $0xe0
   14841:	68 f6 01 00 00       	push   $0x1f6
   14846:	e8 cb ff ff ff       	call   14816 <outb>
   1484b:	83 c4 08             	add    $0x8,%esp

	outb(0x1F2, (uint8_t) (sector_count >> 8));
   1484e:	8b 45 0c             	mov    0xc(%ebp),%eax
   14851:	c1 f8 08             	sar    $0x8,%eax
   14854:	0f b6 c0             	movzbl %al,%eax
   14857:	50                   	push   %eax
   14858:	68 f2 01 00 00       	push   $0x1f2
   1485d:	e8 b4 ff ff ff       	call   14816 <outb>
   14862:	83 c4 08             	add    $0x8,%esp
    outb(0x1F3, (uint8_t) (sector >> 24));		
   14865:	8b 45 08             	mov    0x8(%ebp),%eax
   14868:	c1 f8 18             	sar    $0x18,%eax
   1486b:	0f b6 c0             	movzbl %al,%eax
   1486e:	50                   	push   %eax
   1486f:	68 f3 01 00 00       	push   $0x1f3
   14874:	e8 9d ff ff ff       	call   14816 <outb>
   14879:	83 c4 08             	add    $0x8,%esp
    outb(0x1F4, (uint8_t) (0));					
   1487c:	6a 00                	push   $0x0
   1487e:	68 f4 01 00 00       	push   $0x1f4
   14883:	e8 8e ff ff ff       	call   14816 <outb>
   14888:	83 c4 08             	add    $0x8,%esp
    outb(0x1F5, (uint8_t) (0));					
   1488b:	6a 00                	push   $0x0
   1488d:	68 f5 01 00 00       	push   $0x1f5
   14892:	e8 7f ff ff ff       	call   14816 <outb>
   14897:	83 c4 08             	add    $0x8,%esp

    outb(0x1F2, (uint8_t) (sector_count));
   1489a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1489d:	0f b6 c0             	movzbl %al,%eax
   148a0:	50                   	push   %eax
   148a1:	68 f2 01 00 00       	push   $0x1f2
   148a6:	e8 6b ff ff ff       	call   14816 <outb>
   148ab:	83 c4 08             	add    $0x8,%esp
	outb(0x1F3, (uint8_t) (sector));			
   148ae:	8b 45 08             	mov    0x8(%ebp),%eax
   148b1:	0f b6 c0             	movzbl %al,%eax
   148b4:	50                   	push   %eax
   148b5:	68 f3 01 00 00       	push   $0x1f3
   148ba:	e8 57 ff ff ff       	call   14816 <outb>
   148bf:	83 c4 08             	add    $0x8,%esp
	outb(0x1F4, (uint8_t) (sector >> 8));		
   148c2:	8b 45 08             	mov    0x8(%ebp),%eax
   148c5:	c1 f8 08             	sar    $0x8,%eax
   148c8:	0f b6 c0             	movzbl %al,%eax
   148cb:	50                   	push   %eax
   148cc:	68 f4 01 00 00       	push   $0x1f4
   148d1:	e8 40 ff ff ff       	call   14816 <outb>
   148d6:	83 c4 08             	add    $0x8,%esp
	outb(0x1F5, (uint8_t) (sector >> 16));		
   148d9:	8b 45 08             	mov    0x8(%ebp),%eax
   148dc:	c1 f8 10             	sar    $0x10,%eax
   148df:	0f b6 c0             	movzbl %al,%eax
   148e2:	50                   	push   %eax
   148e3:	68 f5 01 00 00       	push   $0x1f5
   148e8:	e8 29 ff ff ff       	call   14816 <outb>
   148ed:	83 c4 08             	add    $0x8,%esp

	outb(0x1F7, (uint8_t) 0x24);
   148f0:	6a 24                	push   $0x24
   148f2:	68 f7 01 00 00       	push   $0x1f7
   148f7:	e8 1a ff ff ff       	call   14816 <outb>
   148fc:	83 c4 08             	add    $0x8,%esp

	
	uint16_t *data_buf = (uint16_t*) buf;
   148ff:	8b 45 10             	mov    0x10(%ebp),%eax
   14902:	89 45 f8             	mov    %eax,-0x8(%ebp)

	// 这里是要读取的扇区
	while (sector_count-- > 0) {
   14905:	eb 4a                	jmp    14951 <read_disk+0x11c>
		
		while ((inb(0x1F7) & 0x88) != 0x8) {}
   14907:	90                   	nop
   14908:	68 f7 01 00 00       	push   $0x1f7
   1490d:	e8 c8 fe ff ff       	call   147da <inb>
   14912:	83 c4 04             	add    $0x4,%esp
   14915:	0f b6 c0             	movzbl %al,%eax
   14918:	25 88 00 00 00       	and    $0x88,%eax
   1491d:	83 f8 08             	cmp    $0x8,%eax
   14920:	75 e6                	jne    14908 <read_disk+0xd3>

		// 以每次2字节方式读取每个扇区
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   14922:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14929:	eb 1d                	jmp    14948 <read_disk+0x113>
			*data_buf++ = inw(0x1F0);
   1492b:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   1492e:	8d 43 02             	lea    0x2(%ebx),%eax
   14931:	89 45 f8             	mov    %eax,-0x8(%ebp)
   14934:	68 f0 01 00 00       	push   $0x1f0
   14939:	e8 b9 fe ff ff       	call   147f7 <inw>
   1493e:	83 c4 04             	add    $0x4,%esp
   14941:	66 89 03             	mov    %ax,(%ebx)
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   14944:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14948:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   1494f:	7e da                	jle    1492b <read_disk+0xf6>
	while (sector_count-- > 0) {
   14951:	8b 45 0c             	mov    0xc(%ebp),%eax
   14954:	8d 50 ff             	lea    -0x1(%eax),%edx
   14957:	89 55 0c             	mov    %edx,0xc(%ebp)
   1495a:	85 c0                	test   %eax,%eax
   1495c:	7f a9                	jg     14907 <read_disk+0xd2>
		}
	}
}
   1495e:	90                   	nop
   1495f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14962:	c9                   	leave  
   14963:	c3                   	ret    

00014964 <is_path_valid>:

static int is_path_valid(const char* path){
   14964:	55                   	push   %ebp
   14965:	89 e5                	mov    %esp,%ebp
    if((path==(const char*)0) || (path[0]=='\0')){
   14967:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1496b:	74 0a                	je     14977 <is_path_valid+0x13>
   1496d:	8b 45 08             	mov    0x8(%ebp),%eax
   14970:	0f b6 00             	movzbl (%eax),%eax
   14973:	84 c0                	test   %al,%al
   14975:	75 07                	jne    1497e <is_path_valid+0x1a>
        return 0;
   14977:	b8 00 00 00 00       	mov    $0x0,%eax
   1497c:	eb 05                	jmp    14983 <is_path_valid+0x1f>
    }

    return 1;
   1497e:	b8 01 00 00 00       	mov    $0x1,%eax
}
   14983:	5d                   	pop    %ebp
   14984:	c3                   	ret    

00014985 <sys_open>:

int sys_open(const char* name,int flags,...){
   14985:	55                   	push   %ebp
   14986:	89 e5                	mov    %esp,%ebp
   14988:	83 ec 18             	sub    $0x18,%esp
    if(kernel_strncmp(name,"tty:",3)==0){
   1498b:	83 ec 04             	sub    $0x4,%esp
   1498e:	6a 03                	push   $0x3
   14990:	68 cf 66 01 00       	push   $0x166cf
   14995:	ff 75 08             	pushl  0x8(%ebp)
   14998:	e8 b9 09 00 00       	call   15356 <kernel_strncmp>
   1499d:	83 c4 10             	add    $0x10,%esp
   149a0:	85 c0                	test   %eax,%eax
   149a2:	0f 85 04 01 00 00    	jne    14aac <sys_open+0x127>
        if(!is_path_valid(name)){
   149a8:	83 ec 0c             	sub    $0xc,%esp
   149ab:	ff 75 08             	pushl  0x8(%ebp)
   149ae:	e8 b1 ff ff ff       	call   14964 <is_path_valid>
   149b3:	83 c4 10             	add    $0x10,%esp
   149b6:	85 c0                	test   %eax,%eax
   149b8:	75 1a                	jne    149d4 <sys_open+0x4f>
            log_printf("path is invalid\n");
   149ba:	83 ec 0c             	sub    $0xc,%esp
   149bd:	68 d4 66 01 00       	push   $0x166d4
   149c2:	e8 b6 10 00 00       	call   15a7d <log_printf>
   149c7:	83 c4 10             	add    $0x10,%esp
            return -1;
   149ca:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   149cf:	e9 0f 01 00 00       	jmp    14ae3 <sys_open+0x15e>
        }

        int fd=-1;
   149d4:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
        file_t* file=file_alloc();
   149db:	e8 04 fd ff ff       	call   146e4 <file_alloc>
   149e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(file){
   149e3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   149e7:	0f 84 8e 00 00 00    	je     14a7b <sys_open+0xf6>
            fd=task_alloc_fd(file);
   149ed:	83 ec 0c             	sub    $0xc,%esp
   149f0:	ff 75 f0             	pushl  -0x10(%ebp)
   149f3:	e8 09 d6 ff ff       	call   12001 <task_alloc_fd>
   149f8:	83 c4 10             	add    $0x10,%esp
   149fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
            if(fd<0){
   149fe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14a02:	78 7a                	js     14a7e <sys_open+0xf9>
        else{
            goto sys_open_failed;
        }

        // 因为有：所以是4 tty:0
        int num=name[4]-'0';
   14a04:	8b 45 08             	mov    0x8(%ebp),%eax
   14a07:	83 c0 04             	add    $0x4,%eax
   14a0a:	0f b6 00             	movzbl (%eax),%eax
   14a0d:	0f be c0             	movsbl %al,%eax
   14a10:	83 e8 30             	sub    $0x30,%eax
   14a13:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int dev_id=dev_open(DEV_TTY,num,0);
   14a16:	83 ec 04             	sub    $0x4,%esp
   14a19:	6a 00                	push   $0x0
   14a1b:	ff 75 ec             	pushl  -0x14(%ebp)
   14a1e:	6a 01                	push   $0x1
   14a20:	e8 19 f0 ff ff       	call   13a3e <dev_open>
   14a25:	83 c4 10             	add    $0x10,%esp
   14a28:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(dev_id<0){
   14a2b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   14a2f:	78 50                	js     14a81 <sys_open+0xfc>
            goto sys_open_failed;
        }

        file->dev_id=dev_id;
   14a31:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14a34:	8b 55 e8             	mov    -0x18(%ebp),%edx
   14a37:	89 50 2c             	mov    %edx,0x2c(%eax)
        file->mode=0;
   14a3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14a3d:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
        file->pos=0;
   14a44:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14a47:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
        file->ref=1;
   14a4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14a51:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
        file->type=FILE_TYPE_TTY;
   14a58:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14a5b:	c7 40 20 01 00 00 00 	movl   $0x1,0x20(%eax)
        kernel_strncpy(file->file_name,name,FILE_NAME_SIZE);
   14a62:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14a65:	83 ec 04             	sub    $0x4,%esp
   14a68:	6a 20                	push   $0x20
   14a6a:	ff 75 08             	pushl  0x8(%ebp)
   14a6d:	50                   	push   %eax
   14a6e:	e8 73 08 00 00       	call   152e6 <kernel_strncpy>
   14a73:	83 c4 10             	add    $0x10,%esp
        return fd;
   14a76:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a79:	eb 68                	jmp    14ae3 <sys_open+0x15e>
            goto sys_open_failed;
   14a7b:	90                   	nop
   14a7c:	eb 04                	jmp    14a82 <sys_open+0xfd>
                goto sys_open_failed;
   14a7e:	90                   	nop
   14a7f:	eb 01                	jmp    14a82 <sys_open+0xfd>
            goto sys_open_failed;
   14a81:	90                   	nop

sys_open_failed:
        if(file){
   14a82:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14a86:	74 0e                	je     14a96 <sys_open+0x111>
            file_free(file);
   14a88:	83 ec 0c             	sub    $0xc,%esp
   14a8b:	ff 75 f0             	pushl  -0x10(%ebp)
   14a8e:	e8 d5 fc ff ff       	call   14768 <file_free>
   14a93:	83 c4 10             	add    $0x10,%esp
        }
        if(fd>=0){
   14a96:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14a9a:	78 42                	js     14ade <sys_open+0x159>
            task_remove_fd(fd);
   14a9c:	83 ec 0c             	sub    $0xc,%esp
   14a9f:	ff 75 f4             	pushl  -0xc(%ebp)
   14aa2:	e8 ab d5 ff ff       	call   12052 <task_remove_fd>
   14aa7:	83 c4 10             	add    $0x10,%esp
   14aaa:	eb 32                	jmp    14ade <sys_open+0x159>
        }
        
    }
    else{
        if(name[0]=='/'){
   14aac:	8b 45 08             	mov    0x8(%ebp),%eax
   14aaf:	0f b6 00             	movzbl (%eax),%eax
   14ab2:	3c 2f                	cmp    $0x2f,%al
   14ab4:	75 28                	jne    14ade <sys_open+0x159>
            read_disk(5000,80,(uint8_t*)TEMP_ADDR);
   14ab6:	83 ec 04             	sub    $0x4,%esp
   14ab9:	68 c0 15 05 00       	push   $0x515c0
   14abe:	6a 50                	push   $0x50
   14ac0:	68 88 13 00 00       	push   $0x1388
   14ac5:	e8 6b fd ff ff       	call   14835 <read_disk>
   14aca:	83 c4 10             	add    $0x10,%esp
            temp_pos=(uint8_t*)TEMP_ADDR;
   14acd:	c7 05 c0 a5 06 00 c0 	movl   $0x515c0,0x6a5c0
   14ad4:	15 05 00 

            return TEMP_FILE_ID;
   14ad7:	b8 64 00 00 00       	mov    $0x64,%eax
   14adc:	eb 05                	jmp    14ae3 <sys_open+0x15e>
        }
    }

    return -1;
   14ade:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   14ae3:	c9                   	leave  
   14ae4:	c3                   	ret    

00014ae5 <sys_read>:
 * @param file 文件描述符
 * @param ptr 读取到的内容存放的地址,这里的ptr会在调用例如get函数时传入，表示读取到的内容存放的地址
 * @param len 读取的长度
 * @return 读取的长度，失败返回-1
*/
int sys_read(int file,char* ptr,int len){
   14ae5:	55                   	push   %ebp
   14ae6:	89 e5                	mov    %esp,%ebp
   14ae8:	83 ec 18             	sub    $0x18,%esp
   if(file==TEMP_FILE_ID){
   14aeb:	83 7d 08 64          	cmpl   $0x64,0x8(%ebp)
   14aef:	75 2d                	jne    14b1e <sys_read+0x39>
        kernel_memcpy(ptr,temp_pos,len);
   14af1:	8b 55 10             	mov    0x10(%ebp),%edx
   14af4:	a1 c0 a5 06 00       	mov    0x6a5c0,%eax
   14af9:	83 ec 04             	sub    $0x4,%esp
   14afc:	52                   	push   %edx
   14afd:	50                   	push   %eax
   14afe:	ff 75 0c             	pushl  0xc(%ebp)
   14b01:	e8 05 09 00 00       	call   1540b <kernel_memcpy>
   14b06:	83 c4 10             	add    $0x10,%esp
        temp_pos+=len;
   14b09:	8b 15 c0 a5 06 00    	mov    0x6a5c0,%edx
   14b0f:	8b 45 10             	mov    0x10(%ebp),%eax
   14b12:	01 d0                	add    %edx,%eax
   14b14:	a3 c0 a5 06 00       	mov    %eax,0x6a5c0

        return len;
   14b19:	8b 45 10             	mov    0x10(%ebp),%eax
   14b1c:	eb 4c                	jmp    14b6a <sys_read+0x85>
   }
   else{
        file=0;
   14b1e:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        
        file_t* p_file=task_file(file);
   14b25:	83 ec 0c             	sub    $0xc,%esp
   14b28:	ff 75 08             	pushl  0x8(%ebp)
   14b2b:	e8 a0 d4 ff ff       	call   11fd0 <task_file>
   14b30:	83 c4 10             	add    $0x10,%esp
   14b33:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(!p_file){
   14b36:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14b3a:	75 17                	jne    14b53 <sys_read+0x6e>
            log_printf("file not opened");
   14b3c:	83 ec 0c             	sub    $0xc,%esp
   14b3f:	68 e5 66 01 00       	push   $0x166e5
   14b44:	e8 34 0f 00 00       	call   15a7d <log_printf>
   14b49:	83 c4 10             	add    $0x10,%esp
            return -1;
   14b4c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14b51:	eb 17                	jmp    14b6a <sys_read+0x85>
        }

        return dev_read(p_file->dev_id,0,ptr,len);
   14b53:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b56:	8b 40 2c             	mov    0x2c(%eax),%eax
   14b59:	ff 75 10             	pushl  0x10(%ebp)
   14b5c:	ff 75 0c             	pushl  0xc(%ebp)
   14b5f:	6a 00                	push   $0x0
   14b61:	50                   	push   %eax
   14b62:	e8 27 f0 ff ff       	call   13b8e <dev_read>
   14b67:	83 c4 10             	add    $0x10,%esp
    }
   
   return -1;
}
   14b6a:	c9                   	leave  
   14b6b:	c3                   	ret    

00014b6c <sys_write>:

// 这里file就是fd
int sys_write(int file,char* ptr,int len){
   14b6c:	55                   	push   %ebp
   14b6d:	89 e5                	mov    %esp,%ebp
   14b6f:	83 ec 18             	sub    $0x18,%esp
    
    file_t* p_file=task_file(file);
   14b72:	83 ec 0c             	sub    $0xc,%esp
   14b75:	ff 75 08             	pushl  0x8(%ebp)
   14b78:	e8 53 d4 ff ff       	call   11fd0 <task_file>
   14b7d:	83 c4 10             	add    $0x10,%esp
   14b80:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!p_file){
   14b83:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14b87:	75 17                	jne    14ba0 <sys_write+0x34>
        log_printf("file not opened");
   14b89:	83 ec 0c             	sub    $0xc,%esp
   14b8c:	68 e5 66 01 00       	push   $0x166e5
   14b91:	e8 e7 0e 00 00       	call   15a7d <log_printf>
   14b96:	83 c4 10             	add    $0x10,%esp
        return -1;
   14b99:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14b9e:	eb 17                	jmp    14bb7 <sys_write+0x4b>
    }

    return dev_write(p_file->dev_id,0,ptr,len);
   14ba0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14ba3:	8b 40 2c             	mov    0x2c(%eax),%eax
   14ba6:	ff 75 10             	pushl  0x10(%ebp)
   14ba9:	ff 75 0c             	pushl  0xc(%ebp)
   14bac:	6a 00                	push   $0x0
   14bae:	50                   	push   %eax
   14baf:	e8 26 f0 ff ff       	call   13bda <dev_write>
   14bb4:	83 c4 10             	add    $0x10,%esp
}
   14bb7:	c9                   	leave  
   14bb8:	c3                   	ret    

00014bb9 <sys_lseek>:

int sys_lseek(int file,int ptr,int dir){
   14bb9:	55                   	push   %ebp
   14bba:	89 e5                	mov    %esp,%ebp
    if(file==TEMP_FILE_ID){
   14bbc:	83 7d 08 64          	cmpl   $0x64,0x8(%ebp)
   14bc0:	75 14                	jne    14bd6 <sys_lseek+0x1d>

        temp_pos=(uint8_t*)(TEMP_ADDR+ptr);
   14bc2:	8b 45 0c             	mov    0xc(%ebp),%eax
   14bc5:	05 c0 15 05 00       	add    $0x515c0,%eax
   14bca:	a3 c0 a5 06 00       	mov    %eax,0x6a5c0
        return 0;
   14bcf:	b8 00 00 00 00       	mov    $0x0,%eax
   14bd4:	eb 05                	jmp    14bdb <sys_lseek+0x22>
    }

    return -1;
   14bd6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}   
   14bdb:	5d                   	pop    %ebp
   14bdc:	c3                   	ret    

00014bdd <sys_close>:

int sys_close(int file){
   14bdd:	55                   	push   %ebp
   14bde:	89 e5                	mov    %esp,%ebp
    return 0;
   14be0:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14be5:	5d                   	pop    %ebp
   14be6:	c3                   	ret    

00014be7 <sys_isatty>:

int sys_isatty(int file){
   14be7:	55                   	push   %ebp
   14be8:	89 e5                	mov    %esp,%ebp
    return -1;
   14bea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   14bef:	5d                   	pop    %ebp
   14bf0:	c3                   	ret    

00014bf1 <sys_fstat>:

int sys_fstat(int file,struct stat* st){
   14bf1:	55                   	push   %ebp
   14bf2:	89 e5                	mov    %esp,%ebp
    return -1;
   14bf4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   14bf9:	5d                   	pop    %ebp
   14bfa:	c3                   	ret    

00014bfb <fs_init>:

void fs_init(void){
   14bfb:	55                   	push   %ebp
   14bfc:	89 e5                	mov    %esp,%ebp
   14bfe:	83 ec 08             	sub    $0x8,%esp
    file_table_init();
   14c01:	e8 a4 fb ff ff       	call   147aa <file_table_init>
}
   14c06:	90                   	nop
   14c07:	c9                   	leave  
   14c08:	c3                   	ret    

00014c09 <sys_dup>:
/**
* @brief 复制文件描述符，返回新的文件描述符
* @return 新的文件描述符，失败返回-1
* @param file 旧的文件描述符
*/
int sys_dup(int file){
   14c09:	55                   	push   %ebp
   14c0a:	89 e5                	mov    %esp,%ebp
   14c0c:	83 ec 18             	sub    $0x18,%esp
    if((file<0) && (file>=TASK_OFILE_NR)){
   14c0f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   14c13:	79 0d                	jns    14c22 <sys_dup+0x19>
   14c15:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   14c19:	7e 07                	jle    14c22 <sys_dup+0x19>
        return -1;
   14c1b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14c20:	eb 6e                	jmp    14c90 <sys_dup+0x87>
    }

    file_t* p_file=task_file(file);
   14c22:	83 ec 0c             	sub    $0xc,%esp
   14c25:	ff 75 08             	pushl  0x8(%ebp)
   14c28:	e8 a3 d3 ff ff       	call   11fd0 <task_file>
   14c2d:	83 c4 10             	add    $0x10,%esp
   14c30:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!p_file){
   14c33:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14c37:	75 17                	jne    14c50 <sys_dup+0x47>
        log_printf("file not opened");
   14c39:	83 ec 0c             	sub    $0xc,%esp
   14c3c:	68 e5 66 01 00       	push   $0x166e5
   14c41:	e8 37 0e 00 00       	call   15a7d <log_printf>
   14c46:	83 c4 10             	add    $0x10,%esp
        return -1;
   14c49:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14c4e:	eb 40                	jmp    14c90 <sys_dup+0x87>
    }

    int fd=task_alloc_fd(p_file);
   14c50:	83 ec 0c             	sub    $0xc,%esp
   14c53:	ff 75 f4             	pushl  -0xc(%ebp)
   14c56:	e8 a6 d3 ff ff       	call   12001 <task_alloc_fd>
   14c5b:	83 c4 10             	add    $0x10,%esp
   14c5e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(fd >= 0){
   14c61:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14c65:	78 14                	js     14c7b <sys_dup+0x72>
        p_file->ref++;
   14c67:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14c6a:	8b 40 28             	mov    0x28(%eax),%eax
   14c6d:	8d 50 01             	lea    0x1(%eax),%edx
   14c70:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14c73:	89 50 28             	mov    %edx,0x28(%eax)
        return fd;
   14c76:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c79:	eb 15                	jmp    14c90 <sys_dup+0x87>
    }

    log_printf("alloc fd failed\n");
   14c7b:	83 ec 0c             	sub    $0xc,%esp
   14c7e:	68 f5 66 01 00       	push   $0x166f5
   14c83:	e8 f5 0d 00 00       	call   15a7d <log_printf>
   14c88:	83 c4 10             	add    $0x10,%esp
    return -1;
   14c8b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14c90:	c9                   	leave  
   14c91:	c3                   	ret    

00014c92 <kernel_init>:
#include "ipc/sem.h"
#include "cpu/cpu.h"
#include "dev/kbd.h"
#include "fs/fs.h"

void kernel_init(boot_info_t* boot_info){
   14c92:	55                   	push   %ebp
   14c93:	89 e5                	mov    %esp,%ebp
   14c95:	83 ec 08             	sub    $0x8,%esp
    irq_init();
   14c98:	e8 f6 da ff ff       	call   12793 <irq_init>

    cpu_init();
   14c9d:	e8 b4 d7 ff ff       	call   12456 <cpu_init>
    log_init();
   14ca2:	e8 a7 0d 00 00       	call   15a4e <log_init>

    memory_init(boot_info);
   14ca7:	83 ec 0c             	sub    $0xc,%esp
   14caa:	ff 75 08             	pushl  0x8(%ebp)
   14cad:	e8 71 ba ff ff       	call   10723 <memory_init>
   14cb2:	83 c4 10             	add    $0x10,%esp
    fs_init();
   14cb5:	e8 41 ff ff ff       	call   14bfb <fs_init>
    
    time_init();
   14cba:	e8 ac f4 ff ff       	call   1416b <time_init>

    task_manager_init();
   14cbf:	e8 93 c6 ff ff       	call   11357 <task_manager_init>

}
   14cc4:	90                   	nop
   14cc5:	c9                   	leave  
   14cc6:	c3                   	ret    

00014cc7 <move_to_first_task>:

void move_to_first_task(void){
   14cc7:	55                   	push   %ebp
   14cc8:	89 e5                	mov    %esp,%ebp
   14cca:	56                   	push   %esi
   14ccb:	53                   	push   %ebx
   14ccc:	83 ec 10             	sub    $0x10,%esp
    task_t* curr=task_current();
   14ccf:	e8 08 c9 ff ff       	call   115dc <task_current>
   14cd4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ASSERT(curr!=0);
   14cd7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14cdb:	75 19                	jne    14cf6 <move_to_first_task+0x2f>
   14cdd:	68 08 67 01 00       	push   $0x16708
   14ce2:	68 5c 67 01 00       	push   $0x1675c
   14ce7:	6a 23                	push   $0x23
   14ce9:	68 10 67 01 00       	push   $0x16710
   14cee:	e8 ba 0a 00 00       	call   157ad <panic>
   14cf3:	83 c4 10             	add    $0x10,%esp
    tss_t* tss=&(curr->tss);
   14cf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14cf9:	05 58 02 00 00       	add    $0x258,%eax
   14cfe:	89 45 f0             	mov    %eax,-0x10(%ebp)
        "push %[eflags]\n\t"
        "push %[cs]\n\t"
        "push %[eip]\n\t"
        "iret"
        :
        :[ss]"r"(tss->ss),[esp]"r"(tss->esp),[eflags]"r"(tss->eflags),[cs]"r"(tss->cs),
   14d01:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14d04:	8b 40 50             	mov    0x50(%eax),%eax
   14d07:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14d0a:	8b 52 38             	mov    0x38(%edx),%edx
   14d0d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   14d10:	8b 49 24             	mov    0x24(%ecx),%ecx
   14d13:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   14d16:	8b 5b 4c             	mov    0x4c(%ebx),%ebx
         [eip]"r"(tss->eip)
   14d19:	8b 75 f0             	mov    -0x10(%ebp),%esi
   14d1c:	8b 76 20             	mov    0x20(%esi),%esi
    __asm__ __volatile__(
   14d1f:	50                   	push   %eax
   14d20:	52                   	push   %edx
   14d21:	51                   	push   %ecx
   14d22:	53                   	push   %ebx
   14d23:	56                   	push   %esi
   14d24:	cf                   	iret   
    );
}
   14d25:	90                   	nop
   14d26:	8d 65 f8             	lea    -0x8(%ebp),%esp
   14d29:	5b                   	pop    %ebx
   14d2a:	5e                   	pop    %esi
   14d2b:	5d                   	pop    %ebp
   14d2c:	c3                   	ret    

00014d2d <init_main>:

void init_main(){
   14d2d:	55                   	push   %ebp
   14d2e:	89 e5                	mov    %esp,%ebp
   14d30:	83 ec 18             	sub    $0x18,%esp
    int count=0;
   14d33:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    log_printf("Kernel is running....");
   14d3a:	83 ec 0c             	sub    $0xc,%esp
   14d3d:	68 43 67 01 00       	push   $0x16743
   14d42:	e8 36 0d 00 00       	call   15a7d <log_printf>
   14d47:	83 c4 10             	add    $0x10,%esp
    task_first_init();
   14d4a:	e8 ef c6 ff ff       	call   1143e <task_first_init>
    move_to_first_task();
   14d4f:	e8 73 ff ff ff       	call   14cc7 <move_to_first_task>
}
   14d54:	90                   	nop
   14d55:	c9                   	leave  
   14d56:	c3                   	ret    

00014d57 <list_count>:
static inline int list_count(list_t* list){
   14d57:	55                   	push   %ebp
   14d58:	89 e5                	mov    %esp,%ebp
    return list->count;
   14d5a:	8b 45 08             	mov    0x8(%ebp),%eax
   14d5d:	8b 40 08             	mov    0x8(%eax),%eax
}
   14d60:	5d                   	pop    %ebp
   14d61:	c3                   	ret    

00014d62 <mutex_init>:
#include "ipc/mutex.h"

void mutex_init(mutex_t* mutex){
   14d62:	55                   	push   %ebp
   14d63:	89 e5                	mov    %esp,%ebp
   14d65:	83 ec 08             	sub    $0x8,%esp
    mutex->locked_count=0;
   14d68:	8b 45 08             	mov    0x8(%ebp),%eax
   14d6b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    mutex->owner=(task_t*)0;
   14d72:	8b 45 08             	mov    0x8(%ebp),%eax
   14d75:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    list_init(&mutex->wait_list); 
   14d7b:	8b 45 08             	mov    0x8(%ebp),%eax
   14d7e:	83 c0 08             	add    $0x8,%eax
   14d81:	83 ec 0c             	sub    $0xc,%esp
   14d84:	50                   	push   %eax
   14d85:	e8 df 0a 00 00       	call   15869 <list_init>
   14d8a:	83 c4 10             	add    $0x10,%esp
}
   14d8d:	90                   	nop
   14d8e:	c9                   	leave  
   14d8f:	c3                   	ret    

00014d90 <mutex_lock>:

void mutex_lock(mutex_t* mutex){
   14d90:	55                   	push   %ebp
   14d91:	89 e5                	mov    %esp,%ebp
   14d93:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   14d96:	e8 c3 e0 ff ff       	call   12e5e <irq_enter_protection>
   14d9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* curr=task_current();
   14d9e:	e8 39 c8 ff ff       	call   115dc <task_current>
   14da3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(mutex->locked_count==0){
   14da6:	8b 45 08             	mov    0x8(%ebp),%eax
   14da9:	8b 40 04             	mov    0x4(%eax),%eax
   14dac:	85 c0                	test   %eax,%eax
   14dae:	75 14                	jne    14dc4 <mutex_lock+0x34>
        mutex->locked_count=1;
   14db0:	8b 45 08             	mov    0x8(%ebp),%eax
   14db3:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
        mutex->owner=curr;
   14dba:	8b 45 08             	mov    0x8(%ebp),%eax
   14dbd:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14dc0:	89 10                	mov    %edx,(%eax)
   14dc2:	eb 4a                	jmp    14e0e <mutex_lock+0x7e>
    }
    else if(mutex->owner==curr){
   14dc4:	8b 45 08             	mov    0x8(%ebp),%eax
   14dc7:	8b 00                	mov    (%eax),%eax
   14dc9:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   14dcc:	75 11                	jne    14ddf <mutex_lock+0x4f>
        mutex->locked_count++;
   14dce:	8b 45 08             	mov    0x8(%ebp),%eax
   14dd1:	8b 40 04             	mov    0x4(%eax),%eax
   14dd4:	8d 50 01             	lea    0x1(%eax),%edx
   14dd7:	8b 45 08             	mov    0x8(%ebp),%eax
   14dda:	89 50 04             	mov    %edx,0x4(%eax)
   14ddd:	eb 2f                	jmp    14e0e <mutex_lock+0x7e>
    }
    else{
        task_set_block(curr);
   14ddf:	83 ec 0c             	sub    $0xc,%esp
   14de2:	ff 75 f0             	pushl  -0x10(%ebp)
   14de5:	e8 80 c7 ff ff       	call   1156a <task_set_block>
   14dea:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&mutex->wait_list,&curr->wait_node);
   14ded:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14df0:	8d 90 50 02 00 00    	lea    0x250(%eax),%edx
   14df6:	8b 45 08             	mov    0x8(%ebp),%eax
   14df9:	83 c0 08             	add    $0x8,%eax
   14dfc:	83 ec 08             	sub    $0x8,%esp
   14dff:	52                   	push   %edx
   14e00:	50                   	push   %eax
   14e01:	e8 e7 0a 00 00       	call   158ed <list_insert_last>
   14e06:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   14e09:	e8 39 c8 ff ff       	call   11647 <task_dispatch>
    }
    irq_leave_protection(state);
   14e0e:	83 ec 0c             	sub    $0xc,%esp
   14e11:	ff 75 f4             	pushl  -0xc(%ebp)
   14e14:	e8 5d e0 ff ff       	call   12e76 <irq_leave_protection>
   14e19:	83 c4 10             	add    $0x10,%esp
}
   14e1c:	90                   	nop
   14e1d:	c9                   	leave  
   14e1e:	c3                   	ret    

00014e1f <mutex_unlock>:

void mutex_unlock(mutex_t* mutex){
   14e1f:	55                   	push   %ebp
   14e20:	89 e5                	mov    %esp,%ebp
   14e22:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   14e25:	e8 34 e0 ff ff       	call   12e5e <irq_enter_protection>
   14e2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* curr=task_current();
   14e2d:	e8 aa c7 ff ff       	call   115dc <task_current>
   14e32:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(mutex->owner==curr){
   14e35:	8b 45 08             	mov    0x8(%ebp),%eax
   14e38:	8b 00                	mov    (%eax),%eax
   14e3a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   14e3d:	0f 85 8a 00 00 00    	jne    14ecd <mutex_unlock+0xae>
        if(--mutex->locked_count==0){
   14e43:	8b 45 08             	mov    0x8(%ebp),%eax
   14e46:	8b 40 04             	mov    0x4(%eax),%eax
   14e49:	8d 50 ff             	lea    -0x1(%eax),%edx
   14e4c:	8b 45 08             	mov    0x8(%ebp),%eax
   14e4f:	89 50 04             	mov    %edx,0x4(%eax)
   14e52:	8b 45 08             	mov    0x8(%ebp),%eax
   14e55:	8b 40 04             	mov    0x4(%eax),%eax
   14e58:	85 c0                	test   %eax,%eax
   14e5a:	75 71                	jne    14ecd <mutex_unlock+0xae>
            mutex->owner=(task_t*)0;
   14e5c:	8b 45 08             	mov    0x8(%ebp),%eax
   14e5f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
            if(list_count(&mutex->wait_list)){
   14e65:	8b 45 08             	mov    0x8(%ebp),%eax
   14e68:	83 c0 08             	add    $0x8,%eax
   14e6b:	83 ec 0c             	sub    $0xc,%esp
   14e6e:	50                   	push   %eax
   14e6f:	e8 e3 fe ff ff       	call   14d57 <list_count>
   14e74:	83 c4 10             	add    $0x10,%esp
   14e77:	85 c0                	test   %eax,%eax
   14e79:	74 52                	je     14ecd <mutex_unlock+0xae>
                list_node_t* node=list_remove_first(&mutex->wait_list);
   14e7b:	8b 45 08             	mov    0x8(%ebp),%eax
   14e7e:	83 c0 08             	add    $0x8,%eax
   14e81:	83 ec 0c             	sub    $0xc,%esp
   14e84:	50                   	push   %eax
   14e85:	e8 c7 0a 00 00       	call   15951 <list_remove_first>
   14e8a:	83 c4 10             	add    $0x10,%esp
   14e8d:	89 45 ec             	mov    %eax,-0x14(%ebp)
                task_t* task=list_node_parent(node,task_t,wait_node);
   14e90:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14e94:	74 0a                	je     14ea0 <mutex_unlock+0x81>
   14e96:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14e99:	2d 50 02 00 00       	sub    $0x250,%eax
   14e9e:	eb 05                	jmp    14ea5 <mutex_unlock+0x86>
   14ea0:	b8 00 00 00 00       	mov    $0x0,%eax
   14ea5:	89 45 e8             	mov    %eax,-0x18(%ebp)
                task_set_ready(task);
   14ea8:	83 ec 0c             	sub    $0xc,%esp
   14eab:	ff 75 e8             	pushl  -0x18(%ebp)
   14eae:	e8 81 c6 ff ff       	call   11534 <task_set_ready>
   14eb3:	83 c4 10             	add    $0x10,%esp
                mutex->locked_count=1;
   14eb6:	8b 45 08             	mov    0x8(%ebp),%eax
   14eb9:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
                mutex->owner=task;
   14ec0:	8b 45 08             	mov    0x8(%ebp),%eax
   14ec3:	8b 55 e8             	mov    -0x18(%ebp),%edx
   14ec6:	89 10                	mov    %edx,(%eax)
                task_dispatch();
   14ec8:	e8 7a c7 ff ff       	call   11647 <task_dispatch>
            }
        }
    }
    irq_leave_protection(state);
   14ecd:	83 ec 0c             	sub    $0xc,%esp
   14ed0:	ff 75 f4             	pushl  -0xc(%ebp)
   14ed3:	e8 9e df ff ff       	call   12e76 <irq_leave_protection>
   14ed8:	83 c4 10             	add    $0x10,%esp
   14edb:	90                   	nop
   14edc:	c9                   	leave  
   14edd:	c3                   	ret    

00014ede <list_count>:
static inline int list_count(list_t* list){
   14ede:	55                   	push   %ebp
   14edf:	89 e5                	mov    %esp,%ebp
    return list->count;
   14ee1:	8b 45 08             	mov    0x8(%ebp),%eax
   14ee4:	8b 40 08             	mov    0x8(%eax),%eax
}
   14ee7:	5d                   	pop    %ebp
   14ee8:	c3                   	ret    

00014ee9 <sem_init>:
#include "ipc/sem.h"

void sem_init(sem_t* sem,int init_count){
   14ee9:	55                   	push   %ebp
   14eea:	89 e5                	mov    %esp,%ebp
   14eec:	83 ec 08             	sub    $0x8,%esp
    sem->count=init_count;
   14eef:	8b 45 08             	mov    0x8(%ebp),%eax
   14ef2:	8b 55 0c             	mov    0xc(%ebp),%edx
   14ef5:	89 10                	mov    %edx,(%eax)
    list_init(&sem->wait_list);
   14ef7:	8b 45 08             	mov    0x8(%ebp),%eax
   14efa:	83 c0 04             	add    $0x4,%eax
   14efd:	83 ec 0c             	sub    $0xc,%esp
   14f00:	50                   	push   %eax
   14f01:	e8 63 09 00 00       	call   15869 <list_init>
   14f06:	83 c4 10             	add    $0x10,%esp
}
   14f09:	90                   	nop
   14f0a:	c9                   	leave  
   14f0b:	c3                   	ret    

00014f0c <sem_wait>:

void sem_wait(sem_t* sem){
   14f0c:	55                   	push   %ebp
   14f0d:	89 e5                	mov    %esp,%ebp
   14f0f:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   14f12:	e8 47 df ff ff       	call   12e5e <irq_enter_protection>
   14f17:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(sem->count>0){
   14f1a:	8b 45 08             	mov    0x8(%ebp),%eax
   14f1d:	8b 00                	mov    (%eax),%eax
   14f1f:	85 c0                	test   %eax,%eax
   14f21:	7e 0f                	jle    14f32 <sem_wait+0x26>
        sem->count--;
   14f23:	8b 45 08             	mov    0x8(%ebp),%eax
   14f26:	8b 00                	mov    (%eax),%eax
   14f28:	8d 50 ff             	lea    -0x1(%eax),%edx
   14f2b:	8b 45 08             	mov    0x8(%ebp),%eax
   14f2e:	89 10                	mov    %edx,(%eax)
   14f30:	eb 37                	jmp    14f69 <sem_wait+0x5d>
    }
    else{
        task_t* curr=task_current();
   14f32:	e8 a5 c6 ff ff       	call   115dc <task_current>
   14f37:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_set_block(curr);
   14f3a:	83 ec 0c             	sub    $0xc,%esp
   14f3d:	ff 75 f0             	pushl  -0x10(%ebp)
   14f40:	e8 25 c6 ff ff       	call   1156a <task_set_block>
   14f45:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&sem->wait_list,&curr->wait_node);
   14f48:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f4b:	8d 90 50 02 00 00    	lea    0x250(%eax),%edx
   14f51:	8b 45 08             	mov    0x8(%ebp),%eax
   14f54:	83 c0 04             	add    $0x4,%eax
   14f57:	83 ec 08             	sub    $0x8,%esp
   14f5a:	52                   	push   %edx
   14f5b:	50                   	push   %eax
   14f5c:	e8 8c 09 00 00       	call   158ed <list_insert_last>
   14f61:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   14f64:	e8 de c6 ff ff       	call   11647 <task_dispatch>
    }
    irq_leave_protection(state);
   14f69:	83 ec 0c             	sub    $0xc,%esp
   14f6c:	ff 75 f4             	pushl  -0xc(%ebp)
   14f6f:	e8 02 df ff ff       	call   12e76 <irq_leave_protection>
   14f74:	83 c4 10             	add    $0x10,%esp
}
   14f77:	90                   	nop
   14f78:	c9                   	leave  
   14f79:	c3                   	ret    

00014f7a <sem_notify>:

void sem_notify(sem_t* sem){
   14f7a:	55                   	push   %ebp
   14f7b:	89 e5                	mov    %esp,%ebp
   14f7d:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   14f80:	e8 d9 de ff ff       	call   12e5e <irq_enter_protection>
   14f85:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(list_count(&sem->wait_list)){
   14f88:	8b 45 08             	mov    0x8(%ebp),%eax
   14f8b:	83 c0 04             	add    $0x4,%eax
   14f8e:	83 ec 0c             	sub    $0xc,%esp
   14f91:	50                   	push   %eax
   14f92:	e8 47 ff ff ff       	call   14ede <list_count>
   14f97:	83 c4 10             	add    $0x10,%esp
   14f9a:	85 c0                	test   %eax,%eax
   14f9c:	74 42                	je     14fe0 <sem_notify+0x66>
        list_node_t* node=list_remove_first(&sem->wait_list);
   14f9e:	8b 45 08             	mov    0x8(%ebp),%eax
   14fa1:	83 c0 04             	add    $0x4,%eax
   14fa4:	83 ec 0c             	sub    $0xc,%esp
   14fa7:	50                   	push   %eax
   14fa8:	e8 a4 09 00 00       	call   15951 <list_remove_first>
   14fad:	83 c4 10             	add    $0x10,%esp
   14fb0:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_t* task=list_node_parent(node,task_t,wait_node);
   14fb3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14fb7:	74 0a                	je     14fc3 <sem_notify+0x49>
   14fb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14fbc:	2d 50 02 00 00       	sub    $0x250,%eax
   14fc1:	eb 05                	jmp    14fc8 <sem_notify+0x4e>
   14fc3:	b8 00 00 00 00       	mov    $0x0,%eax
   14fc8:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_ready(task);
   14fcb:	83 ec 0c             	sub    $0xc,%esp
   14fce:	ff 75 ec             	pushl  -0x14(%ebp)
   14fd1:	e8 5e c5 ff ff       	call   11534 <task_set_ready>
   14fd6:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   14fd9:	e8 69 c6 ff ff       	call   11647 <task_dispatch>
   14fde:	eb 0d                	jmp    14fed <sem_notify+0x73>
    }
    else{
        sem->count++;
   14fe0:	8b 45 08             	mov    0x8(%ebp),%eax
   14fe3:	8b 00                	mov    (%eax),%eax
   14fe5:	8d 50 01             	lea    0x1(%eax),%edx
   14fe8:	8b 45 08             	mov    0x8(%ebp),%eax
   14feb:	89 10                	mov    %edx,(%eax)
    }
    irq_leave_protection(state);
   14fed:	83 ec 0c             	sub    $0xc,%esp
   14ff0:	ff 75 f4             	pushl  -0xc(%ebp)
   14ff3:	e8 7e de ff ff       	call   12e76 <irq_leave_protection>
   14ff8:	83 c4 10             	add    $0x10,%esp
}
   14ffb:	90                   	nop
   14ffc:	c9                   	leave  
   14ffd:	c3                   	ret    

00014ffe <sem_count>:

int sem_count(sem_t* sem){
   14ffe:	55                   	push   %ebp
   14fff:	89 e5                	mov    %esp,%ebp
   15001:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state=irq_enter_protection();
   15004:	e8 55 de ff ff       	call   12e5e <irq_enter_protection>
   15009:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int count=sem->count;
   1500c:	8b 45 08             	mov    0x8(%ebp),%eax
   1500f:	8b 00                	mov    (%eax),%eax
   15011:	89 45 f0             	mov    %eax,-0x10(%ebp)
    irq_leave_protection(state);
   15014:	83 ec 0c             	sub    $0xc,%esp
   15017:	ff 75 f4             	pushl  -0xc(%ebp)
   1501a:	e8 57 de ff ff       	call   12e76 <irq_leave_protection>
   1501f:	83 c4 10             	add    $0x10,%esp
    return count;
   15022:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15025:	c9                   	leave  
   15026:	c3                   	ret    

00015027 <bitmap_byte_count>:
#include "tools/bitmap.h"
#include "tools/klib.h"

int bitmap_byte_count(int bit_count){
   15027:	55                   	push   %ebp
   15028:	89 e5                	mov    %esp,%ebp
    return (bit_count+8-1)/8;
   1502a:	8b 45 08             	mov    0x8(%ebp),%eax
   1502d:	83 c0 07             	add    $0x7,%eax
   15030:	8d 50 07             	lea    0x7(%eax),%edx
   15033:	85 c0                	test   %eax,%eax
   15035:	0f 48 c2             	cmovs  %edx,%eax
   15038:	c1 f8 03             	sar    $0x3,%eax
}
   1503b:	5d                   	pop    %ebp
   1503c:	c3                   	ret    

0001503d <bitmap_init>:

void bitmap_init(bitmap_t* bitmap,uint8_t* bits,int count,int init_bit){
   1503d:	55                   	push   %ebp
   1503e:	89 e5                	mov    %esp,%ebp
   15040:	83 ec 18             	sub    $0x18,%esp
    bitmap->bit_count=count;
   15043:	8b 45 08             	mov    0x8(%ebp),%eax
   15046:	8b 55 10             	mov    0x10(%ebp),%edx
   15049:	89 10                	mov    %edx,(%eax)
    bitmap->bits=bits;
   1504b:	8b 45 08             	mov    0x8(%ebp),%eax
   1504e:	8b 55 0c             	mov    0xc(%ebp),%edx
   15051:	89 50 04             	mov    %edx,0x4(%eax)
    int bytes=bitmap_byte_count(bitmap->bit_count);
   15054:	8b 45 08             	mov    0x8(%ebp),%eax
   15057:	8b 00                	mov    (%eax),%eax
   15059:	50                   	push   %eax
   1505a:	e8 c8 ff ff ff       	call   15027 <bitmap_byte_count>
   1505f:	83 c4 04             	add    $0x4,%esp
   15062:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_memset(bitmap->bits,init_bit? 0xFF : 0,bytes);
   15065:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   15069:	74 07                	je     15072 <bitmap_init+0x35>
   1506b:	ba ff 00 00 00       	mov    $0xff,%edx
   15070:	eb 05                	jmp    15077 <bitmap_init+0x3a>
   15072:	ba 00 00 00 00       	mov    $0x0,%edx
   15077:	8b 45 08             	mov    0x8(%ebp),%eax
   1507a:	8b 40 04             	mov    0x4(%eax),%eax
   1507d:	83 ec 04             	sub    $0x4,%esp
   15080:	ff 75 f4             	pushl  -0xc(%ebp)
   15083:	52                   	push   %edx
   15084:	50                   	push   %eax
   15085:	e8 d0 03 00 00       	call   1545a <kernel_memset>
   1508a:	83 c4 10             	add    $0x10,%esp
}
   1508d:	90                   	nop
   1508e:	c9                   	leave  
   1508f:	c3                   	ret    

00015090 <bitmap_get_bit>:

int bitmap_get_bit(bitmap_t* bitmap,int index){
   15090:	55                   	push   %ebp
   15091:	89 e5                	mov    %esp,%ebp
   15093:	53                   	push   %ebx
    if(index>bitmap->bit_count) return -1;
   15094:	8b 45 08             	mov    0x8(%ebp),%eax
   15097:	8b 00                	mov    (%eax),%eax
   15099:	39 45 0c             	cmp    %eax,0xc(%ebp)
   1509c:	7e 07                	jle    150a5 <bitmap_get_bit+0x15>
   1509e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   150a3:	eb 37                	jmp    150dc <bitmap_get_bit+0x4c>
    return bitmap->bits[index/8] & (1<<(index % 8));
   150a5:	8b 45 08             	mov    0x8(%ebp),%eax
   150a8:	8b 50 04             	mov    0x4(%eax),%edx
   150ab:	8b 45 0c             	mov    0xc(%ebp),%eax
   150ae:	8d 48 07             	lea    0x7(%eax),%ecx
   150b1:	85 c0                	test   %eax,%eax
   150b3:	0f 48 c1             	cmovs  %ecx,%eax
   150b6:	c1 f8 03             	sar    $0x3,%eax
   150b9:	01 d0                	add    %edx,%eax
   150bb:	0f b6 00             	movzbl (%eax),%eax
   150be:	0f b6 d8             	movzbl %al,%ebx
   150c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   150c4:	99                   	cltd   
   150c5:	c1 ea 1d             	shr    $0x1d,%edx
   150c8:	01 d0                	add    %edx,%eax
   150ca:	83 e0 07             	and    $0x7,%eax
   150cd:	29 d0                	sub    %edx,%eax
   150cf:	ba 01 00 00 00       	mov    $0x1,%edx
   150d4:	89 c1                	mov    %eax,%ecx
   150d6:	d3 e2                	shl    %cl,%edx
   150d8:	89 d0                	mov    %edx,%eax
   150da:	21 d8                	and    %ebx,%eax
}
   150dc:	5b                   	pop    %ebx
   150dd:	5d                   	pop    %ebp
   150de:	c3                   	ret    

000150df <bitmap_set_bit>:

void bitmap_set_bit(bitmap_t* bitmap,int index,int count,int bit){
   150df:	55                   	push   %ebp
   150e0:	89 e5                	mov    %esp,%ebp
   150e2:	56                   	push   %esi
   150e3:	53                   	push   %ebx
   150e4:	83 ec 10             	sub    $0x10,%esp
    if(index+count>bitmap->bit_count) return;
   150e7:	8b 55 0c             	mov    0xc(%ebp),%edx
   150ea:	8b 45 10             	mov    0x10(%ebp),%eax
   150ed:	01 c2                	add    %eax,%edx
   150ef:	8b 45 08             	mov    0x8(%ebp),%eax
   150f2:	8b 00                	mov    (%eax),%eax
   150f4:	39 c2                	cmp    %eax,%edx
   150f6:	0f 8f c6 00 00 00    	jg     151c2 <bitmap_set_bit+0xe3>
    for(int i=0;(i<count) && (index<bitmap->bit_count);i++,index++){
   150fc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15103:	e9 a2 00 00 00       	jmp    151aa <bitmap_set_bit+0xcb>
        if(bit){
   15108:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   1510c:	74 4a                	je     15158 <bitmap_set_bit+0x79>
            bitmap->bits[index/8] |=(1<<(index%8));
   1510e:	8b 45 08             	mov    0x8(%ebp),%eax
   15111:	8b 50 04             	mov    0x4(%eax),%edx
   15114:	8b 45 0c             	mov    0xc(%ebp),%eax
   15117:	8d 48 07             	lea    0x7(%eax),%ecx
   1511a:	85 c0                	test   %eax,%eax
   1511c:	0f 48 c1             	cmovs  %ecx,%eax
   1511f:	c1 f8 03             	sar    $0x3,%eax
   15122:	89 c3                	mov    %eax,%ebx
   15124:	89 d8                	mov    %ebx,%eax
   15126:	01 d0                	add    %edx,%eax
   15128:	0f b6 00             	movzbl (%eax),%eax
   1512b:	89 c6                	mov    %eax,%esi
   1512d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15130:	99                   	cltd   
   15131:	c1 ea 1d             	shr    $0x1d,%edx
   15134:	01 d0                	add    %edx,%eax
   15136:	83 e0 07             	and    $0x7,%eax
   15139:	29 d0                	sub    %edx,%eax
   1513b:	ba 01 00 00 00       	mov    $0x1,%edx
   15140:	89 c1                	mov    %eax,%ecx
   15142:	d3 e2                	shl    %cl,%edx
   15144:	89 d0                	mov    %edx,%eax
   15146:	89 f2                	mov    %esi,%edx
   15148:	09 c2                	or     %eax,%edx
   1514a:	8b 45 08             	mov    0x8(%ebp),%eax
   1514d:	8b 40 04             	mov    0x4(%eax),%eax
   15150:	89 d9                	mov    %ebx,%ecx
   15152:	01 c8                	add    %ecx,%eax
   15154:	88 10                	mov    %dl,(%eax)
   15156:	eb 4a                	jmp    151a2 <bitmap_set_bit+0xc3>
        }
        else{
            bitmap->bits[index/8]&=~(1<<(index%8));
   15158:	8b 45 08             	mov    0x8(%ebp),%eax
   1515b:	8b 50 04             	mov    0x4(%eax),%edx
   1515e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15161:	8d 48 07             	lea    0x7(%eax),%ecx
   15164:	85 c0                	test   %eax,%eax
   15166:	0f 48 c1             	cmovs  %ecx,%eax
   15169:	c1 f8 03             	sar    $0x3,%eax
   1516c:	89 c3                	mov    %eax,%ebx
   1516e:	89 d8                	mov    %ebx,%eax
   15170:	01 d0                	add    %edx,%eax
   15172:	0f b6 00             	movzbl (%eax),%eax
   15175:	89 c6                	mov    %eax,%esi
   15177:	8b 45 0c             	mov    0xc(%ebp),%eax
   1517a:	99                   	cltd   
   1517b:	c1 ea 1d             	shr    $0x1d,%edx
   1517e:	01 d0                	add    %edx,%eax
   15180:	83 e0 07             	and    $0x7,%eax
   15183:	29 d0                	sub    %edx,%eax
   15185:	ba 01 00 00 00       	mov    $0x1,%edx
   1518a:	89 c1                	mov    %eax,%ecx
   1518c:	d3 e2                	shl    %cl,%edx
   1518e:	89 d0                	mov    %edx,%eax
   15190:	f7 d0                	not    %eax
   15192:	89 f2                	mov    %esi,%edx
   15194:	21 c2                	and    %eax,%edx
   15196:	8b 45 08             	mov    0x8(%ebp),%eax
   15199:	8b 40 04             	mov    0x4(%eax),%eax
   1519c:	89 d9                	mov    %ebx,%ecx
   1519e:	01 c8                	add    %ecx,%eax
   151a0:	88 10                	mov    %dl,(%eax)
    for(int i=0;(i<count) && (index<bitmap->bit_count);i++,index++){
   151a2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   151a6:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
   151aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151ad:	3b 45 10             	cmp    0x10(%ebp),%eax
   151b0:	7d 11                	jge    151c3 <bitmap_set_bit+0xe4>
   151b2:	8b 45 08             	mov    0x8(%ebp),%eax
   151b5:	8b 00                	mov    (%eax),%eax
   151b7:	39 45 0c             	cmp    %eax,0xc(%ebp)
   151ba:	0f 8c 48 ff ff ff    	jl     15108 <bitmap_set_bit+0x29>
   151c0:	eb 01                	jmp    151c3 <bitmap_set_bit+0xe4>
    if(index+count>bitmap->bit_count) return;
   151c2:	90                   	nop
        }
    }
}
   151c3:	83 c4 10             	add    $0x10,%esp
   151c6:	5b                   	pop    %ebx
   151c7:	5e                   	pop    %esi
   151c8:	5d                   	pop    %ebp
   151c9:	c3                   	ret    

000151ca <bitmap_is_set>:

int bitmap_is_set(bitmap_t* bitmap,int index){
   151ca:	55                   	push   %ebp
   151cb:	89 e5                	mov    %esp,%ebp
    return bitmap_get_bit(bitmap,index) ? 1 : 0;
   151cd:	ff 75 0c             	pushl  0xc(%ebp)
   151d0:	ff 75 08             	pushl  0x8(%ebp)
   151d3:	e8 b8 fe ff ff       	call   15090 <bitmap_get_bit>
   151d8:	83 c4 08             	add    $0x8,%esp
   151db:	85 c0                	test   %eax,%eax
   151dd:	0f 95 c0             	setne  %al
   151e0:	0f b6 c0             	movzbl %al,%eax
}
   151e3:	c9                   	leave  
   151e4:	c3                   	ret    

000151e5 <bitmap_alloc_nbits>:

int bitmap_alloc_nbits(bitmap_t* bitmap,int bit,int count){
   151e5:	55                   	push   %ebp
   151e6:	89 e5                	mov    %esp,%ebp
   151e8:	83 ec 10             	sub    $0x10,%esp
    int search_idx = 0;
   151eb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int ok_idx = -1;
   151f2:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)

    while (search_idx < bitmap->bit_count) {
   151f9:	e9 85 00 00 00       	jmp    15283 <bitmap_alloc_nbits+0x9e>
        if (bitmap_get_bit(bitmap, search_idx) != bit) {
   151fe:	ff 75 fc             	pushl  -0x4(%ebp)
   15201:	ff 75 08             	pushl  0x8(%ebp)
   15204:	e8 87 fe ff ff       	call   15090 <bitmap_get_bit>
   15209:	83 c4 08             	add    $0x8,%esp
   1520c:	39 45 0c             	cmp    %eax,0xc(%ebp)
   1520f:	74 06                	je     15217 <bitmap_alloc_nbits+0x32>
            search_idx++;
   15211:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
            continue;
   15215:	eb 6c                	jmp    15283 <bitmap_alloc_nbits+0x9e>
        }

        ok_idx = search_idx;
   15217:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1521a:	89 45 f8             	mov    %eax,-0x8(%ebp)

        int i;
        for (i = 1; (i < count) && (search_idx < bitmap->bit_count); i++) {
   1521d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   15224:	eb 27                	jmp    1524d <bitmap_alloc_nbits+0x68>
            if (bitmap_get_bit(bitmap, search_idx++) != bit) {
   15226:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15229:	8d 50 01             	lea    0x1(%eax),%edx
   1522c:	89 55 fc             	mov    %edx,-0x4(%ebp)
   1522f:	50                   	push   %eax
   15230:	ff 75 08             	pushl  0x8(%ebp)
   15233:	e8 58 fe ff ff       	call   15090 <bitmap_get_bit>
   15238:	83 c4 08             	add    $0x8,%esp
   1523b:	39 45 0c             	cmp    %eax,0xc(%ebp)
   1523e:	74 09                	je     15249 <bitmap_alloc_nbits+0x64>
                ok_idx = -1;
   15240:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
                break;
   15247:	eb 16                	jmp    1525f <bitmap_alloc_nbits+0x7a>
        for (i = 1; (i < count) && (search_idx < bitmap->bit_count); i++) {
   15249:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1524d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15250:	3b 45 10             	cmp    0x10(%ebp),%eax
   15253:	7d 0a                	jge    1525f <bitmap_alloc_nbits+0x7a>
   15255:	8b 45 08             	mov    0x8(%ebp),%eax
   15258:	8b 00                	mov    (%eax),%eax
   1525a:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   1525d:	7c c7                	jl     15226 <bitmap_alloc_nbits+0x41>
            }
        }
        
        if (i >= count) {
   1525f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15262:	3b 45 10             	cmp    0x10(%ebp),%eax
   15265:	7c 1c                	jl     15283 <bitmap_alloc_nbits+0x9e>
            bitmap_set_bit(bitmap, ok_idx, count, ~bit);
   15267:	8b 45 0c             	mov    0xc(%ebp),%eax
   1526a:	f7 d0                	not    %eax
   1526c:	50                   	push   %eax
   1526d:	ff 75 10             	pushl  0x10(%ebp)
   15270:	ff 75 f8             	pushl  -0x8(%ebp)
   15273:	ff 75 08             	pushl  0x8(%ebp)
   15276:	e8 64 fe ff ff       	call   150df <bitmap_set_bit>
   1527b:	83 c4 10             	add    $0x10,%esp
            return ok_idx;
   1527e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15281:	eb 13                	jmp    15296 <bitmap_alloc_nbits+0xb1>
    while (search_idx < bitmap->bit_count) {
   15283:	8b 45 08             	mov    0x8(%ebp),%eax
   15286:	8b 00                	mov    (%eax),%eax
   15288:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   1528b:	0f 8c 6d ff ff ff    	jl     151fe <bitmap_alloc_nbits+0x19>
        }
    }

    return -1;
   15291:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15296:	c9                   	leave  
   15297:	c3                   	ret    

00015298 <hlt>:
static inline void hlt(void){
   15298:	55                   	push   %ebp
   15299:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile("hlt");
   1529b:	f4                   	hlt    
}
   1529c:	90                   	nop
   1529d:	5d                   	pop    %ebp
   1529e:	c3                   	ret    

0001529f <kernel_strcpy>:
#include "tools/klib.h"

// 复制字符串
void kernel_strcpy(char* dest,const char* src){
   1529f:	55                   	push   %ebp
   152a0:	89 e5                	mov    %esp,%ebp
    if(!dest || !src){
   152a2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   152a6:	74 3b                	je     152e3 <kernel_strcpy+0x44>
   152a8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   152ac:	74 35                	je     152e3 <kernel_strcpy+0x44>
        return;
    }
    while(*dest&&*src){
   152ae:	eb 17                	jmp    152c7 <kernel_strcpy+0x28>
        *dest++=*src++;
   152b0:	8b 55 0c             	mov    0xc(%ebp),%edx
   152b3:	8d 42 01             	lea    0x1(%edx),%eax
   152b6:	89 45 0c             	mov    %eax,0xc(%ebp)
   152b9:	8b 45 08             	mov    0x8(%ebp),%eax
   152bc:	8d 48 01             	lea    0x1(%eax),%ecx
   152bf:	89 4d 08             	mov    %ecx,0x8(%ebp)
   152c2:	0f b6 12             	movzbl (%edx),%edx
   152c5:	88 10                	mov    %dl,(%eax)
    while(*dest&&*src){
   152c7:	8b 45 08             	mov    0x8(%ebp),%eax
   152ca:	0f b6 00             	movzbl (%eax),%eax
   152cd:	84 c0                	test   %al,%al
   152cf:	74 0a                	je     152db <kernel_strcpy+0x3c>
   152d1:	8b 45 0c             	mov    0xc(%ebp),%eax
   152d4:	0f b6 00             	movzbl (%eax),%eax
   152d7:	84 c0                	test   %al,%al
   152d9:	75 d5                	jne    152b0 <kernel_strcpy+0x11>
    }
    *dest='\0';
   152db:	8b 45 08             	mov    0x8(%ebp),%eax
   152de:	c6 00 00             	movb   $0x0,(%eax)
   152e1:	eb 01                	jmp    152e4 <kernel_strcpy+0x45>
        return;
   152e3:	90                   	nop
}
   152e4:	5d                   	pop    %ebp
   152e5:	c3                   	ret    

000152e6 <kernel_strncpy>:

// 复制字符串指明复制多个字符
void kernel_strncpy(char* dest,const char* src,unsigned int size){
   152e6:	55                   	push   %ebp
   152e7:	89 e5                	mov    %esp,%ebp
   152e9:	83 ec 10             	sub    $0x10,%esp
    if(!dest||!src||!size){
   152ec:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   152f0:	74 61                	je     15353 <kernel_strncpy+0x6d>
   152f2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   152f6:	74 5b                	je     15353 <kernel_strncpy+0x6d>
   152f8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   152fc:	74 55                	je     15353 <kernel_strncpy+0x6d>
        return;
    }
    char*d=dest;
   152fe:	8b 45 08             	mov    0x8(%ebp),%eax
   15301:	89 45 fc             	mov    %eax,-0x4(%ebp)
    const char* s=src;
   15304:	8b 45 0c             	mov    0xc(%ebp),%eax
   15307:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while((size-->0)&&(*s)){
   1530a:	eb 17                	jmp    15323 <kernel_strncpy+0x3d>
        *d++=*s++;
   1530c:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1530f:	8d 42 01             	lea    0x1(%edx),%eax
   15312:	89 45 f8             	mov    %eax,-0x8(%ebp)
   15315:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15318:	8d 48 01             	lea    0x1(%eax),%ecx
   1531b:	89 4d fc             	mov    %ecx,-0x4(%ebp)
   1531e:	0f b6 12             	movzbl (%edx),%edx
   15321:	88 10                	mov    %dl,(%eax)
    while((size-->0)&&(*s)){
   15323:	8b 45 10             	mov    0x10(%ebp),%eax
   15326:	8d 50 ff             	lea    -0x1(%eax),%edx
   15329:	89 55 10             	mov    %edx,0x10(%ebp)
   1532c:	85 c0                	test   %eax,%eax
   1532e:	74 0a                	je     1533a <kernel_strncpy+0x54>
   15330:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15333:	0f b6 00             	movzbl (%eax),%eax
   15336:	84 c0                	test   %al,%al
   15338:	75 d2                	jne    1530c <kernel_strncpy+0x26>
    }
    if(size==0){
   1533a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1533e:	75 0b                	jne    1534b <kernel_strncpy+0x65>
        *(d-1)='\0';
   15340:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15343:	83 e8 01             	sub    $0x1,%eax
   15346:	c6 00 00             	movb   $0x0,(%eax)
   15349:	eb 09                	jmp    15354 <kernel_strncpy+0x6e>
    }
    else{
        *d='\0';
   1534b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1534e:	c6 00 00             	movb   $0x0,(%eax)
   15351:	eb 01                	jmp    15354 <kernel_strncpy+0x6e>
        return;
   15353:	90                   	nop
    }
}
   15354:	c9                   	leave  
   15355:	c3                   	ret    

00015356 <kernel_strncmp>:
 * @brief 字符串比较函数
 * @param s1 字符串1
 * @param s2 字符串2
 * @param size 比较的长度
 */
int kernel_strncmp(const char* s1,const char* s2,unsigned int size){
   15356:	55                   	push   %ebp
   15357:	89 e5                	mov    %esp,%ebp
    if(!s1 || !s2){
   15359:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1535d:	74 06                	je     15365 <kernel_strncmp+0xf>
   1535f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   15363:	75 0f                	jne    15374 <kernel_strncmp+0x1e>
        return -1;
   15365:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1536a:	eb 62                	jmp    153ce <kernel_strncmp+0x78>
    }
    while(*s1 && *s2 && (*s1==*s2) && size){
        s1++;
   1536c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        s2++;
   15370:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    while(*s1 && *s2 && (*s1==*s2) && size){
   15374:	8b 45 08             	mov    0x8(%ebp),%eax
   15377:	0f b6 00             	movzbl (%eax),%eax
   1537a:	84 c0                	test   %al,%al
   1537c:	74 20                	je     1539e <kernel_strncmp+0x48>
   1537e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15381:	0f b6 00             	movzbl (%eax),%eax
   15384:	84 c0                	test   %al,%al
   15386:	74 16                	je     1539e <kernel_strncmp+0x48>
   15388:	8b 45 08             	mov    0x8(%ebp),%eax
   1538b:	0f b6 10             	movzbl (%eax),%edx
   1538e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15391:	0f b6 00             	movzbl (%eax),%eax
   15394:	38 c2                	cmp    %al,%dl
   15396:	75 06                	jne    1539e <kernel_strncmp+0x48>
   15398:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1539c:	75 ce                	jne    1536c <kernel_strncmp+0x16>
    }
    // 相等返回1
    return !((*s1=='\0') || (*s2=='\0') || (*s1==*s2));
   1539e:	8b 45 08             	mov    0x8(%ebp),%eax
   153a1:	0f b6 00             	movzbl (%eax),%eax
   153a4:	84 c0                	test   %al,%al
   153a6:	74 21                	je     153c9 <kernel_strncmp+0x73>
   153a8:	8b 45 0c             	mov    0xc(%ebp),%eax
   153ab:	0f b6 00             	movzbl (%eax),%eax
   153ae:	84 c0                	test   %al,%al
   153b0:	74 17                	je     153c9 <kernel_strncmp+0x73>
   153b2:	8b 45 08             	mov    0x8(%ebp),%eax
   153b5:	0f b6 10             	movzbl (%eax),%edx
   153b8:	8b 45 0c             	mov    0xc(%ebp),%eax
   153bb:	0f b6 00             	movzbl (%eax),%eax
   153be:	38 c2                	cmp    %al,%dl
   153c0:	74 07                	je     153c9 <kernel_strncmp+0x73>
   153c2:	b8 01 00 00 00       	mov    $0x1,%eax
   153c7:	eb 05                	jmp    153ce <kernel_strncmp+0x78>
   153c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
   153ce:	5d                   	pop    %ebp
   153cf:	c3                   	ret    

000153d0 <kernel_strlen>:
 * @brief 获取字符串的长度
 * @param str 要获取长度的字符串
 * @return 字符串的长度
 * @note 如果字符串为空，返回0
 */
int kernel_strlen(const char* str){
   153d0:	55                   	push   %ebp
   153d1:	89 e5                	mov    %esp,%ebp
   153d3:	83 ec 10             	sub    $0x10,%esp
    if(!str){
   153d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   153da:	75 07                	jne    153e3 <kernel_strlen+0x13>
        return 0;
   153dc:	b8 00 00 00 00       	mov    $0x0,%eax
   153e1:	eb 26                	jmp    15409 <kernel_strlen+0x39>
    }
    const char*c=str;
   153e3:	8b 45 08             	mov    0x8(%ebp),%eax
   153e6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int len=0;
   153e9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    while(*c++){
   153f0:	eb 04                	jmp    153f6 <kernel_strlen+0x26>
        len++;
   153f2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while(*c++){
   153f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   153f9:	8d 50 01             	lea    0x1(%eax),%edx
   153fc:	89 55 fc             	mov    %edx,-0x4(%ebp)
   153ff:	0f b6 00             	movzbl (%eax),%eax
   15402:	84 c0                	test   %al,%al
   15404:	75 ec                	jne    153f2 <kernel_strlen+0x22>
    }
    return len;
   15406:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
   15409:	c9                   	leave  
   1540a:	c3                   	ret    

0001540b <kernel_memcpy>:

// 复制内存的值
void kernel_memcpy(void* dest,void* src,unsigned int size){
   1540b:	55                   	push   %ebp
   1540c:	89 e5                	mov    %esp,%ebp
   1540e:	83 ec 10             	sub    $0x10,%esp
    if(!dest || !src || !size){
   15411:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   15415:	74 40                	je     15457 <kernel_memcpy+0x4c>
   15417:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1541b:	74 3a                	je     15457 <kernel_memcpy+0x4c>
   1541d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   15421:	74 34                	je     15457 <kernel_memcpy+0x4c>
        return;
    }
    uint8_t* s=(uint8_t*) src;
   15423:	8b 45 0c             	mov    0xc(%ebp),%eax
   15426:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t* d=(uint8_t*) dest;
   15429:	8b 45 08             	mov    0x8(%ebp),%eax
   1542c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(size--){
   1542f:	eb 17                	jmp    15448 <kernel_memcpy+0x3d>
        *d++=*s++;
   15431:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15434:	8d 42 01             	lea    0x1(%edx),%eax
   15437:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1543a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1543d:	8d 48 01             	lea    0x1(%eax),%ecx
   15440:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   15443:	0f b6 12             	movzbl (%edx),%edx
   15446:	88 10                	mov    %dl,(%eax)
    while(size--){
   15448:	8b 45 10             	mov    0x10(%ebp),%eax
   1544b:	8d 50 ff             	lea    -0x1(%eax),%edx
   1544e:	89 55 10             	mov    %edx,0x10(%ebp)
   15451:	85 c0                	test   %eax,%eax
   15453:	75 dc                	jne    15431 <kernel_memcpy+0x26>
   15455:	eb 01                	jmp    15458 <kernel_memcpy+0x4d>
        return;
   15457:	90                   	nop
    }
    
}
   15458:	c9                   	leave  
   15459:	c3                   	ret    

0001545a <kernel_memset>:

// 设置内存的值
void kernel_memset(void* dest,uint8_t v,int size){
   1545a:	55                   	push   %ebp
   1545b:	89 e5                	mov    %esp,%ebp
   1545d:	83 ec 14             	sub    $0x14,%esp
   15460:	8b 45 0c             	mov    0xc(%ebp),%eax
   15463:	88 45 ec             	mov    %al,-0x14(%ebp)
    if(!dest || !size){
   15466:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1546a:	74 2c                	je     15498 <kernel_memset+0x3e>
   1546c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   15470:	74 26                	je     15498 <kernel_memset+0x3e>
        return;
    }
    uint8_t* d=(uint8_t*) dest;
   15472:	8b 45 08             	mov    0x8(%ebp),%eax
   15475:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(size--){
   15478:	eb 0f                	jmp    15489 <kernel_memset+0x2f>
        *d++=v;
   1547a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1547d:	8d 50 01             	lea    0x1(%eax),%edx
   15480:	89 55 fc             	mov    %edx,-0x4(%ebp)
   15483:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
   15487:	88 10                	mov    %dl,(%eax)
    while(size--){
   15489:	8b 45 10             	mov    0x10(%ebp),%eax
   1548c:	8d 50 ff             	lea    -0x1(%eax),%edx
   1548f:	89 55 10             	mov    %edx,0x10(%ebp)
   15492:	85 c0                	test   %eax,%eax
   15494:	75 e4                	jne    1547a <kernel_memset+0x20>
   15496:	eb 01                	jmp    15499 <kernel_memset+0x3f>
        return;
   15498:	90                   	nop
    }
}
   15499:	c9                   	leave  
   1549a:	c3                   	ret    

0001549b <kernel_memcmp>:

// 比较内存的值
int kernel_memcmp(void* d1,void* d2,unsigned int size){
   1549b:	55                   	push   %ebp
   1549c:	89 e5                	mov    %esp,%ebp
   1549e:	83 ec 10             	sub    $0x10,%esp
     if(!d1 || !d2 || !size){
   154a1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   154a5:	74 0c                	je     154b3 <kernel_memcmp+0x18>
   154a7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   154ab:	74 06                	je     154b3 <kernel_memcmp+0x18>
   154ad:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   154b1:	75 07                	jne    154ba <kernel_memcmp+0x1f>
        return 1;
   154b3:	b8 01 00 00 00       	mov    $0x1,%eax
   154b8:	eb 43                	jmp    154fd <kernel_memcmp+0x62>
    }
    uint8_t* p_d1=(uint8_t*) d1;
   154ba:	8b 45 08             	mov    0x8(%ebp),%eax
   154bd:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t* p_d2=(uint8_t*) d2;
   154c0:	8b 45 0c             	mov    0xc(%ebp),%eax
   154c3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    // 不同返回1，相同返回0
    while(size--){
   154c6:	eb 23                	jmp    154eb <kernel_memcmp+0x50>
        if(*p_d1++!=*p_d2++){
   154c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   154cb:	8d 50 01             	lea    0x1(%eax),%edx
   154ce:	89 55 fc             	mov    %edx,-0x4(%ebp)
   154d1:	0f b6 08             	movzbl (%eax),%ecx
   154d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   154d7:	8d 50 01             	lea    0x1(%eax),%edx
   154da:	89 55 f8             	mov    %edx,-0x8(%ebp)
   154dd:	0f b6 00             	movzbl (%eax),%eax
   154e0:	38 c1                	cmp    %al,%cl
   154e2:	74 07                	je     154eb <kernel_memcmp+0x50>
            return 1;
   154e4:	b8 01 00 00 00       	mov    $0x1,%eax
   154e9:	eb 12                	jmp    154fd <kernel_memcmp+0x62>
    while(size--){
   154eb:	8b 45 10             	mov    0x10(%ebp),%eax
   154ee:	8d 50 ff             	lea    -0x1(%eax),%edx
   154f1:	89 55 10             	mov    %edx,0x10(%ebp)
   154f4:	85 c0                	test   %eax,%eax
   154f6:	75 d0                	jne    154c8 <kernel_memcmp+0x2d>
        }
    }
    return 0;
   154f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   154fd:	c9                   	leave  
   154fe:	c3                   	ret    

000154ff <kernel_sprintf>:

void kernel_sprintf(char* buf,const char* fmt,...){
   154ff:	55                   	push   %ebp
   15500:	89 e5                	mov    %esp,%ebp
   15502:	83 ec 18             	sub    $0x18,%esp
    va_list args;
    va_start(args,fmt);
   15505:	8d 45 10             	lea    0x10(%ebp),%eax
   15508:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_vsprintf(buf,fmt,args);
   1550b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1550e:	83 ec 04             	sub    $0x4,%esp
   15511:	50                   	push   %eax
   15512:	ff 75 0c             	pushl  0xc(%ebp)
   15515:	ff 75 08             	pushl  0x8(%ebp)
   15518:	e8 45 01 00 00       	call   15662 <kernel_vsprintf>
   1551d:	83 c4 10             	add    $0x10,%esp
    va_end(args);
}
   15520:	90                   	nop
   15521:	c9                   	leave  
   15522:	c3                   	ret    

00015523 <kernel_itoa>:

void kernel_itoa(char * buf, int num, int base) {
   15523:	55                   	push   %ebp
   15524:	89 e5                	mov    %esp,%ebp
   15526:	53                   	push   %ebx
   15527:	83 ec 20             	sub    $0x20,%esp
    static const char * num2ch = {"FEDCBA9876543210123456789ABCDEF"};
    char * p = buf;
   1552a:	8b 45 08             	mov    0x8(%ebp),%eax
   1552d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int old_num = num;
   15530:	8b 45 0c             	mov    0xc(%ebp),%eax
   15533:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if ((base != 2) && (base != 8) && (base != 10) && (base != 16)) {
   15536:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   1553a:	74 1d                	je     15559 <kernel_itoa+0x36>
   1553c:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
   15540:	74 17                	je     15559 <kernel_itoa+0x36>
   15542:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   15546:	74 11                	je     15559 <kernel_itoa+0x36>
   15548:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
   1554c:	74 0b                	je     15559 <kernel_itoa+0x36>
        *p = '\0';
   1554e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15551:	c6 00 00             	movb   $0x0,(%eax)
        return;
   15554:	e9 03 01 00 00       	jmp    1565c <kernel_itoa+0x139>
    }

    int signed_num = 0;
   15559:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if ((num < 0) && (base == 10)) {
   15560:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   15564:	79 19                	jns    1557f <kernel_itoa+0x5c>
   15566:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   1556a:	75 13                	jne    1557f <kernel_itoa+0x5c>
        *p++ = '-';
   1556c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1556f:	8d 50 01             	lea    0x1(%eax),%edx
   15572:	89 55 f8             	mov    %edx,-0x8(%ebp)
   15575:	c6 00 2d             	movb   $0x2d,(%eax)
        signed_num = 1;
   15578:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    }

    if (signed_num) {
   1557f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15583:	74 3b                	je     155c0 <kernel_itoa+0x9d>
        do {
            char ch = num2ch[num % base + 15];
   15585:	8b 0d 98 70 01 00    	mov    0x17098,%ecx
   1558b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1558e:	99                   	cltd   
   1558f:	f7 7d 10             	idivl  0x10(%ebp)
   15592:	89 d0                	mov    %edx,%eax
   15594:	83 c0 0f             	add    $0xf,%eax
   15597:	01 c8                	add    %ecx,%eax
   15599:	0f b6 00             	movzbl (%eax),%eax
   1559c:	88 45 e6             	mov    %al,-0x1a(%ebp)
            *p++ = ch;
   1559f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   155a2:	8d 50 01             	lea    0x1(%eax),%edx
   155a5:	89 55 f8             	mov    %edx,-0x8(%ebp)
   155a8:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
   155ac:	88 10                	mov    %dl,(%eax)
            num /= base;
   155ae:	8b 45 0c             	mov    0xc(%ebp),%eax
   155b1:	99                   	cltd   
   155b2:	f7 7d 10             	idivl  0x10(%ebp)
   155b5:	89 45 0c             	mov    %eax,0xc(%ebp)
        } while (num);
   155b8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   155bc:	75 c7                	jne    15585 <kernel_itoa+0x62>
   155be:	eb 4b                	jmp    1560b <kernel_itoa+0xe8>
    } else {
        uint32_t u_num = (uint32_t)num;
   155c0:	8b 45 0c             	mov    0xc(%ebp),%eax
   155c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
        do {
            char ch = num2ch[u_num % base + 15];
   155c6:	8b 0d 98 70 01 00    	mov    0x17098,%ecx
   155cc:	8b 5d 10             	mov    0x10(%ebp),%ebx
   155cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   155d2:	ba 00 00 00 00       	mov    $0x0,%edx
   155d7:	f7 f3                	div    %ebx
   155d9:	89 d0                	mov    %edx,%eax
   155db:	83 c0 0f             	add    $0xf,%eax
   155de:	01 c8                	add    %ecx,%eax
   155e0:	0f b6 00             	movzbl (%eax),%eax
   155e3:	88 45 e7             	mov    %al,-0x19(%ebp)
            *p++ = ch;
   155e6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   155e9:	8d 50 01             	lea    0x1(%eax),%edx
   155ec:	89 55 f8             	mov    %edx,-0x8(%ebp)
   155ef:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
   155f3:	88 10                	mov    %dl,(%eax)
            u_num /= base;
   155f5:	8b 5d 10             	mov    0x10(%ebp),%ebx
   155f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   155fb:	ba 00 00 00 00       	mov    $0x0,%edx
   15600:	f7 f3                	div    %ebx
   15602:	89 45 f0             	mov    %eax,-0x10(%ebp)
        } while (u_num);
   15605:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   15609:	75 bb                	jne    155c6 <kernel_itoa+0xa3>
    }
    *p-- = '\0';
   1560b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1560e:	8d 50 ff             	lea    -0x1(%eax),%edx
   15611:	89 55 f8             	mov    %edx,-0x8(%ebp)
   15614:	c6 00 00             	movb   $0x0,(%eax)

    char * start = (!signed_num) ? buf : buf + 1;
   15617:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1561b:	74 08                	je     15625 <kernel_itoa+0x102>
   1561d:	8b 45 08             	mov    0x8(%ebp),%eax
   15620:	83 c0 01             	add    $0x1,%eax
   15623:	eb 03                	jmp    15628 <kernel_itoa+0x105>
   15625:	8b 45 08             	mov    0x8(%ebp),%eax
   15628:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while (start < p) {
   1562b:	eb 27                	jmp    15654 <kernel_itoa+0x131>
        char ch = *start;
   1562d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15630:	0f b6 00             	movzbl (%eax),%eax
   15633:	88 45 e5             	mov    %al,-0x1b(%ebp)
        *start = *p;
   15636:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15639:	0f b6 10             	movzbl (%eax),%edx
   1563c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1563f:	88 10                	mov    %dl,(%eax)
        *p-- = ch;
   15641:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15644:	8d 50 ff             	lea    -0x1(%eax),%edx
   15647:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1564a:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
   1564e:	88 10                	mov    %dl,(%eax)
        start++;
   15650:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    while (start < p) {
   15654:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15657:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   1565a:	72 d1                	jb     1562d <kernel_itoa+0x10a>
    }
}
   1565c:	83 c4 20             	add    $0x20,%esp
   1565f:	5b                   	pop    %ebx
   15660:	5d                   	pop    %ebp
   15661:	c3                   	ret    

00015662 <kernel_vsprintf>:

void kernel_vsprintf(char* buf,const char*fmt,va_list args){
   15662:	55                   	push   %ebp
   15663:	89 e5                	mov    %esp,%ebp
   15665:	83 ec 20             	sub    $0x20,%esp
    enum {NORMAL,READ_FMT} state=NORMAL;
   15668:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    char* curr=buf;
   1566f:	8b 45 08             	mov    0x8(%ebp),%eax
   15672:	89 45 f8             	mov    %eax,-0x8(%ebp)
    char ch;
    while((ch=*fmt++)){
   15675:	e9 17 01 00 00       	jmp    15791 <kernel_vsprintf+0x12f>
       switch (state)
   1567a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1567d:	85 c0                	test   %eax,%eax
   1567f:	74 0a                	je     1568b <kernel_vsprintf+0x29>
   15681:	83 f8 01             	cmp    $0x1,%eax
   15684:	74 2b                	je     156b1 <kernel_vsprintf+0x4f>
   15686:	e9 06 01 00 00       	jmp    15791 <kernel_vsprintf+0x12f>
       {
            case NORMAL:
                if(ch=='%'){
   1568b:	80 7d ef 25          	cmpb   $0x25,-0x11(%ebp)
   1568f:	75 0c                	jne    1569d <kernel_vsprintf+0x3b>
                    state=READ_FMT;
   15691:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
   15698:	e9 f4 00 00 00       	jmp    15791 <kernel_vsprintf+0x12f>
                }
                else{
                    *curr++=ch;
   1569d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   156a0:	8d 50 01             	lea    0x1(%eax),%edx
   156a3:	89 55 f8             	mov    %edx,-0x8(%ebp)
   156a6:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
   156aa:	88 10                	mov    %dl,(%eax)
                }
                break;
   156ac:	e9 e0 00 00 00       	jmp    15791 <kernel_vsprintf+0x12f>
            case READ_FMT:
                if(ch=='s'){
   156b1:	80 7d ef 73          	cmpb   $0x73,-0x11(%ebp)
   156b5:	75 47                	jne    156fe <kernel_vsprintf+0x9c>
                    const char*str=va_arg(args,char*);
   156b7:	8b 45 10             	mov    0x10(%ebp),%eax
   156ba:	8d 50 04             	lea    0x4(%eax),%edx
   156bd:	89 55 10             	mov    %edx,0x10(%ebp)
   156c0:	8b 00                	mov    (%eax),%eax
   156c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
                    int len=kernel_strlen(str);
   156c5:	ff 75 f4             	pushl  -0xc(%ebp)
   156c8:	e8 03 fd ff ff       	call   153d0 <kernel_strlen>
   156cd:	83 c4 04             	add    $0x4,%esp
   156d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
                    while(len--){
   156d3:	eb 17                	jmp    156ec <kernel_vsprintf+0x8a>
                        *curr++=*str++;
   156d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   156d8:	8d 42 01             	lea    0x1(%edx),%eax
   156db:	89 45 f4             	mov    %eax,-0xc(%ebp)
   156de:	8b 45 f8             	mov    -0x8(%ebp),%eax
   156e1:	8d 48 01             	lea    0x1(%eax),%ecx
   156e4:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   156e7:	0f b6 12             	movzbl (%edx),%edx
   156ea:	88 10                	mov    %dl,(%eax)
                    while(len--){
   156ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
   156ef:	8d 50 ff             	lea    -0x1(%eax),%edx
   156f2:	89 55 f0             	mov    %edx,-0x10(%ebp)
   156f5:	85 c0                	test   %eax,%eax
   156f7:	75 dc                	jne    156d5 <kernel_vsprintf+0x73>
   156f9:	e9 8b 00 00 00       	jmp    15789 <kernel_vsprintf+0x127>
                    }
                }
                else if(ch=='d'){
   156fe:	80 7d ef 64          	cmpb   $0x64,-0x11(%ebp)
   15702:	75 2e                	jne    15732 <kernel_vsprintf+0xd0>
                    int num=va_arg(args,int);
   15704:	8b 45 10             	mov    0x10(%ebp),%eax
   15707:	8d 50 04             	lea    0x4(%eax),%edx
   1570a:	89 55 10             	mov    %edx,0x10(%ebp)
   1570d:	8b 00                	mov    (%eax),%eax
   1570f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                    kernel_itoa(curr,num,10);
   15712:	6a 0a                	push   $0xa
   15714:	ff 75 e4             	pushl  -0x1c(%ebp)
   15717:	ff 75 f8             	pushl  -0x8(%ebp)
   1571a:	e8 04 fe ff ff       	call   15523 <kernel_itoa>
   1571f:	83 c4 0c             	add    $0xc,%esp
                    curr+=kernel_strlen(curr);
   15722:	ff 75 f8             	pushl  -0x8(%ebp)
   15725:	e8 a6 fc ff ff       	call   153d0 <kernel_strlen>
   1572a:	83 c4 04             	add    $0x4,%esp
   1572d:	01 45 f8             	add    %eax,-0x8(%ebp)
   15730:	eb 57                	jmp    15789 <kernel_vsprintf+0x127>
                }
                else if(ch=='x'){
   15732:	80 7d ef 78          	cmpb   $0x78,-0x11(%ebp)
   15736:	75 2e                	jne    15766 <kernel_vsprintf+0x104>
                    int num=va_arg(args,int);
   15738:	8b 45 10             	mov    0x10(%ebp),%eax
   1573b:	8d 50 04             	lea    0x4(%eax),%edx
   1573e:	89 55 10             	mov    %edx,0x10(%ebp)
   15741:	8b 00                	mov    (%eax),%eax
   15743:	89 45 e8             	mov    %eax,-0x18(%ebp)
                    kernel_itoa(curr,num,16);
   15746:	6a 10                	push   $0x10
   15748:	ff 75 e8             	pushl  -0x18(%ebp)
   1574b:	ff 75 f8             	pushl  -0x8(%ebp)
   1574e:	e8 d0 fd ff ff       	call   15523 <kernel_itoa>
   15753:	83 c4 0c             	add    $0xc,%esp
                    curr+=kernel_strlen(curr);
   15756:	ff 75 f8             	pushl  -0x8(%ebp)
   15759:	e8 72 fc ff ff       	call   153d0 <kernel_strlen>
   1575e:	83 c4 04             	add    $0x4,%esp
   15761:	01 45 f8             	add    %eax,-0x8(%ebp)
   15764:	eb 23                	jmp    15789 <kernel_vsprintf+0x127>
                }
                else if(ch=='c'){
   15766:	80 7d ef 63          	cmpb   $0x63,-0x11(%ebp)
   1576a:	75 1d                	jne    15789 <kernel_vsprintf+0x127>
                    char c=va_arg(args,int);
   1576c:	8b 45 10             	mov    0x10(%ebp),%eax
   1576f:	8d 50 04             	lea    0x4(%eax),%edx
   15772:	89 55 10             	mov    %edx,0x10(%ebp)
   15775:	8b 00                	mov    (%eax),%eax
   15777:	88 45 ee             	mov    %al,-0x12(%ebp)
                    *curr++=c;
   1577a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1577d:	8d 50 01             	lea    0x1(%eax),%edx
   15780:	89 55 f8             	mov    %edx,-0x8(%ebp)
   15783:	0f b6 55 ee          	movzbl -0x12(%ebp),%edx
   15787:	88 10                	mov    %dl,(%eax)
                }
                state=NORMAL;
   15789:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
                break;
   15790:	90                   	nop
    while((ch=*fmt++)){
   15791:	8b 45 0c             	mov    0xc(%ebp),%eax
   15794:	8d 50 01             	lea    0x1(%eax),%edx
   15797:	89 55 0c             	mov    %edx,0xc(%ebp)
   1579a:	0f b6 00             	movzbl (%eax),%eax
   1579d:	88 45 ef             	mov    %al,-0x11(%ebp)
   157a0:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
   157a4:	0f 85 d0 fe ff ff    	jne    1567a <kernel_vsprintf+0x18>
        
       }
    }

}
   157aa:	90                   	nop
   157ab:	c9                   	leave  
   157ac:	c3                   	ret    

000157ad <panic>:

void panic (const char * file, int line, const char * func, const char * cond){
   157ad:	55                   	push   %ebp
   157ae:	89 e5                	mov    %esp,%ebp
   157b0:	83 ec 08             	sub    $0x8,%esp
    log_printf("assert failed!, %s\n",cond);
   157b3:	83 ec 08             	sub    $0x8,%esp
   157b6:	ff 75 14             	pushl  0x14(%ebp)
   157b9:	68 70 67 01 00       	push   $0x16770
   157be:	e8 ba 02 00 00       	call   15a7d <log_printf>
   157c3:	83 c4 10             	add    $0x10,%esp
    log_printf("file: %s\nline: %d\nfunc: %s\n",file,line,func);
   157c6:	ff 75 10             	pushl  0x10(%ebp)
   157c9:	ff 75 0c             	pushl  0xc(%ebp)
   157cc:	ff 75 08             	pushl  0x8(%ebp)
   157cf:	68 84 67 01 00       	push   $0x16784
   157d4:	e8 a4 02 00 00       	call   15a7d <log_printf>
   157d9:	83 c4 10             	add    $0x10,%esp
    for(;;){
        hlt();
   157dc:	e8 b7 fa ff ff       	call   15298 <hlt>
   157e1:	eb f9                	jmp    157dc <panic+0x2f>

000157e3 <string_count>:
    }
}

int string_count(char**start){
   157e3:	55                   	push   %ebp
   157e4:	89 e5                	mov    %esp,%ebp
   157e6:	83 ec 10             	sub    $0x10,%esp
    int count=0;
   157e9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    if(start){
   157f0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   157f4:	74 15                	je     1580b <string_count+0x28>
        while(*start++){
   157f6:	eb 04                	jmp    157fc <string_count+0x19>
            count++;
   157f8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        while(*start++){
   157fc:	8b 45 08             	mov    0x8(%ebp),%eax
   157ff:	8d 50 04             	lea    0x4(%eax),%edx
   15802:	89 55 08             	mov    %edx,0x8(%ebp)
   15805:	8b 00                	mov    (%eax),%eax
   15807:	85 c0                	test   %eax,%eax
   15809:	75 ed                	jne    157f8 <string_count+0x15>
        }
    }

    return count;
   1580b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1580e:	c9                   	leave  
   1580f:	c3                   	ret    

00015810 <get_file_name>:

char* get_file_name(char*name){
   15810:	55                   	push   %ebp
   15811:	89 e5                	mov    %esp,%ebp
   15813:	83 ec 10             	sub    $0x10,%esp
    char*s=name;
   15816:	8b 45 08             	mov    0x8(%ebp),%eax
   15819:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while(*s!='\0'){
   1581c:	eb 04                	jmp    15822 <get_file_name+0x12>
        s++;
   1581e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while(*s!='\0'){
   15822:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15825:	0f b6 00             	movzbl (%eax),%eax
   15828:	84 c0                	test   %al,%al
   1582a:	75 f2                	jne    1581e <get_file_name+0xe>
    }

    while((*s!='/') && (*s!='\\') && (s>=name)){
   1582c:	eb 04                	jmp    15832 <get_file_name+0x22>
        s--;
   1582e:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    while((*s!='/') && (*s!='\\') && (s>=name)){
   15832:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15835:	0f b6 00             	movzbl (%eax),%eax
   15838:	3c 2f                	cmp    $0x2f,%al
   1583a:	74 12                	je     1584e <get_file_name+0x3e>
   1583c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1583f:	0f b6 00             	movzbl (%eax),%eax
   15842:	3c 5c                	cmp    $0x5c,%al
   15844:	74 08                	je     1584e <get_file_name+0x3e>
   15846:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15849:	3b 45 08             	cmp    0x8(%ebp),%eax
   1584c:	73 e0                	jae    1582e <get_file_name+0x1e>
    }

    return s+1;
   1584e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15851:	83 c0 01             	add    $0x1,%eax
   15854:	c9                   	leave  
   15855:	c3                   	ret    

00015856 <list_is_empty>:
static inline int list_is_empty(list_t* list){
   15856:	55                   	push   %ebp
   15857:	89 e5                	mov    %esp,%ebp
    return list->count==0;
   15859:	8b 45 08             	mov    0x8(%ebp),%eax
   1585c:	8b 40 08             	mov    0x8(%eax),%eax
   1585f:	85 c0                	test   %eax,%eax
   15861:	0f 94 c0             	sete   %al
   15864:	0f b6 c0             	movzbl %al,%eax
}
   15867:	5d                   	pop    %ebp
   15868:	c3                   	ret    

00015869 <list_init>:
#include "tools/list.h"

void list_init(list_t* list){
   15869:	55                   	push   %ebp
   1586a:	89 e5                	mov    %esp,%ebp
    list->first=list->last=(list_node_t*)0;
   1586c:	8b 45 08             	mov    0x8(%ebp),%eax
   1586f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   15876:	8b 45 08             	mov    0x8(%ebp),%eax
   15879:	8b 50 04             	mov    0x4(%eax),%edx
   1587c:	8b 45 08             	mov    0x8(%ebp),%eax
   1587f:	89 10                	mov    %edx,(%eax)
    list->count=0;
   15881:	8b 45 08             	mov    0x8(%ebp),%eax
   15884:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
   1588b:	90                   	nop
   1588c:	5d                   	pop    %ebp
   1588d:	c3                   	ret    

0001588e <list_insert_first>:

void list_insert_first(list_t* list,list_node_t* node){
   1588e:	55                   	push   %ebp
   1588f:	89 e5                	mov    %esp,%ebp
    node->next=list->first;
   15891:	8b 45 08             	mov    0x8(%ebp),%eax
   15894:	8b 10                	mov    (%eax),%edx
   15896:	8b 45 0c             	mov    0xc(%ebp),%eax
   15899:	89 50 04             	mov    %edx,0x4(%eax)
    node->pre=(list_node_t*)0;
   1589c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1589f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(list_is_empty(list)){
   158a5:	ff 75 08             	pushl  0x8(%ebp)
   158a8:	e8 a9 ff ff ff       	call   15856 <list_is_empty>
   158ad:	83 c4 04             	add    $0x4,%esp
   158b0:	85 c0                	test   %eax,%eax
   158b2:	74 15                	je     158c9 <list_insert_first+0x3b>
        list->last=list->first=node;
   158b4:	8b 45 08             	mov    0x8(%ebp),%eax
   158b7:	8b 55 0c             	mov    0xc(%ebp),%edx
   158ba:	89 10                	mov    %edx,(%eax)
   158bc:	8b 45 08             	mov    0x8(%ebp),%eax
   158bf:	8b 10                	mov    (%eax),%edx
   158c1:	8b 45 08             	mov    0x8(%ebp),%eax
   158c4:	89 50 04             	mov    %edx,0x4(%eax)
   158c7:	eb 12                	jmp    158db <list_insert_first+0x4d>
    }
    else{
        list->first->pre=node;
   158c9:	8b 45 08             	mov    0x8(%ebp),%eax
   158cc:	8b 00                	mov    (%eax),%eax
   158ce:	8b 55 0c             	mov    0xc(%ebp),%edx
   158d1:	89 10                	mov    %edx,(%eax)
        list->first=node;
   158d3:	8b 45 08             	mov    0x8(%ebp),%eax
   158d6:	8b 55 0c             	mov    0xc(%ebp),%edx
   158d9:	89 10                	mov    %edx,(%eax)
    }
    list->count++;
   158db:	8b 45 08             	mov    0x8(%ebp),%eax
   158de:	8b 40 08             	mov    0x8(%eax),%eax
   158e1:	8d 50 01             	lea    0x1(%eax),%edx
   158e4:	8b 45 08             	mov    0x8(%ebp),%eax
   158e7:	89 50 08             	mov    %edx,0x8(%eax)
}
   158ea:	90                   	nop
   158eb:	c9                   	leave  
   158ec:	c3                   	ret    

000158ed <list_insert_last>:

void list_insert_last(list_t*list,list_node_t*node){
   158ed:	55                   	push   %ebp
   158ee:	89 e5                	mov    %esp,%ebp
    node->pre=list->last;
   158f0:	8b 45 08             	mov    0x8(%ebp),%eax
   158f3:	8b 50 04             	mov    0x4(%eax),%edx
   158f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   158f9:	89 10                	mov    %edx,(%eax)
    node->next=(list_node_t*)0;
   158fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   158fe:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if(list_is_empty(list)){
   15905:	ff 75 08             	pushl  0x8(%ebp)
   15908:	e8 49 ff ff ff       	call   15856 <list_is_empty>
   1590d:	83 c4 04             	add    $0x4,%esp
   15910:	85 c0                	test   %eax,%eax
   15912:	74 16                	je     1592a <list_insert_last+0x3d>
        list->first=list->last=node;
   15914:	8b 45 08             	mov    0x8(%ebp),%eax
   15917:	8b 55 0c             	mov    0xc(%ebp),%edx
   1591a:	89 50 04             	mov    %edx,0x4(%eax)
   1591d:	8b 45 08             	mov    0x8(%ebp),%eax
   15920:	8b 50 04             	mov    0x4(%eax),%edx
   15923:	8b 45 08             	mov    0x8(%ebp),%eax
   15926:	89 10                	mov    %edx,(%eax)
   15928:	eb 15                	jmp    1593f <list_insert_last+0x52>
    }
    else{
        list->last->next=node;
   1592a:	8b 45 08             	mov    0x8(%ebp),%eax
   1592d:	8b 40 04             	mov    0x4(%eax),%eax
   15930:	8b 55 0c             	mov    0xc(%ebp),%edx
   15933:	89 50 04             	mov    %edx,0x4(%eax)
        list->last=node;
   15936:	8b 45 08             	mov    0x8(%ebp),%eax
   15939:	8b 55 0c             	mov    0xc(%ebp),%edx
   1593c:	89 50 04             	mov    %edx,0x4(%eax)
    }
    list->count++;
   1593f:	8b 45 08             	mov    0x8(%ebp),%eax
   15942:	8b 40 08             	mov    0x8(%eax),%eax
   15945:	8d 50 01             	lea    0x1(%eax),%edx
   15948:	8b 45 08             	mov    0x8(%ebp),%eax
   1594b:	89 50 08             	mov    %edx,0x8(%eax)
}
   1594e:	90                   	nop
   1594f:	c9                   	leave  
   15950:	c3                   	ret    

00015951 <list_remove_first>:

/**
 * @brief 删除链表的第一个节点
 * @param list 具体要操作的链表
 */
list_node_t* list_remove_first(list_t* list){
   15951:	55                   	push   %ebp
   15952:	89 e5                	mov    %esp,%ebp
   15954:	83 ec 10             	sub    $0x10,%esp
    if(list_is_empty(list)){
   15957:	ff 75 08             	pushl  0x8(%ebp)
   1595a:	e8 f7 fe ff ff       	call   15856 <list_is_empty>
   1595f:	83 c4 04             	add    $0x4,%esp
   15962:	85 c0                	test   %eax,%eax
   15964:	74 07                	je     1596d <list_remove_first+0x1c>
        return (list_node_t*)0;
   15966:	b8 00 00 00 00       	mov    $0x0,%eax
   1596b:	eb 5a                	jmp    159c7 <list_remove_first+0x76>
    }
    list_node_t* remove_node=list->first;
   1596d:	8b 45 08             	mov    0x8(%ebp),%eax
   15970:	8b 00                	mov    (%eax),%eax
   15972:	89 45 fc             	mov    %eax,-0x4(%ebp)
    list->first=remove_node->next;
   15975:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15978:	8b 50 04             	mov    0x4(%eax),%edx
   1597b:	8b 45 08             	mov    0x8(%ebp),%eax
   1597e:	89 10                	mov    %edx,(%eax)
    if(list->first==(list_node_t*)0){
   15980:	8b 45 08             	mov    0x8(%ebp),%eax
   15983:	8b 00                	mov    (%eax),%eax
   15985:	85 c0                	test   %eax,%eax
   15987:	75 0c                	jne    15995 <list_remove_first+0x44>
        list->last=(list_node_t*)0;
   15989:	8b 45 08             	mov    0x8(%ebp),%eax
   1598c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   15993:	eb 0b                	jmp    159a0 <list_remove_first+0x4f>
    }
    else{
        list->first->pre=(list_node_t*)0;
   15995:	8b 45 08             	mov    0x8(%ebp),%eax
   15998:	8b 00                	mov    (%eax),%eax
   1599a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    remove_node->pre=remove_node->next=(list_node_t*)0;
   159a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   159a3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   159aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
   159ad:	8b 50 04             	mov    0x4(%eax),%edx
   159b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   159b3:	89 10                	mov    %edx,(%eax)
    list->count--;
   159b5:	8b 45 08             	mov    0x8(%ebp),%eax
   159b8:	8b 40 08             	mov    0x8(%eax),%eax
   159bb:	8d 50 ff             	lea    -0x1(%eax),%edx
   159be:	8b 45 08             	mov    0x8(%ebp),%eax
   159c1:	89 50 08             	mov    %edx,0x8(%eax)
    return remove_node;
   159c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   159c7:	c9                   	leave  
   159c8:	c3                   	ret    

000159c9 <list_remove>:

list_node_t* list_remove(list_t* list,list_node_t*node){
   159c9:	55                   	push   %ebp
   159ca:	89 e5                	mov    %esp,%ebp
    if(node==list->first){
   159cc:	8b 45 08             	mov    0x8(%ebp),%eax
   159cf:	8b 00                	mov    (%eax),%eax
   159d1:	39 45 0c             	cmp    %eax,0xc(%ebp)
   159d4:	75 0b                	jne    159e1 <list_remove+0x18>
        list->first=node->next;
   159d6:	8b 45 0c             	mov    0xc(%ebp),%eax
   159d9:	8b 50 04             	mov    0x4(%eax),%edx
   159dc:	8b 45 08             	mov    0x8(%ebp),%eax
   159df:	89 10                	mov    %edx,(%eax)
    }
    if(node==list->last){
   159e1:	8b 45 08             	mov    0x8(%ebp),%eax
   159e4:	8b 40 04             	mov    0x4(%eax),%eax
   159e7:	39 45 0c             	cmp    %eax,0xc(%ebp)
   159ea:	75 0b                	jne    159f7 <list_remove+0x2e>
        list->last=node->pre;
   159ec:	8b 45 0c             	mov    0xc(%ebp),%eax
   159ef:	8b 10                	mov    (%eax),%edx
   159f1:	8b 45 08             	mov    0x8(%ebp),%eax
   159f4:	89 50 04             	mov    %edx,0x4(%eax)
    }
    if(node->pre){
   159f7:	8b 45 0c             	mov    0xc(%ebp),%eax
   159fa:	8b 00                	mov    (%eax),%eax
   159fc:	85 c0                	test   %eax,%eax
   159fe:	74 0e                	je     15a0e <list_remove+0x45>
        node->pre->next=node->next;
   15a00:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a03:	8b 00                	mov    (%eax),%eax
   15a05:	8b 55 0c             	mov    0xc(%ebp),%edx
   15a08:	8b 52 04             	mov    0x4(%edx),%edx
   15a0b:	89 50 04             	mov    %edx,0x4(%eax)
    }
    if(node->next){
   15a0e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a11:	8b 40 04             	mov    0x4(%eax),%eax
   15a14:	85 c0                	test   %eax,%eax
   15a16:	74 0d                	je     15a25 <list_remove+0x5c>
        node->next->pre=node->pre;
   15a18:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a1b:	8b 40 04             	mov    0x4(%eax),%eax
   15a1e:	8b 55 0c             	mov    0xc(%ebp),%edx
   15a21:	8b 12                	mov    (%edx),%edx
   15a23:	89 10                	mov    %edx,(%eax)
    }
    node->pre=node->next=(list_node_t*)0;
   15a25:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a28:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   15a2f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a32:	8b 50 04             	mov    0x4(%eax),%edx
   15a35:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a38:	89 10                	mov    %edx,(%eax)
    list->count--;
   15a3a:	8b 45 08             	mov    0x8(%ebp),%eax
   15a3d:	8b 40 08             	mov    0x8(%eax),%eax
   15a40:	8d 50 ff             	lea    -0x1(%eax),%edx
   15a43:	8b 45 08             	mov    0x8(%ebp),%eax
   15a46:	89 50 08             	mov    %edx,0x8(%eax)
    return node;
   15a49:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a4c:	5d                   	pop    %ebp
   15a4d:	c3                   	ret    

00015a4e <log_init>:
static mutex_t mutex;

// 用来记录打印设备的id
static int log_dev_id;

void log_init(void){
   15a4e:	55                   	push   %ebp
   15a4f:	89 e5                	mov    %esp,%ebp
   15a51:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   15a54:	83 ec 0c             	sub    $0xc,%esp
   15a57:	68 c4 a5 06 00       	push   $0x6a5c4
   15a5c:	e8 01 f3 ff ff       	call   14d62 <mutex_init>
   15a61:	83 c4 10             	add    $0x10,%esp

    log_dev_id=dev_open(DEV_TTY,0,0);
   15a64:	83 ec 04             	sub    $0x4,%esp
   15a67:	6a 00                	push   $0x0
   15a69:	6a 00                	push   $0x0
   15a6b:	6a 01                	push   $0x1
   15a6d:	e8 cc df ff ff       	call   13a3e <dev_open>
   15a72:	83 c4 10             	add    $0x10,%esp
   15a75:	a3 d8 a5 06 00       	mov    %eax,0x6a5d8
    outb(COM1_PORT+1,0x00);
    outb(COM1_PORT+3,0x03);
    outb(COM1_PORT+2,0xc7);
    outb(COM1_PORT+4,0x0F);
#endif
}
   15a7a:	90                   	nop
   15a7b:	c9                   	leave  
   15a7c:	c3                   	ret    

00015a7d <log_printf>:

void log_printf(const char* fmt,...){
   15a7d:	55                   	push   %ebp
   15a7e:	89 e5                	mov    %esp,%ebp
   15a80:	81 ec 98 00 00 00    	sub    $0x98,%esp
    char str_buf[128];
    va_list args;
    kernel_memset(str_buf,'\0',128);
   15a86:	83 ec 04             	sub    $0x4,%esp
   15a89:	68 80 00 00 00       	push   $0x80
   15a8e:	6a 00                	push   $0x0
   15a90:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   15a96:	50                   	push   %eax
   15a97:	e8 be f9 ff ff       	call   1545a <kernel_memset>
   15a9c:	83 c4 10             	add    $0x10,%esp
    va_start(args,fmt);
   15a9f:	8d 45 0c             	lea    0xc(%ebp),%eax
   15aa2:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
    kernel_vsprintf(str_buf,fmt,args);
   15aa8:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
   15aae:	83 ec 04             	sub    $0x4,%esp
   15ab1:	50                   	push   %eax
   15ab2:	ff 75 08             	pushl  0x8(%ebp)
   15ab5:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   15abb:	50                   	push   %eax
   15abc:	e8 a1 fb ff ff       	call   15662 <kernel_vsprintf>
   15ac1:	83 c4 10             	add    $0x10,%esp
    va_end(args);
    
    mutex_lock(&mutex);
   15ac4:	83 ec 0c             	sub    $0xc,%esp
   15ac7:	68 c4 a5 06 00       	push   $0x6a5c4
   15acc:	e8 bf f2 ff ff       	call   14d90 <mutex_lock>
   15ad1:	83 c4 10             	add    $0x10,%esp
        outb(COM1_PORT,*p++);
    }
    outb(COM1_PORT,'\r');
    outb(COM1_PORT,'\n');
#else
    dev_write(log_dev_id,0,str_buf,kernel_strlen(str_buf));
   15ad4:	83 ec 0c             	sub    $0xc,%esp
   15ad7:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   15add:	50                   	push   %eax
   15ade:	e8 ed f8 ff ff       	call   153d0 <kernel_strlen>
   15ae3:	83 c4 10             	add    $0x10,%esp
   15ae6:	89 c2                	mov    %eax,%edx
   15ae8:	a1 d8 a5 06 00       	mov    0x6a5d8,%eax
   15aed:	52                   	push   %edx
   15aee:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
   15af4:	52                   	push   %edx
   15af5:	6a 00                	push   $0x0
   15af7:	50                   	push   %eax
   15af8:	e8 dd e0 ff ff       	call   13bda <dev_write>
   15afd:	83 c4 10             	add    $0x10,%esp
    char c='\n';
   15b00:	c6 85 73 ff ff ff 0a 	movb   $0xa,-0x8d(%ebp)
    dev_write(log_dev_id,0,&c,1);
   15b07:	a1 d8 a5 06 00       	mov    0x6a5d8,%eax
   15b0c:	6a 01                	push   $0x1
   15b0e:	8d 95 73 ff ff ff    	lea    -0x8d(%ebp),%edx
   15b14:	52                   	push   %edx
   15b15:	6a 00                	push   $0x0
   15b17:	50                   	push   %eax
   15b18:	e8 bd e0 ff ff       	call   13bda <dev_write>
   15b1d:	83 c4 10             	add    $0x10,%esp
#endif
    mutex_unlock(&mutex);
   15b20:	83 ec 0c             	sub    $0xc,%esp
   15b23:	68 c4 a5 06 00       	push   $0x6a5c4
   15b28:	e8 f2 f2 ff ff       	call   14e1f <mutex_unlock>
   15b2d:	83 c4 10             	add    $0x10,%esp
   15b30:	90                   	nop
   15b31:	c9                   	leave  
   15b32:	c3                   	ret    

Disassembly of section .first_task:

80000000 <first_task_entry>:
    .text
	.global first_task_entry
	.extern first_task_main
first_task_entry:
	mov %ss,%ax
80000000:	66 8c d0             	mov    %ss,%ax
	mov %ax, %ds
80000003:	8e d8                	mov    %eax,%ds
	mov %ax, %ss
80000005:	8e d0                	mov    %eax,%ss
	mov %ax, %es
80000007:	8e c0                	mov    %eax,%es
	mov %ax, %fs
80000009:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
8000000b:	8e e8                	mov    %eax,%gs
8000000d:	e9 00 00 00 00       	jmp    80000012 <first_task_main>

80000012 <first_task_main>:
#include "tools/log.h"
#include "core/task.h"
#include "applib/lib_syscall.h"
#include "dev/tty.h" 

int first_task_main(void){
80000012:	55                   	push   %ebp
80000013:	89 e5                	mov    %esp,%ebp
80000015:	83 ec 28             	sub    $0x28,%esp
        print_msg("child task id=%d",pid);
        print_msg("parent: %d",count);
    }
#endif

    for(int i=0;i<TTY_NR;i++){
80000018:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
8000001f:	eb 75                	jmp    80000096 <first_task_main+0x84>
        int pid=fork();
80000021:	e8 67 01 00 00       	call   8000018d <fork>
80000026:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(pid<0){
80000029:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
8000002d:	79 14                	jns    80000043 <first_task_main+0x31>
            print_msg("create shell failed.",0);
8000002f:	83 ec 08             	sub    $0x8,%esp
80000032:	6a 00                	push   $0x0
80000034:	68 b4 00 00 80       	push   $0x800000b4
80000039:	e8 27 01 00 00       	call   80000165 <print_msg>
8000003e:	83 c4 10             	add    $0x10,%esp
            break;
80000041:	eb 59                	jmp    8000009c <first_task_main+0x8a>
        }
        else if(pid==0){
80000043:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
80000047:	75 49                	jne    80000092 <first_task_main+0x80>
            char tty_num[5]="tty:?";
80000049:	c7 45 eb 74 74 79 3a 	movl   $0x3a797474,-0x15(%ebp)
80000050:	c6 45 ef 3f          	movb   $0x3f,-0x11(%ebp)
            tty_num[4]=i+'0';
80000054:	8b 45 f4             	mov    -0xc(%ebp),%eax
80000057:	83 c0 30             	add    $0x30,%eax
8000005a:	88 45 ef             	mov    %al,-0x11(%ebp)
            char* argv[]={tty_num,(char*)0};
8000005d:	8d 45 eb             	lea    -0x15(%ebp),%eax
80000060:	89 45 e0             	mov    %eax,-0x20(%ebp)
80000063:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
            execve("/shell.elf",argv,(char**)0);
8000006a:	83 ec 04             	sub    $0x4,%esp
8000006d:	6a 00                	push   $0x0
8000006f:	8d 45 e0             	lea    -0x20(%ebp),%eax
80000072:	50                   	push   %eax
80000073:	68 c9 00 00 80       	push   $0x800000c9
80000078:	e8 2b 01 00 00       	call   800001a8 <execve>
8000007d:	83 c4 10             	add    $0x10,%esp
            
            while(1){
                msleep(1000);
80000080:	83 ec 0c             	sub    $0xc,%esp
80000083:	68 e8 03 00 00       	push   $0x3e8
80000088:	e8 93 00 00 00       	call   80000120 <msleep>
8000008d:	83 c4 10             	add    $0x10,%esp
80000090:	eb ee                	jmp    80000080 <first_task_main+0x6e>
    for(int i=0;i<TTY_NR;i++){
80000092:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
80000096:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
8000009a:	7e 85                	jle    80000021 <first_task_main+0xf>
    }

    for(;;){

        // 回收所有的孤儿进程
        int status=0;
8000009c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
        wait(&status);
800000a3:	83 ec 0c             	sub    $0xc,%esp
800000a6:	8d 45 dc             	lea    -0x24(%ebp),%eax
800000a9:	50                   	push   %eax
800000aa:	e8 bd 02 00 00       	call   8000036c <wait>
800000af:	83 c4 10             	add    $0x10,%esp
    for(;;){
800000b2:	eb e8                	jmp    8000009c <first_task_main+0x8a>
800000b4:	63 72 65             	arpl   %si,0x65(%edx)
800000b7:	61                   	popa   
800000b8:	74 65                	je     8000011f <sys_call+0x4b>
800000ba:	20 73 68             	and    %dh,0x68(%ebx)
800000bd:	65 6c                	gs insb (%dx),%es:(%edi)
800000bf:	6c                   	insb   (%dx),%es:(%edi)
800000c0:	20 66 61             	and    %ah,0x61(%esi)
800000c3:	69 6c 65 64 2e 00 2f 	imul   $0x732f002e,0x64(%ebp,%eiz,2),%ebp
800000ca:	73 
800000cb:	68 65 6c 6c 2e       	push   $0x2e6c6c65
800000d0:	65 6c                	gs insb (%dx),%es:(%edi)
800000d2:	66                   	data16
	...

800000d4 <sys_call>:
#include "lib_syscall.h"
#include "comm/types.h"
#include "core/syscall.h"
#include "os_cfg.h"

static inline int sys_call(syscall_args_t*args){
800000d4:	55                   	push   %ebp
800000d5:	89 e5                	mov    %esp,%ebp
800000d7:	57                   	push   %edi
800000d8:	56                   	push   %esi
800000d9:	53                   	push   %ebx
800000da:	83 ec 10             	sub    $0x10,%esp
    uint32_t addr[]={0,SELECTOR_SYSCALL | 0};
800000dd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
800000e4:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%ebp)
        "push %[arg0]\n\t"
        "push %[id]\n\t"
        "lcall *(%[a])"
        :"=a"(ret)
        :[a]"r"(addr),
         [arg3]"r"(args->arg3),
800000eb:	8b 45 08             	mov    0x8(%ebp),%eax
800000ee:	8b 50 10             	mov    0x10(%eax),%edx
         [arg2]"r"(args->arg2),
800000f1:	8b 45 08             	mov    0x8(%ebp),%eax
800000f4:	8b 48 0c             	mov    0xc(%eax),%ecx
         [arg1]"r"(args->arg1),
800000f7:	8b 45 08             	mov    0x8(%ebp),%eax
800000fa:	8b 58 08             	mov    0x8(%eax),%ebx
         [arg0]"r"(args->arg0),
800000fd:	8b 45 08             	mov    0x8(%ebp),%eax
80000100:	8b 70 04             	mov    0x4(%eax),%esi
         [id]"r"(args->id)
80000103:	8b 45 08             	mov    0x8(%ebp),%eax
80000106:	8b 38                	mov    (%eax),%edi
    __asm__ __volatile__(
80000108:	8d 45 e8             	lea    -0x18(%ebp),%eax
8000010b:	52                   	push   %edx
8000010c:	51                   	push   %ecx
8000010d:	53                   	push   %ebx
8000010e:	56                   	push   %esi
8000010f:	57                   	push   %edi
80000110:	ff 18                	lcall  *(%eax)
80000112:	89 45 f0             	mov    %eax,-0x10(%ebp)
    );
    return ret;
80000115:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
80000118:	83 c4 10             	add    $0x10,%esp
8000011b:	5b                   	pop    %ebx
8000011c:	5e                   	pop    %esi
8000011d:	5f                   	pop    %edi
8000011e:	5d                   	pop    %ebp
8000011f:	c3                   	ret    

80000120 <msleep>:

void msleep(int ms){
80000120:	55                   	push   %ebp
80000121:	89 e5                	mov    %esp,%ebp
80000123:	83 ec 20             	sub    $0x20,%esp
    if(ms<=0){
80000126:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
8000012a:	7e 1b                	jle    80000147 <msleep+0x27>
        return;
    }

    syscall_args_t args;
    args.id=SYS_SLEEP;
8000012c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    args.arg0=ms;
80000133:	8b 45 08             	mov    0x8(%ebp),%eax
80000136:	89 45 f0             	mov    %eax,-0x10(%ebp)

    sys_call(&args);
80000139:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000013c:	50                   	push   %eax
8000013d:	e8 92 ff ff ff       	call   800000d4 <sys_call>
80000142:	83 c4 04             	add    $0x4,%esp
80000145:	eb 01                	jmp    80000148 <msleep+0x28>
        return;
80000147:	90                   	nop
}
80000148:	c9                   	leave  
80000149:	c3                   	ret    

8000014a <getpid>:

int getpid(void){
8000014a:	55                   	push   %ebp
8000014b:	89 e5                	mov    %esp,%ebp
8000014d:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_GETPID;
80000150:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
    return sys_call(&args);
80000157:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000015a:	50                   	push   %eax
8000015b:	e8 74 ff ff ff       	call   800000d4 <sys_call>
80000160:	83 c4 04             	add    $0x4,%esp
}
80000163:	c9                   	leave  
80000164:	c3                   	ret    

80000165 <print_msg>:

void print_msg(const char* fmt,int arg){
80000165:	55                   	push   %ebp
80000166:	89 e5                	mov    %esp,%ebp
80000168:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_PRINT_MSG;
8000016b:	c7 45 ec 64 00 00 00 	movl   $0x64,-0x14(%ebp)
    args.arg0=(uint32_t)fmt;
80000172:	8b 45 08             	mov    0x8(%ebp),%eax
80000175:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=arg;
80000178:	8b 45 0c             	mov    0xc(%ebp),%eax
8000017b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    sys_call(&args);
8000017e:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000181:	50                   	push   %eax
80000182:	e8 4d ff ff ff       	call   800000d4 <sys_call>
80000187:	83 c4 04             	add    $0x4,%esp
}
8000018a:	90                   	nop
8000018b:	c9                   	leave  
8000018c:	c3                   	ret    

8000018d <fork>:

int fork(void){
8000018d:	55                   	push   %ebp
8000018e:	89 e5                	mov    %esp,%ebp
80000190:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_FORK;
80000193:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
    return sys_call(&args);
8000019a:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000019d:	50                   	push   %eax
8000019e:	e8 31 ff ff ff       	call   800000d4 <sys_call>
800001a3:	83 c4 04             	add    $0x4,%esp
}
800001a6:	c9                   	leave  
800001a7:	c3                   	ret    

800001a8 <execve>:

int execve(const char* name,char* const* argv,char* const* env){
800001a8:	55                   	push   %ebp
800001a9:	89 e5                	mov    %esp,%ebp
800001ab:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_EXECVE;
800001ae:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
    args.arg0=(int)name;
800001b5:	8b 45 08             	mov    0x8(%ebp),%eax
800001b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)argv;
800001bb:	8b 45 0c             	mov    0xc(%ebp),%eax
800001be:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)env;
800001c1:	8b 45 10             	mov    0x10(%ebp),%eax
800001c4:	89 45 f8             	mov    %eax,-0x8(%ebp)

    sys_call(&args);
800001c7:	8d 45 ec             	lea    -0x14(%ebp),%eax
800001ca:	50                   	push   %eax
800001cb:	e8 04 ff ff ff       	call   800000d4 <sys_call>
800001d0:	83 c4 04             	add    $0x4,%esp
}
800001d3:	90                   	nop
800001d4:	c9                   	leave  
800001d5:	c3                   	ret    

800001d6 <yield>:

int yield(void){
800001d6:	55                   	push   %ebp
800001d7:	89 e5                	mov    %esp,%ebp
800001d9:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_YIELD;
800001dc:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%ebp)

    return sys_call(&args);
800001e3:	8d 45 ec             	lea    -0x14(%ebp),%eax
800001e6:	50                   	push   %eax
800001e7:	e8 e8 fe ff ff       	call   800000d4 <sys_call>
800001ec:	83 c4 04             	add    $0x4,%esp
}
800001ef:	c9                   	leave  
800001f0:	c3                   	ret    

800001f1 <open>:

int open(const char*name,int flags, ...){
800001f1:	55                   	push   %ebp
800001f2:	89 e5                	mov    %esp,%ebp
800001f4:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_OPEN;
800001f7:	c7 45 ec 32 00 00 00 	movl   $0x32,-0x14(%ebp)
    args.arg0=(int)name;
800001fe:	8b 45 08             	mov    0x8(%ebp),%eax
80000201:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)flags;
80000204:	8b 45 0c             	mov    0xc(%ebp),%eax
80000207:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return sys_call(&args);
8000020a:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000020d:	50                   	push   %eax
8000020e:	e8 c1 fe ff ff       	call   800000d4 <sys_call>
80000213:	83 c4 04             	add    $0x4,%esp
}
80000216:	c9                   	leave  
80000217:	c3                   	ret    

80000218 <read>:

int read(int file,char* ptr,int len){
80000218:	55                   	push   %ebp
80000219:	89 e5                	mov    %esp,%ebp
8000021b:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_READ;
8000021e:	c7 45 ec 33 00 00 00 	movl   $0x33,-0x14(%ebp)
    args.arg0=(int)file;
80000225:	8b 45 08             	mov    0x8(%ebp),%eax
80000228:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)ptr;
8000022b:	8b 45 0c             	mov    0xc(%ebp),%eax
8000022e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)len;
80000231:	8b 45 10             	mov    0x10(%ebp),%eax
80000234:	89 45 f8             	mov    %eax,-0x8(%ebp)

    return sys_call(&args);
80000237:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000023a:	50                   	push   %eax
8000023b:	e8 94 fe ff ff       	call   800000d4 <sys_call>
80000240:	83 c4 04             	add    $0x4,%esp
}
80000243:	c9                   	leave  
80000244:	c3                   	ret    

80000245 <write>:

int write(int file,char*ptr,int len){
80000245:	55                   	push   %ebp
80000246:	89 e5                	mov    %esp,%ebp
80000248:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_WRITE;
8000024b:	c7 45 ec 34 00 00 00 	movl   $0x34,-0x14(%ebp)
    args.arg0=(int)file;
80000252:	8b 45 08             	mov    0x8(%ebp),%eax
80000255:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)ptr;
80000258:	8b 45 0c             	mov    0xc(%ebp),%eax
8000025b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)len;
8000025e:	8b 45 10             	mov    0x10(%ebp),%eax
80000261:	89 45 f8             	mov    %eax,-0x8(%ebp)

    return sys_call(&args);
80000264:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000267:	50                   	push   %eax
80000268:	e8 67 fe ff ff       	call   800000d4 <sys_call>
8000026d:	83 c4 04             	add    $0x4,%esp
}
80000270:	c9                   	leave  
80000271:	c3                   	ret    

80000272 <close>:

int close(int file){
80000272:	55                   	push   %ebp
80000273:	89 e5                	mov    %esp,%ebp
80000275:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_CLOSE;
80000278:	c7 45 ec 35 00 00 00 	movl   $0x35,-0x14(%ebp)
    args.arg0=(int)file;
8000027f:	8b 45 08             	mov    0x8(%ebp),%eax
80000282:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
80000285:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000288:	50                   	push   %eax
80000289:	e8 46 fe ff ff       	call   800000d4 <sys_call>
8000028e:	83 c4 04             	add    $0x4,%esp
}
80000291:	c9                   	leave  
80000292:	c3                   	ret    

80000293 <lseek>:

int lseek(int file,int ptr,int dir){
80000293:	55                   	push   %ebp
80000294:	89 e5                	mov    %esp,%ebp
80000296:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_LSEEK;
80000299:	c7 45 ec 36 00 00 00 	movl   $0x36,-0x14(%ebp)
    args.arg0=(int)file;
800002a0:	8b 45 08             	mov    0x8(%ebp),%eax
800002a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)ptr;
800002a6:	8b 45 0c             	mov    0xc(%ebp),%eax
800002a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2=(int)dir;
800002ac:	8b 45 10             	mov    0x10(%ebp),%eax
800002af:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return sys_call(&args);
800002b2:	8d 45 ec             	lea    -0x14(%ebp),%eax
800002b5:	50                   	push   %eax
800002b6:	e8 19 fe ff ff       	call   800000d4 <sys_call>
800002bb:	83 c4 04             	add    $0x4,%esp
}
800002be:	c9                   	leave  
800002bf:	c3                   	ret    

800002c0 <isatty>:

int isatty(int file){
800002c0:	55                   	push   %ebp
800002c1:	89 e5                	mov    %esp,%ebp
800002c3:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_ISATTY;
800002c6:	c7 45 ec 37 00 00 00 	movl   $0x37,-0x14(%ebp)
    args.arg0=(int)file;
800002cd:	8b 45 08             	mov    0x8(%ebp),%eax
800002d0:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
800002d3:	8d 45 ec             	lea    -0x14(%ebp),%eax
800002d6:	50                   	push   %eax
800002d7:	e8 f8 fd ff ff       	call   800000d4 <sys_call>
800002dc:	83 c4 04             	add    $0x4,%esp
}
800002df:	c9                   	leave  
800002e0:	c3                   	ret    

800002e1 <fstat>:

int fstat(int file,struct stat* st){
800002e1:	55                   	push   %ebp
800002e2:	89 e5                	mov    %esp,%ebp
800002e4:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_FSTAT;
800002e7:	c7 45 ec 39 00 00 00 	movl   $0x39,-0x14(%ebp)
    args.arg0=(int)file;
800002ee:	8b 45 08             	mov    0x8(%ebp),%eax
800002f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1=(int)st;
800002f4:	8b 45 0c             	mov    0xc(%ebp),%eax
800002f7:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return sys_call(&args);
800002fa:	8d 45 ec             	lea    -0x14(%ebp),%eax
800002fd:	50                   	push   %eax
800002fe:	e8 d1 fd ff ff       	call   800000d4 <sys_call>
80000303:	83 c4 04             	add    $0x4,%esp
}
80000306:	c9                   	leave  
80000307:	c3                   	ret    

80000308 <sbrk>:

void* sbrk(ptrdiff_t incr){
80000308:	55                   	push   %ebp
80000309:	89 e5                	mov    %esp,%ebp
8000030b:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_SBRK;
8000030e:	c7 45 ec 38 00 00 00 	movl   $0x38,-0x14(%ebp)
    args.arg0=(int)incr;
80000315:	8b 45 08             	mov    0x8(%ebp),%eax
80000318:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return (void*)sys_call(&args);
8000031b:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000031e:	50                   	push   %eax
8000031f:	e8 b0 fd ff ff       	call   800000d4 <sys_call>
80000324:	83 c4 04             	add    $0x4,%esp
}
80000327:	c9                   	leave  
80000328:	c3                   	ret    

80000329 <dup>:
/** 
* @brief 复制文件描述符
* @param file 需要复制的文件描述符
* @return 复制后的文件描述符，失败返回-1
*/
int dup(int file){
80000329:	55                   	push   %ebp
8000032a:	89 e5                	mov    %esp,%ebp
8000032c:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_DUP;
8000032f:	c7 45 ec 3a 00 00 00 	movl   $0x3a,-0x14(%ebp)
    args.arg0=(int)file;
80000336:	8b 45 08             	mov    0x8(%ebp),%eax
80000339:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
8000033c:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000033f:	50                   	push   %eax
80000340:	e8 8f fd ff ff       	call   800000d4 <sys_call>
80000345:	83 c4 04             	add    $0x4,%esp
}
80000348:	c9                   	leave  
80000349:	c3                   	ret    

8000034a <_exit>:

/**
 * @brief  当我们使用newlib库时，exit函数会调用_exit函数
 * @param status 退出的状态码
 */
void _exit(int status){
8000034a:	55                   	push   %ebp
8000034b:	89 e5                	mov    %esp,%ebp
8000034d:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_EXIT;
80000350:	c7 45 ec 05 00 00 00 	movl   $0x5,-0x14(%ebp)
    args.arg0=(int)status;
80000357:	8b 45 08             	mov    0x8(%ebp),%eax
8000035a:	89 45 f0             	mov    %eax,-0x10(%ebp)

    sys_call(&args);
8000035d:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000360:	50                   	push   %eax
80000361:	e8 6e fd ff ff       	call   800000d4 <sys_call>
80000366:	83 c4 04             	add    $0x4,%esp

    for(;;){
        asm volatile("hlt");
80000369:	f4                   	hlt    
8000036a:	eb fd                	jmp    80000369 <_exit+0x1f>

8000036c <wait>:
    }
}

int wait(int* status){
8000036c:	55                   	push   %ebp
8000036d:	89 e5                	mov    %esp,%ebp
8000036f:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id=SYS_WAIT;
80000372:	c7 45 ec 06 00 00 00 	movl   $0x6,-0x14(%ebp)
    args.arg0=(int)status;
80000379:	8b 45 08             	mov    0x8(%ebp),%eax
8000037c:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
8000037f:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000382:	50                   	push   %eax
80000383:	e8 4c fd ff ff       	call   800000d4 <sys_call>
80000388:	83 c4 04             	add    $0x4,%esp
8000038b:	c9                   	leave  
8000038c:	c3                   	ret    
